// @generated by protobuf-ts 2.2.2 with parameter server_grpc1,client_grpc1
// @generated from protobuf file "Flight.proto" (package "arrow.flight.protocol", syntax proto3)
// tslint:disable
//
//
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
// <p>
// http://www.apache.org/licenses/LICENSE-2.0
// <p>
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 *
 * The request that a client provides to a server on handshake.
 *
 * @generated from protobuf message arrow.flight.protocol.HandshakeRequest
 */
export interface HandshakeRequest {
    /**
     *
     * A defined protocol version
     *
     * @generated from protobuf field: uint64 protocol_version = 1;
     */
    protocolVersion: bigint;
    /**
     *
     * Arbitrary auth/handshake info.
     *
     * @generated from protobuf field: bytes payload = 2;
     */
    payload: Uint8Array;
}
/**
 * @generated from protobuf message arrow.flight.protocol.HandshakeResponse
 */
export interface HandshakeResponse {
    /**
     *
     * A defined protocol version
     *
     * @generated from protobuf field: uint64 protocol_version = 1;
     */
    protocolVersion: bigint;
    /**
     *
     * Arbitrary auth/handshake info.
     *
     * @generated from protobuf field: bytes payload = 2;
     */
    payload: Uint8Array;
}
/**
 *
 * A message for doing simple auth.
 *
 * @generated from protobuf message arrow.flight.protocol.BasicAuth
 */
export interface BasicAuth {
    /**
     * @generated from protobuf field: string username = 2;
     */
    username: string;
    /**
     * @generated from protobuf field: string password = 3;
     */
    password: string;
}
/**
 * @generated from protobuf message arrow.flight.protocol.Empty
 */
export interface Empty {
}
/**
 *
 * Describes an available action, including both the name used for execution
 * along with a short description of the purpose of the action.
 *
 * @generated from protobuf message arrow.flight.protocol.ActionType
 */
export interface ActionType {
    /**
     * @generated from protobuf field: string type = 1;
     */
    type: string;
    /**
     * @generated from protobuf field: string description = 2;
     */
    description: string;
}
/**
 *
 * A service specific expression that can be used to return a limited set
 * of available Arrow Flight streams.
 *
 * @generated from protobuf message arrow.flight.protocol.Criteria
 */
export interface Criteria {
    /**
     * @generated from protobuf field: bytes expression = 1;
     */
    expression: Uint8Array;
}
/**
 *
 * An opaque action specific for the service.
 *
 * @generated from protobuf message arrow.flight.protocol.Action
 */
export interface Action {
    /**
     * @generated from protobuf field: string type = 1;
     */
    type: string;
    /**
     * @generated from protobuf field: bytes body = 2;
     */
    body: Uint8Array;
}
/**
 *
 * An opaque result returned after executing an action.
 *
 * @generated from protobuf message arrow.flight.protocol.Result
 */
export interface Result {
    /**
     * @generated from protobuf field: bytes body = 1;
     */
    body: Uint8Array;
}
/**
 *
 * Wrap the result of a getSchema call
 *
 * @generated from protobuf message arrow.flight.protocol.SchemaResult
 */
export interface SchemaResult {
    /**
     * The schema of the dataset in its IPC form:
     *   4 bytes - an optional IPC_CONTINUATION_TOKEN prefix
     *   4 bytes - the byte length of the payload
     *   a flatbuffer Message whose header is the Schema
     *
     * @generated from protobuf field: bytes schema = 1;
     */
    schema: Uint8Array;
}
/**
 *
 * The name or tag for a Flight. May be used as a way to retrieve or generate
 * a flight or be used to expose a set of previously defined flights.
 *
 * @generated from protobuf message arrow.flight.protocol.FlightDescriptor
 */
export interface FlightDescriptor {
    /**
     * @generated from protobuf field: arrow.flight.protocol.FlightDescriptor.DescriptorType type = 1;
     */
    type: FlightDescriptor_DescriptorType;
    /**
     *
     * Opaque value used to express a command. Should only be defined when
     * type = CMD.
     *
     * @generated from protobuf field: bytes cmd = 2;
     */
    cmd: Uint8Array;
    /**
     *
     * List of strings identifying a particular dataset. Should only be defined
     * when type = PATH.
     *
     * @generated from protobuf field: repeated string path = 3;
     */
    path: string[];
}
/**
 *
 * Describes what type of descriptor is defined.
 *
 * @generated from protobuf enum arrow.flight.protocol.FlightDescriptor.DescriptorType
 */
export enum FlightDescriptor_DescriptorType {
    /**
     * Protobuf pattern, not used.
     *
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     *
     * A named path that identifies a dataset. A path is composed of a string
     * or list of strings describing a particular dataset. This is conceptually
     *  similar to a path inside a filesystem.
     *
     * @generated from protobuf enum value: PATH = 1;
     */
    PATH = 1,
    /**
     *
     * An opaque command to generate a dataset.
     *
     * @generated from protobuf enum value: CMD = 2;
     */
    CMD = 2
}
/**
 *
 * The access coordinates for retrieval of a dataset. With a FlightInfo, a
 * consumer is able to determine how to retrieve a dataset.
 *
 * @generated from protobuf message arrow.flight.protocol.FlightInfo
 */
export interface FlightInfo {
    /**
     * The schema of the dataset in its IPC form:
     *   4 bytes - an optional IPC_CONTINUATION_TOKEN prefix
     *   4 bytes - the byte length of the payload
     *   a flatbuffer Message whose header is the Schema
     *
     * @generated from protobuf field: bytes schema = 1;
     */
    schema: Uint8Array;
    /**
     *
     * The descriptor associated with this info.
     *
     * @generated from protobuf field: arrow.flight.protocol.FlightDescriptor flight_descriptor = 2;
     */
    flightDescriptor?: FlightDescriptor;
    /**
     *
     * A list of endpoints associated with the flight. To consume the whole
     * flight, all endpoints must be consumed.
     *
     * @generated from protobuf field: repeated arrow.flight.protocol.FlightEndpoint endpoint = 3;
     */
    endpoint: FlightEndpoint[];
    /**
     * Set these to -1 if unknown.
     *
     * @generated from protobuf field: int64 total_records = 4;
     */
    totalRecords: bigint;
    /**
     * @generated from protobuf field: int64 total_bytes = 5;
     */
    totalBytes: bigint;
}
/**
 *
 * A particular stream or split associated with a flight.
 *
 * @generated from protobuf message arrow.flight.protocol.FlightEndpoint
 */
export interface FlightEndpoint {
    /**
     *
     * Token used to retrieve this stream.
     *
     * @generated from protobuf field: arrow.flight.protocol.Ticket ticket = 1;
     */
    ticket?: Ticket;
    /**
     *
     * A list of URIs where this ticket can be redeemed. If the list is
     * empty, the expectation is that the ticket can only be redeemed on the
     * current service where the ticket was generated.
     *
     * @generated from protobuf field: repeated arrow.flight.protocol.Location location = 2;
     */
    location: Location[];
}
/**
 *
 * A location where a Flight service will accept retrieval of a particular
 * stream given a ticket.
 *
 * @generated from protobuf message arrow.flight.protocol.Location
 */
export interface Location {
    /**
     * @generated from protobuf field: string uri = 1;
     */
    uri: string;
}
/**
 *
 * An opaque identifier that the service can use to retrieve a particular
 * portion of a stream.
 *
 * @generated from protobuf message arrow.flight.protocol.Ticket
 */
export interface Ticket {
    /**
     * @generated from protobuf field: bytes ticket = 1;
     */
    ticket: Uint8Array;
}
/**
 *
 * A batch of Arrow data as part of a stream of batches.
 *
 * @generated from protobuf message arrow.flight.protocol.FlightData
 */
export interface FlightData {
    /**
     *
     * The descriptor of the data. This is only relevant when a client is
     * starting a new DoPut stream.
     *
     * @generated from protobuf field: arrow.flight.protocol.FlightDescriptor flight_descriptor = 1;
     */
    flightDescriptor?: FlightDescriptor;
    /**
     *
     * Header for message data as described in Message.fbs::Message.
     *
     * @generated from protobuf field: bytes data_header = 2;
     */
    dataHeader: Uint8Array;
    /**
     *
     * Application-defined metadata.
     *
     * @generated from protobuf field: bytes app_metadata = 3;
     */
    appMetadata: Uint8Array;
    /**
     *
     * The actual batch of Arrow data. Preferably handled with minimal-copies
     * coming last in the definition to help with sidecar patterns (it is
     * expected that some implementations will fetch this field off the wire
     * with specialized code to avoid extra memory copies).
     *
     * @generated from protobuf field: bytes data_body = 1000;
     */
    dataBody: Uint8Array;
}
/**
 * *
 * The response message associated with the submission of a DoPut.
 *
 * @generated from protobuf message arrow.flight.protocol.PutResult
 */
export interface PutResult {
    /**
     * @generated from protobuf field: bytes app_metadata = 1;
     */
    appMetadata: Uint8Array;
}
// @generated message type with reflection information, may provide speed optimized methods
class HandshakeRequest$Type extends MessageType<HandshakeRequest> {
    constructor() {
        super("arrow.flight.protocol.HandshakeRequest", [
            { no: 1, name: "protocol_version", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "payload", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<HandshakeRequest>): HandshakeRequest {
        const message = { protocolVersion: 0n, payload: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HandshakeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HandshakeRequest): HandshakeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 protocol_version */ 1:
                    message.protocolVersion = reader.uint64().toBigInt();
                    break;
                case /* bytes payload */ 2:
                    message.payload = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HandshakeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 protocol_version = 1; */
        if (message.protocolVersion !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.protocolVersion);
        /* bytes payload = 2; */
        if (message.payload.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.payload);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message arrow.flight.protocol.HandshakeRequest
 */
export const HandshakeRequest = new HandshakeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HandshakeResponse$Type extends MessageType<HandshakeResponse> {
    constructor() {
        super("arrow.flight.protocol.HandshakeResponse", [
            { no: 1, name: "protocol_version", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "payload", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<HandshakeResponse>): HandshakeResponse {
        const message = { protocolVersion: 0n, payload: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HandshakeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HandshakeResponse): HandshakeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 protocol_version */ 1:
                    message.protocolVersion = reader.uint64().toBigInt();
                    break;
                case /* bytes payload */ 2:
                    message.payload = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HandshakeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 protocol_version = 1; */
        if (message.protocolVersion !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.protocolVersion);
        /* bytes payload = 2; */
        if (message.payload.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.payload);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message arrow.flight.protocol.HandshakeResponse
 */
export const HandshakeResponse = new HandshakeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BasicAuth$Type extends MessageType<BasicAuth> {
    constructor() {
        super("arrow.flight.protocol.BasicAuth", [
            { no: 2, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BasicAuth>): BasicAuth {
        const message = { username: "", password: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BasicAuth>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BasicAuth): BasicAuth {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string username */ 2:
                    message.username = reader.string();
                    break;
                case /* string password */ 3:
                    message.password = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BasicAuth, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string username = 2; */
        if (message.username !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.username);
        /* string password = 3; */
        if (message.password !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.password);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message arrow.flight.protocol.BasicAuth
 */
export const BasicAuth = new BasicAuth$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Empty$Type extends MessageType<Empty> {
    constructor() {
        super("arrow.flight.protocol.Empty", []);
    }
    create(value?: PartialMessage<Empty>): Empty {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Empty>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Empty): Empty {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Empty, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message arrow.flight.protocol.Empty
 */
export const Empty = new Empty$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActionType$Type extends MessageType<ActionType> {
    constructor() {
        super("arrow.flight.protocol.ActionType", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ActionType>): ActionType {
        const message = { type: "", description: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ActionType>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActionType): ActionType {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ActionType, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message arrow.flight.protocol.ActionType
 */
export const ActionType = new ActionType$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Criteria$Type extends MessageType<Criteria> {
    constructor() {
        super("arrow.flight.protocol.Criteria", [
            { no: 1, name: "expression", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Criteria>): Criteria {
        const message = { expression: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Criteria>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Criteria): Criteria {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes expression */ 1:
                    message.expression = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Criteria, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes expression = 1; */
        if (message.expression.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.expression);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message arrow.flight.protocol.Criteria
 */
export const Criteria = new Criteria$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Action$Type extends MessageType<Action> {
    constructor() {
        super("arrow.flight.protocol.Action", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "body", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Action>): Action {
        const message = { type: "", body: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Action>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Action): Action {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* bytes body */ 2:
                    message.body = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Action, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* bytes body = 2; */
        if (message.body.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.body);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message arrow.flight.protocol.Action
 */
export const Action = new Action$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Result$Type extends MessageType<Result> {
    constructor() {
        super("arrow.flight.protocol.Result", [
            { no: 1, name: "body", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Result>): Result {
        const message = { body: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Result>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Result): Result {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes body */ 1:
                    message.body = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Result, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes body = 1; */
        if (message.body.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.body);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message arrow.flight.protocol.Result
 */
export const Result = new Result$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SchemaResult$Type extends MessageType<SchemaResult> {
    constructor() {
        super("arrow.flight.protocol.SchemaResult", [
            { no: 1, name: "schema", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<SchemaResult>): SchemaResult {
        const message = { schema: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SchemaResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SchemaResult): SchemaResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes schema */ 1:
                    message.schema = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SchemaResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes schema = 1; */
        if (message.schema.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.schema);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message arrow.flight.protocol.SchemaResult
 */
export const SchemaResult = new SchemaResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FlightDescriptor$Type extends MessageType<FlightDescriptor> {
    constructor() {
        super("arrow.flight.protocol.FlightDescriptor", [
            { no: 1, name: "type", kind: "enum", T: () => ["arrow.flight.protocol.FlightDescriptor.DescriptorType", FlightDescriptor_DescriptorType] },
            { no: 2, name: "cmd", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "path", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FlightDescriptor>): FlightDescriptor {
        const message = { type: 0, cmd: new Uint8Array(0), path: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FlightDescriptor>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FlightDescriptor): FlightDescriptor {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* arrow.flight.protocol.FlightDescriptor.DescriptorType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* bytes cmd */ 2:
                    message.cmd = reader.bytes();
                    break;
                case /* repeated string path */ 3:
                    message.path.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FlightDescriptor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* arrow.flight.protocol.FlightDescriptor.DescriptorType type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* bytes cmd = 2; */
        if (message.cmd.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.cmd);
        /* repeated string path = 3; */
        for (let i = 0; i < message.path.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.path[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message arrow.flight.protocol.FlightDescriptor
 */
export const FlightDescriptor = new FlightDescriptor$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FlightInfo$Type extends MessageType<FlightInfo> {
    constructor() {
        super("arrow.flight.protocol.FlightInfo", [
            { no: 1, name: "schema", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "flight_descriptor", kind: "message", T: () => FlightDescriptor },
            { no: 3, name: "endpoint", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => FlightEndpoint },
            { no: 4, name: "total_records", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "total_bytes", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<FlightInfo>): FlightInfo {
        const message = { schema: new Uint8Array(0), endpoint: [], totalRecords: 0n, totalBytes: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FlightInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FlightInfo): FlightInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes schema */ 1:
                    message.schema = reader.bytes();
                    break;
                case /* arrow.flight.protocol.FlightDescriptor flight_descriptor */ 2:
                    message.flightDescriptor = FlightDescriptor.internalBinaryRead(reader, reader.uint32(), options, message.flightDescriptor);
                    break;
                case /* repeated arrow.flight.protocol.FlightEndpoint endpoint */ 3:
                    message.endpoint.push(FlightEndpoint.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int64 total_records */ 4:
                    message.totalRecords = reader.int64().toBigInt();
                    break;
                case /* int64 total_bytes */ 5:
                    message.totalBytes = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FlightInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes schema = 1; */
        if (message.schema.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.schema);
        /* arrow.flight.protocol.FlightDescriptor flight_descriptor = 2; */
        if (message.flightDescriptor)
            FlightDescriptor.internalBinaryWrite(message.flightDescriptor, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated arrow.flight.protocol.FlightEndpoint endpoint = 3; */
        for (let i = 0; i < message.endpoint.length; i++)
            FlightEndpoint.internalBinaryWrite(message.endpoint[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* int64 total_records = 4; */
        if (message.totalRecords !== 0n)
            writer.tag(4, WireType.Varint).int64(message.totalRecords);
        /* int64 total_bytes = 5; */
        if (message.totalBytes !== 0n)
            writer.tag(5, WireType.Varint).int64(message.totalBytes);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message arrow.flight.protocol.FlightInfo
 */
export const FlightInfo = new FlightInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FlightEndpoint$Type extends MessageType<FlightEndpoint> {
    constructor() {
        super("arrow.flight.protocol.FlightEndpoint", [
            { no: 1, name: "ticket", kind: "message", T: () => Ticket },
            { no: 2, name: "location", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Location }
        ]);
    }
    create(value?: PartialMessage<FlightEndpoint>): FlightEndpoint {
        const message = { location: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FlightEndpoint>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FlightEndpoint): FlightEndpoint {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* arrow.flight.protocol.Ticket ticket */ 1:
                    message.ticket = Ticket.internalBinaryRead(reader, reader.uint32(), options, message.ticket);
                    break;
                case /* repeated arrow.flight.protocol.Location location */ 2:
                    message.location.push(Location.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FlightEndpoint, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* arrow.flight.protocol.Ticket ticket = 1; */
        if (message.ticket)
            Ticket.internalBinaryWrite(message.ticket, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated arrow.flight.protocol.Location location = 2; */
        for (let i = 0; i < message.location.length; i++)
            Location.internalBinaryWrite(message.location[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message arrow.flight.protocol.FlightEndpoint
 */
export const FlightEndpoint = new FlightEndpoint$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Location$Type extends MessageType<Location> {
    constructor() {
        super("arrow.flight.protocol.Location", [
            { no: 1, name: "uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Location>): Location {
        const message = { uri: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Location>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Location): Location {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uri */ 1:
                    message.uri = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Location, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uri = 1; */
        if (message.uri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uri);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message arrow.flight.protocol.Location
 */
export const Location = new Location$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Ticket$Type extends MessageType<Ticket> {
    constructor() {
        super("arrow.flight.protocol.Ticket", [
            { no: 1, name: "ticket", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Ticket>): Ticket {
        const message = { ticket: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Ticket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Ticket): Ticket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes ticket */ 1:
                    message.ticket = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Ticket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes ticket = 1; */
        if (message.ticket.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.ticket);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message arrow.flight.protocol.Ticket
 */
export const Ticket = new Ticket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FlightData$Type extends MessageType<FlightData> {
    constructor() {
        super("arrow.flight.protocol.FlightData", [
            { no: 1, name: "flight_descriptor", kind: "message", T: () => FlightDescriptor },
            { no: 2, name: "data_header", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "app_metadata", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 1000, name: "data_body", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<FlightData>): FlightData {
        const message = { dataHeader: new Uint8Array(0), appMetadata: new Uint8Array(0), dataBody: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FlightData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FlightData): FlightData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* arrow.flight.protocol.FlightDescriptor flight_descriptor */ 1:
                    message.flightDescriptor = FlightDescriptor.internalBinaryRead(reader, reader.uint32(), options, message.flightDescriptor);
                    break;
                case /* bytes data_header */ 2:
                    message.dataHeader = reader.bytes();
                    break;
                case /* bytes app_metadata */ 3:
                    message.appMetadata = reader.bytes();
                    break;
                case /* bytes data_body */ 1000:
                    message.dataBody = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FlightData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* arrow.flight.protocol.FlightDescriptor flight_descriptor = 1; */
        if (message.flightDescriptor)
            FlightDescriptor.internalBinaryWrite(message.flightDescriptor, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bytes data_header = 2; */
        if (message.dataHeader.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.dataHeader);
        /* bytes app_metadata = 3; */
        if (message.appMetadata.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.appMetadata);
        /* bytes data_body = 1000; */
        if (message.dataBody.length)
            writer.tag(1000, WireType.LengthDelimited).bytes(message.dataBody);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message arrow.flight.protocol.FlightData
 */
export const FlightData = new FlightData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PutResult$Type extends MessageType<PutResult> {
    constructor() {
        super("arrow.flight.protocol.PutResult", [
            { no: 1, name: "app_metadata", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<PutResult>): PutResult {
        const message = { appMetadata: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PutResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PutResult): PutResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes app_metadata */ 1:
                    message.appMetadata = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PutResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes app_metadata = 1; */
        if (message.appMetadata.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.appMetadata);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message arrow.flight.protocol.PutResult
 */
export const PutResult = new PutResult$Type();
/**
 * @generated ServiceType for protobuf service arrow.flight.protocol.FlightService
 */
export const FlightService = new ServiceType("arrow.flight.protocol.FlightService", [
    { name: "Handshake", serverStreaming: true, clientStreaming: true, options: {}, I: HandshakeRequest, O: HandshakeResponse },
    { name: "ListFlights", serverStreaming: true, options: {}, I: Criteria, O: FlightInfo },
    { name: "GetFlightInfo", options: {}, I: FlightDescriptor, O: FlightInfo },
    { name: "GetSchema", options: {}, I: FlightDescriptor, O: SchemaResult },
    { name: "DoGet", serverStreaming: true, options: {}, I: Ticket, O: FlightData },
    { name: "DoPut", serverStreaming: true, clientStreaming: true, options: {}, I: FlightData, O: PutResult },
    { name: "DoExchange", serverStreaming: true, clientStreaming: true, options: {}, I: FlightData, O: FlightData },
    { name: "DoAction", serverStreaming: true, options: {}, I: Action, O: Result },
    { name: "ListActions", serverStreaming: true, options: {}, I: Empty, O: ActionType }
]);
