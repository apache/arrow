# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from collections.abc import Callable
from contextlib import AbstractContextManager
from decimal import Decimal
from os import PathLike
from typing import Any, Literal
import socket

import pyarrow.fs


def randsign() -> int: ...
def random_seed(seed: int) -> AbstractContextManager[None]: ...
def randdecimal(precision: int, scale: int) -> Decimal: ...
def random_ascii(length: int) -> bytes: ...
def rands(nchars: int) -> str: ...
def get_modified_env_with_pythonpath() -> dict[str, str]: ...
def invoke_script(script_name: str, *args: str) -> None: ...
def changed_environ(name: str, value: str) -> AbstractContextManager[None]: ...
def change_cwd(path: str | PathLike[str]) -> AbstractContextManager[None]: ...
def disabled_gc() -> AbstractContextManager[None]: ...
def _filesystem_uri(path: str) -> str: ...


def memory_leak_check(
    f: Callable[[], Any],
    metric: Literal['rss', 'vms', 'shared'] = 'rss',
    threshold: int = 131072,
    iterations: int = 10,
    check_interval: int = 1
) -> None: ...


class FSProtocolClass:
    def __init__(self, path: str | PathLike[str]) -> None: ...
    def __fspath__(self) -> str: ...


class ProxyHandler(pyarrow.fs.FileSystemHandler):
    _fs: pyarrow.fs.FileSystem
    def __init__(self, fs: pyarrow.fs.FileSystem) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def get_type_name(self) -> str: ...
    def normalize_path(self, path: str) -> str: ...
    def get_file_info(self, paths: list[str]) -> list[pyarrow.fs.FileInfo]: ...
    def get_file_info_selector(
        self, selector: pyarrow.fs.FileSelector) -> list[pyarrow.fs.FileInfo]: ...

    def create_dir(self, path: str, recursive: bool) -> None: ...
    def delete_dir(self, path: str) -> None: ...
    def delete_dir_contents(self, path: str, missing_dir_ok: bool = False) -> None: ...
    def delete_root_dir_contents(self) -> None: ...
    def delete_file(self, path: str) -> None: ...
    def move(self, src: str, dest: str) -> None: ...
    def copy_file(self, src: str, dest: str) -> None: ...
    def open_input_stream(self, path: str) -> Any: ...
    def open_input_file(self, path: str) -> Any: ...
    def open_output_stream(self, path: str, metadata: dict[str, str]) -> Any: ...
    def open_append_stream(self, path: str, metadata: dict[str, str]) -> Any: ...


def _ensure_minio_component_version(component: str, minimum_year: int) -> bool: ...
def _run_mc_command(mcdir: str, *args: str) -> None: ...
def windows_has_tzdata() -> bool: ...
def running_on_musllinux() -> bool: ...


def signal_wakeup_fd(
    *, warn_on_full_buffer: bool = False) -> AbstractContextManager[socket.socket]: ...


def _configure_s3_limited_user(
    s3_server: dict[str, Any], policy: str, username: str, password: str) -> None: ...


def _wait_for_minio_startup(
    mcdir: str, address: str, access_key: str, secret_key: str) -> None: ...
