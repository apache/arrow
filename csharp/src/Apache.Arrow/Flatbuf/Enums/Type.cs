// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

namespace Apache.Arrow.Flatbuf
{

/// ----------------------------------------------------------------------
/// Top-level Type value, enabling extensible type-specific metadata. We can
/// add new logical types to Type without breaking backwards compatibility
internal enum Type : byte
{
  NONE = 0,
  Null = 1,
  Int = 2,
  FloatingPoint = 3,
  Binary = 4,
  Utf8 = 5,
  Bool = 6,
  Decimal = 7,
  Date = 8,
  Time = 9,
  Timestamp = 10,
  Interval = 11,
  List = 12,
  Struct_ = 13,
  Union = 14,
  FixedSizeBinary = 15,
  FixedSizeList = 16,
  Map = 17,
  Duration = 18,
  LargeBinary = 19,
  LargeUtf8 = 20,
  LargeList = 21,
  RunEndEncoded = 22,
  BinaryView = 23,
  Utf8View = 24,
  ListView = 25,
  LargeListView = 26,
};



static internal class TypeVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, byte typeId, uint tablePos)
  {
    bool result = true;
    switch((Type)typeId)
    {
      case Type.Null:
        result = NullVerify.Verify(verifier, tablePos);
        break;
      case Type.Int:
        result = IntVerify.Verify(verifier, tablePos);
        break;
      case Type.FloatingPoint:
        result = FloatingPointVerify.Verify(verifier, tablePos);
        break;
      case Type.Binary:
        result = BinaryVerify.Verify(verifier, tablePos);
        break;
      case Type.Utf8:
        result = Utf8Verify.Verify(verifier, tablePos);
        break;
      case Type.Bool:
        result = BoolVerify.Verify(verifier, tablePos);
        break;
      case Type.Decimal:
        result = DecimalVerify.Verify(verifier, tablePos);
        break;
      case Type.Date:
        result = DateVerify.Verify(verifier, tablePos);
        break;
      case Type.Time:
        result = TimeVerify.Verify(verifier, tablePos);
        break;
      case Type.Timestamp:
        result = TimestampVerify.Verify(verifier, tablePos);
        break;
      case Type.Interval:
        result = IntervalVerify.Verify(verifier, tablePos);
        break;
      case Type.List:
        result = ListVerify.Verify(verifier, tablePos);
        break;
      case Type.Struct_:
        result = Struct_Verify.Verify(verifier, tablePos);
        break;
      case Type.Union:
        result = UnionVerify.Verify(verifier, tablePos);
        break;
      case Type.FixedSizeBinary:
        result = FixedSizeBinaryVerify.Verify(verifier, tablePos);
        break;
      case Type.FixedSizeList:
        result = FixedSizeListVerify.Verify(verifier, tablePos);
        break;
      case Type.Map:
        result = MapVerify.Verify(verifier, tablePos);
        break;
      case Type.Duration:
        result = DurationVerify.Verify(verifier, tablePos);
        break;
      case Type.LargeBinary:
        result = LargeBinaryVerify.Verify(verifier, tablePos);
        break;
      case Type.LargeUtf8:
        result = LargeUtf8Verify.Verify(verifier, tablePos);
        break;
      case Type.LargeList:
        result = LargeListVerify.Verify(verifier, tablePos);
        break;
      case Type.RunEndEncoded:
        result = RunEndEncodedVerify.Verify(verifier, tablePos);
        break;
      case Type.BinaryView:
        result = BinaryViewVerify.Verify(verifier, tablePos);
        break;
      case Type.Utf8View:
        result = Utf8ViewVerify.Verify(verifier, tablePos);
        break;
      case Type.ListView:
        result = ListViewVerify.Verify(verifier, tablePos);
        break;
      case Type.LargeListView:
        result = LargeListViewVerify.Verify(verifier, tablePos);
        break;
      default: result = true;
        break;
    }
    return result;
  }
}


}
