// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SCHEMA_ORG_APACHE_ARROW_FLATBUF_H_
#define FLATBUFFERS_GENERATED_SCHEMA_ORG_APACHE_ARROW_FLATBUF_H_

#include "flatbuffers/flatbuffers.h"

namespace org {
namespace apache {
namespace arrow {
namespace flatbuf {

struct Null;

struct Struct_;

struct List;

struct LargeList;

struct FixedSizeList;

struct Map;

struct Union;

struct Int;

struct FloatingPoint;

struct Utf8;

struct Binary;

struct LargeUtf8;

struct LargeBinary;

struct FixedSizeBinary;

struct Bool;

struct Decimal;

struct Date;

struct Time;

struct Timestamp;

struct Interval;

struct Duration;

struct KeyValue;

struct DictionaryEncoding;

struct Field;

struct Buffer;

struct Schema;

enum MetadataVersion {
  /// 0.1.0
  MetadataVersion_V1 = 0,
  /// 0.2.0
  MetadataVersion_V2 = 1,
  /// 0.3.0 -> 0.7.1
  MetadataVersion_V3 = 2,
  /// >= 0.8.0
  MetadataVersion_V4 = 3,
  MetadataVersion_MIN = MetadataVersion_V1,
  MetadataVersion_MAX = MetadataVersion_V4
};

inline const MetadataVersion (&EnumValuesMetadataVersion())[4] {
  static const MetadataVersion values[] = {
    MetadataVersion_V1,
    MetadataVersion_V2,
    MetadataVersion_V3,
    MetadataVersion_V4
  };
  return values;
}

inline const char * const *EnumNamesMetadataVersion() {
  static const char * const names[5] = {
    "V1",
    "V2",
    "V3",
    "V4",
    nullptr
  };
  return names;
}

inline const char *EnumNameMetadataVersion(MetadataVersion e) {
  if (e < MetadataVersion_V1 || e > MetadataVersion_V4) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMetadataVersion()[index];
}

enum UnionMode {
  UnionMode_Sparse = 0,
  UnionMode_Dense = 1,
  UnionMode_MIN = UnionMode_Sparse,
  UnionMode_MAX = UnionMode_Dense
};

inline const UnionMode (&EnumValuesUnionMode())[2] {
  static const UnionMode values[] = {
    UnionMode_Sparse,
    UnionMode_Dense
  };
  return values;
}

inline const char * const *EnumNamesUnionMode() {
  static const char * const names[3] = {
    "Sparse",
    "Dense",
    nullptr
  };
  return names;
}

inline const char *EnumNameUnionMode(UnionMode e) {
  if (e < UnionMode_Sparse || e > UnionMode_Dense) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesUnionMode()[index];
}

enum Precision {
  Precision_HALF = 0,
  Precision_SINGLE = 1,
  Precision_DOUBLE = 2,
  Precision_MIN = Precision_HALF,
  Precision_MAX = Precision_DOUBLE
};

inline const Precision (&EnumValuesPrecision())[3] {
  static const Precision values[] = {
    Precision_HALF,
    Precision_SINGLE,
    Precision_DOUBLE
  };
  return values;
}

inline const char * const *EnumNamesPrecision() {
  static const char * const names[4] = {
    "HALF",
    "SINGLE",
    "DOUBLE",
    nullptr
  };
  return names;
}

inline const char *EnumNamePrecision(Precision e) {
  if (e < Precision_HALF || e > Precision_DOUBLE) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPrecision()[index];
}

enum DateUnit {
  DateUnit_DAY = 0,
  DateUnit_MILLISECOND = 1,
  DateUnit_MIN = DateUnit_DAY,
  DateUnit_MAX = DateUnit_MILLISECOND
};

inline const DateUnit (&EnumValuesDateUnit())[2] {
  static const DateUnit values[] = {
    DateUnit_DAY,
    DateUnit_MILLISECOND
  };
  return values;
}

inline const char * const *EnumNamesDateUnit() {
  static const char * const names[3] = {
    "DAY",
    "MILLISECOND",
    nullptr
  };
  return names;
}

inline const char *EnumNameDateUnit(DateUnit e) {
  if (e < DateUnit_DAY || e > DateUnit_MILLISECOND) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDateUnit()[index];
}

enum TimeUnit {
  TimeUnit_SECOND = 0,
  TimeUnit_MILLISECOND = 1,
  TimeUnit_MICROSECOND = 2,
  TimeUnit_NANOSECOND = 3,
  TimeUnit_MIN = TimeUnit_SECOND,
  TimeUnit_MAX = TimeUnit_NANOSECOND
};

inline const TimeUnit (&EnumValuesTimeUnit())[4] {
  static const TimeUnit values[] = {
    TimeUnit_SECOND,
    TimeUnit_MILLISECOND,
    TimeUnit_MICROSECOND,
    TimeUnit_NANOSECOND
  };
  return values;
}

inline const char * const *EnumNamesTimeUnit() {
  static const char * const names[5] = {
    "SECOND",
    "MILLISECOND",
    "MICROSECOND",
    "NANOSECOND",
    nullptr
  };
  return names;
}

inline const char *EnumNameTimeUnit(TimeUnit e) {
  if (e < TimeUnit_SECOND || e > TimeUnit_NANOSECOND) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTimeUnit()[index];
}

enum IntervalUnit {
  IntervalUnit_YEAR_MONTH = 0,
  IntervalUnit_DAY_TIME = 1,
  IntervalUnit_MIN = IntervalUnit_YEAR_MONTH,
  IntervalUnit_MAX = IntervalUnit_DAY_TIME
};

inline const IntervalUnit (&EnumValuesIntervalUnit())[2] {
  static const IntervalUnit values[] = {
    IntervalUnit_YEAR_MONTH,
    IntervalUnit_DAY_TIME
  };
  return values;
}

inline const char * const *EnumNamesIntervalUnit() {
  static const char * const names[3] = {
    "YEAR_MONTH",
    "DAY_TIME",
    nullptr
  };
  return names;
}

inline const char *EnumNameIntervalUnit(IntervalUnit e) {
  if (e < IntervalUnit_YEAR_MONTH || e > IntervalUnit_DAY_TIME) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesIntervalUnit()[index];
}

/// ----------------------------------------------------------------------
/// Top-level Type value, enabling extensible type-specific metadata. We can
/// add new logical types to Type without breaking backwards compatibility
enum Type {
  Type_NONE = 0,
  Type_Null = 1,
  Type_Int = 2,
  Type_FloatingPoint = 3,
  Type_Binary = 4,
  Type_Utf8 = 5,
  Type_Bool = 6,
  Type_Decimal = 7,
  Type_Date = 8,
  Type_Time = 9,
  Type_Timestamp = 10,
  Type_Interval = 11,
  Type_List = 12,
  Type_Struct_ = 13,
  Type_Union = 14,
  Type_FixedSizeBinary = 15,
  Type_FixedSizeList = 16,
  Type_Map = 17,
  Type_Duration = 18,
  Type_LargeBinary = 19,
  Type_LargeUtf8 = 20,
  Type_LargeList = 21,
  Type_MIN = Type_NONE,
  Type_MAX = Type_LargeList
};

inline const Type (&EnumValuesType())[22] {
  static const Type values[] = {
    Type_NONE,
    Type_Null,
    Type_Int,
    Type_FloatingPoint,
    Type_Binary,
    Type_Utf8,
    Type_Bool,
    Type_Decimal,
    Type_Date,
    Type_Time,
    Type_Timestamp,
    Type_Interval,
    Type_List,
    Type_Struct_,
    Type_Union,
    Type_FixedSizeBinary,
    Type_FixedSizeList,
    Type_Map,
    Type_Duration,
    Type_LargeBinary,
    Type_LargeUtf8,
    Type_LargeList
  };
  return values;
}

inline const char * const *EnumNamesType() {
  static const char * const names[23] = {
    "NONE",
    "Null",
    "Int",
    "FloatingPoint",
    "Binary",
    "Utf8",
    "Bool",
    "Decimal",
    "Date",
    "Time",
    "Timestamp",
    "Interval",
    "List",
    "Struct_",
    "Union",
    "FixedSizeBinary",
    "FixedSizeList",
    "Map",
    "Duration",
    "LargeBinary",
    "LargeUtf8",
    "LargeList",
    nullptr
  };
  return names;
}

inline const char *EnumNameType(Type e) {
  if (e < Type_NONE || e > Type_LargeList) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesType()[index];
}

template<typename T> struct TypeTraits {
  static const Type enum_value = Type_NONE;
};

template<> struct TypeTraits<org::apache::arrow::flatbuf::Null> {
  static const Type enum_value = Type_Null;
};

template<> struct TypeTraits<org::apache::arrow::flatbuf::Int> {
  static const Type enum_value = Type_Int;
};

template<> struct TypeTraits<org::apache::arrow::flatbuf::FloatingPoint> {
  static const Type enum_value = Type_FloatingPoint;
};

template<> struct TypeTraits<org::apache::arrow::flatbuf::Binary> {
  static const Type enum_value = Type_Binary;
};

template<> struct TypeTraits<org::apache::arrow::flatbuf::Utf8> {
  static const Type enum_value = Type_Utf8;
};

template<> struct TypeTraits<org::apache::arrow::flatbuf::Bool> {
  static const Type enum_value = Type_Bool;
};

template<> struct TypeTraits<org::apache::arrow::flatbuf::Decimal> {
  static const Type enum_value = Type_Decimal;
};

template<> struct TypeTraits<org::apache::arrow::flatbuf::Date> {
  static const Type enum_value = Type_Date;
};

template<> struct TypeTraits<org::apache::arrow::flatbuf::Time> {
  static const Type enum_value = Type_Time;
};

template<> struct TypeTraits<org::apache::arrow::flatbuf::Timestamp> {
  static const Type enum_value = Type_Timestamp;
};

template<> struct TypeTraits<org::apache::arrow::flatbuf::Interval> {
  static const Type enum_value = Type_Interval;
};

template<> struct TypeTraits<org::apache::arrow::flatbuf::List> {
  static const Type enum_value = Type_List;
};

template<> struct TypeTraits<org::apache::arrow::flatbuf::Struct_> {
  static const Type enum_value = Type_Struct_;
};

template<> struct TypeTraits<org::apache::arrow::flatbuf::Union> {
  static const Type enum_value = Type_Union;
};

template<> struct TypeTraits<org::apache::arrow::flatbuf::FixedSizeBinary> {
  static const Type enum_value = Type_FixedSizeBinary;
};

template<> struct TypeTraits<org::apache::arrow::flatbuf::FixedSizeList> {
  static const Type enum_value = Type_FixedSizeList;
};

template<> struct TypeTraits<org::apache::arrow::flatbuf::Map> {
  static const Type enum_value = Type_Map;
};

template<> struct TypeTraits<org::apache::arrow::flatbuf::Duration> {
  static const Type enum_value = Type_Duration;
};

template<> struct TypeTraits<org::apache::arrow::flatbuf::LargeBinary> {
  static const Type enum_value = Type_LargeBinary;
};

template<> struct TypeTraits<org::apache::arrow::flatbuf::LargeUtf8> {
  static const Type enum_value = Type_LargeUtf8;
};

template<> struct TypeTraits<org::apache::arrow::flatbuf::LargeList> {
  static const Type enum_value = Type_LargeList;
};

bool VerifyType(flatbuffers::Verifier &verifier, const void *obj, Type type);
bool VerifyTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

/// ----------------------------------------------------------------------
/// Dictionary encoding metadata
/// Maintained for forwards compatibility, in the future
/// Dictionaries might be explicit maps between integers and values
/// allowing for non-contiguous index values
enum DictionaryKind {
  DictionaryKind_DenseArray = 0,
  DictionaryKind_MIN = DictionaryKind_DenseArray,
  DictionaryKind_MAX = DictionaryKind_DenseArray
};

inline const DictionaryKind (&EnumValuesDictionaryKind())[1] {
  static const DictionaryKind values[] = {
    DictionaryKind_DenseArray
  };
  return values;
}

inline const char * const *EnumNamesDictionaryKind() {
  static const char * const names[2] = {
    "DenseArray",
    nullptr
  };
  return names;
}

inline const char *EnumNameDictionaryKind(DictionaryKind e) {
  if (e < DictionaryKind_DenseArray || e > DictionaryKind_DenseArray) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDictionaryKind()[index];
}

/// ----------------------------------------------------------------------
/// Endianness of the platform producing the data
enum Endianness {
  Endianness_Little = 0,
  Endianness_Big = 1,
  Endianness_MIN = Endianness_Little,
  Endianness_MAX = Endianness_Big
};

inline const Endianness (&EnumValuesEndianness())[2] {
  static const Endianness values[] = {
    Endianness_Little,
    Endianness_Big
  };
  return values;
}

inline const char * const *EnumNamesEndianness() {
  static const char * const names[3] = {
    "Little",
    "Big",
    nullptr
  };
  return names;
}

inline const char *EnumNameEndianness(Endianness e) {
  if (e < Endianness_Little || e > Endianness_Big) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEndianness()[index];
}

/// ----------------------------------------------------------------------
/// A Buffer represents a single contiguous memory segment
FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Buffer FLATBUFFERS_FINAL_CLASS {
 private:
  int64_t offset_;
  int64_t length_;

 public:
  Buffer() {
    memset(static_cast<void *>(this), 0, sizeof(Buffer));
  }
  Buffer(int64_t _offset, int64_t _length)
      : offset_(flatbuffers::EndianScalar(_offset)),
        length_(flatbuffers::EndianScalar(_length)) {
  }
  /// The relative offset into the shared memory page where the bytes for this
  /// buffer starts
  int64_t offset() const {
    return flatbuffers::EndianScalar(offset_);
  }
  /// The absolute length (in bytes) of the memory buffer. The memory is found
  /// from offset (inclusive) to offset + length (non-inclusive). When building
  /// messages using the encapsulated IPC message, padding bytes may be written
  /// after a buffer, but such padding bytes do not need to be accounted for in
  /// the size here.
  int64_t length() const {
    return flatbuffers::EndianScalar(length_);
  }
};
FLATBUFFERS_STRUCT_END(Buffer, 16);

/// These are stored in the flatbuffer in the Type union below
struct Null FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct NullBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NullBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NullBuilder &operator=(const NullBuilder &);
  flatbuffers::Offset<Null> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Null>(end);
    return o;
  }
};

inline flatbuffers::Offset<Null> CreateNull(
    flatbuffers::FlatBufferBuilder &_fbb) {
  NullBuilder builder_(_fbb);
  return builder_.Finish();
}

/// A Struct_ in the flatbuffer metadata is the same as an Arrow Struct
/// (according to the physical memory layout). We used Struct_ here as
/// Struct is a reserved word in Flatbuffers
struct Struct_ FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct Struct_Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit Struct_Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Struct_Builder &operator=(const Struct_Builder &);
  flatbuffers::Offset<Struct_> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Struct_>(end);
    return o;
  }
};

inline flatbuffers::Offset<Struct_> CreateStruct_(
    flatbuffers::FlatBufferBuilder &_fbb) {
  Struct_Builder builder_(_fbb);
  return builder_.Finish();
}

struct List FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ListBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ListBuilder &operator=(const ListBuilder &);
  flatbuffers::Offset<List> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<List>(end);
    return o;
  }
};

inline flatbuffers::Offset<List> CreateList(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ListBuilder builder_(_fbb);
  return builder_.Finish();
}

/// Same as List, but with 64-bit offsets, allowing to represent
/// extremely large data values.
struct LargeList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LargeListBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LargeListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LargeListBuilder &operator=(const LargeListBuilder &);
  flatbuffers::Offset<LargeList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LargeList>(end);
    return o;
  }
};

inline flatbuffers::Offset<LargeList> CreateLargeList(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LargeListBuilder builder_(_fbb);
  return builder_.Finish();
}

struct FixedSizeList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LISTSIZE = 4
  };
  /// Number of list items per value
  int32_t listSize() const {
    return GetField<int32_t>(VT_LISTSIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_LISTSIZE) &&
           verifier.EndTable();
  }
};

struct FixedSizeListBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_listSize(int32_t listSize) {
    fbb_.AddElement<int32_t>(FixedSizeList::VT_LISTSIZE, listSize, 0);
  }
  explicit FixedSizeListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FixedSizeListBuilder &operator=(const FixedSizeListBuilder &);
  flatbuffers::Offset<FixedSizeList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FixedSizeList>(end);
    return o;
  }
};

inline flatbuffers::Offset<FixedSizeList> CreateFixedSizeList(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t listSize = 0) {
  FixedSizeListBuilder builder_(_fbb);
  builder_.add_listSize(listSize);
  return builder_.Finish();
}

/// A Map is a logical nested type that is represented as
///
/// List<entries: Struct<key: K, value: V>>
///
/// In this layout, the keys and values are each respectively contiguous. We do
/// not constrain the key and value types, so the application is responsible
/// for ensuring that the keys are hashable and unique. Whether the keys are sorted
/// may be set in the metadata for this field.
///
/// In a field with Map type, the field has a child Struct field, which then
/// has two children: key type and the second the value type. The names of the
/// child fields may be respectively "entries", "key", and "value", but this is
/// not enforced.
///
/// Map
///   - child[0] entries: Struct
///     - child[0] key: K
///     - child[1] value: V
///
/// Neither the "entries" field nor the "key" field may be nullable.
///
/// The metadata is structured so that Arrow systems without special handling
/// for Map can make Map an alias for List. The "layout" attribute for the Map
/// field must have the same contents as a List.
struct Map FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEYSSORTED = 4
  };
  /// Set to true if the keys within each value are sorted
  bool keysSorted() const {
    return GetField<uint8_t>(VT_KEYSSORTED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_KEYSSORTED) &&
           verifier.EndTable();
  }
};

struct MapBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_keysSorted(bool keysSorted) {
    fbb_.AddElement<uint8_t>(Map::VT_KEYSSORTED, static_cast<uint8_t>(keysSorted), 0);
  }
  explicit MapBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MapBuilder &operator=(const MapBuilder &);
  flatbuffers::Offset<Map> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Map>(end);
    return o;
  }
};

inline flatbuffers::Offset<Map> CreateMap(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool keysSorted = false) {
  MapBuilder builder_(_fbb);
  builder_.add_keysSorted(keysSorted);
  return builder_.Finish();
}

/// A union is a complex type with children in Field
/// By default ids in the type vector refer to the offsets in the children
/// optionally typeIds provides an indirection between the child offset and the type id
/// for each child typeIds[offset] is the id used in the type vector
struct Union FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODE = 4,
    VT_TYPEIDS = 6
  };
  org::apache::arrow::flatbuf::UnionMode mode() const {
    return static_cast<org::apache::arrow::flatbuf::UnionMode>(GetField<int16_t>(VT_MODE, 0));
  }
  const flatbuffers::Vector<int32_t> *typeIds() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_TYPEIDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_MODE) &&
           VerifyOffset(verifier, VT_TYPEIDS) &&
           verifier.VerifyVector(typeIds()) &&
           verifier.EndTable();
  }
};

struct UnionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mode(org::apache::arrow::flatbuf::UnionMode mode) {
    fbb_.AddElement<int16_t>(Union::VT_MODE, static_cast<int16_t>(mode), 0);
  }
  void add_typeIds(flatbuffers::Offset<flatbuffers::Vector<int32_t>> typeIds) {
    fbb_.AddOffset(Union::VT_TYPEIDS, typeIds);
  }
  explicit UnionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnionBuilder &operator=(const UnionBuilder &);
  flatbuffers::Offset<Union> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Union>(end);
    return o;
  }
};

inline flatbuffers::Offset<Union> CreateUnion(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::flatbuf::UnionMode mode = org::apache::arrow::flatbuf::UnionMode_Sparse,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> typeIds = 0) {
  UnionBuilder builder_(_fbb);
  builder_.add_typeIds(typeIds);
  builder_.add_mode(mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<Union> CreateUnionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::flatbuf::UnionMode mode = org::apache::arrow::flatbuf::UnionMode_Sparse,
    const std::vector<int32_t> *typeIds = nullptr) {
  auto typeIds__ = typeIds ? _fbb.CreateVector<int32_t>(*typeIds) : 0;
  return org::apache::arrow::flatbuf::CreateUnion(
      _fbb,
      mode,
      typeIds__);
}

struct Int FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BITWIDTH = 4,
    VT_IS_SIGNED = 6
  };
  int32_t bitWidth() const {
    return GetField<int32_t>(VT_BITWIDTH, 0);
  }
  bool is_signed() const {
    return GetField<uint8_t>(VT_IS_SIGNED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BITWIDTH) &&
           VerifyField<uint8_t>(verifier, VT_IS_SIGNED) &&
           verifier.EndTable();
  }
};

struct IntBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bitWidth(int32_t bitWidth) {
    fbb_.AddElement<int32_t>(Int::VT_BITWIDTH, bitWidth, 0);
  }
  void add_is_signed(bool is_signed) {
    fbb_.AddElement<uint8_t>(Int::VT_IS_SIGNED, static_cast<uint8_t>(is_signed), 0);
  }
  explicit IntBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IntBuilder &operator=(const IntBuilder &);
  flatbuffers::Offset<Int> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Int>(end);
    return o;
  }
};

inline flatbuffers::Offset<Int> CreateInt(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t bitWidth = 0,
    bool is_signed = false) {
  IntBuilder builder_(_fbb);
  builder_.add_bitWidth(bitWidth);
  builder_.add_is_signed(is_signed);
  return builder_.Finish();
}

struct FloatingPoint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PRECISION = 4
  };
  org::apache::arrow::flatbuf::Precision precision() const {
    return static_cast<org::apache::arrow::flatbuf::Precision>(GetField<int16_t>(VT_PRECISION, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_PRECISION) &&
           verifier.EndTable();
  }
};

struct FloatingPointBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_precision(org::apache::arrow::flatbuf::Precision precision) {
    fbb_.AddElement<int16_t>(FloatingPoint::VT_PRECISION, static_cast<int16_t>(precision), 0);
  }
  explicit FloatingPointBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FloatingPointBuilder &operator=(const FloatingPointBuilder &);
  flatbuffers::Offset<FloatingPoint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FloatingPoint>(end);
    return o;
  }
};

inline flatbuffers::Offset<FloatingPoint> CreateFloatingPoint(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::flatbuf::Precision precision = org::apache::arrow::flatbuf::Precision_HALF) {
  FloatingPointBuilder builder_(_fbb);
  builder_.add_precision(precision);
  return builder_.Finish();
}

/// Unicode with UTF-8 encoding
struct Utf8 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct Utf8Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit Utf8Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Utf8Builder &operator=(const Utf8Builder &);
  flatbuffers::Offset<Utf8> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Utf8>(end);
    return o;
  }
};

inline flatbuffers::Offset<Utf8> CreateUtf8(
    flatbuffers::FlatBufferBuilder &_fbb) {
  Utf8Builder builder_(_fbb);
  return builder_.Finish();
}

/// Opaque binary data
struct Binary FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct BinaryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit BinaryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BinaryBuilder &operator=(const BinaryBuilder &);
  flatbuffers::Offset<Binary> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Binary>(end);
    return o;
  }
};

inline flatbuffers::Offset<Binary> CreateBinary(
    flatbuffers::FlatBufferBuilder &_fbb) {
  BinaryBuilder builder_(_fbb);
  return builder_.Finish();
}

/// Same as Utf8, but with 64-bit offsets, allowing to represent
/// extremely large data values.
struct LargeUtf8 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LargeUtf8Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LargeUtf8Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LargeUtf8Builder &operator=(const LargeUtf8Builder &);
  flatbuffers::Offset<LargeUtf8> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LargeUtf8>(end);
    return o;
  }
};

inline flatbuffers::Offset<LargeUtf8> CreateLargeUtf8(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LargeUtf8Builder builder_(_fbb);
  return builder_.Finish();
}

/// Same as Binary, but with 64-bit offsets, allowing to represent
/// extremely large data values.
struct LargeBinary FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LargeBinaryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LargeBinaryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LargeBinaryBuilder &operator=(const LargeBinaryBuilder &);
  flatbuffers::Offset<LargeBinary> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LargeBinary>(end);
    return o;
  }
};

inline flatbuffers::Offset<LargeBinary> CreateLargeBinary(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LargeBinaryBuilder builder_(_fbb);
  return builder_.Finish();
}

struct FixedSizeBinary FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BYTEWIDTH = 4
  };
  /// Number of bytes per value
  int32_t byteWidth() const {
    return GetField<int32_t>(VT_BYTEWIDTH, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BYTEWIDTH) &&
           verifier.EndTable();
  }
};

struct FixedSizeBinaryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_byteWidth(int32_t byteWidth) {
    fbb_.AddElement<int32_t>(FixedSizeBinary::VT_BYTEWIDTH, byteWidth, 0);
  }
  explicit FixedSizeBinaryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FixedSizeBinaryBuilder &operator=(const FixedSizeBinaryBuilder &);
  flatbuffers::Offset<FixedSizeBinary> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FixedSizeBinary>(end);
    return o;
  }
};

inline flatbuffers::Offset<FixedSizeBinary> CreateFixedSizeBinary(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t byteWidth = 0) {
  FixedSizeBinaryBuilder builder_(_fbb);
  builder_.add_byteWidth(byteWidth);
  return builder_.Finish();
}

struct Bool FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct BoolBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit BoolBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BoolBuilder &operator=(const BoolBuilder &);
  flatbuffers::Offset<Bool> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Bool>(end);
    return o;
  }
};

inline flatbuffers::Offset<Bool> CreateBool(
    flatbuffers::FlatBufferBuilder &_fbb) {
  BoolBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Decimal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PRECISION = 4,
    VT_SCALE = 6
  };
  /// Total number of decimal digits
  int32_t precision() const {
    return GetField<int32_t>(VT_PRECISION, 0);
  }
  /// Number of digits after the decimal point "."
  int32_t scale() const {
    return GetField<int32_t>(VT_SCALE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PRECISION) &&
           VerifyField<int32_t>(verifier, VT_SCALE) &&
           verifier.EndTable();
  }
};

struct DecimalBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_precision(int32_t precision) {
    fbb_.AddElement<int32_t>(Decimal::VT_PRECISION, precision, 0);
  }
  void add_scale(int32_t scale) {
    fbb_.AddElement<int32_t>(Decimal::VT_SCALE, scale, 0);
  }
  explicit DecimalBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DecimalBuilder &operator=(const DecimalBuilder &);
  flatbuffers::Offset<Decimal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Decimal>(end);
    return o;
  }
};

inline flatbuffers::Offset<Decimal> CreateDecimal(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t precision = 0,
    int32_t scale = 0) {
  DecimalBuilder builder_(_fbb);
  builder_.add_scale(scale);
  builder_.add_precision(precision);
  return builder_.Finish();
}

/// Date is either a 32-bit or 64-bit type representing elapsed time since UNIX
/// epoch (1970-01-01), stored in either of two units:
///
/// * Milliseconds (64 bits) indicating UNIX time elapsed since the epoch (no
///   leap seconds), where the values are evenly divisible by 86400000
/// * Days (32 bits) since the UNIX epoch
struct Date FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UNIT = 4
  };
  org::apache::arrow::flatbuf::DateUnit unit() const {
    return static_cast<org::apache::arrow::flatbuf::DateUnit>(GetField<int16_t>(VT_UNIT, 1));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_UNIT) &&
           verifier.EndTable();
  }
};

struct DateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_unit(org::apache::arrow::flatbuf::DateUnit unit) {
    fbb_.AddElement<int16_t>(Date::VT_UNIT, static_cast<int16_t>(unit), 1);
  }
  explicit DateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DateBuilder &operator=(const DateBuilder &);
  flatbuffers::Offset<Date> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Date>(end);
    return o;
  }
};

inline flatbuffers::Offset<Date> CreateDate(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::flatbuf::DateUnit unit = org::apache::arrow::flatbuf::DateUnit_MILLISECOND) {
  DateBuilder builder_(_fbb);
  builder_.add_unit(unit);
  return builder_.Finish();
}

/// Time type. The physical storage type depends on the unit
/// - SECOND and MILLISECOND: 32 bits
/// - MICROSECOND and NANOSECOND: 64 bits
struct Time FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UNIT = 4,
    VT_BITWIDTH = 6
  };
  org::apache::arrow::flatbuf::TimeUnit unit() const {
    return static_cast<org::apache::arrow::flatbuf::TimeUnit>(GetField<int16_t>(VT_UNIT, 1));
  }
  int32_t bitWidth() const {
    return GetField<int32_t>(VT_BITWIDTH, 32);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_UNIT) &&
           VerifyField<int32_t>(verifier, VT_BITWIDTH) &&
           verifier.EndTable();
  }
};

struct TimeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_unit(org::apache::arrow::flatbuf::TimeUnit unit) {
    fbb_.AddElement<int16_t>(Time::VT_UNIT, static_cast<int16_t>(unit), 1);
  }
  void add_bitWidth(int32_t bitWidth) {
    fbb_.AddElement<int32_t>(Time::VT_BITWIDTH, bitWidth, 32);
  }
  explicit TimeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TimeBuilder &operator=(const TimeBuilder &);
  flatbuffers::Offset<Time> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Time>(end);
    return o;
  }
};

inline flatbuffers::Offset<Time> CreateTime(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::flatbuf::TimeUnit unit = org::apache::arrow::flatbuf::TimeUnit_MILLISECOND,
    int32_t bitWidth = 32) {
  TimeBuilder builder_(_fbb);
  builder_.add_bitWidth(bitWidth);
  builder_.add_unit(unit);
  return builder_.Finish();
}

/// Time elapsed from the Unix epoch, 00:00:00.000 on 1 January 1970, excluding
/// leap seconds, as a 64-bit integer. Note that UNIX time does not include
/// leap seconds.
///
/// The Timestamp metadata supports both "time zone naive" and "time zone
/// aware" timestamps. Read about the timezone attribute for more detail
struct Timestamp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UNIT = 4,
    VT_TIMEZONE = 6
  };
  org::apache::arrow::flatbuf::TimeUnit unit() const {
    return static_cast<org::apache::arrow::flatbuf::TimeUnit>(GetField<int16_t>(VT_UNIT, 0));
  }
  /// The time zone is a string indicating the name of a time zone, one of:
  ///
  /// * As used in the Olson time zone database (the "tz database" or
  ///   "tzdata"), such as "America/New_York"
  /// * An absolute time zone offset of the form +XX:XX or -XX:XX, such as +07:30
  ///
  /// Whether a timezone string is present indicates different semantics about
  /// the data:
  ///
  /// * If the time zone is null or equal to an empty string, the data is "time
  ///   zone naive" and shall be displayed *as is* to the user, not localized
  ///   to the locale of the user. This data can be though of as UTC but
  ///   without having "UTC" as the time zone, it is not considered to be
  ///   localized to any time zone
  ///
  /// * If the time zone is set to a valid value, values can be displayed as
  ///   "localized" to that time zone, even though the underlying 64-bit
  ///   integers are identical to the same data stored in UTC. Converting
  ///   between time zones is a metadata-only operation and does not change the
  ///   underlying values
  const flatbuffers::String *timezone() const {
    return GetPointer<const flatbuffers::String *>(VT_TIMEZONE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_UNIT) &&
           VerifyOffset(verifier, VT_TIMEZONE) &&
           verifier.VerifyString(timezone()) &&
           verifier.EndTable();
  }
};

struct TimestampBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_unit(org::apache::arrow::flatbuf::TimeUnit unit) {
    fbb_.AddElement<int16_t>(Timestamp::VT_UNIT, static_cast<int16_t>(unit), 0);
  }
  void add_timezone(flatbuffers::Offset<flatbuffers::String> timezone) {
    fbb_.AddOffset(Timestamp::VT_TIMEZONE, timezone);
  }
  explicit TimestampBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TimestampBuilder &operator=(const TimestampBuilder &);
  flatbuffers::Offset<Timestamp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Timestamp>(end);
    return o;
  }
};

inline flatbuffers::Offset<Timestamp> CreateTimestamp(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::flatbuf::TimeUnit unit = org::apache::arrow::flatbuf::TimeUnit_SECOND,
    flatbuffers::Offset<flatbuffers::String> timezone = 0) {
  TimestampBuilder builder_(_fbb);
  builder_.add_timezone(timezone);
  builder_.add_unit(unit);
  return builder_.Finish();
}

inline flatbuffers::Offset<Timestamp> CreateTimestampDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::flatbuf::TimeUnit unit = org::apache::arrow::flatbuf::TimeUnit_SECOND,
    const char *timezone = nullptr) {
  auto timezone__ = timezone ? _fbb.CreateString(timezone) : 0;
  return org::apache::arrow::flatbuf::CreateTimestamp(
      _fbb,
      unit,
      timezone__);
}

struct Interval FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UNIT = 4
  };
  org::apache::arrow::flatbuf::IntervalUnit unit() const {
    return static_cast<org::apache::arrow::flatbuf::IntervalUnit>(GetField<int16_t>(VT_UNIT, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_UNIT) &&
           verifier.EndTable();
  }
};

struct IntervalBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_unit(org::apache::arrow::flatbuf::IntervalUnit unit) {
    fbb_.AddElement<int16_t>(Interval::VT_UNIT, static_cast<int16_t>(unit), 0);
  }
  explicit IntervalBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IntervalBuilder &operator=(const IntervalBuilder &);
  flatbuffers::Offset<Interval> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Interval>(end);
    return o;
  }
};

inline flatbuffers::Offset<Interval> CreateInterval(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::flatbuf::IntervalUnit unit = org::apache::arrow::flatbuf::IntervalUnit_YEAR_MONTH) {
  IntervalBuilder builder_(_fbb);
  builder_.add_unit(unit);
  return builder_.Finish();
}

struct Duration FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UNIT = 4
  };
  org::apache::arrow::flatbuf::TimeUnit unit() const {
    return static_cast<org::apache::arrow::flatbuf::TimeUnit>(GetField<int16_t>(VT_UNIT, 1));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_UNIT) &&
           verifier.EndTable();
  }
};

struct DurationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_unit(org::apache::arrow::flatbuf::TimeUnit unit) {
    fbb_.AddElement<int16_t>(Duration::VT_UNIT, static_cast<int16_t>(unit), 1);
  }
  explicit DurationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DurationBuilder &operator=(const DurationBuilder &);
  flatbuffers::Offset<Duration> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Duration>(end);
    return o;
  }
};

inline flatbuffers::Offset<Duration> CreateDuration(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::flatbuf::TimeUnit unit = org::apache::arrow::flatbuf::TimeUnit_MILLISECOND) {
  DurationBuilder builder_(_fbb);
  builder_.add_unit(unit);
  return builder_.Finish();
}

/// ----------------------------------------------------------------------
/// user defined key value pairs to add custom metadata to arrow
/// key namespacing is the responsibility of the user
struct KeyValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const flatbuffers::String *key() const {
    return GetPointer<const flatbuffers::String *>(VT_KEY);
  }
  const flatbuffers::String *value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct KeyValueBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(KeyValue::VT_KEY, key);
  }
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(KeyValue::VT_VALUE, value);
  }
  explicit KeyValueBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  KeyValueBuilder &operator=(const KeyValueBuilder &);
  flatbuffers::Offset<KeyValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<KeyValue>(end);
    return o;
  }
};

inline flatbuffers::Offset<KeyValue> CreateKeyValue(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> key = 0,
    flatbuffers::Offset<flatbuffers::String> value = 0) {
  KeyValueBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

inline flatbuffers::Offset<KeyValue> CreateKeyValueDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    const char *value = nullptr) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return org::apache::arrow::flatbuf::CreateKeyValue(
      _fbb,
      key__,
      value__);
}

struct DictionaryEncoding FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_INDEXTYPE = 6,
    VT_ISORDERED = 8,
    VT_DICTIONARYKIND = 10
  };
  /// The known dictionary id in the application where this data is used. In
  /// the file or streaming formats, the dictionary ids are found in the
  /// DictionaryBatch messages
  int64_t id() const {
    return GetField<int64_t>(VT_ID, 0);
  }
  /// The dictionary indices are constrained to be positive integers. If this
  /// field is null, the indices must be signed int32
  const org::apache::arrow::flatbuf::Int *indexType() const {
    return GetPointer<const org::apache::arrow::flatbuf::Int *>(VT_INDEXTYPE);
  }
  /// By default, dictionaries are not ordered, or the order does not have
  /// semantic meaning. In some statistical, applications, dictionary-encoding
  /// is used to represent ordered categorical data, and we provide a way to
  /// preserve that metadata here
  bool isOrdered() const {
    return GetField<uint8_t>(VT_ISORDERED, 0) != 0;
  }
  org::apache::arrow::flatbuf::DictionaryKind dictionaryKind() const {
    return static_cast<org::apache::arrow::flatbuf::DictionaryKind>(GetField<int16_t>(VT_DICTIONARYKIND, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_INDEXTYPE) &&
           verifier.VerifyTable(indexType()) &&
           VerifyField<uint8_t>(verifier, VT_ISORDERED) &&
           VerifyField<int16_t>(verifier, VT_DICTIONARYKIND) &&
           verifier.EndTable();
  }
};

struct DictionaryEncodingBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int64_t id) {
    fbb_.AddElement<int64_t>(DictionaryEncoding::VT_ID, id, 0);
  }
  void add_indexType(flatbuffers::Offset<org::apache::arrow::flatbuf::Int> indexType) {
    fbb_.AddOffset(DictionaryEncoding::VT_INDEXTYPE, indexType);
  }
  void add_isOrdered(bool isOrdered) {
    fbb_.AddElement<uint8_t>(DictionaryEncoding::VT_ISORDERED, static_cast<uint8_t>(isOrdered), 0);
  }
  void add_dictionaryKind(org::apache::arrow::flatbuf::DictionaryKind dictionaryKind) {
    fbb_.AddElement<int16_t>(DictionaryEncoding::VT_DICTIONARYKIND, static_cast<int16_t>(dictionaryKind), 0);
  }
  explicit DictionaryEncodingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DictionaryEncodingBuilder &operator=(const DictionaryEncodingBuilder &);
  flatbuffers::Offset<DictionaryEncoding> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DictionaryEncoding>(end);
    return o;
  }
};

inline flatbuffers::Offset<DictionaryEncoding> CreateDictionaryEncoding(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t id = 0,
    flatbuffers::Offset<org::apache::arrow::flatbuf::Int> indexType = 0,
    bool isOrdered = false,
    org::apache::arrow::flatbuf::DictionaryKind dictionaryKind = org::apache::arrow::flatbuf::DictionaryKind_DenseArray) {
  DictionaryEncodingBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_indexType(indexType);
  builder_.add_dictionaryKind(dictionaryKind);
  builder_.add_isOrdered(isOrdered);
  return builder_.Finish();
}

/// ----------------------------------------------------------------------
/// A field represents a named column in a record / row batch or child of a
/// nested type.
struct Field FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_NULLABLE = 6,
    VT_TYPE_TYPE = 8,
    VT_TYPE = 10,
    VT_DICTIONARY = 12,
    VT_CHILDREN = 14,
    VT_CUSTOM_METADATA = 16
  };
  /// Name is not required, in i.e. a List
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  /// Whether or not this field can contain nulls. Should be true in general.
  bool nullable() const {
    return GetField<uint8_t>(VT_NULLABLE, 0) != 0;
  }
  org::apache::arrow::flatbuf::Type type_type() const {
    return static_cast<org::apache::arrow::flatbuf::Type>(GetField<uint8_t>(VT_TYPE_TYPE, 0));
  }
  /// This is the type of the decoded value if the field is dictionary encoded.
  const void *type() const {
    return GetPointer<const void *>(VT_TYPE);
  }
  template<typename T> const T *type_as() const;
  const org::apache::arrow::flatbuf::Null *type_as_Null() const {
    return type_type() == org::apache::arrow::flatbuf::Type_Null ? static_cast<const org::apache::arrow::flatbuf::Null *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Int *type_as_Int() const {
    return type_type() == org::apache::arrow::flatbuf::Type_Int ? static_cast<const org::apache::arrow::flatbuf::Int *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::FloatingPoint *type_as_FloatingPoint() const {
    return type_type() == org::apache::arrow::flatbuf::Type_FloatingPoint ? static_cast<const org::apache::arrow::flatbuf::FloatingPoint *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Binary *type_as_Binary() const {
    return type_type() == org::apache::arrow::flatbuf::Type_Binary ? static_cast<const org::apache::arrow::flatbuf::Binary *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Utf8 *type_as_Utf8() const {
    return type_type() == org::apache::arrow::flatbuf::Type_Utf8 ? static_cast<const org::apache::arrow::flatbuf::Utf8 *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Bool *type_as_Bool() const {
    return type_type() == org::apache::arrow::flatbuf::Type_Bool ? static_cast<const org::apache::arrow::flatbuf::Bool *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Decimal *type_as_Decimal() const {
    return type_type() == org::apache::arrow::flatbuf::Type_Decimal ? static_cast<const org::apache::arrow::flatbuf::Decimal *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Date *type_as_Date() const {
    return type_type() == org::apache::arrow::flatbuf::Type_Date ? static_cast<const org::apache::arrow::flatbuf::Date *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Time *type_as_Time() const {
    return type_type() == org::apache::arrow::flatbuf::Type_Time ? static_cast<const org::apache::arrow::flatbuf::Time *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Timestamp *type_as_Timestamp() const {
    return type_type() == org::apache::arrow::flatbuf::Type_Timestamp ? static_cast<const org::apache::arrow::flatbuf::Timestamp *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Interval *type_as_Interval() const {
    return type_type() == org::apache::arrow::flatbuf::Type_Interval ? static_cast<const org::apache::arrow::flatbuf::Interval *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::List *type_as_List() const {
    return type_type() == org::apache::arrow::flatbuf::Type_List ? static_cast<const org::apache::arrow::flatbuf::List *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Struct_ *type_as_Struct_() const {
    return type_type() == org::apache::arrow::flatbuf::Type_Struct_ ? static_cast<const org::apache::arrow::flatbuf::Struct_ *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Union *type_as_Union() const {
    return type_type() == org::apache::arrow::flatbuf::Type_Union ? static_cast<const org::apache::arrow::flatbuf::Union *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::FixedSizeBinary *type_as_FixedSizeBinary() const {
    return type_type() == org::apache::arrow::flatbuf::Type_FixedSizeBinary ? static_cast<const org::apache::arrow::flatbuf::FixedSizeBinary *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::FixedSizeList *type_as_FixedSizeList() const {
    return type_type() == org::apache::arrow::flatbuf::Type_FixedSizeList ? static_cast<const org::apache::arrow::flatbuf::FixedSizeList *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Map *type_as_Map() const {
    return type_type() == org::apache::arrow::flatbuf::Type_Map ? static_cast<const org::apache::arrow::flatbuf::Map *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::Duration *type_as_Duration() const {
    return type_type() == org::apache::arrow::flatbuf::Type_Duration ? static_cast<const org::apache::arrow::flatbuf::Duration *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::LargeBinary *type_as_LargeBinary() const {
    return type_type() == org::apache::arrow::flatbuf::Type_LargeBinary ? static_cast<const org::apache::arrow::flatbuf::LargeBinary *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::LargeUtf8 *type_as_LargeUtf8() const {
    return type_type() == org::apache::arrow::flatbuf::Type_LargeUtf8 ? static_cast<const org::apache::arrow::flatbuf::LargeUtf8 *>(type()) : nullptr;
  }
  const org::apache::arrow::flatbuf::LargeList *type_as_LargeList() const {
    return type_type() == org::apache::arrow::flatbuf::Type_LargeList ? static_cast<const org::apache::arrow::flatbuf::LargeList *>(type()) : nullptr;
  }
  /// Present only if the field is dictionary encoded.
  const org::apache::arrow::flatbuf::DictionaryEncoding *dictionary() const {
    return GetPointer<const org::apache::arrow::flatbuf::DictionaryEncoding *>(VT_DICTIONARY);
  }
  /// children apply only to nested data types like Struct, List and Union. For
  /// primitive types children will have length 0.
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::Field>> *children() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::Field>> *>(VT_CHILDREN);
  }
  /// User-defined metadata
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::KeyValue>> *custom_metadata() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::KeyValue>> *>(VT_CUSTOM_METADATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_NULLABLE) &&
           VerifyField<uint8_t>(verifier, VT_TYPE_TYPE) &&
           VerifyOffset(verifier, VT_TYPE) &&
           VerifyType(verifier, type(), type_type()) &&
           VerifyOffset(verifier, VT_DICTIONARY) &&
           verifier.VerifyTable(dictionary()) &&
           VerifyOffset(verifier, VT_CHILDREN) &&
           verifier.VerifyVector(children()) &&
           verifier.VerifyVectorOfTables(children()) &&
           VerifyOffset(verifier, VT_CUSTOM_METADATA) &&
           verifier.VerifyVector(custom_metadata()) &&
           verifier.VerifyVectorOfTables(custom_metadata()) &&
           verifier.EndTable();
  }
};

template<> inline const org::apache::arrow::flatbuf::Null *Field::type_as<org::apache::arrow::flatbuf::Null>() const {
  return type_as_Null();
}

template<> inline const org::apache::arrow::flatbuf::Int *Field::type_as<org::apache::arrow::flatbuf::Int>() const {
  return type_as_Int();
}

template<> inline const org::apache::arrow::flatbuf::FloatingPoint *Field::type_as<org::apache::arrow::flatbuf::FloatingPoint>() const {
  return type_as_FloatingPoint();
}

template<> inline const org::apache::arrow::flatbuf::Binary *Field::type_as<org::apache::arrow::flatbuf::Binary>() const {
  return type_as_Binary();
}

template<> inline const org::apache::arrow::flatbuf::Utf8 *Field::type_as<org::apache::arrow::flatbuf::Utf8>() const {
  return type_as_Utf8();
}

template<> inline const org::apache::arrow::flatbuf::Bool *Field::type_as<org::apache::arrow::flatbuf::Bool>() const {
  return type_as_Bool();
}

template<> inline const org::apache::arrow::flatbuf::Decimal *Field::type_as<org::apache::arrow::flatbuf::Decimal>() const {
  return type_as_Decimal();
}

template<> inline const org::apache::arrow::flatbuf::Date *Field::type_as<org::apache::arrow::flatbuf::Date>() const {
  return type_as_Date();
}

template<> inline const org::apache::arrow::flatbuf::Time *Field::type_as<org::apache::arrow::flatbuf::Time>() const {
  return type_as_Time();
}

template<> inline const org::apache::arrow::flatbuf::Timestamp *Field::type_as<org::apache::arrow::flatbuf::Timestamp>() const {
  return type_as_Timestamp();
}

template<> inline const org::apache::arrow::flatbuf::Interval *Field::type_as<org::apache::arrow::flatbuf::Interval>() const {
  return type_as_Interval();
}

template<> inline const org::apache::arrow::flatbuf::List *Field::type_as<org::apache::arrow::flatbuf::List>() const {
  return type_as_List();
}

template<> inline const org::apache::arrow::flatbuf::Struct_ *Field::type_as<org::apache::arrow::flatbuf::Struct_>() const {
  return type_as_Struct_();
}

template<> inline const org::apache::arrow::flatbuf::Union *Field::type_as<org::apache::arrow::flatbuf::Union>() const {
  return type_as_Union();
}

template<> inline const org::apache::arrow::flatbuf::FixedSizeBinary *Field::type_as<org::apache::arrow::flatbuf::FixedSizeBinary>() const {
  return type_as_FixedSizeBinary();
}

template<> inline const org::apache::arrow::flatbuf::FixedSizeList *Field::type_as<org::apache::arrow::flatbuf::FixedSizeList>() const {
  return type_as_FixedSizeList();
}

template<> inline const org::apache::arrow::flatbuf::Map *Field::type_as<org::apache::arrow::flatbuf::Map>() const {
  return type_as_Map();
}

template<> inline const org::apache::arrow::flatbuf::Duration *Field::type_as<org::apache::arrow::flatbuf::Duration>() const {
  return type_as_Duration();
}

template<> inline const org::apache::arrow::flatbuf::LargeBinary *Field::type_as<org::apache::arrow::flatbuf::LargeBinary>() const {
  return type_as_LargeBinary();
}

template<> inline const org::apache::arrow::flatbuf::LargeUtf8 *Field::type_as<org::apache::arrow::flatbuf::LargeUtf8>() const {
  return type_as_LargeUtf8();
}

template<> inline const org::apache::arrow::flatbuf::LargeList *Field::type_as<org::apache::arrow::flatbuf::LargeList>() const {
  return type_as_LargeList();
}

struct FieldBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Field::VT_NAME, name);
  }
  void add_nullable(bool nullable) {
    fbb_.AddElement<uint8_t>(Field::VT_NULLABLE, static_cast<uint8_t>(nullable), 0);
  }
  void add_type_type(org::apache::arrow::flatbuf::Type type_type) {
    fbb_.AddElement<uint8_t>(Field::VT_TYPE_TYPE, static_cast<uint8_t>(type_type), 0);
  }
  void add_type(flatbuffers::Offset<void> type) {
    fbb_.AddOffset(Field::VT_TYPE, type);
  }
  void add_dictionary(flatbuffers::Offset<org::apache::arrow::flatbuf::DictionaryEncoding> dictionary) {
    fbb_.AddOffset(Field::VT_DICTIONARY, dictionary);
  }
  void add_children(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::Field>>> children) {
    fbb_.AddOffset(Field::VT_CHILDREN, children);
  }
  void add_custom_metadata(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::KeyValue>>> custom_metadata) {
    fbb_.AddOffset(Field::VT_CUSTOM_METADATA, custom_metadata);
  }
  explicit FieldBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FieldBuilder &operator=(const FieldBuilder &);
  flatbuffers::Offset<Field> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Field>(end);
    return o;
  }
};

inline flatbuffers::Offset<Field> CreateField(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    bool nullable = false,
    org::apache::arrow::flatbuf::Type type_type = org::apache::arrow::flatbuf::Type_NONE,
    flatbuffers::Offset<void> type = 0,
    flatbuffers::Offset<org::apache::arrow::flatbuf::DictionaryEncoding> dictionary = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::Field>>> children = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::KeyValue>>> custom_metadata = 0) {
  FieldBuilder builder_(_fbb);
  builder_.add_custom_metadata(custom_metadata);
  builder_.add_children(children);
  builder_.add_dictionary(dictionary);
  builder_.add_type(type);
  builder_.add_name(name);
  builder_.add_type_type(type_type);
  builder_.add_nullable(nullable);
  return builder_.Finish();
}

inline flatbuffers::Offset<Field> CreateFieldDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    bool nullable = false,
    org::apache::arrow::flatbuf::Type type_type = org::apache::arrow::flatbuf::Type_NONE,
    flatbuffers::Offset<void> type = 0,
    flatbuffers::Offset<org::apache::arrow::flatbuf::DictionaryEncoding> dictionary = 0,
    const std::vector<flatbuffers::Offset<org::apache::arrow::flatbuf::Field>> *children = nullptr,
    const std::vector<flatbuffers::Offset<org::apache::arrow::flatbuf::KeyValue>> *custom_metadata = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto children__ = children ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::flatbuf::Field>>(*children) : 0;
  auto custom_metadata__ = custom_metadata ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::flatbuf::KeyValue>>(*custom_metadata) : 0;
  return org::apache::arrow::flatbuf::CreateField(
      _fbb,
      name__,
      nullable,
      type_type,
      type,
      dictionary,
      children__,
      custom_metadata__);
}

/// ----------------------------------------------------------------------
/// A Schema describes the columns in a row batch
struct Schema FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENDIANNESS = 4,
    VT_FIELDS = 6,
    VT_CUSTOM_METADATA = 8
  };
  /// endianness of the buffer
  /// it is Little Endian by default
  /// if endianness doesn't match the underlying system then the vectors need to be converted
  org::apache::arrow::flatbuf::Endianness endianness() const {
    return static_cast<org::apache::arrow::flatbuf::Endianness>(GetField<int16_t>(VT_ENDIANNESS, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::Field>> *fields() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::Field>> *>(VT_FIELDS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::KeyValue>> *custom_metadata() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::KeyValue>> *>(VT_CUSTOM_METADATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_ENDIANNESS) &&
           VerifyOffset(verifier, VT_FIELDS) &&
           verifier.VerifyVector(fields()) &&
           verifier.VerifyVectorOfTables(fields()) &&
           VerifyOffset(verifier, VT_CUSTOM_METADATA) &&
           verifier.VerifyVector(custom_metadata()) &&
           verifier.VerifyVectorOfTables(custom_metadata()) &&
           verifier.EndTable();
  }
};

struct SchemaBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_endianness(org::apache::arrow::flatbuf::Endianness endianness) {
    fbb_.AddElement<int16_t>(Schema::VT_ENDIANNESS, static_cast<int16_t>(endianness), 0);
  }
  void add_fields(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::Field>>> fields) {
    fbb_.AddOffset(Schema::VT_FIELDS, fields);
  }
  void add_custom_metadata(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::KeyValue>>> custom_metadata) {
    fbb_.AddOffset(Schema::VT_CUSTOM_METADATA, custom_metadata);
  }
  explicit SchemaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SchemaBuilder &operator=(const SchemaBuilder &);
  flatbuffers::Offset<Schema> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Schema>(end);
    return o;
  }
};

inline flatbuffers::Offset<Schema> CreateSchema(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::flatbuf::Endianness endianness = org::apache::arrow::flatbuf::Endianness_Little,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::Field>>> fields = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::KeyValue>>> custom_metadata = 0) {
  SchemaBuilder builder_(_fbb);
  builder_.add_custom_metadata(custom_metadata);
  builder_.add_fields(fields);
  builder_.add_endianness(endianness);
  return builder_.Finish();
}

inline flatbuffers::Offset<Schema> CreateSchemaDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::flatbuf::Endianness endianness = org::apache::arrow::flatbuf::Endianness_Little,
    const std::vector<flatbuffers::Offset<org::apache::arrow::flatbuf::Field>> *fields = nullptr,
    const std::vector<flatbuffers::Offset<org::apache::arrow::flatbuf::KeyValue>> *custom_metadata = nullptr) {
  auto fields__ = fields ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::flatbuf::Field>>(*fields) : 0;
  auto custom_metadata__ = custom_metadata ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::flatbuf::KeyValue>>(*custom_metadata) : 0;
  return org::apache::arrow::flatbuf::CreateSchema(
      _fbb,
      endianness,
      fields__,
      custom_metadata__);
}

inline bool VerifyType(flatbuffers::Verifier &verifier, const void *obj, Type type) {
  switch (type) {
    case Type_NONE: {
      return true;
    }
    case Type_Null: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::Null *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Int: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::Int *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_FloatingPoint: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::FloatingPoint *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Binary: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::Binary *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Utf8: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::Utf8 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Bool: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::Bool *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Decimal: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::Decimal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Date: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::Date *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Time: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::Time *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Timestamp: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::Timestamp *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Interval: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::Interval *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_List: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::List *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Struct_: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::Struct_ *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Union: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::Union *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_FixedSizeBinary: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::FixedSizeBinary *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_FixedSizeList: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::FixedSizeList *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Map: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::Map *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Duration: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::Duration *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_LargeBinary: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::LargeBinary *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_LargeUtf8: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::LargeUtf8 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_LargeList: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::LargeList *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyType(
        verifier,  values->Get(i), types->GetEnum<Type>(i))) {
      return false;
    }
  }
  return true;
}

inline const org::apache::arrow::flatbuf::Schema *GetSchema(const void *buf) {
  return flatbuffers::GetRoot<org::apache::arrow::flatbuf::Schema>(buf);
}

inline const org::apache::arrow::flatbuf::Schema *GetSizePrefixedSchema(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<org::apache::arrow::flatbuf::Schema>(buf);
}

inline bool VerifySchemaBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<org::apache::arrow::flatbuf::Schema>(nullptr);
}

inline bool VerifySizePrefixedSchemaBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<org::apache::arrow::flatbuf::Schema>(nullptr);
}

inline void FinishSchemaBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<org::apache::arrow::flatbuf::Schema> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedSchemaBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<org::apache::arrow::flatbuf::Schema> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace flatbuf
}  // namespace arrow
}  // namespace apache
}  // namespace org

#endif  // FLATBUFFERS_GENERATED_SCHEMA_ORG_APACHE_ARROW_FLATBUF_H_
