// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PARQUET3_PARQUET_FORMAT3_H_
#define FLATBUFFERS_GENERATED_PARQUET3_PARQUET_FORMAT3_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

namespace parquet {
namespace format3 {

struct Empty;
struct EmptyBuilder;

struct DecimalOpts;
struct DecimalOptsBuilder;

struct TimeOpts;
struct TimeOptsBuilder;

struct IntOpts;
struct IntOptsBuilder;

struct Value;
struct ValueBuilder;

struct Statistics;
struct StatisticsBuilder;

struct SchemaElement;
struct SchemaElementBuilder;

struct KV;
struct KVBuilder;

struct PageEncodingStats;
struct PageEncodingStatsBuilder;

struct ColumnMetadata;
struct ColumnMetadataBuilder;

struct ColumnChunk;
struct ColumnChunkBuilder;

struct SortingColumn;
struct SortingColumnBuilder;

struct RowGroup;
struct RowGroupBuilder;

struct FileMetaData;
struct FileMetaDataBuilder;

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
enum class Type : int8_t {
  BOOLEAN = 0,
  INT32 = 1,
  INT64 = 2,
  INT96 = 3,
  FLOAT = 4,
  DOUBLE = 5,
  BYTE_ARRAY = 6,
  FIXED_LEN_BYTE_ARRAY = 7,
  MIN = BOOLEAN,
  MAX = FIXED_LEN_BYTE_ARRAY
};

inline const Type (&EnumValuesType())[8] {
  static const Type values[] = {
    Type::BOOLEAN,
    Type::INT32,
    Type::INT64,
    Type::INT96,
    Type::FLOAT,
    Type::DOUBLE,
    Type::BYTE_ARRAY,
    Type::FIXED_LEN_BYTE_ARRAY
  };
  return values;
}

inline const char * const *EnumNamesType() {
  static const char * const names[9] = {
    "BOOLEAN",
    "INT32",
    "INT64",
    "INT96",
    "FLOAT",
    "DOUBLE",
    "BYTE_ARRAY",
    "FIXED_LEN_BYTE_ARRAY",
    nullptr
  };
  return names;
}

inline const char *EnumNameType(Type e) {
  if (::flatbuffers::IsOutRange(e, Type::BOOLEAN, Type::FIXED_LEN_BYTE_ARRAY)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesType()[index];
}

enum class FieldRepetitionType : int8_t {
  REQUIRED = 0,
  OPTIONAL = 1,
  REPEATED = 2,
  MIN = REQUIRED,
  MAX = REPEATED
};

inline const FieldRepetitionType (&EnumValuesFieldRepetitionType())[3] {
  static const FieldRepetitionType values[] = {
    FieldRepetitionType::REQUIRED,
    FieldRepetitionType::OPTIONAL,
    FieldRepetitionType::REPEATED
  };
  return values;
}

inline const char * const *EnumNamesFieldRepetitionType() {
  static const char * const names[4] = {
    "REQUIRED",
    "OPTIONAL",
    "REPEATED",
    nullptr
  };
  return names;
}

inline const char *EnumNameFieldRepetitionType(FieldRepetitionType e) {
  if (::flatbuffers::IsOutRange(e, FieldRepetitionType::REQUIRED, FieldRepetitionType::REPEATED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFieldRepetitionType()[index];
}

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
enum class Encoding : int8_t {
  PLAIN = 0,
  PLAIN_DICTIONARY = 2,
  RLE = 3,
  DELTA_BINARY_PACKED = 5,
  DELTA_LENGTH_BYTE_ARRAY = 6,
  DELTA_BYTE_ARRAY = 7,
  RLE_DICTIONARY = 8,
  BYTE_STREAM_SPLIT = 9,
  MIN = PLAIN,
  MAX = BYTE_STREAM_SPLIT
};

inline const Encoding (&EnumValuesEncoding())[8] {
  static const Encoding values[] = {
    Encoding::PLAIN,
    Encoding::PLAIN_DICTIONARY,
    Encoding::RLE,
    Encoding::DELTA_BINARY_PACKED,
    Encoding::DELTA_LENGTH_BYTE_ARRAY,
    Encoding::DELTA_BYTE_ARRAY,
    Encoding::RLE_DICTIONARY,
    Encoding::BYTE_STREAM_SPLIT
  };
  return values;
}

inline const char * const *EnumNamesEncoding() {
  static const char * const names[11] = {
    "PLAIN",
    "",
    "PLAIN_DICTIONARY",
    "RLE",
    "",
    "DELTA_BINARY_PACKED",
    "DELTA_LENGTH_BYTE_ARRAY",
    "DELTA_BYTE_ARRAY",
    "RLE_DICTIONARY",
    "BYTE_STREAM_SPLIT",
    nullptr
  };
  return names;
}

inline const char *EnumNameEncoding(Encoding e) {
  if (::flatbuffers::IsOutRange(e, Encoding::PLAIN, Encoding::BYTE_STREAM_SPLIT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEncoding()[index];
}

enum class CompressionCodec : int8_t {
  UNCOMPRESSED = 0,
  SNAPPY = 1,
  GZIP = 2,
  LZO = 3,
  BROTLI = 4,
  ZSTD = 6,
  LZ4_RAW = 7,
  MIN = UNCOMPRESSED,
  MAX = LZ4_RAW
};

inline const CompressionCodec (&EnumValuesCompressionCodec())[7] {
  static const CompressionCodec values[] = {
    CompressionCodec::UNCOMPRESSED,
    CompressionCodec::SNAPPY,
    CompressionCodec::GZIP,
    CompressionCodec::LZO,
    CompressionCodec::BROTLI,
    CompressionCodec::ZSTD,
    CompressionCodec::LZ4_RAW
  };
  return values;
}

inline const char * const *EnumNamesCompressionCodec() {
  static const char * const names[9] = {
    "UNCOMPRESSED",
    "SNAPPY",
    "GZIP",
    "LZO",
    "BROTLI",
    "",
    "ZSTD",
    "LZ4_RAW",
    nullptr
  };
  return names;
}

inline const char *EnumNameCompressionCodec(CompressionCodec e) {
  if (::flatbuffers::IsOutRange(e, CompressionCodec::UNCOMPRESSED, CompressionCodec::LZ4_RAW)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCompressionCodec()[index];
}

enum class TimeUnit : int8_t {
  MS = 0,
  US = 1,
  NS = 2,
  MIN = MS,
  MAX = NS
};

inline const TimeUnit (&EnumValuesTimeUnit())[3] {
  static const TimeUnit values[] = {
    TimeUnit::MS,
    TimeUnit::US,
    TimeUnit::NS
  };
  return values;
}

inline const char * const *EnumNamesTimeUnit() {
  static const char * const names[4] = {
    "MS",
    "US",
    "NS",
    nullptr
  };
  return names;
}

inline const char *EnumNameTimeUnit(TimeUnit e) {
  if (::flatbuffers::IsOutRange(e, TimeUnit::MS, TimeUnit::NS)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTimeUnit()[index];
}

enum class LogicalType : uint8_t {
  NONE = 0,
  StringType = 1,
  MapType = 2,
  ListType = 3,
  EnumType = 4,
  DecimalType = 5,
  DateType = 6,
  TimeType = 7,
  TimestampType = 8,
  IntType = 9,
  NullType = 10,
  JsonType = 11,
  BsonType = 12,
  UUIDType = 13,
  Float16Type = 14,
  MIN = NONE,
  MAX = Float16Type
};

inline const LogicalType (&EnumValuesLogicalType())[15] {
  static const LogicalType values[] = {
    LogicalType::NONE,
    LogicalType::StringType,
    LogicalType::MapType,
    LogicalType::ListType,
    LogicalType::EnumType,
    LogicalType::DecimalType,
    LogicalType::DateType,
    LogicalType::TimeType,
    LogicalType::TimestampType,
    LogicalType::IntType,
    LogicalType::NullType,
    LogicalType::JsonType,
    LogicalType::BsonType,
    LogicalType::UUIDType,
    LogicalType::Float16Type
  };
  return values;
}

inline const char * const *EnumNamesLogicalType() {
  static const char * const names[16] = {
    "NONE",
    "StringType",
    "MapType",
    "ListType",
    "EnumType",
    "DecimalType",
    "DateType",
    "TimeType",
    "TimestampType",
    "IntType",
    "NullType",
    "JsonType",
    "BsonType",
    "UUIDType",
    "Float16Type",
    nullptr
  };
  return names;
}

inline const char *EnumNameLogicalType(LogicalType e) {
  if (::flatbuffers::IsOutRange(e, LogicalType::NONE, LogicalType::Float16Type)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLogicalType()[index];
}

bool VerifyLogicalType(::flatbuffers::Verifier &verifier, const void *obj, LogicalType type);
bool VerifyLogicalTypeVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<LogicalType> *types);

enum class ColumnOrder : uint8_t {
  NONE = 0,
  TypeDefinedOrder = 1,
  MIN = NONE,
  MAX = TypeDefinedOrder
};

inline const ColumnOrder (&EnumValuesColumnOrder())[2] {
  static const ColumnOrder values[] = {
    ColumnOrder::NONE,
    ColumnOrder::TypeDefinedOrder
  };
  return values;
}

inline const char * const *EnumNamesColumnOrder() {
  static const char * const names[3] = {
    "NONE",
    "TypeDefinedOrder",
    nullptr
  };
  return names;
}

inline const char *EnumNameColumnOrder(ColumnOrder e) {
  if (::flatbuffers::IsOutRange(e, ColumnOrder::NONE, ColumnOrder::TypeDefinedOrder)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesColumnOrder()[index];
}

template<typename T> struct ColumnOrderTraits {
  static const ColumnOrder enum_value = ColumnOrder::NONE;
};

template<> struct ColumnOrderTraits<parquet::format3::Empty> {
  static const ColumnOrder enum_value = ColumnOrder::TypeDefinedOrder;
};

bool VerifyColumnOrder(::flatbuffers::Verifier &verifier, const void *obj, ColumnOrder type);
bool VerifyColumnOrderVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<ColumnOrder> *types);

enum class PageType : int8_t {
  DATA_PAGE = 0,
  INDEX_PAGE = 1,
  DICTIONARY_PAGE = 2,
  DATA_PAGE_V2 = 3,
  MIN = DATA_PAGE,
  MAX = DATA_PAGE_V2
};

inline const PageType (&EnumValuesPageType())[4] {
  static const PageType values[] = {
    PageType::DATA_PAGE,
    PageType::INDEX_PAGE,
    PageType::DICTIONARY_PAGE,
    PageType::DATA_PAGE_V2
  };
  return values;
}

inline const char * const *EnumNamesPageType() {
  static const char * const names[5] = {
    "DATA_PAGE",
    "INDEX_PAGE",
    "DICTIONARY_PAGE",
    "DATA_PAGE_V2",
    nullptr
  };
  return names;
}

inline const char *EnumNamePageType(PageType e) {
  if (::flatbuffers::IsOutRange(e, PageType::DATA_PAGE, PageType::DATA_PAGE_V2)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPageType()[index];
}

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
struct Empty FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EmptyBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct EmptyBuilder {
  typedef Empty Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit EmptyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Empty> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Empty>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Empty> CreateEmpty(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  EmptyBuilder builder_(_fbb);
  return builder_.Finish();
}

struct DecimalOpts FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DecimalOptsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PRECISION = 4,
    VT_SCALE = 6
  };
  int32_t precision() const {
    return GetField<int32_t>(VT_PRECISION, 0);
  }
  int32_t scale() const {
    return GetField<int32_t>(VT_SCALE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PRECISION, 4) &&
           VerifyField<int32_t>(verifier, VT_SCALE, 4) &&
           verifier.EndTable();
  }
};

struct DecimalOptsBuilder {
  typedef DecimalOpts Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_precision(int32_t precision) {
    fbb_.AddElement<int32_t>(DecimalOpts::VT_PRECISION, precision, 0);
  }
  void add_scale(int32_t scale) {
    fbb_.AddElement<int32_t>(DecimalOpts::VT_SCALE, scale, 0);
  }
  explicit DecimalOptsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DecimalOpts> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DecimalOpts>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DecimalOpts> CreateDecimalOpts(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t precision = 0,
    int32_t scale = 0) {
  DecimalOptsBuilder builder_(_fbb);
  builder_.add_scale(scale);
  builder_.add_precision(precision);
  return builder_.Finish();
}

struct TimeOpts FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TimeOptsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IS_ADJUSTED_TO_UTC = 4,
    VT_UNIT = 6
  };
  bool is_adjusted_to_utc() const {
    return GetField<uint8_t>(VT_IS_ADJUSTED_TO_UTC, 0) != 0;
  }
  parquet::format3::TimeUnit unit() const {
    return static_cast<parquet::format3::TimeUnit>(GetField<int8_t>(VT_UNIT, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_IS_ADJUSTED_TO_UTC, 1) &&
           VerifyField<int8_t>(verifier, VT_UNIT, 1) &&
           verifier.EndTable();
  }
};

struct TimeOptsBuilder {
  typedef TimeOpts Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_is_adjusted_to_utc(bool is_adjusted_to_utc) {
    fbb_.AddElement<uint8_t>(TimeOpts::VT_IS_ADJUSTED_TO_UTC, static_cast<uint8_t>(is_adjusted_to_utc), 0);
  }
  void add_unit(parquet::format3::TimeUnit unit) {
    fbb_.AddElement<int8_t>(TimeOpts::VT_UNIT, static_cast<int8_t>(unit), 0);
  }
  explicit TimeOptsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TimeOpts> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TimeOpts>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TimeOpts> CreateTimeOpts(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool is_adjusted_to_utc = false,
    parquet::format3::TimeUnit unit = parquet::format3::TimeUnit::MS) {
  TimeOptsBuilder builder_(_fbb);
  builder_.add_unit(unit);
  builder_.add_is_adjusted_to_utc(is_adjusted_to_utc);
  return builder_.Finish();
}

struct IntOpts FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IntOptsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BIT_WIDTH = 4,
    VT_IS_SIGNED = 6
  };
  int8_t bit_width() const {
    return GetField<int8_t>(VT_BIT_WIDTH, 8);
  }
  bool is_signed() const {
    return GetField<uint8_t>(VT_IS_SIGNED, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_BIT_WIDTH, 1) &&
           VerifyField<uint8_t>(verifier, VT_IS_SIGNED, 1) &&
           verifier.EndTable();
  }
};

struct IntOptsBuilder {
  typedef IntOpts Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_bit_width(int8_t bit_width) {
    fbb_.AddElement<int8_t>(IntOpts::VT_BIT_WIDTH, bit_width, 8);
  }
  void add_is_signed(bool is_signed) {
    fbb_.AddElement<uint8_t>(IntOpts::VT_IS_SIGNED, static_cast<uint8_t>(is_signed), 0);
  }
  explicit IntOptsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IntOpts> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IntOpts>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<IntOpts> CreateIntOpts(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int8_t bit_width = 8,
    bool is_signed = false) {
  IntOptsBuilder builder_(_fbb);
  builder_.add_is_signed(is_signed);
  builder_.add_bit_width(bit_width);
  return builder_.Finish();
}

struct Value FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const ::flatbuffers::Vector<int8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<int8_t> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct ValueBuilder {
  typedef Value Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> data) {
    fbb_.AddOffset(Value::VT_DATA, data);
  }
  explicit ValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Value> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Value>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Value> CreateValue(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> data = 0) {
  ValueBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Value> CreateValueDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<int8_t>(*data) : 0;
  return parquet::format3::CreateValue(
      _fbb,
      data__);
}

struct Statistics FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StatisticsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NULL_COUNT = 4,
    VT_DISTINCT_COUNT = 6,
    VT_MAX_VALUE = 8,
    VT_MAX8 = 10,
    VT_MAX4 = 12,
    VT_MAX1 = 14,
    VT_MIN_VALUE = 16,
    VT_MIN8 = 18,
    VT_MIN4 = 20,
    VT_MIN1 = 22,
    VT_IS_MAX_VALUE_EXACT = 24,
    VT_IS_MIN_VALUE_EXACT = 26
  };
  ::flatbuffers::Optional<int32_t> null_count() const {
    return GetOptional<int32_t, int32_t>(VT_NULL_COUNT);
  }
  ::flatbuffers::Optional<int32_t> distinct_count() const {
    return GetOptional<int32_t, int32_t>(VT_DISTINCT_COUNT);
  }
  const ::flatbuffers::Vector<int8_t> *max_value() const {
    return GetPointer<const ::flatbuffers::Vector<int8_t> *>(VT_MAX_VALUE);
  }
  uint64_t max8() const {
    return GetField<uint64_t>(VT_MAX8, 0);
  }
  uint32_t max4() const {
    return GetField<uint32_t>(VT_MAX4, 0);
  }
  uint8_t max1() const {
    return GetField<uint8_t>(VT_MAX1, 0);
  }
  const ::flatbuffers::Vector<int8_t> *min_value() const {
    return GetPointer<const ::flatbuffers::Vector<int8_t> *>(VT_MIN_VALUE);
  }
  uint64_t min8() const {
    return GetField<uint64_t>(VT_MIN8, 0);
  }
  uint32_t min4() const {
    return GetField<uint32_t>(VT_MIN4, 0);
  }
  uint8_t min1() const {
    return GetField<uint8_t>(VT_MIN1, 0);
  }
  bool is_max_value_exact() const {
    return GetField<uint8_t>(VT_IS_MAX_VALUE_EXACT, 0) != 0;
  }
  bool is_min_value_exact() const {
    return GetField<uint8_t>(VT_IS_MIN_VALUE_EXACT, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NULL_COUNT, 4) &&
           VerifyField<int32_t>(verifier, VT_DISTINCT_COUNT, 4) &&
           VerifyOffset(verifier, VT_MAX_VALUE) &&
           verifier.VerifyVector(max_value()) &&
           VerifyField<uint64_t>(verifier, VT_MAX8, 8) &&
           VerifyField<uint32_t>(verifier, VT_MAX4, 4) &&
           VerifyField<uint8_t>(verifier, VT_MAX1, 1) &&
           VerifyOffset(verifier, VT_MIN_VALUE) &&
           verifier.VerifyVector(min_value()) &&
           VerifyField<uint64_t>(verifier, VT_MIN8, 8) &&
           VerifyField<uint32_t>(verifier, VT_MIN4, 4) &&
           VerifyField<uint8_t>(verifier, VT_MIN1, 1) &&
           VerifyField<uint8_t>(verifier, VT_IS_MAX_VALUE_EXACT, 1) &&
           VerifyField<uint8_t>(verifier, VT_IS_MIN_VALUE_EXACT, 1) &&
           verifier.EndTable();
  }
};

struct StatisticsBuilder {
  typedef Statistics Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_null_count(int32_t null_count) {
    fbb_.AddElement<int32_t>(Statistics::VT_NULL_COUNT, null_count);
  }
  void add_distinct_count(int32_t distinct_count) {
    fbb_.AddElement<int32_t>(Statistics::VT_DISTINCT_COUNT, distinct_count);
  }
  void add_max_value(::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> max_value) {
    fbb_.AddOffset(Statistics::VT_MAX_VALUE, max_value);
  }
  void add_max8(uint64_t max8) {
    fbb_.AddElement<uint64_t>(Statistics::VT_MAX8, max8, 0);
  }
  void add_max4(uint32_t max4) {
    fbb_.AddElement<uint32_t>(Statistics::VT_MAX4, max4, 0);
  }
  void add_max1(uint8_t max1) {
    fbb_.AddElement<uint8_t>(Statistics::VT_MAX1, max1, 0);
  }
  void add_min_value(::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> min_value) {
    fbb_.AddOffset(Statistics::VT_MIN_VALUE, min_value);
  }
  void add_min8(uint64_t min8) {
    fbb_.AddElement<uint64_t>(Statistics::VT_MIN8, min8, 0);
  }
  void add_min4(uint32_t min4) {
    fbb_.AddElement<uint32_t>(Statistics::VT_MIN4, min4, 0);
  }
  void add_min1(uint8_t min1) {
    fbb_.AddElement<uint8_t>(Statistics::VT_MIN1, min1, 0);
  }
  void add_is_max_value_exact(bool is_max_value_exact) {
    fbb_.AddElement<uint8_t>(Statistics::VT_IS_MAX_VALUE_EXACT, static_cast<uint8_t>(is_max_value_exact), 0);
  }
  void add_is_min_value_exact(bool is_min_value_exact) {
    fbb_.AddElement<uint8_t>(Statistics::VT_IS_MIN_VALUE_EXACT, static_cast<uint8_t>(is_min_value_exact), 0);
  }
  explicit StatisticsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Statistics> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Statistics>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Statistics> CreateStatistics(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Optional<int32_t> null_count = ::flatbuffers::nullopt,
    ::flatbuffers::Optional<int32_t> distinct_count = ::flatbuffers::nullopt,
    ::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> max_value = 0,
    uint64_t max8 = 0,
    uint32_t max4 = 0,
    uint8_t max1 = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> min_value = 0,
    uint64_t min8 = 0,
    uint32_t min4 = 0,
    uint8_t min1 = 0,
    bool is_max_value_exact = false,
    bool is_min_value_exact = false) {
  StatisticsBuilder builder_(_fbb);
  builder_.add_min8(min8);
  builder_.add_max8(max8);
  builder_.add_min4(min4);
  builder_.add_min_value(min_value);
  builder_.add_max4(max4);
  builder_.add_max_value(max_value);
  if(distinct_count) { builder_.add_distinct_count(*distinct_count); }
  if(null_count) { builder_.add_null_count(*null_count); }
  builder_.add_is_min_value_exact(is_min_value_exact);
  builder_.add_is_max_value_exact(is_max_value_exact);
  builder_.add_min1(min1);
  builder_.add_max1(max1);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Statistics> CreateStatisticsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Optional<int32_t> null_count = ::flatbuffers::nullopt,
    ::flatbuffers::Optional<int32_t> distinct_count = ::flatbuffers::nullopt,
    const std::vector<int8_t> *max_value = nullptr,
    uint64_t max8 = 0,
    uint32_t max4 = 0,
    uint8_t max1 = 0,
    const std::vector<int8_t> *min_value = nullptr,
    uint64_t min8 = 0,
    uint32_t min4 = 0,
    uint8_t min1 = 0,
    bool is_max_value_exact = false,
    bool is_min_value_exact = false) {
  auto max_value__ = max_value ? _fbb.CreateVector<int8_t>(*max_value) : 0;
  auto min_value__ = min_value ? _fbb.CreateVector<int8_t>(*min_value) : 0;
  return parquet::format3::CreateStatistics(
      _fbb,
      null_count,
      distinct_count,
      max_value__,
      max8,
      max4,
      max1,
      min_value__,
      min8,
      min4,
      min1,
      is_max_value_exact,
      is_min_value_exact);
}

struct SchemaElement FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SchemaElementBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TYPE = 6,
    VT_REPETITION_TYPE = 8,
    VT_LOGICAL_TYPE_TYPE = 10,
    VT_LOGICAL_TYPE = 12,
    VT_TYPE_LENGTH = 14,
    VT_NUM_CHILDREN = 16,
    VT_FIELD_ID = 18,
    VT_COLUMN_ORDER_TYPE = 20,
    VT_COLUMN_ORDER = 22
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  ::flatbuffers::Optional<parquet::format3::Type> type() const {
    return GetOptional<int8_t, parquet::format3::Type>(VT_TYPE);
  }
  parquet::format3::FieldRepetitionType repetition_type() const {
    return static_cast<parquet::format3::FieldRepetitionType>(GetField<int8_t>(VT_REPETITION_TYPE, 0));
  }
  parquet::format3::LogicalType logical_type_type() const {
    return static_cast<parquet::format3::LogicalType>(GetField<uint8_t>(VT_LOGICAL_TYPE_TYPE, 0));
  }
  const void *logical_type() const {
    return GetPointer<const void *>(VT_LOGICAL_TYPE);
  }
  const parquet::format3::Empty *logical_type_as_StringType() const {
    return logical_type_type() == parquet::format3::LogicalType::StringType ? static_cast<const parquet::format3::Empty *>(logical_type()) : nullptr;
  }
  const parquet::format3::Empty *logical_type_as_MapType() const {
    return logical_type_type() == parquet::format3::LogicalType::MapType ? static_cast<const parquet::format3::Empty *>(logical_type()) : nullptr;
  }
  const parquet::format3::Empty *logical_type_as_ListType() const {
    return logical_type_type() == parquet::format3::LogicalType::ListType ? static_cast<const parquet::format3::Empty *>(logical_type()) : nullptr;
  }
  const parquet::format3::Empty *logical_type_as_EnumType() const {
    return logical_type_type() == parquet::format3::LogicalType::EnumType ? static_cast<const parquet::format3::Empty *>(logical_type()) : nullptr;
  }
  const parquet::format3::DecimalOpts *logical_type_as_DecimalType() const {
    return logical_type_type() == parquet::format3::LogicalType::DecimalType ? static_cast<const parquet::format3::DecimalOpts *>(logical_type()) : nullptr;
  }
  const parquet::format3::Empty *logical_type_as_DateType() const {
    return logical_type_type() == parquet::format3::LogicalType::DateType ? static_cast<const parquet::format3::Empty *>(logical_type()) : nullptr;
  }
  const parquet::format3::TimeOpts *logical_type_as_TimeType() const {
    return logical_type_type() == parquet::format3::LogicalType::TimeType ? static_cast<const parquet::format3::TimeOpts *>(logical_type()) : nullptr;
  }
  const parquet::format3::TimeOpts *logical_type_as_TimestampType() const {
    return logical_type_type() == parquet::format3::LogicalType::TimestampType ? static_cast<const parquet::format3::TimeOpts *>(logical_type()) : nullptr;
  }
  const parquet::format3::IntOpts *logical_type_as_IntType() const {
    return logical_type_type() == parquet::format3::LogicalType::IntType ? static_cast<const parquet::format3::IntOpts *>(logical_type()) : nullptr;
  }
  const parquet::format3::Empty *logical_type_as_NullType() const {
    return logical_type_type() == parquet::format3::LogicalType::NullType ? static_cast<const parquet::format3::Empty *>(logical_type()) : nullptr;
  }
  const parquet::format3::Empty *logical_type_as_JsonType() const {
    return logical_type_type() == parquet::format3::LogicalType::JsonType ? static_cast<const parquet::format3::Empty *>(logical_type()) : nullptr;
  }
  const parquet::format3::Empty *logical_type_as_BsonType() const {
    return logical_type_type() == parquet::format3::LogicalType::BsonType ? static_cast<const parquet::format3::Empty *>(logical_type()) : nullptr;
  }
  const parquet::format3::Empty *logical_type_as_UUIDType() const {
    return logical_type_type() == parquet::format3::LogicalType::UUIDType ? static_cast<const parquet::format3::Empty *>(logical_type()) : nullptr;
  }
  const parquet::format3::Empty *logical_type_as_Float16Type() const {
    return logical_type_type() == parquet::format3::LogicalType::Float16Type ? static_cast<const parquet::format3::Empty *>(logical_type()) : nullptr;
  }
  ::flatbuffers::Optional<int32_t> type_length() const {
    return GetOptional<int32_t, int32_t>(VT_TYPE_LENGTH);
  }
  int32_t num_children() const {
    return GetField<int32_t>(VT_NUM_CHILDREN, 0);
  }
  ::flatbuffers::Optional<int32_t> field_id() const {
    return GetOptional<int32_t, int32_t>(VT_FIELD_ID);
  }
  parquet::format3::ColumnOrder column_order_type() const {
    return static_cast<parquet::format3::ColumnOrder>(GetField<uint8_t>(VT_COLUMN_ORDER_TYPE, 0));
  }
  const void *column_order() const {
    return GetPointer<const void *>(VT_COLUMN_ORDER);
  }
  template<typename T> const T *column_order_as() const;
  const parquet::format3::Empty *column_order_as_TypeDefinedOrder() const {
    return column_order_type() == parquet::format3::ColumnOrder::TypeDefinedOrder ? static_cast<const parquet::format3::Empty *>(column_order()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<int8_t>(verifier, VT_REPETITION_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_LOGICAL_TYPE_TYPE, 1) &&
           VerifyOffset(verifier, VT_LOGICAL_TYPE) &&
           VerifyLogicalType(verifier, logical_type(), logical_type_type()) &&
           VerifyField<int32_t>(verifier, VT_TYPE_LENGTH, 4) &&
           VerifyField<int32_t>(verifier, VT_NUM_CHILDREN, 4) &&
           VerifyField<int32_t>(verifier, VT_FIELD_ID, 4) &&
           VerifyField<uint8_t>(verifier, VT_COLUMN_ORDER_TYPE, 1) &&
           VerifyOffset(verifier, VT_COLUMN_ORDER) &&
           VerifyColumnOrder(verifier, column_order(), column_order_type()) &&
           verifier.EndTable();
  }
};

template<> inline const parquet::format3::Empty *SchemaElement::column_order_as<parquet::format3::Empty>() const {
  return column_order_as_TypeDefinedOrder();
}

struct SchemaElementBuilder {
  typedef SchemaElement Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(SchemaElement::VT_NAME, name);
  }
  void add_type(parquet::format3::Type type) {
    fbb_.AddElement<int8_t>(SchemaElement::VT_TYPE, static_cast<int8_t>(type));
  }
  void add_repetition_type(parquet::format3::FieldRepetitionType repetition_type) {
    fbb_.AddElement<int8_t>(SchemaElement::VT_REPETITION_TYPE, static_cast<int8_t>(repetition_type), 0);
  }
  void add_logical_type_type(parquet::format3::LogicalType logical_type_type) {
    fbb_.AddElement<uint8_t>(SchemaElement::VT_LOGICAL_TYPE_TYPE, static_cast<uint8_t>(logical_type_type), 0);
  }
  void add_logical_type(::flatbuffers::Offset<void> logical_type) {
    fbb_.AddOffset(SchemaElement::VT_LOGICAL_TYPE, logical_type);
  }
  void add_type_length(int32_t type_length) {
    fbb_.AddElement<int32_t>(SchemaElement::VT_TYPE_LENGTH, type_length);
  }
  void add_num_children(int32_t num_children) {
    fbb_.AddElement<int32_t>(SchemaElement::VT_NUM_CHILDREN, num_children, 0);
  }
  void add_field_id(int32_t field_id) {
    fbb_.AddElement<int32_t>(SchemaElement::VT_FIELD_ID, field_id);
  }
  void add_column_order_type(parquet::format3::ColumnOrder column_order_type) {
    fbb_.AddElement<uint8_t>(SchemaElement::VT_COLUMN_ORDER_TYPE, static_cast<uint8_t>(column_order_type), 0);
  }
  void add_column_order(::flatbuffers::Offset<void> column_order) {
    fbb_.AddOffset(SchemaElement::VT_COLUMN_ORDER, column_order);
  }
  explicit SchemaElementBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SchemaElement> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SchemaElement>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SchemaElement> CreateSchemaElement(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Optional<parquet::format3::Type> type = ::flatbuffers::nullopt,
    parquet::format3::FieldRepetitionType repetition_type = parquet::format3::FieldRepetitionType::REQUIRED,
    parquet::format3::LogicalType logical_type_type = parquet::format3::LogicalType::NONE,
    ::flatbuffers::Offset<void> logical_type = 0,
    ::flatbuffers::Optional<int32_t> type_length = ::flatbuffers::nullopt,
    int32_t num_children = 0,
    ::flatbuffers::Optional<int32_t> field_id = ::flatbuffers::nullopt,
    parquet::format3::ColumnOrder column_order_type = parquet::format3::ColumnOrder::NONE,
    ::flatbuffers::Offset<void> column_order = 0) {
  SchemaElementBuilder builder_(_fbb);
  builder_.add_column_order(column_order);
  if(field_id) { builder_.add_field_id(*field_id); }
  builder_.add_num_children(num_children);
  if(type_length) { builder_.add_type_length(*type_length); }
  builder_.add_logical_type(logical_type);
  builder_.add_name(name);
  builder_.add_column_order_type(column_order_type);
  builder_.add_logical_type_type(logical_type_type);
  builder_.add_repetition_type(repetition_type);
  if(type) { builder_.add_type(*type); }
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SchemaElement> CreateSchemaElementDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    ::flatbuffers::Optional<parquet::format3::Type> type = ::flatbuffers::nullopt,
    parquet::format3::FieldRepetitionType repetition_type = parquet::format3::FieldRepetitionType::REQUIRED,
    parquet::format3::LogicalType logical_type_type = parquet::format3::LogicalType::NONE,
    ::flatbuffers::Offset<void> logical_type = 0,
    ::flatbuffers::Optional<int32_t> type_length = ::flatbuffers::nullopt,
    int32_t num_children = 0,
    ::flatbuffers::Optional<int32_t> field_id = ::flatbuffers::nullopt,
    parquet::format3::ColumnOrder column_order_type = parquet::format3::ColumnOrder::NONE,
    ::flatbuffers::Offset<void> column_order = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return parquet::format3::CreateSchemaElement(
      _fbb,
      name__,
      type,
      repetition_type,
      logical_type_type,
      logical_type,
      type_length,
      num_children,
      field_id,
      column_order_type,
      column_order);
}

struct KV FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KVBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VAL = 6
  };
  const ::flatbuffers::String *key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  const ::flatbuffers::String *val() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VAL);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, VT_VAL) &&
           verifier.VerifyString(val()) &&
           verifier.EndTable();
  }
};

struct KVBuilder {
  typedef KV Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
    fbb_.AddOffset(KV::VT_KEY, key);
  }
  void add_val(::flatbuffers::Offset<::flatbuffers::String> val) {
    fbb_.AddOffset(KV::VT_VAL, val);
  }
  explicit KVBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KV> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KV>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<KV> CreateKV(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> key = 0,
    ::flatbuffers::Offset<::flatbuffers::String> val = 0) {
  KVBuilder builder_(_fbb);
  builder_.add_val(val);
  builder_.add_key(key);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<KV> CreateKVDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    const char *val = nullptr) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  auto val__ = val ? _fbb.CreateString(val) : 0;
  return parquet::format3::CreateKV(
      _fbb,
      key__,
      val__);
}

struct PageEncodingStats FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PageEncodingStatsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PAGE_TYPE = 4,
    VT_ENCODING = 6,
    VT_COUNT = 8
  };
  parquet::format3::PageType page_type() const {
    return static_cast<parquet::format3::PageType>(GetField<int8_t>(VT_PAGE_TYPE, 0));
  }
  parquet::format3::Encoding encoding() const {
    return static_cast<parquet::format3::Encoding>(GetField<int8_t>(VT_ENCODING, 0));
  }
  int32_t count() const {
    return GetField<int32_t>(VT_COUNT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_PAGE_TYPE, 1) &&
           VerifyField<int8_t>(verifier, VT_ENCODING, 1) &&
           VerifyField<int32_t>(verifier, VT_COUNT, 4) &&
           verifier.EndTable();
  }
};

struct PageEncodingStatsBuilder {
  typedef PageEncodingStats Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_page_type(parquet::format3::PageType page_type) {
    fbb_.AddElement<int8_t>(PageEncodingStats::VT_PAGE_TYPE, static_cast<int8_t>(page_type), 0);
  }
  void add_encoding(parquet::format3::Encoding encoding) {
    fbb_.AddElement<int8_t>(PageEncodingStats::VT_ENCODING, static_cast<int8_t>(encoding), 0);
  }
  void add_count(int32_t count) {
    fbb_.AddElement<int32_t>(PageEncodingStats::VT_COUNT, count, 0);
  }
  explicit PageEncodingStatsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PageEncodingStats> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PageEncodingStats>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PageEncodingStats> CreatePageEncodingStats(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    parquet::format3::PageType page_type = parquet::format3::PageType::DATA_PAGE,
    parquet::format3::Encoding encoding = parquet::format3::Encoding::PLAIN,
    int32_t count = 0) {
  PageEncodingStatsBuilder builder_(_fbb);
  builder_.add_count(count);
  builder_.add_encoding(encoding);
  builder_.add_page_type(page_type);
  return builder_.Finish();
}

struct ColumnMetadata FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ColumnMetadataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_ENCODINGS = 6,
    VT_PATH_IN_SCHEMA = 8,
    VT_CODEC = 10,
    VT_NUM_VALUES = 12,
    VT_TOTAL_UNCOMPRESSED_SIZE = 14,
    VT_TOTAL_COMPRESSED_SIZE = 16,
    VT_KEY_VALUE_METADATA = 18,
    VT_DATA_PAGE_OFFSET = 20,
    VT_INDEX_PAGE_OFFSET = 22,
    VT_DICTIONARY_PAGE_OFFSET = 24,
    VT_STATISTICS = 26,
    VT_ENCODING_STATS = 28,
    VT_BLOOM_FILTER_OFFSET = 30,
    VT_BLOOM_FILTER_LENGTH = 32
  };
  parquet::format3::Type type() const {
    return static_cast<parquet::format3::Type>(GetField<int8_t>(VT_TYPE, 0));
  }
  const ::flatbuffers::Vector<parquet::format3::Encoding> *encodings() const {
    return GetPointer<const ::flatbuffers::Vector<parquet::format3::Encoding> *>(VT_ENCODINGS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *path_in_schema() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_PATH_IN_SCHEMA);
  }
  parquet::format3::CompressionCodec codec() const {
    return static_cast<parquet::format3::CompressionCodec>(GetField<int8_t>(VT_CODEC, 0));
  }
  int64_t num_values() const {
    return GetField<int64_t>(VT_NUM_VALUES, 0);
  }
  int64_t total_uncompressed_size() const {
    return GetField<int64_t>(VT_TOTAL_UNCOMPRESSED_SIZE, 0);
  }
  int64_t total_compressed_size() const {
    return GetField<int64_t>(VT_TOTAL_COMPRESSED_SIZE, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<parquet::format3::KV>> *key_value_metadata() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<parquet::format3::KV>> *>(VT_KEY_VALUE_METADATA);
  }
  int64_t data_page_offset() const {
    return GetField<int64_t>(VT_DATA_PAGE_OFFSET, 0);
  }
  ::flatbuffers::Optional<int64_t> index_page_offset() const {
    return GetOptional<int64_t, int64_t>(VT_INDEX_PAGE_OFFSET);
  }
  ::flatbuffers::Optional<int64_t> dictionary_page_offset() const {
    return GetOptional<int64_t, int64_t>(VT_DICTIONARY_PAGE_OFFSET);
  }
  const parquet::format3::Statistics *statistics() const {
    return GetPointer<const parquet::format3::Statistics *>(VT_STATISTICS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<parquet::format3::PageEncodingStats>> *encoding_stats() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<parquet::format3::PageEncodingStats>> *>(VT_ENCODING_STATS);
  }
  ::flatbuffers::Optional<int64_t> bloom_filter_offset() const {
    return GetOptional<int64_t, int64_t>(VT_BLOOM_FILTER_OFFSET);
  }
  ::flatbuffers::Optional<int32_t> bloom_filter_length() const {
    return GetOptional<int32_t, int32_t>(VT_BLOOM_FILTER_LENGTH);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_ENCODINGS) &&
           verifier.VerifyVector(encodings()) &&
           VerifyOffset(verifier, VT_PATH_IN_SCHEMA) &&
           verifier.VerifyVector(path_in_schema()) &&
           verifier.VerifyVectorOfStrings(path_in_schema()) &&
           VerifyField<int8_t>(verifier, VT_CODEC, 1) &&
           VerifyField<int64_t>(verifier, VT_NUM_VALUES, 8) &&
           VerifyField<int64_t>(verifier, VT_TOTAL_UNCOMPRESSED_SIZE, 8) &&
           VerifyField<int64_t>(verifier, VT_TOTAL_COMPRESSED_SIZE, 8) &&
           VerifyOffset(verifier, VT_KEY_VALUE_METADATA) &&
           verifier.VerifyVector(key_value_metadata()) &&
           verifier.VerifyVectorOfTables(key_value_metadata()) &&
           VerifyField<int64_t>(verifier, VT_DATA_PAGE_OFFSET, 8) &&
           VerifyField<int64_t>(verifier, VT_INDEX_PAGE_OFFSET, 8) &&
           VerifyField<int64_t>(verifier, VT_DICTIONARY_PAGE_OFFSET, 8) &&
           VerifyOffset(verifier, VT_STATISTICS) &&
           verifier.VerifyTable(statistics()) &&
           VerifyOffset(verifier, VT_ENCODING_STATS) &&
           verifier.VerifyVector(encoding_stats()) &&
           verifier.VerifyVectorOfTables(encoding_stats()) &&
           VerifyField<int64_t>(verifier, VT_BLOOM_FILTER_OFFSET, 8) &&
           VerifyField<int32_t>(verifier, VT_BLOOM_FILTER_LENGTH, 4) &&
           verifier.EndTable();
  }
};

struct ColumnMetadataBuilder {
  typedef ColumnMetadata Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(parquet::format3::Type type) {
    fbb_.AddElement<int8_t>(ColumnMetadata::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_encodings(::flatbuffers::Offset<::flatbuffers::Vector<parquet::format3::Encoding>> encodings) {
    fbb_.AddOffset(ColumnMetadata::VT_ENCODINGS, encodings);
  }
  void add_path_in_schema(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> path_in_schema) {
    fbb_.AddOffset(ColumnMetadata::VT_PATH_IN_SCHEMA, path_in_schema);
  }
  void add_codec(parquet::format3::CompressionCodec codec) {
    fbb_.AddElement<int8_t>(ColumnMetadata::VT_CODEC, static_cast<int8_t>(codec), 0);
  }
  void add_num_values(int64_t num_values) {
    fbb_.AddElement<int64_t>(ColumnMetadata::VT_NUM_VALUES, num_values, 0);
  }
  void add_total_uncompressed_size(int64_t total_uncompressed_size) {
    fbb_.AddElement<int64_t>(ColumnMetadata::VT_TOTAL_UNCOMPRESSED_SIZE, total_uncompressed_size, 0);
  }
  void add_total_compressed_size(int64_t total_compressed_size) {
    fbb_.AddElement<int64_t>(ColumnMetadata::VT_TOTAL_COMPRESSED_SIZE, total_compressed_size, 0);
  }
  void add_key_value_metadata(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<parquet::format3::KV>>> key_value_metadata) {
    fbb_.AddOffset(ColumnMetadata::VT_KEY_VALUE_METADATA, key_value_metadata);
  }
  void add_data_page_offset(int64_t data_page_offset) {
    fbb_.AddElement<int64_t>(ColumnMetadata::VT_DATA_PAGE_OFFSET, data_page_offset, 0);
  }
  void add_index_page_offset(int64_t index_page_offset) {
    fbb_.AddElement<int64_t>(ColumnMetadata::VT_INDEX_PAGE_OFFSET, index_page_offset);
  }
  void add_dictionary_page_offset(int64_t dictionary_page_offset) {
    fbb_.AddElement<int64_t>(ColumnMetadata::VT_DICTIONARY_PAGE_OFFSET, dictionary_page_offset);
  }
  void add_statistics(::flatbuffers::Offset<parquet::format3::Statistics> statistics) {
    fbb_.AddOffset(ColumnMetadata::VT_STATISTICS, statistics);
  }
  void add_encoding_stats(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<parquet::format3::PageEncodingStats>>> encoding_stats) {
    fbb_.AddOffset(ColumnMetadata::VT_ENCODING_STATS, encoding_stats);
  }
  void add_bloom_filter_offset(int64_t bloom_filter_offset) {
    fbb_.AddElement<int64_t>(ColumnMetadata::VT_BLOOM_FILTER_OFFSET, bloom_filter_offset);
  }
  void add_bloom_filter_length(int32_t bloom_filter_length) {
    fbb_.AddElement<int32_t>(ColumnMetadata::VT_BLOOM_FILTER_LENGTH, bloom_filter_length);
  }
  explicit ColumnMetadataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ColumnMetadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ColumnMetadata>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ColumnMetadata> CreateColumnMetadata(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    parquet::format3::Type type = parquet::format3::Type::BOOLEAN,
    ::flatbuffers::Offset<::flatbuffers::Vector<parquet::format3::Encoding>> encodings = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> path_in_schema = 0,
    parquet::format3::CompressionCodec codec = parquet::format3::CompressionCodec::UNCOMPRESSED,
    int64_t num_values = 0,
    int64_t total_uncompressed_size = 0,
    int64_t total_compressed_size = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<parquet::format3::KV>>> key_value_metadata = 0,
    int64_t data_page_offset = 0,
    ::flatbuffers::Optional<int64_t> index_page_offset = ::flatbuffers::nullopt,
    ::flatbuffers::Optional<int64_t> dictionary_page_offset = ::flatbuffers::nullopt,
    ::flatbuffers::Offset<parquet::format3::Statistics> statistics = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<parquet::format3::PageEncodingStats>>> encoding_stats = 0,
    ::flatbuffers::Optional<int64_t> bloom_filter_offset = ::flatbuffers::nullopt,
    ::flatbuffers::Optional<int32_t> bloom_filter_length = ::flatbuffers::nullopt) {
  ColumnMetadataBuilder builder_(_fbb);
  if(bloom_filter_offset) { builder_.add_bloom_filter_offset(*bloom_filter_offset); }
  if(dictionary_page_offset) { builder_.add_dictionary_page_offset(*dictionary_page_offset); }
  if(index_page_offset) { builder_.add_index_page_offset(*index_page_offset); }
  builder_.add_data_page_offset(data_page_offset);
  builder_.add_total_compressed_size(total_compressed_size);
  builder_.add_total_uncompressed_size(total_uncompressed_size);
  builder_.add_num_values(num_values);
  if(bloom_filter_length) { builder_.add_bloom_filter_length(*bloom_filter_length); }
  builder_.add_encoding_stats(encoding_stats);
  builder_.add_statistics(statistics);
  builder_.add_key_value_metadata(key_value_metadata);
  builder_.add_path_in_schema(path_in_schema);
  builder_.add_encodings(encodings);
  builder_.add_codec(codec);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ColumnMetadata> CreateColumnMetadataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    parquet::format3::Type type = parquet::format3::Type::BOOLEAN,
    const std::vector<parquet::format3::Encoding> *encodings = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *path_in_schema = nullptr,
    parquet::format3::CompressionCodec codec = parquet::format3::CompressionCodec::UNCOMPRESSED,
    int64_t num_values = 0,
    int64_t total_uncompressed_size = 0,
    int64_t total_compressed_size = 0,
    const std::vector<::flatbuffers::Offset<parquet::format3::KV>> *key_value_metadata = nullptr,
    int64_t data_page_offset = 0,
    ::flatbuffers::Optional<int64_t> index_page_offset = ::flatbuffers::nullopt,
    ::flatbuffers::Optional<int64_t> dictionary_page_offset = ::flatbuffers::nullopt,
    ::flatbuffers::Offset<parquet::format3::Statistics> statistics = 0,
    const std::vector<::flatbuffers::Offset<parquet::format3::PageEncodingStats>> *encoding_stats = nullptr,
    ::flatbuffers::Optional<int64_t> bloom_filter_offset = ::flatbuffers::nullopt,
    ::flatbuffers::Optional<int32_t> bloom_filter_length = ::flatbuffers::nullopt) {
  auto encodings__ = encodings ? _fbb.CreateVector<parquet::format3::Encoding>(*encodings) : 0;
  auto path_in_schema__ = path_in_schema ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*path_in_schema) : 0;
  auto key_value_metadata__ = key_value_metadata ? _fbb.CreateVector<::flatbuffers::Offset<parquet::format3::KV>>(*key_value_metadata) : 0;
  auto encoding_stats__ = encoding_stats ? _fbb.CreateVector<::flatbuffers::Offset<parquet::format3::PageEncodingStats>>(*encoding_stats) : 0;
  return parquet::format3::CreateColumnMetadata(
      _fbb,
      type,
      encodings__,
      path_in_schema__,
      codec,
      num_values,
      total_uncompressed_size,
      total_compressed_size,
      key_value_metadata__,
      data_page_offset,
      index_page_offset,
      dictionary_page_offset,
      statistics,
      encoding_stats__,
      bloom_filter_offset,
      bloom_filter_length);
}

struct ColumnChunk FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ColumnChunkBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FILE_PATH = 4,
    VT_META_DATA = 6
  };
  const ::flatbuffers::String *file_path() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FILE_PATH);
  }
  const parquet::format3::ColumnMetadata *meta_data() const {
    return GetPointer<const parquet::format3::ColumnMetadata *>(VT_META_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FILE_PATH) &&
           verifier.VerifyString(file_path()) &&
           VerifyOffset(verifier, VT_META_DATA) &&
           verifier.VerifyTable(meta_data()) &&
           verifier.EndTable();
  }
};

struct ColumnChunkBuilder {
  typedef ColumnChunk Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_file_path(::flatbuffers::Offset<::flatbuffers::String> file_path) {
    fbb_.AddOffset(ColumnChunk::VT_FILE_PATH, file_path);
  }
  void add_meta_data(::flatbuffers::Offset<parquet::format3::ColumnMetadata> meta_data) {
    fbb_.AddOffset(ColumnChunk::VT_META_DATA, meta_data);
  }
  explicit ColumnChunkBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ColumnChunk> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ColumnChunk>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ColumnChunk> CreateColumnChunk(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> file_path = 0,
    ::flatbuffers::Offset<parquet::format3::ColumnMetadata> meta_data = 0) {
  ColumnChunkBuilder builder_(_fbb);
  builder_.add_meta_data(meta_data);
  builder_.add_file_path(file_path);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ColumnChunk> CreateColumnChunkDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *file_path = nullptr,
    ::flatbuffers::Offset<parquet::format3::ColumnMetadata> meta_data = 0) {
  auto file_path__ = file_path ? _fbb.CreateString(file_path) : 0;
  return parquet::format3::CreateColumnChunk(
      _fbb,
      file_path__,
      meta_data);
}

struct SortingColumn FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SortingColumnBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLUMN_IDX = 4,
    VT_DESCENDING = 6,
    VT_NULLS_FIRST = 8
  };
  int32_t column_idx() const {
    return GetField<int32_t>(VT_COLUMN_IDX, 0);
  }
  bool descending() const {
    return GetField<uint8_t>(VT_DESCENDING, 0) != 0;
  }
  bool nulls_first() const {
    return GetField<uint8_t>(VT_NULLS_FIRST, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_COLUMN_IDX, 4) &&
           VerifyField<uint8_t>(verifier, VT_DESCENDING, 1) &&
           VerifyField<uint8_t>(verifier, VT_NULLS_FIRST, 1) &&
           verifier.EndTable();
  }
};

struct SortingColumnBuilder {
  typedef SortingColumn Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_column_idx(int32_t column_idx) {
    fbb_.AddElement<int32_t>(SortingColumn::VT_COLUMN_IDX, column_idx, 0);
  }
  void add_descending(bool descending) {
    fbb_.AddElement<uint8_t>(SortingColumn::VT_DESCENDING, static_cast<uint8_t>(descending), 0);
  }
  void add_nulls_first(bool nulls_first) {
    fbb_.AddElement<uint8_t>(SortingColumn::VT_NULLS_FIRST, static_cast<uint8_t>(nulls_first), 0);
  }
  explicit SortingColumnBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SortingColumn> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SortingColumn>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SortingColumn> CreateSortingColumn(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t column_idx = 0,
    bool descending = false,
    bool nulls_first = false) {
  SortingColumnBuilder builder_(_fbb);
  builder_.add_column_idx(column_idx);
  builder_.add_nulls_first(nulls_first);
  builder_.add_descending(descending);
  return builder_.Finish();
}

struct RowGroup FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RowGroupBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLUMNS = 4,
    VT_TOTAL_BYTE_SIZE = 6,
    VT_NUM_ROWS = 8,
    VT_SORTING_COLUMNS = 10,
    VT_FILE_OFFSET = 12,
    VT_TOTAL_COMPRESSED_SIZE = 14,
    VT_ORDINAL = 16
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<parquet::format3::ColumnChunk>> *columns() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<parquet::format3::ColumnChunk>> *>(VT_COLUMNS);
  }
  int64_t total_byte_size() const {
    return GetField<int64_t>(VT_TOTAL_BYTE_SIZE, 0);
  }
  int64_t num_rows() const {
    return GetField<int64_t>(VT_NUM_ROWS, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<parquet::format3::SortingColumn>> *sorting_columns() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<parquet::format3::SortingColumn>> *>(VT_SORTING_COLUMNS);
  }
  int64_t file_offset() const {
    return GetField<int64_t>(VT_FILE_OFFSET, 0);
  }
  int64_t total_compressed_size() const {
    return GetField<int64_t>(VT_TOTAL_COMPRESSED_SIZE, 0);
  }
  ::flatbuffers::Optional<int16_t> ordinal() const {
    return GetOptional<int16_t, int16_t>(VT_ORDINAL);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COLUMNS) &&
           verifier.VerifyVector(columns()) &&
           verifier.VerifyVectorOfTables(columns()) &&
           VerifyField<int64_t>(verifier, VT_TOTAL_BYTE_SIZE, 8) &&
           VerifyField<int64_t>(verifier, VT_NUM_ROWS, 8) &&
           VerifyOffset(verifier, VT_SORTING_COLUMNS) &&
           verifier.VerifyVector(sorting_columns()) &&
           verifier.VerifyVectorOfTables(sorting_columns()) &&
           VerifyField<int64_t>(verifier, VT_FILE_OFFSET, 8) &&
           VerifyField<int64_t>(verifier, VT_TOTAL_COMPRESSED_SIZE, 8) &&
           VerifyField<int16_t>(verifier, VT_ORDINAL, 2) &&
           verifier.EndTable();
  }
};

struct RowGroupBuilder {
  typedef RowGroup Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_columns(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<parquet::format3::ColumnChunk>>> columns) {
    fbb_.AddOffset(RowGroup::VT_COLUMNS, columns);
  }
  void add_total_byte_size(int64_t total_byte_size) {
    fbb_.AddElement<int64_t>(RowGroup::VT_TOTAL_BYTE_SIZE, total_byte_size, 0);
  }
  void add_num_rows(int64_t num_rows) {
    fbb_.AddElement<int64_t>(RowGroup::VT_NUM_ROWS, num_rows, 0);
  }
  void add_sorting_columns(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<parquet::format3::SortingColumn>>> sorting_columns) {
    fbb_.AddOffset(RowGroup::VT_SORTING_COLUMNS, sorting_columns);
  }
  void add_file_offset(int64_t file_offset) {
    fbb_.AddElement<int64_t>(RowGroup::VT_FILE_OFFSET, file_offset, 0);
  }
  void add_total_compressed_size(int64_t total_compressed_size) {
    fbb_.AddElement<int64_t>(RowGroup::VT_TOTAL_COMPRESSED_SIZE, total_compressed_size, 0);
  }
  void add_ordinal(int16_t ordinal) {
    fbb_.AddElement<int16_t>(RowGroup::VT_ORDINAL, ordinal);
  }
  explicit RowGroupBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RowGroup> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RowGroup>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RowGroup> CreateRowGroup(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<parquet::format3::ColumnChunk>>> columns = 0,
    int64_t total_byte_size = 0,
    int64_t num_rows = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<parquet::format3::SortingColumn>>> sorting_columns = 0,
    int64_t file_offset = 0,
    int64_t total_compressed_size = 0,
    ::flatbuffers::Optional<int16_t> ordinal = ::flatbuffers::nullopt) {
  RowGroupBuilder builder_(_fbb);
  builder_.add_total_compressed_size(total_compressed_size);
  builder_.add_file_offset(file_offset);
  builder_.add_num_rows(num_rows);
  builder_.add_total_byte_size(total_byte_size);
  builder_.add_sorting_columns(sorting_columns);
  builder_.add_columns(columns);
  if(ordinal) { builder_.add_ordinal(*ordinal); }
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RowGroup> CreateRowGroupDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<parquet::format3::ColumnChunk>> *columns = nullptr,
    int64_t total_byte_size = 0,
    int64_t num_rows = 0,
    const std::vector<::flatbuffers::Offset<parquet::format3::SortingColumn>> *sorting_columns = nullptr,
    int64_t file_offset = 0,
    int64_t total_compressed_size = 0,
    ::flatbuffers::Optional<int16_t> ordinal = ::flatbuffers::nullopt) {
  auto columns__ = columns ? _fbb.CreateVector<::flatbuffers::Offset<parquet::format3::ColumnChunk>>(*columns) : 0;
  auto sorting_columns__ = sorting_columns ? _fbb.CreateVector<::flatbuffers::Offset<parquet::format3::SortingColumn>>(*sorting_columns) : 0;
  return parquet::format3::CreateRowGroup(
      _fbb,
      columns__,
      total_byte_size,
      num_rows,
      sorting_columns__,
      file_offset,
      total_compressed_size,
      ordinal);
}

struct FileMetaData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FileMetaDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_SCHEMA = 6,
    VT_NUM_ROWS = 8,
    VT_ROW_GROUPS = 10,
    VT_KV = 12,
    VT_CREATED_BY = 14
  };
  int32_t version() const {
    return GetField<int32_t>(VT_VERSION, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<parquet::format3::SchemaElement>> *schema() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<parquet::format3::SchemaElement>> *>(VT_SCHEMA);
  }
  int64_t num_rows() const {
    return GetField<int64_t>(VT_NUM_ROWS, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<parquet::format3::RowGroup>> *row_groups() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<parquet::format3::RowGroup>> *>(VT_ROW_GROUPS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<parquet::format3::KV>> *kv() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<parquet::format3::KV>> *>(VT_KV);
  }
  const ::flatbuffers::String *created_by() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATED_BY);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VERSION, 4) &&
           VerifyOffset(verifier, VT_SCHEMA) &&
           verifier.VerifyVector(schema()) &&
           verifier.VerifyVectorOfTables(schema()) &&
           VerifyField<int64_t>(verifier, VT_NUM_ROWS, 8) &&
           VerifyOffset(verifier, VT_ROW_GROUPS) &&
           verifier.VerifyVector(row_groups()) &&
           verifier.VerifyVectorOfTables(row_groups()) &&
           VerifyOffset(verifier, VT_KV) &&
           verifier.VerifyVector(kv()) &&
           verifier.VerifyVectorOfTables(kv()) &&
           VerifyOffset(verifier, VT_CREATED_BY) &&
           verifier.VerifyString(created_by()) &&
           verifier.EndTable();
  }
};

struct FileMetaDataBuilder {
  typedef FileMetaData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_version(int32_t version) {
    fbb_.AddElement<int32_t>(FileMetaData::VT_VERSION, version, 0);
  }
  void add_schema(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<parquet::format3::SchemaElement>>> schema) {
    fbb_.AddOffset(FileMetaData::VT_SCHEMA, schema);
  }
  void add_num_rows(int64_t num_rows) {
    fbb_.AddElement<int64_t>(FileMetaData::VT_NUM_ROWS, num_rows, 0);
  }
  void add_row_groups(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<parquet::format3::RowGroup>>> row_groups) {
    fbb_.AddOffset(FileMetaData::VT_ROW_GROUPS, row_groups);
  }
  void add_kv(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<parquet::format3::KV>>> kv) {
    fbb_.AddOffset(FileMetaData::VT_KV, kv);
  }
  void add_created_by(::flatbuffers::Offset<::flatbuffers::String> created_by) {
    fbb_.AddOffset(FileMetaData::VT_CREATED_BY, created_by);
  }
  explicit FileMetaDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FileMetaData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FileMetaData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FileMetaData> CreateFileMetaData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t version = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<parquet::format3::SchemaElement>>> schema = 0,
    int64_t num_rows = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<parquet::format3::RowGroup>>> row_groups = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<parquet::format3::KV>>> kv = 0,
    ::flatbuffers::Offset<::flatbuffers::String> created_by = 0) {
  FileMetaDataBuilder builder_(_fbb);
  builder_.add_num_rows(num_rows);
  builder_.add_created_by(created_by);
  builder_.add_kv(kv);
  builder_.add_row_groups(row_groups);
  builder_.add_schema(schema);
  builder_.add_version(version);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FileMetaData> CreateFileMetaDataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t version = 0,
    const std::vector<::flatbuffers::Offset<parquet::format3::SchemaElement>> *schema = nullptr,
    int64_t num_rows = 0,
    const std::vector<::flatbuffers::Offset<parquet::format3::RowGroup>> *row_groups = nullptr,
    const std::vector<::flatbuffers::Offset<parquet::format3::KV>> *kv = nullptr,
    const char *created_by = nullptr) {
  auto schema__ = schema ? _fbb.CreateVector<::flatbuffers::Offset<parquet::format3::SchemaElement>>(*schema) : 0;
  auto row_groups__ = row_groups ? _fbb.CreateVector<::flatbuffers::Offset<parquet::format3::RowGroup>>(*row_groups) : 0;
  auto kv__ = kv ? _fbb.CreateVector<::flatbuffers::Offset<parquet::format3::KV>>(*kv) : 0;
  auto created_by__ = created_by ? _fbb.CreateString(created_by) : 0;
  return parquet::format3::CreateFileMetaData(
      _fbb,
      version,
      schema__,
      num_rows,
      row_groups__,
      kv__,
      created_by__);
}

inline bool VerifyLogicalType(::flatbuffers::Verifier &verifier, const void *obj, LogicalType type) {
  switch (type) {
    case LogicalType::NONE: {
      return true;
    }
    case LogicalType::StringType: {
      auto ptr = reinterpret_cast<const parquet::format3::Empty *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LogicalType::MapType: {
      auto ptr = reinterpret_cast<const parquet::format3::Empty *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LogicalType::ListType: {
      auto ptr = reinterpret_cast<const parquet::format3::Empty *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LogicalType::EnumType: {
      auto ptr = reinterpret_cast<const parquet::format3::Empty *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LogicalType::DecimalType: {
      auto ptr = reinterpret_cast<const parquet::format3::DecimalOpts *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LogicalType::DateType: {
      auto ptr = reinterpret_cast<const parquet::format3::Empty *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LogicalType::TimeType: {
      auto ptr = reinterpret_cast<const parquet::format3::TimeOpts *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LogicalType::TimestampType: {
      auto ptr = reinterpret_cast<const parquet::format3::TimeOpts *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LogicalType::IntType: {
      auto ptr = reinterpret_cast<const parquet::format3::IntOpts *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LogicalType::NullType: {
      auto ptr = reinterpret_cast<const parquet::format3::Empty *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LogicalType::JsonType: {
      auto ptr = reinterpret_cast<const parquet::format3::Empty *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LogicalType::BsonType: {
      auto ptr = reinterpret_cast<const parquet::format3::Empty *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LogicalType::UUIDType: {
      auto ptr = reinterpret_cast<const parquet::format3::Empty *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LogicalType::Float16Type: {
      auto ptr = reinterpret_cast<const parquet::format3::Empty *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyLogicalTypeVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<LogicalType> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyLogicalType(
        verifier,  values->Get(i), types->GetEnum<LogicalType>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyColumnOrder(::flatbuffers::Verifier &verifier, const void *obj, ColumnOrder type) {
  switch (type) {
    case ColumnOrder::NONE: {
      return true;
    }
    case ColumnOrder::TypeDefinedOrder: {
      auto ptr = reinterpret_cast<const parquet::format3::Empty *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyColumnOrderVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<ColumnOrder> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyColumnOrder(
        verifier,  values->Get(i), types->GetEnum<ColumnOrder>(i))) {
      return false;
    }
  }
  return true;
}

inline const parquet::format3::FileMetaData *GetFileMetaData(const void *buf) {
  return ::flatbuffers::GetRoot<parquet::format3::FileMetaData>(buf);
}

inline const parquet::format3::FileMetaData *GetSizePrefixedFileMetaData(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<parquet::format3::FileMetaData>(buf);
}

inline bool VerifyFileMetaDataBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<parquet::format3::FileMetaData>(nullptr);
}

inline bool VerifySizePrefixedFileMetaDataBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<parquet::format3::FileMetaData>(nullptr);
}

inline void FinishFileMetaDataBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<parquet::format3::FileMetaData> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedFileMetaDataBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<parquet::format3::FileMetaData> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace format3
}  // namespace parquet

#endif  // FLATBUFFERS_GENERATED_PARQUET3_PARQUET_FORMAT3_H_
