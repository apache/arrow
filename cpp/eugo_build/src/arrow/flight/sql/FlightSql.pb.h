// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: FlightSql.proto
// Protobuf C++ Version: 5.30.0-dev

#ifndef FlightSql_2eproto_2epb_2eh
#define FlightSql_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5030000
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_type_handler.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/descriptor.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_FlightSql_2eproto ARROW_FLIGHT_SQL_EXPORT

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct ARROW_FLIGHT_SQL_EXPORT TableStruct_FlightSql_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_FlightSql_2eproto;
}  // extern "C"
namespace arrow {
namespace flight {
namespace protocol {
namespace sql {
enum ActionCancelQueryResult_CancelResult : int;
ARROW_FLIGHT_SQL_EXPORT bool ActionCancelQueryResult_CancelResult_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t ActionCancelQueryResult_CancelResult_internal_data_[];
enum ActionEndSavepointRequest_EndSavepoint : int;
ARROW_FLIGHT_SQL_EXPORT bool ActionEndSavepointRequest_EndSavepoint_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t ActionEndSavepointRequest_EndSavepoint_internal_data_[];
enum ActionEndTransactionRequest_EndTransaction : int;
ARROW_FLIGHT_SQL_EXPORT bool ActionEndTransactionRequest_EndTransaction_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t ActionEndTransactionRequest_EndTransaction_internal_data_[];
enum CommandStatementIngest_TableDefinitionOptions_TableExistsOption : int;
ARROW_FLIGHT_SQL_EXPORT bool CommandStatementIngest_TableDefinitionOptions_TableExistsOption_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t CommandStatementIngest_TableDefinitionOptions_TableExistsOption_internal_data_[];
enum CommandStatementIngest_TableDefinitionOptions_TableNotExistOption : int;
ARROW_FLIGHT_SQL_EXPORT bool CommandStatementIngest_TableDefinitionOptions_TableNotExistOption_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t CommandStatementIngest_TableDefinitionOptions_TableNotExistOption_internal_data_[];
enum Nullable : int;
ARROW_FLIGHT_SQL_EXPORT bool Nullable_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t Nullable_internal_data_[];
enum Searchable : int;
ARROW_FLIGHT_SQL_EXPORT bool Searchable_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t Searchable_internal_data_[];
enum SqlInfo : int;
ARROW_FLIGHT_SQL_EXPORT bool SqlInfo_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t SqlInfo_internal_data_[];
enum SqlNullOrdering : int;
ARROW_FLIGHT_SQL_EXPORT bool SqlNullOrdering_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t SqlNullOrdering_internal_data_[];
enum SqlOuterJoinsSupportLevel : int;
ARROW_FLIGHT_SQL_EXPORT bool SqlOuterJoinsSupportLevel_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t SqlOuterJoinsSupportLevel_internal_data_[];
enum SqlSupportedCaseSensitivity : int;
ARROW_FLIGHT_SQL_EXPORT bool SqlSupportedCaseSensitivity_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t SqlSupportedCaseSensitivity_internal_data_[];
enum SqlSupportedElementActions : int;
ARROW_FLIGHT_SQL_EXPORT bool SqlSupportedElementActions_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t SqlSupportedElementActions_internal_data_[];
enum SqlSupportedGroupBy : int;
ARROW_FLIGHT_SQL_EXPORT bool SqlSupportedGroupBy_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t SqlSupportedGroupBy_internal_data_[];
enum SqlSupportedPositionedCommands : int;
ARROW_FLIGHT_SQL_EXPORT bool SqlSupportedPositionedCommands_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t SqlSupportedPositionedCommands_internal_data_[];
enum SqlSupportedResultSetConcurrency : int;
ARROW_FLIGHT_SQL_EXPORT bool SqlSupportedResultSetConcurrency_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t SqlSupportedResultSetConcurrency_internal_data_[];
enum SqlSupportedResultSetType : int;
ARROW_FLIGHT_SQL_EXPORT bool SqlSupportedResultSetType_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t SqlSupportedResultSetType_internal_data_[];
enum SqlSupportedSubqueries : int;
ARROW_FLIGHT_SQL_EXPORT bool SqlSupportedSubqueries_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t SqlSupportedSubqueries_internal_data_[];
enum SqlSupportedTransaction : int;
ARROW_FLIGHT_SQL_EXPORT bool SqlSupportedTransaction_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t SqlSupportedTransaction_internal_data_[];
enum SqlSupportedTransactions : int;
ARROW_FLIGHT_SQL_EXPORT bool SqlSupportedTransactions_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t SqlSupportedTransactions_internal_data_[];
enum SqlSupportedUnions : int;
ARROW_FLIGHT_SQL_EXPORT bool SqlSupportedUnions_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t SqlSupportedUnions_internal_data_[];
enum SqlSupportsConvert : int;
ARROW_FLIGHT_SQL_EXPORT bool SqlSupportsConvert_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t SqlSupportsConvert_internal_data_[];
enum SqlTransactionIsolationLevel : int;
ARROW_FLIGHT_SQL_EXPORT bool SqlTransactionIsolationLevel_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t SqlTransactionIsolationLevel_internal_data_[];
enum SupportedAnsi92SqlGrammarLevel : int;
ARROW_FLIGHT_SQL_EXPORT bool SupportedAnsi92SqlGrammarLevel_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t SupportedAnsi92SqlGrammarLevel_internal_data_[];
enum SupportedSqlGrammar : int;
ARROW_FLIGHT_SQL_EXPORT bool SupportedSqlGrammar_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t SupportedSqlGrammar_internal_data_[];
enum UpdateDeleteRules : int;
ARROW_FLIGHT_SQL_EXPORT bool UpdateDeleteRules_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t UpdateDeleteRules_internal_data_[];
enum XdbcDataType : int;
ARROW_FLIGHT_SQL_EXPORT bool XdbcDataType_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t XdbcDataType_internal_data_[];
enum XdbcDatetimeSubcode : int;
ARROW_FLIGHT_SQL_EXPORT bool XdbcDatetimeSubcode_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t XdbcDatetimeSubcode_internal_data_[];
class ActionBeginSavepointRequest;
struct ActionBeginSavepointRequestDefaultTypeInternal;
ARROW_FLIGHT_SQL_EXPORT extern ActionBeginSavepointRequestDefaultTypeInternal _ActionBeginSavepointRequest_default_instance_;
ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull ActionBeginSavepointRequest_class_data_;
class ActionBeginSavepointResult;
struct ActionBeginSavepointResultDefaultTypeInternal;
ARROW_FLIGHT_SQL_EXPORT extern ActionBeginSavepointResultDefaultTypeInternal _ActionBeginSavepointResult_default_instance_;
ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull ActionBeginSavepointResult_class_data_;
class ActionBeginTransactionRequest;
struct ActionBeginTransactionRequestDefaultTypeInternal;
ARROW_FLIGHT_SQL_EXPORT extern ActionBeginTransactionRequestDefaultTypeInternal _ActionBeginTransactionRequest_default_instance_;
ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull ActionBeginTransactionRequest_class_data_;
class ActionBeginTransactionResult;
struct ActionBeginTransactionResultDefaultTypeInternal;
ARROW_FLIGHT_SQL_EXPORT extern ActionBeginTransactionResultDefaultTypeInternal _ActionBeginTransactionResult_default_instance_;
ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull ActionBeginTransactionResult_class_data_;
class ActionCancelQueryRequest;
struct ActionCancelQueryRequestDefaultTypeInternal;
ARROW_FLIGHT_SQL_EXPORT extern ActionCancelQueryRequestDefaultTypeInternal _ActionCancelQueryRequest_default_instance_;
ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull ActionCancelQueryRequest_class_data_;
class ActionCancelQueryResult;
struct ActionCancelQueryResultDefaultTypeInternal;
ARROW_FLIGHT_SQL_EXPORT extern ActionCancelQueryResultDefaultTypeInternal _ActionCancelQueryResult_default_instance_;
ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull ActionCancelQueryResult_class_data_;
class ActionClosePreparedStatementRequest;
struct ActionClosePreparedStatementRequestDefaultTypeInternal;
ARROW_FLIGHT_SQL_EXPORT extern ActionClosePreparedStatementRequestDefaultTypeInternal _ActionClosePreparedStatementRequest_default_instance_;
ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull ActionClosePreparedStatementRequest_class_data_;
class ActionCreatePreparedStatementRequest;
struct ActionCreatePreparedStatementRequestDefaultTypeInternal;
ARROW_FLIGHT_SQL_EXPORT extern ActionCreatePreparedStatementRequestDefaultTypeInternal _ActionCreatePreparedStatementRequest_default_instance_;
ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull ActionCreatePreparedStatementRequest_class_data_;
class ActionCreatePreparedStatementResult;
struct ActionCreatePreparedStatementResultDefaultTypeInternal;
ARROW_FLIGHT_SQL_EXPORT extern ActionCreatePreparedStatementResultDefaultTypeInternal _ActionCreatePreparedStatementResult_default_instance_;
ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull ActionCreatePreparedStatementResult_class_data_;
class ActionCreatePreparedSubstraitPlanRequest;
struct ActionCreatePreparedSubstraitPlanRequestDefaultTypeInternal;
ARROW_FLIGHT_SQL_EXPORT extern ActionCreatePreparedSubstraitPlanRequestDefaultTypeInternal _ActionCreatePreparedSubstraitPlanRequest_default_instance_;
ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull ActionCreatePreparedSubstraitPlanRequest_class_data_;
class ActionEndSavepointRequest;
struct ActionEndSavepointRequestDefaultTypeInternal;
ARROW_FLIGHT_SQL_EXPORT extern ActionEndSavepointRequestDefaultTypeInternal _ActionEndSavepointRequest_default_instance_;
ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull ActionEndSavepointRequest_class_data_;
class ActionEndTransactionRequest;
struct ActionEndTransactionRequestDefaultTypeInternal;
ARROW_FLIGHT_SQL_EXPORT extern ActionEndTransactionRequestDefaultTypeInternal _ActionEndTransactionRequest_default_instance_;
ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull ActionEndTransactionRequest_class_data_;
class CommandGetCatalogs;
struct CommandGetCatalogsDefaultTypeInternal;
ARROW_FLIGHT_SQL_EXPORT extern CommandGetCatalogsDefaultTypeInternal _CommandGetCatalogs_default_instance_;
ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull CommandGetCatalogs_class_data_;
class CommandGetCrossReference;
struct CommandGetCrossReferenceDefaultTypeInternal;
ARROW_FLIGHT_SQL_EXPORT extern CommandGetCrossReferenceDefaultTypeInternal _CommandGetCrossReference_default_instance_;
ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull CommandGetCrossReference_class_data_;
class CommandGetDbSchemas;
struct CommandGetDbSchemasDefaultTypeInternal;
ARROW_FLIGHT_SQL_EXPORT extern CommandGetDbSchemasDefaultTypeInternal _CommandGetDbSchemas_default_instance_;
ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull CommandGetDbSchemas_class_data_;
class CommandGetExportedKeys;
struct CommandGetExportedKeysDefaultTypeInternal;
ARROW_FLIGHT_SQL_EXPORT extern CommandGetExportedKeysDefaultTypeInternal _CommandGetExportedKeys_default_instance_;
ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull CommandGetExportedKeys_class_data_;
class CommandGetImportedKeys;
struct CommandGetImportedKeysDefaultTypeInternal;
ARROW_FLIGHT_SQL_EXPORT extern CommandGetImportedKeysDefaultTypeInternal _CommandGetImportedKeys_default_instance_;
ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull CommandGetImportedKeys_class_data_;
class CommandGetPrimaryKeys;
struct CommandGetPrimaryKeysDefaultTypeInternal;
ARROW_FLIGHT_SQL_EXPORT extern CommandGetPrimaryKeysDefaultTypeInternal _CommandGetPrimaryKeys_default_instance_;
ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull CommandGetPrimaryKeys_class_data_;
class CommandGetSqlInfo;
struct CommandGetSqlInfoDefaultTypeInternal;
ARROW_FLIGHT_SQL_EXPORT extern CommandGetSqlInfoDefaultTypeInternal _CommandGetSqlInfo_default_instance_;
ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull CommandGetSqlInfo_class_data_;
class CommandGetTableTypes;
struct CommandGetTableTypesDefaultTypeInternal;
ARROW_FLIGHT_SQL_EXPORT extern CommandGetTableTypesDefaultTypeInternal _CommandGetTableTypes_default_instance_;
ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull CommandGetTableTypes_class_data_;
class CommandGetTables;
struct CommandGetTablesDefaultTypeInternal;
ARROW_FLIGHT_SQL_EXPORT extern CommandGetTablesDefaultTypeInternal _CommandGetTables_default_instance_;
ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull CommandGetTables_class_data_;
class CommandGetXdbcTypeInfo;
struct CommandGetXdbcTypeInfoDefaultTypeInternal;
ARROW_FLIGHT_SQL_EXPORT extern CommandGetXdbcTypeInfoDefaultTypeInternal _CommandGetXdbcTypeInfo_default_instance_;
ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull CommandGetXdbcTypeInfo_class_data_;
class CommandPreparedStatementQuery;
struct CommandPreparedStatementQueryDefaultTypeInternal;
ARROW_FLIGHT_SQL_EXPORT extern CommandPreparedStatementQueryDefaultTypeInternal _CommandPreparedStatementQuery_default_instance_;
ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull CommandPreparedStatementQuery_class_data_;
class CommandPreparedStatementUpdate;
struct CommandPreparedStatementUpdateDefaultTypeInternal;
ARROW_FLIGHT_SQL_EXPORT extern CommandPreparedStatementUpdateDefaultTypeInternal _CommandPreparedStatementUpdate_default_instance_;
ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull CommandPreparedStatementUpdate_class_data_;
class CommandStatementIngest;
struct CommandStatementIngestDefaultTypeInternal;
ARROW_FLIGHT_SQL_EXPORT extern CommandStatementIngestDefaultTypeInternal _CommandStatementIngest_default_instance_;
ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull CommandStatementIngest_class_data_;
class CommandStatementIngest_OptionsEntry_DoNotUse;
struct CommandStatementIngest_OptionsEntry_DoNotUseDefaultTypeInternal;
ARROW_FLIGHT_SQL_EXPORT extern CommandStatementIngest_OptionsEntry_DoNotUseDefaultTypeInternal _CommandStatementIngest_OptionsEntry_DoNotUse_default_instance_;
ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull CommandStatementIngest_OptionsEntry_DoNotUse_class_data_;
class CommandStatementIngest_TableDefinitionOptions;
struct CommandStatementIngest_TableDefinitionOptionsDefaultTypeInternal;
ARROW_FLIGHT_SQL_EXPORT extern CommandStatementIngest_TableDefinitionOptionsDefaultTypeInternal _CommandStatementIngest_TableDefinitionOptions_default_instance_;
ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull CommandStatementIngest_TableDefinitionOptions_class_data_;
class CommandStatementQuery;
struct CommandStatementQueryDefaultTypeInternal;
ARROW_FLIGHT_SQL_EXPORT extern CommandStatementQueryDefaultTypeInternal _CommandStatementQuery_default_instance_;
ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull CommandStatementQuery_class_data_;
class CommandStatementSubstraitPlan;
struct CommandStatementSubstraitPlanDefaultTypeInternal;
ARROW_FLIGHT_SQL_EXPORT extern CommandStatementSubstraitPlanDefaultTypeInternal _CommandStatementSubstraitPlan_default_instance_;
ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull CommandStatementSubstraitPlan_class_data_;
class CommandStatementUpdate;
struct CommandStatementUpdateDefaultTypeInternal;
ARROW_FLIGHT_SQL_EXPORT extern CommandStatementUpdateDefaultTypeInternal _CommandStatementUpdate_default_instance_;
ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull CommandStatementUpdate_class_data_;
class DoPutPreparedStatementResult;
struct DoPutPreparedStatementResultDefaultTypeInternal;
ARROW_FLIGHT_SQL_EXPORT extern DoPutPreparedStatementResultDefaultTypeInternal _DoPutPreparedStatementResult_default_instance_;
ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull DoPutPreparedStatementResult_class_data_;
class DoPutUpdateResult;
struct DoPutUpdateResultDefaultTypeInternal;
ARROW_FLIGHT_SQL_EXPORT extern DoPutUpdateResultDefaultTypeInternal _DoPutUpdateResult_default_instance_;
ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull DoPutUpdateResult_class_data_;
class SubstraitPlan;
struct SubstraitPlanDefaultTypeInternal;
ARROW_FLIGHT_SQL_EXPORT extern SubstraitPlanDefaultTypeInternal _SubstraitPlan_default_instance_;
ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull SubstraitPlan_class_data_;
class TicketStatementQuery;
struct TicketStatementQueryDefaultTypeInternal;
ARROW_FLIGHT_SQL_EXPORT extern TicketStatementQueryDefaultTypeInternal _TicketStatementQuery_default_instance_;
ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull TicketStatementQuery_class_data_;
}  // namespace sql
}  // namespace protocol
}  // namespace flight
}  // namespace arrow
namespace google {
namespace protobuf {
template <>
internal::EnumTraitsT<::arrow::flight::protocol::sql::ActionCancelQueryResult_CancelResult_internal_data_>
    internal::EnumTraitsImpl::value<::arrow::flight::protocol::sql::ActionCancelQueryResult_CancelResult>;
template <>
internal::EnumTraitsT<::arrow::flight::protocol::sql::ActionEndSavepointRequest_EndSavepoint_internal_data_>
    internal::EnumTraitsImpl::value<::arrow::flight::protocol::sql::ActionEndSavepointRequest_EndSavepoint>;
template <>
internal::EnumTraitsT<::arrow::flight::protocol::sql::ActionEndTransactionRequest_EndTransaction_internal_data_>
    internal::EnumTraitsImpl::value<::arrow::flight::protocol::sql::ActionEndTransactionRequest_EndTransaction>;
template <>
internal::EnumTraitsT<::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions_TableExistsOption_internal_data_>
    internal::EnumTraitsImpl::value<::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions_TableExistsOption>;
template <>
internal::EnumTraitsT<::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions_TableNotExistOption_internal_data_>
    internal::EnumTraitsImpl::value<::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions_TableNotExistOption>;
template <>
internal::EnumTraitsT<::arrow::flight::protocol::sql::Nullable_internal_data_>
    internal::EnumTraitsImpl::value<::arrow::flight::protocol::sql::Nullable>;
template <>
internal::EnumTraitsT<::arrow::flight::protocol::sql::Searchable_internal_data_>
    internal::EnumTraitsImpl::value<::arrow::flight::protocol::sql::Searchable>;
template <>
internal::EnumTraitsT<::arrow::flight::protocol::sql::SqlInfo_internal_data_>
    internal::EnumTraitsImpl::value<::arrow::flight::protocol::sql::SqlInfo>;
template <>
internal::EnumTraitsT<::arrow::flight::protocol::sql::SqlNullOrdering_internal_data_>
    internal::EnumTraitsImpl::value<::arrow::flight::protocol::sql::SqlNullOrdering>;
template <>
internal::EnumTraitsT<::arrow::flight::protocol::sql::SqlOuterJoinsSupportLevel_internal_data_>
    internal::EnumTraitsImpl::value<::arrow::flight::protocol::sql::SqlOuterJoinsSupportLevel>;
template <>
internal::EnumTraitsT<::arrow::flight::protocol::sql::SqlSupportedCaseSensitivity_internal_data_>
    internal::EnumTraitsImpl::value<::arrow::flight::protocol::sql::SqlSupportedCaseSensitivity>;
template <>
internal::EnumTraitsT<::arrow::flight::protocol::sql::SqlSupportedElementActions_internal_data_>
    internal::EnumTraitsImpl::value<::arrow::flight::protocol::sql::SqlSupportedElementActions>;
template <>
internal::EnumTraitsT<::arrow::flight::protocol::sql::SqlSupportedGroupBy_internal_data_>
    internal::EnumTraitsImpl::value<::arrow::flight::protocol::sql::SqlSupportedGroupBy>;
template <>
internal::EnumTraitsT<::arrow::flight::protocol::sql::SqlSupportedPositionedCommands_internal_data_>
    internal::EnumTraitsImpl::value<::arrow::flight::protocol::sql::SqlSupportedPositionedCommands>;
template <>
internal::EnumTraitsT<::arrow::flight::protocol::sql::SqlSupportedResultSetConcurrency_internal_data_>
    internal::EnumTraitsImpl::value<::arrow::flight::protocol::sql::SqlSupportedResultSetConcurrency>;
template <>
internal::EnumTraitsT<::arrow::flight::protocol::sql::SqlSupportedResultSetType_internal_data_>
    internal::EnumTraitsImpl::value<::arrow::flight::protocol::sql::SqlSupportedResultSetType>;
template <>
internal::EnumTraitsT<::arrow::flight::protocol::sql::SqlSupportedSubqueries_internal_data_>
    internal::EnumTraitsImpl::value<::arrow::flight::protocol::sql::SqlSupportedSubqueries>;
template <>
internal::EnumTraitsT<::arrow::flight::protocol::sql::SqlSupportedTransaction_internal_data_>
    internal::EnumTraitsImpl::value<::arrow::flight::protocol::sql::SqlSupportedTransaction>;
template <>
internal::EnumTraitsT<::arrow::flight::protocol::sql::SqlSupportedTransactions_internal_data_>
    internal::EnumTraitsImpl::value<::arrow::flight::protocol::sql::SqlSupportedTransactions>;
template <>
internal::EnumTraitsT<::arrow::flight::protocol::sql::SqlSupportedUnions_internal_data_>
    internal::EnumTraitsImpl::value<::arrow::flight::protocol::sql::SqlSupportedUnions>;
template <>
internal::EnumTraitsT<::arrow::flight::protocol::sql::SqlSupportsConvert_internal_data_>
    internal::EnumTraitsImpl::value<::arrow::flight::protocol::sql::SqlSupportsConvert>;
template <>
internal::EnumTraitsT<::arrow::flight::protocol::sql::SqlTransactionIsolationLevel_internal_data_>
    internal::EnumTraitsImpl::value<::arrow::flight::protocol::sql::SqlTransactionIsolationLevel>;
template <>
internal::EnumTraitsT<::arrow::flight::protocol::sql::SupportedAnsi92SqlGrammarLevel_internal_data_>
    internal::EnumTraitsImpl::value<::arrow::flight::protocol::sql::SupportedAnsi92SqlGrammarLevel>;
template <>
internal::EnumTraitsT<::arrow::flight::protocol::sql::SupportedSqlGrammar_internal_data_>
    internal::EnumTraitsImpl::value<::arrow::flight::protocol::sql::SupportedSqlGrammar>;
template <>
internal::EnumTraitsT<::arrow::flight::protocol::sql::UpdateDeleteRules_internal_data_>
    internal::EnumTraitsImpl::value<::arrow::flight::protocol::sql::UpdateDeleteRules>;
template <>
internal::EnumTraitsT<::arrow::flight::protocol::sql::XdbcDataType_internal_data_>
    internal::EnumTraitsImpl::value<::arrow::flight::protocol::sql::XdbcDataType>;
template <>
internal::EnumTraitsT<::arrow::flight::protocol::sql::XdbcDatetimeSubcode_internal_data_>
    internal::EnumTraitsImpl::value<::arrow::flight::protocol::sql::XdbcDatetimeSubcode>;
}  // namespace protobuf
}  // namespace google

namespace arrow {
namespace flight {
namespace protocol {
namespace sql {
enum ActionEndTransactionRequest_EndTransaction : int {
  ActionEndTransactionRequest_EndTransaction_END_TRANSACTION_UNSPECIFIED = 0,
  ActionEndTransactionRequest_EndTransaction_END_TRANSACTION_COMMIT = 1,
  ActionEndTransactionRequest_EndTransaction_END_TRANSACTION_ROLLBACK = 2,
  ActionEndTransactionRequest_EndTransaction_ActionEndTransactionRequest_EndTransaction_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ActionEndTransactionRequest_EndTransaction_ActionEndTransactionRequest_EndTransaction_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

ARROW_FLIGHT_SQL_EXPORT bool ActionEndTransactionRequest_EndTransaction_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t ActionEndTransactionRequest_EndTransaction_internal_data_[];
inline constexpr ActionEndTransactionRequest_EndTransaction ActionEndTransactionRequest_EndTransaction_EndTransaction_MIN =
    static_cast<ActionEndTransactionRequest_EndTransaction>(0);
inline constexpr ActionEndTransactionRequest_EndTransaction ActionEndTransactionRequest_EndTransaction_EndTransaction_MAX =
    static_cast<ActionEndTransactionRequest_EndTransaction>(2);
inline constexpr int ActionEndTransactionRequest_EndTransaction_EndTransaction_ARRAYSIZE = 2 + 1;
ARROW_FLIGHT_SQL_EXPORT const ::google::protobuf::EnumDescriptor*
ActionEndTransactionRequest_EndTransaction_descriptor();
template <typename T>
const std::string& ActionEndTransactionRequest_EndTransaction_Name(T value) {
  static_assert(std::is_same<T, ActionEndTransactionRequest_EndTransaction>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to EndTransaction_Name().");
  return ActionEndTransactionRequest_EndTransaction_Name(static_cast<ActionEndTransactionRequest_EndTransaction>(value));
}
template <>
inline const std::string& ActionEndTransactionRequest_EndTransaction_Name(ActionEndTransactionRequest_EndTransaction value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ActionEndTransactionRequest_EndTransaction_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool ActionEndTransactionRequest_EndTransaction_Parse(absl::string_view name, ActionEndTransactionRequest_EndTransaction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ActionEndTransactionRequest_EndTransaction>(
      ActionEndTransactionRequest_EndTransaction_descriptor(), name, value);
}
enum ActionEndSavepointRequest_EndSavepoint : int {
  ActionEndSavepointRequest_EndSavepoint_END_SAVEPOINT_UNSPECIFIED = 0,
  ActionEndSavepointRequest_EndSavepoint_END_SAVEPOINT_RELEASE = 1,
  ActionEndSavepointRequest_EndSavepoint_END_SAVEPOINT_ROLLBACK = 2,
  ActionEndSavepointRequest_EndSavepoint_ActionEndSavepointRequest_EndSavepoint_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ActionEndSavepointRequest_EndSavepoint_ActionEndSavepointRequest_EndSavepoint_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

ARROW_FLIGHT_SQL_EXPORT bool ActionEndSavepointRequest_EndSavepoint_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t ActionEndSavepointRequest_EndSavepoint_internal_data_[];
inline constexpr ActionEndSavepointRequest_EndSavepoint ActionEndSavepointRequest_EndSavepoint_EndSavepoint_MIN =
    static_cast<ActionEndSavepointRequest_EndSavepoint>(0);
inline constexpr ActionEndSavepointRequest_EndSavepoint ActionEndSavepointRequest_EndSavepoint_EndSavepoint_MAX =
    static_cast<ActionEndSavepointRequest_EndSavepoint>(2);
inline constexpr int ActionEndSavepointRequest_EndSavepoint_EndSavepoint_ARRAYSIZE = 2 + 1;
ARROW_FLIGHT_SQL_EXPORT const ::google::protobuf::EnumDescriptor*
ActionEndSavepointRequest_EndSavepoint_descriptor();
template <typename T>
const std::string& ActionEndSavepointRequest_EndSavepoint_Name(T value) {
  static_assert(std::is_same<T, ActionEndSavepointRequest_EndSavepoint>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to EndSavepoint_Name().");
  return ActionEndSavepointRequest_EndSavepoint_Name(static_cast<ActionEndSavepointRequest_EndSavepoint>(value));
}
template <>
inline const std::string& ActionEndSavepointRequest_EndSavepoint_Name(ActionEndSavepointRequest_EndSavepoint value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ActionEndSavepointRequest_EndSavepoint_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool ActionEndSavepointRequest_EndSavepoint_Parse(absl::string_view name, ActionEndSavepointRequest_EndSavepoint* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ActionEndSavepointRequest_EndSavepoint>(
      ActionEndSavepointRequest_EndSavepoint_descriptor(), name, value);
}
enum CommandStatementIngest_TableDefinitionOptions_TableNotExistOption : int {
  CommandStatementIngest_TableDefinitionOptions_TableNotExistOption_TABLE_NOT_EXIST_OPTION_UNSPECIFIED = 0,
  CommandStatementIngest_TableDefinitionOptions_TableNotExistOption_TABLE_NOT_EXIST_OPTION_CREATE = 1,
  CommandStatementIngest_TableDefinitionOptions_TableNotExistOption_TABLE_NOT_EXIST_OPTION_FAIL = 2,
  CommandStatementIngest_TableDefinitionOptions_TableNotExistOption_CommandStatementIngest_TableDefinitionOptions_TableNotExistOption_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  CommandStatementIngest_TableDefinitionOptions_TableNotExistOption_CommandStatementIngest_TableDefinitionOptions_TableNotExistOption_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

ARROW_FLIGHT_SQL_EXPORT bool CommandStatementIngest_TableDefinitionOptions_TableNotExistOption_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t CommandStatementIngest_TableDefinitionOptions_TableNotExistOption_internal_data_[];
inline constexpr CommandStatementIngest_TableDefinitionOptions_TableNotExistOption CommandStatementIngest_TableDefinitionOptions_TableNotExistOption_TableNotExistOption_MIN =
    static_cast<CommandStatementIngest_TableDefinitionOptions_TableNotExistOption>(0);
inline constexpr CommandStatementIngest_TableDefinitionOptions_TableNotExistOption CommandStatementIngest_TableDefinitionOptions_TableNotExistOption_TableNotExistOption_MAX =
    static_cast<CommandStatementIngest_TableDefinitionOptions_TableNotExistOption>(2);
inline constexpr int CommandStatementIngest_TableDefinitionOptions_TableNotExistOption_TableNotExistOption_ARRAYSIZE = 2 + 1;
ARROW_FLIGHT_SQL_EXPORT const ::google::protobuf::EnumDescriptor*
CommandStatementIngest_TableDefinitionOptions_TableNotExistOption_descriptor();
template <typename T>
const std::string& CommandStatementIngest_TableDefinitionOptions_TableNotExistOption_Name(T value) {
  static_assert(std::is_same<T, CommandStatementIngest_TableDefinitionOptions_TableNotExistOption>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TableNotExistOption_Name().");
  return CommandStatementIngest_TableDefinitionOptions_TableNotExistOption_Name(static_cast<CommandStatementIngest_TableDefinitionOptions_TableNotExistOption>(value));
}
template <>
inline const std::string& CommandStatementIngest_TableDefinitionOptions_TableNotExistOption_Name(CommandStatementIngest_TableDefinitionOptions_TableNotExistOption value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CommandStatementIngest_TableDefinitionOptions_TableNotExistOption_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool CommandStatementIngest_TableDefinitionOptions_TableNotExistOption_Parse(absl::string_view name, CommandStatementIngest_TableDefinitionOptions_TableNotExistOption* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CommandStatementIngest_TableDefinitionOptions_TableNotExistOption>(
      CommandStatementIngest_TableDefinitionOptions_TableNotExistOption_descriptor(), name, value);
}
enum CommandStatementIngest_TableDefinitionOptions_TableExistsOption : int {
  CommandStatementIngest_TableDefinitionOptions_TableExistsOption_TABLE_EXISTS_OPTION_UNSPECIFIED = 0,
  CommandStatementIngest_TableDefinitionOptions_TableExistsOption_TABLE_EXISTS_OPTION_FAIL = 1,
  CommandStatementIngest_TableDefinitionOptions_TableExistsOption_TABLE_EXISTS_OPTION_APPEND = 2,
  CommandStatementIngest_TableDefinitionOptions_TableExistsOption_TABLE_EXISTS_OPTION_REPLACE = 3,
  CommandStatementIngest_TableDefinitionOptions_TableExistsOption_CommandStatementIngest_TableDefinitionOptions_TableExistsOption_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  CommandStatementIngest_TableDefinitionOptions_TableExistsOption_CommandStatementIngest_TableDefinitionOptions_TableExistsOption_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

ARROW_FLIGHT_SQL_EXPORT bool CommandStatementIngest_TableDefinitionOptions_TableExistsOption_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t CommandStatementIngest_TableDefinitionOptions_TableExistsOption_internal_data_[];
inline constexpr CommandStatementIngest_TableDefinitionOptions_TableExistsOption CommandStatementIngest_TableDefinitionOptions_TableExistsOption_TableExistsOption_MIN =
    static_cast<CommandStatementIngest_TableDefinitionOptions_TableExistsOption>(0);
inline constexpr CommandStatementIngest_TableDefinitionOptions_TableExistsOption CommandStatementIngest_TableDefinitionOptions_TableExistsOption_TableExistsOption_MAX =
    static_cast<CommandStatementIngest_TableDefinitionOptions_TableExistsOption>(3);
inline constexpr int CommandStatementIngest_TableDefinitionOptions_TableExistsOption_TableExistsOption_ARRAYSIZE = 3 + 1;
ARROW_FLIGHT_SQL_EXPORT const ::google::protobuf::EnumDescriptor*
CommandStatementIngest_TableDefinitionOptions_TableExistsOption_descriptor();
template <typename T>
const std::string& CommandStatementIngest_TableDefinitionOptions_TableExistsOption_Name(T value) {
  static_assert(std::is_same<T, CommandStatementIngest_TableDefinitionOptions_TableExistsOption>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TableExistsOption_Name().");
  return CommandStatementIngest_TableDefinitionOptions_TableExistsOption_Name(static_cast<CommandStatementIngest_TableDefinitionOptions_TableExistsOption>(value));
}
template <>
inline const std::string& CommandStatementIngest_TableDefinitionOptions_TableExistsOption_Name(CommandStatementIngest_TableDefinitionOptions_TableExistsOption value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CommandStatementIngest_TableDefinitionOptions_TableExistsOption_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool CommandStatementIngest_TableDefinitionOptions_TableExistsOption_Parse(absl::string_view name, CommandStatementIngest_TableDefinitionOptions_TableExistsOption* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CommandStatementIngest_TableDefinitionOptions_TableExistsOption>(
      CommandStatementIngest_TableDefinitionOptions_TableExistsOption_descriptor(), name, value);
}
enum ActionCancelQueryResult_CancelResult : int {
  ActionCancelQueryResult_CancelResult_CANCEL_RESULT_UNSPECIFIED = 0,
  ActionCancelQueryResult_CancelResult_CANCEL_RESULT_CANCELLED = 1,
  ActionCancelQueryResult_CancelResult_CANCEL_RESULT_CANCELLING = 2,
  ActionCancelQueryResult_CancelResult_CANCEL_RESULT_NOT_CANCELLABLE = 3,
  ActionCancelQueryResult_CancelResult_ActionCancelQueryResult_CancelResult_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ActionCancelQueryResult_CancelResult_ActionCancelQueryResult_CancelResult_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

ARROW_FLIGHT_SQL_EXPORT bool ActionCancelQueryResult_CancelResult_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t ActionCancelQueryResult_CancelResult_internal_data_[];
inline constexpr ActionCancelQueryResult_CancelResult ActionCancelQueryResult_CancelResult_CancelResult_MIN =
    static_cast<ActionCancelQueryResult_CancelResult>(0);
inline constexpr ActionCancelQueryResult_CancelResult ActionCancelQueryResult_CancelResult_CancelResult_MAX =
    static_cast<ActionCancelQueryResult_CancelResult>(3);
inline constexpr int ActionCancelQueryResult_CancelResult_CancelResult_ARRAYSIZE = 3 + 1;
ARROW_FLIGHT_SQL_EXPORT const ::google::protobuf::EnumDescriptor*
ActionCancelQueryResult_CancelResult_descriptor();
template <typename T>
const std::string& ActionCancelQueryResult_CancelResult_Name(T value) {
  static_assert(std::is_same<T, ActionCancelQueryResult_CancelResult>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CancelResult_Name().");
  return ActionCancelQueryResult_CancelResult_Name(static_cast<ActionCancelQueryResult_CancelResult>(value));
}
template <>
inline const std::string& ActionCancelQueryResult_CancelResult_Name(ActionCancelQueryResult_CancelResult value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ActionCancelQueryResult_CancelResult_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool ActionCancelQueryResult_CancelResult_Parse(absl::string_view name, ActionCancelQueryResult_CancelResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ActionCancelQueryResult_CancelResult>(
      ActionCancelQueryResult_CancelResult_descriptor(), name, value);
}
enum SqlInfo : int {
  FLIGHT_SQL_SERVER_NAME = 0,
  FLIGHT_SQL_SERVER_VERSION = 1,
  FLIGHT_SQL_SERVER_ARROW_VERSION = 2,
  FLIGHT_SQL_SERVER_READ_ONLY = 3,
  FLIGHT_SQL_SERVER_SQL = 4,
  FLIGHT_SQL_SERVER_SUBSTRAIT = 5,
  FLIGHT_SQL_SERVER_SUBSTRAIT_MIN_VERSION = 6,
  FLIGHT_SQL_SERVER_SUBSTRAIT_MAX_VERSION = 7,
  FLIGHT_SQL_SERVER_TRANSACTION = 8,
  FLIGHT_SQL_SERVER_CANCEL = 9,
  FLIGHT_SQL_SERVER_BULK_INGESTION = 10,
  FLIGHT_SQL_SERVER_INGEST_TRANSACTIONS_SUPPORTED = 11,
  FLIGHT_SQL_SERVER_STATEMENT_TIMEOUT = 100,
  FLIGHT_SQL_SERVER_TRANSACTION_TIMEOUT = 101,
  SQL_DDL_CATALOG = 500,
  SQL_DDL_SCHEMA = 501,
  SQL_DDL_TABLE = 502,
  SQL_IDENTIFIER_CASE = 503,
  SQL_IDENTIFIER_QUOTE_CHAR = 504,
  SQL_QUOTED_IDENTIFIER_CASE = 505,
  SQL_ALL_TABLES_ARE_SELECTABLE = 506,
  SQL_NULL_ORDERING = 507,
  SQL_KEYWORDS = 508,
  SQL_NUMERIC_FUNCTIONS = 509,
  SQL_STRING_FUNCTIONS = 510,
  SQL_SYSTEM_FUNCTIONS = 511,
  SQL_DATETIME_FUNCTIONS = 512,
  SQL_SEARCH_STRING_ESCAPE = 513,
  SQL_EXTRA_NAME_CHARACTERS = 514,
  SQL_SUPPORTS_COLUMN_ALIASING = 515,
  SQL_NULL_PLUS_NULL_IS_NULL = 516,
  SQL_SUPPORTS_CONVERT = 517,
  SQL_SUPPORTS_TABLE_CORRELATION_NAMES = 518,
  SQL_SUPPORTS_DIFFERENT_TABLE_CORRELATION_NAMES = 519,
  SQL_SUPPORTS_EXPRESSIONS_IN_ORDER_BY = 520,
  SQL_SUPPORTS_ORDER_BY_UNRELATED = 521,
  SQL_SUPPORTED_GROUP_BY = 522,
  SQL_SUPPORTS_LIKE_ESCAPE_CLAUSE = 523,
  SQL_SUPPORTS_NON_NULLABLE_COLUMNS = 524,
  SQL_SUPPORTED_GRAMMAR = 525,
  SQL_ANSI92_SUPPORTED_LEVEL = 526,
  SQL_SUPPORTS_INTEGRITY_ENHANCEMENT_FACILITY = 527,
  SQL_OUTER_JOINS_SUPPORT_LEVEL = 528,
  SQL_SCHEMA_TERM = 529,
  SQL_PROCEDURE_TERM = 530,
  SQL_CATALOG_TERM = 531,
  SQL_CATALOG_AT_START = 532,
  SQL_SCHEMAS_SUPPORTED_ACTIONS = 533,
  SQL_CATALOGS_SUPPORTED_ACTIONS = 534,
  SQL_SUPPORTED_POSITIONED_COMMANDS = 535,
  SQL_SELECT_FOR_UPDATE_SUPPORTED = 536,
  SQL_STORED_PROCEDURES_SUPPORTED = 537,
  SQL_SUPPORTED_SUBQUERIES = 538,
  SQL_CORRELATED_SUBQUERIES_SUPPORTED = 539,
  SQL_SUPPORTED_UNIONS = 540,
  SQL_MAX_BINARY_LITERAL_LENGTH = 541,
  SQL_MAX_CHAR_LITERAL_LENGTH = 542,
  SQL_MAX_COLUMN_NAME_LENGTH = 543,
  SQL_MAX_COLUMNS_IN_GROUP_BY = 544,
  SQL_MAX_COLUMNS_IN_INDEX = 545,
  SQL_MAX_COLUMNS_IN_ORDER_BY = 546,
  SQL_MAX_COLUMNS_IN_SELECT = 547,
  SQL_MAX_COLUMNS_IN_TABLE = 548,
  SQL_MAX_CONNECTIONS = 549,
  SQL_MAX_CURSOR_NAME_LENGTH = 550,
  SQL_MAX_INDEX_LENGTH = 551,
  SQL_DB_SCHEMA_NAME_LENGTH = 552,
  SQL_MAX_PROCEDURE_NAME_LENGTH = 553,
  SQL_MAX_CATALOG_NAME_LENGTH = 554,
  SQL_MAX_ROW_SIZE = 555,
  SQL_MAX_ROW_SIZE_INCLUDES_BLOBS = 556,
  SQL_MAX_STATEMENT_LENGTH = 557,
  SQL_MAX_STATEMENTS = 558,
  SQL_MAX_TABLE_NAME_LENGTH = 559,
  SQL_MAX_TABLES_IN_SELECT = 560,
  SQL_MAX_USERNAME_LENGTH = 561,
  SQL_DEFAULT_TRANSACTION_ISOLATION = 562,
  SQL_TRANSACTIONS_SUPPORTED = 563,
  SQL_SUPPORTED_TRANSACTIONS_ISOLATION_LEVELS = 564,
  SQL_DATA_DEFINITION_CAUSES_TRANSACTION_COMMIT = 565,
  SQL_DATA_DEFINITIONS_IN_TRANSACTIONS_IGNORED = 566,
  SQL_SUPPORTED_RESULT_SET_TYPES = 567,
  SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_UNSPECIFIED = 568,
  SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_FORWARD_ONLY = 569,
  SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_SCROLL_SENSITIVE = 570,
  SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_SCROLL_INSENSITIVE = 571,
  SQL_BATCH_UPDATES_SUPPORTED = 572,
  SQL_SAVEPOINTS_SUPPORTED = 573,
  SQL_NAMED_PARAMETERS_SUPPORTED = 574,
  SQL_LOCATORS_UPDATE_COPY = 575,
  SQL_STORED_FUNCTIONS_USING_CALL_SYNTAX_SUPPORTED = 576,
  SqlInfo_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SqlInfo_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

ARROW_FLIGHT_SQL_EXPORT bool SqlInfo_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t SqlInfo_internal_data_[];
inline constexpr SqlInfo SqlInfo_MIN =
    static_cast<SqlInfo>(0);
inline constexpr SqlInfo SqlInfo_MAX =
    static_cast<SqlInfo>(576);
inline constexpr int SqlInfo_ARRAYSIZE = 576 + 1;
ARROW_FLIGHT_SQL_EXPORT const ::google::protobuf::EnumDescriptor*
SqlInfo_descriptor();
template <typename T>
const std::string& SqlInfo_Name(T value) {
  static_assert(std::is_same<T, SqlInfo>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SqlInfo_Name().");
  return ::google::protobuf::internal::NameOfEnum(SqlInfo_descriptor(), value);
}
inline bool SqlInfo_Parse(absl::string_view name, SqlInfo* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SqlInfo>(
      SqlInfo_descriptor(), name, value);
}
enum SqlSupportedTransaction : int {
  SQL_SUPPORTED_TRANSACTION_NONE = 0,
  SQL_SUPPORTED_TRANSACTION_TRANSACTION = 1,
  SQL_SUPPORTED_TRANSACTION_SAVEPOINT = 2,
  SqlSupportedTransaction_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SqlSupportedTransaction_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

ARROW_FLIGHT_SQL_EXPORT bool SqlSupportedTransaction_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t SqlSupportedTransaction_internal_data_[];
inline constexpr SqlSupportedTransaction SqlSupportedTransaction_MIN =
    static_cast<SqlSupportedTransaction>(0);
inline constexpr SqlSupportedTransaction SqlSupportedTransaction_MAX =
    static_cast<SqlSupportedTransaction>(2);
inline constexpr int SqlSupportedTransaction_ARRAYSIZE = 2 + 1;
ARROW_FLIGHT_SQL_EXPORT const ::google::protobuf::EnumDescriptor*
SqlSupportedTransaction_descriptor();
template <typename T>
const std::string& SqlSupportedTransaction_Name(T value) {
  static_assert(std::is_same<T, SqlSupportedTransaction>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SqlSupportedTransaction_Name().");
  return SqlSupportedTransaction_Name(static_cast<SqlSupportedTransaction>(value));
}
template <>
inline const std::string& SqlSupportedTransaction_Name(SqlSupportedTransaction value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SqlSupportedTransaction_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool SqlSupportedTransaction_Parse(absl::string_view name, SqlSupportedTransaction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SqlSupportedTransaction>(
      SqlSupportedTransaction_descriptor(), name, value);
}
enum SqlSupportedCaseSensitivity : int {
  SQL_CASE_SENSITIVITY_UNKNOWN = 0,
  SQL_CASE_SENSITIVITY_CASE_INSENSITIVE = 1,
  SQL_CASE_SENSITIVITY_UPPERCASE = 2,
  SQL_CASE_SENSITIVITY_LOWERCASE = 3,
  SqlSupportedCaseSensitivity_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SqlSupportedCaseSensitivity_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

ARROW_FLIGHT_SQL_EXPORT bool SqlSupportedCaseSensitivity_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t SqlSupportedCaseSensitivity_internal_data_[];
inline constexpr SqlSupportedCaseSensitivity SqlSupportedCaseSensitivity_MIN =
    static_cast<SqlSupportedCaseSensitivity>(0);
inline constexpr SqlSupportedCaseSensitivity SqlSupportedCaseSensitivity_MAX =
    static_cast<SqlSupportedCaseSensitivity>(3);
inline constexpr int SqlSupportedCaseSensitivity_ARRAYSIZE = 3 + 1;
ARROW_FLIGHT_SQL_EXPORT const ::google::protobuf::EnumDescriptor*
SqlSupportedCaseSensitivity_descriptor();
template <typename T>
const std::string& SqlSupportedCaseSensitivity_Name(T value) {
  static_assert(std::is_same<T, SqlSupportedCaseSensitivity>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SqlSupportedCaseSensitivity_Name().");
  return SqlSupportedCaseSensitivity_Name(static_cast<SqlSupportedCaseSensitivity>(value));
}
template <>
inline const std::string& SqlSupportedCaseSensitivity_Name(SqlSupportedCaseSensitivity value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SqlSupportedCaseSensitivity_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool SqlSupportedCaseSensitivity_Parse(absl::string_view name, SqlSupportedCaseSensitivity* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SqlSupportedCaseSensitivity>(
      SqlSupportedCaseSensitivity_descriptor(), name, value);
}
enum SqlNullOrdering : int {
  SQL_NULLS_SORTED_HIGH = 0,
  SQL_NULLS_SORTED_LOW = 1,
  SQL_NULLS_SORTED_AT_START = 2,
  SQL_NULLS_SORTED_AT_END = 3,
  SqlNullOrdering_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SqlNullOrdering_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

ARROW_FLIGHT_SQL_EXPORT bool SqlNullOrdering_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t SqlNullOrdering_internal_data_[];
inline constexpr SqlNullOrdering SqlNullOrdering_MIN =
    static_cast<SqlNullOrdering>(0);
inline constexpr SqlNullOrdering SqlNullOrdering_MAX =
    static_cast<SqlNullOrdering>(3);
inline constexpr int SqlNullOrdering_ARRAYSIZE = 3 + 1;
ARROW_FLIGHT_SQL_EXPORT const ::google::protobuf::EnumDescriptor*
SqlNullOrdering_descriptor();
template <typename T>
const std::string& SqlNullOrdering_Name(T value) {
  static_assert(std::is_same<T, SqlNullOrdering>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SqlNullOrdering_Name().");
  return SqlNullOrdering_Name(static_cast<SqlNullOrdering>(value));
}
template <>
inline const std::string& SqlNullOrdering_Name(SqlNullOrdering value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SqlNullOrdering_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool SqlNullOrdering_Parse(absl::string_view name, SqlNullOrdering* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SqlNullOrdering>(
      SqlNullOrdering_descriptor(), name, value);
}
enum SupportedSqlGrammar : int {
  SQL_MINIMUM_GRAMMAR = 0,
  SQL_CORE_GRAMMAR = 1,
  SQL_EXTENDED_GRAMMAR = 2,
  SupportedSqlGrammar_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SupportedSqlGrammar_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

ARROW_FLIGHT_SQL_EXPORT bool SupportedSqlGrammar_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t SupportedSqlGrammar_internal_data_[];
inline constexpr SupportedSqlGrammar SupportedSqlGrammar_MIN =
    static_cast<SupportedSqlGrammar>(0);
inline constexpr SupportedSqlGrammar SupportedSqlGrammar_MAX =
    static_cast<SupportedSqlGrammar>(2);
inline constexpr int SupportedSqlGrammar_ARRAYSIZE = 2 + 1;
ARROW_FLIGHT_SQL_EXPORT const ::google::protobuf::EnumDescriptor*
SupportedSqlGrammar_descriptor();
template <typename T>
const std::string& SupportedSqlGrammar_Name(T value) {
  static_assert(std::is_same<T, SupportedSqlGrammar>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SupportedSqlGrammar_Name().");
  return SupportedSqlGrammar_Name(static_cast<SupportedSqlGrammar>(value));
}
template <>
inline const std::string& SupportedSqlGrammar_Name(SupportedSqlGrammar value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SupportedSqlGrammar_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool SupportedSqlGrammar_Parse(absl::string_view name, SupportedSqlGrammar* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SupportedSqlGrammar>(
      SupportedSqlGrammar_descriptor(), name, value);
}
enum SupportedAnsi92SqlGrammarLevel : int {
  ANSI92_ENTRY_SQL = 0,
  ANSI92_INTERMEDIATE_SQL = 1,
  ANSI92_FULL_SQL = 2,
  SupportedAnsi92SqlGrammarLevel_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SupportedAnsi92SqlGrammarLevel_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

ARROW_FLIGHT_SQL_EXPORT bool SupportedAnsi92SqlGrammarLevel_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t SupportedAnsi92SqlGrammarLevel_internal_data_[];
inline constexpr SupportedAnsi92SqlGrammarLevel SupportedAnsi92SqlGrammarLevel_MIN =
    static_cast<SupportedAnsi92SqlGrammarLevel>(0);
inline constexpr SupportedAnsi92SqlGrammarLevel SupportedAnsi92SqlGrammarLevel_MAX =
    static_cast<SupportedAnsi92SqlGrammarLevel>(2);
inline constexpr int SupportedAnsi92SqlGrammarLevel_ARRAYSIZE = 2 + 1;
ARROW_FLIGHT_SQL_EXPORT const ::google::protobuf::EnumDescriptor*
SupportedAnsi92SqlGrammarLevel_descriptor();
template <typename T>
const std::string& SupportedAnsi92SqlGrammarLevel_Name(T value) {
  static_assert(std::is_same<T, SupportedAnsi92SqlGrammarLevel>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SupportedAnsi92SqlGrammarLevel_Name().");
  return SupportedAnsi92SqlGrammarLevel_Name(static_cast<SupportedAnsi92SqlGrammarLevel>(value));
}
template <>
inline const std::string& SupportedAnsi92SqlGrammarLevel_Name(SupportedAnsi92SqlGrammarLevel value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SupportedAnsi92SqlGrammarLevel_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool SupportedAnsi92SqlGrammarLevel_Parse(absl::string_view name, SupportedAnsi92SqlGrammarLevel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SupportedAnsi92SqlGrammarLevel>(
      SupportedAnsi92SqlGrammarLevel_descriptor(), name, value);
}
enum SqlOuterJoinsSupportLevel : int {
  SQL_JOINS_UNSUPPORTED = 0,
  SQL_LIMITED_OUTER_JOINS = 1,
  SQL_FULL_OUTER_JOINS = 2,
  SqlOuterJoinsSupportLevel_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SqlOuterJoinsSupportLevel_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

ARROW_FLIGHT_SQL_EXPORT bool SqlOuterJoinsSupportLevel_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t SqlOuterJoinsSupportLevel_internal_data_[];
inline constexpr SqlOuterJoinsSupportLevel SqlOuterJoinsSupportLevel_MIN =
    static_cast<SqlOuterJoinsSupportLevel>(0);
inline constexpr SqlOuterJoinsSupportLevel SqlOuterJoinsSupportLevel_MAX =
    static_cast<SqlOuterJoinsSupportLevel>(2);
inline constexpr int SqlOuterJoinsSupportLevel_ARRAYSIZE = 2 + 1;
ARROW_FLIGHT_SQL_EXPORT const ::google::protobuf::EnumDescriptor*
SqlOuterJoinsSupportLevel_descriptor();
template <typename T>
const std::string& SqlOuterJoinsSupportLevel_Name(T value) {
  static_assert(std::is_same<T, SqlOuterJoinsSupportLevel>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SqlOuterJoinsSupportLevel_Name().");
  return SqlOuterJoinsSupportLevel_Name(static_cast<SqlOuterJoinsSupportLevel>(value));
}
template <>
inline const std::string& SqlOuterJoinsSupportLevel_Name(SqlOuterJoinsSupportLevel value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SqlOuterJoinsSupportLevel_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool SqlOuterJoinsSupportLevel_Parse(absl::string_view name, SqlOuterJoinsSupportLevel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SqlOuterJoinsSupportLevel>(
      SqlOuterJoinsSupportLevel_descriptor(), name, value);
}
enum SqlSupportedGroupBy : int {
  SQL_GROUP_BY_UNRELATED = 0,
  SQL_GROUP_BY_BEYOND_SELECT = 1,
  SqlSupportedGroupBy_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SqlSupportedGroupBy_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

ARROW_FLIGHT_SQL_EXPORT bool SqlSupportedGroupBy_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t SqlSupportedGroupBy_internal_data_[];
inline constexpr SqlSupportedGroupBy SqlSupportedGroupBy_MIN =
    static_cast<SqlSupportedGroupBy>(0);
inline constexpr SqlSupportedGroupBy SqlSupportedGroupBy_MAX =
    static_cast<SqlSupportedGroupBy>(1);
inline constexpr int SqlSupportedGroupBy_ARRAYSIZE = 1 + 1;
ARROW_FLIGHT_SQL_EXPORT const ::google::protobuf::EnumDescriptor*
SqlSupportedGroupBy_descriptor();
template <typename T>
const std::string& SqlSupportedGroupBy_Name(T value) {
  static_assert(std::is_same<T, SqlSupportedGroupBy>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SqlSupportedGroupBy_Name().");
  return SqlSupportedGroupBy_Name(static_cast<SqlSupportedGroupBy>(value));
}
template <>
inline const std::string& SqlSupportedGroupBy_Name(SqlSupportedGroupBy value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SqlSupportedGroupBy_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool SqlSupportedGroupBy_Parse(absl::string_view name, SqlSupportedGroupBy* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SqlSupportedGroupBy>(
      SqlSupportedGroupBy_descriptor(), name, value);
}
enum SqlSupportedElementActions : int {
  SQL_ELEMENT_IN_PROCEDURE_CALLS = 0,
  SQL_ELEMENT_IN_INDEX_DEFINITIONS = 1,
  SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS = 2,
  SqlSupportedElementActions_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SqlSupportedElementActions_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

ARROW_FLIGHT_SQL_EXPORT bool SqlSupportedElementActions_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t SqlSupportedElementActions_internal_data_[];
inline constexpr SqlSupportedElementActions SqlSupportedElementActions_MIN =
    static_cast<SqlSupportedElementActions>(0);
inline constexpr SqlSupportedElementActions SqlSupportedElementActions_MAX =
    static_cast<SqlSupportedElementActions>(2);
inline constexpr int SqlSupportedElementActions_ARRAYSIZE = 2 + 1;
ARROW_FLIGHT_SQL_EXPORT const ::google::protobuf::EnumDescriptor*
SqlSupportedElementActions_descriptor();
template <typename T>
const std::string& SqlSupportedElementActions_Name(T value) {
  static_assert(std::is_same<T, SqlSupportedElementActions>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SqlSupportedElementActions_Name().");
  return SqlSupportedElementActions_Name(static_cast<SqlSupportedElementActions>(value));
}
template <>
inline const std::string& SqlSupportedElementActions_Name(SqlSupportedElementActions value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SqlSupportedElementActions_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool SqlSupportedElementActions_Parse(absl::string_view name, SqlSupportedElementActions* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SqlSupportedElementActions>(
      SqlSupportedElementActions_descriptor(), name, value);
}
enum SqlSupportedPositionedCommands : int {
  SQL_POSITIONED_DELETE = 0,
  SQL_POSITIONED_UPDATE = 1,
  SqlSupportedPositionedCommands_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SqlSupportedPositionedCommands_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

ARROW_FLIGHT_SQL_EXPORT bool SqlSupportedPositionedCommands_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t SqlSupportedPositionedCommands_internal_data_[];
inline constexpr SqlSupportedPositionedCommands SqlSupportedPositionedCommands_MIN =
    static_cast<SqlSupportedPositionedCommands>(0);
inline constexpr SqlSupportedPositionedCommands SqlSupportedPositionedCommands_MAX =
    static_cast<SqlSupportedPositionedCommands>(1);
inline constexpr int SqlSupportedPositionedCommands_ARRAYSIZE = 1 + 1;
ARROW_FLIGHT_SQL_EXPORT const ::google::protobuf::EnumDescriptor*
SqlSupportedPositionedCommands_descriptor();
template <typename T>
const std::string& SqlSupportedPositionedCommands_Name(T value) {
  static_assert(std::is_same<T, SqlSupportedPositionedCommands>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SqlSupportedPositionedCommands_Name().");
  return SqlSupportedPositionedCommands_Name(static_cast<SqlSupportedPositionedCommands>(value));
}
template <>
inline const std::string& SqlSupportedPositionedCommands_Name(SqlSupportedPositionedCommands value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SqlSupportedPositionedCommands_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool SqlSupportedPositionedCommands_Parse(absl::string_view name, SqlSupportedPositionedCommands* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SqlSupportedPositionedCommands>(
      SqlSupportedPositionedCommands_descriptor(), name, value);
}
enum SqlSupportedSubqueries : int {
  SQL_SUBQUERIES_IN_COMPARISONS = 0,
  SQL_SUBQUERIES_IN_EXISTS = 1,
  SQL_SUBQUERIES_IN_INS = 2,
  SQL_SUBQUERIES_IN_QUANTIFIEDS = 3,
  SqlSupportedSubqueries_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SqlSupportedSubqueries_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

ARROW_FLIGHT_SQL_EXPORT bool SqlSupportedSubqueries_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t SqlSupportedSubqueries_internal_data_[];
inline constexpr SqlSupportedSubqueries SqlSupportedSubqueries_MIN =
    static_cast<SqlSupportedSubqueries>(0);
inline constexpr SqlSupportedSubqueries SqlSupportedSubqueries_MAX =
    static_cast<SqlSupportedSubqueries>(3);
inline constexpr int SqlSupportedSubqueries_ARRAYSIZE = 3 + 1;
ARROW_FLIGHT_SQL_EXPORT const ::google::protobuf::EnumDescriptor*
SqlSupportedSubqueries_descriptor();
template <typename T>
const std::string& SqlSupportedSubqueries_Name(T value) {
  static_assert(std::is_same<T, SqlSupportedSubqueries>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SqlSupportedSubqueries_Name().");
  return SqlSupportedSubqueries_Name(static_cast<SqlSupportedSubqueries>(value));
}
template <>
inline const std::string& SqlSupportedSubqueries_Name(SqlSupportedSubqueries value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SqlSupportedSubqueries_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool SqlSupportedSubqueries_Parse(absl::string_view name, SqlSupportedSubqueries* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SqlSupportedSubqueries>(
      SqlSupportedSubqueries_descriptor(), name, value);
}
enum SqlSupportedUnions : int {
  SQL_UNION = 0,
  SQL_UNION_ALL = 1,
  SqlSupportedUnions_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SqlSupportedUnions_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

ARROW_FLIGHT_SQL_EXPORT bool SqlSupportedUnions_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t SqlSupportedUnions_internal_data_[];
inline constexpr SqlSupportedUnions SqlSupportedUnions_MIN =
    static_cast<SqlSupportedUnions>(0);
inline constexpr SqlSupportedUnions SqlSupportedUnions_MAX =
    static_cast<SqlSupportedUnions>(1);
inline constexpr int SqlSupportedUnions_ARRAYSIZE = 1 + 1;
ARROW_FLIGHT_SQL_EXPORT const ::google::protobuf::EnumDescriptor*
SqlSupportedUnions_descriptor();
template <typename T>
const std::string& SqlSupportedUnions_Name(T value) {
  static_assert(std::is_same<T, SqlSupportedUnions>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SqlSupportedUnions_Name().");
  return SqlSupportedUnions_Name(static_cast<SqlSupportedUnions>(value));
}
template <>
inline const std::string& SqlSupportedUnions_Name(SqlSupportedUnions value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SqlSupportedUnions_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool SqlSupportedUnions_Parse(absl::string_view name, SqlSupportedUnions* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SqlSupportedUnions>(
      SqlSupportedUnions_descriptor(), name, value);
}
enum SqlTransactionIsolationLevel : int {
  SQL_TRANSACTION_NONE = 0,
  SQL_TRANSACTION_READ_UNCOMMITTED = 1,
  SQL_TRANSACTION_READ_COMMITTED = 2,
  SQL_TRANSACTION_REPEATABLE_READ = 3,
  SQL_TRANSACTION_SERIALIZABLE = 4,
  SqlTransactionIsolationLevel_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SqlTransactionIsolationLevel_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

ARROW_FLIGHT_SQL_EXPORT bool SqlTransactionIsolationLevel_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t SqlTransactionIsolationLevel_internal_data_[];
inline constexpr SqlTransactionIsolationLevel SqlTransactionIsolationLevel_MIN =
    static_cast<SqlTransactionIsolationLevel>(0);
inline constexpr SqlTransactionIsolationLevel SqlTransactionIsolationLevel_MAX =
    static_cast<SqlTransactionIsolationLevel>(4);
inline constexpr int SqlTransactionIsolationLevel_ARRAYSIZE = 4 + 1;
ARROW_FLIGHT_SQL_EXPORT const ::google::protobuf::EnumDescriptor*
SqlTransactionIsolationLevel_descriptor();
template <typename T>
const std::string& SqlTransactionIsolationLevel_Name(T value) {
  static_assert(std::is_same<T, SqlTransactionIsolationLevel>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SqlTransactionIsolationLevel_Name().");
  return SqlTransactionIsolationLevel_Name(static_cast<SqlTransactionIsolationLevel>(value));
}
template <>
inline const std::string& SqlTransactionIsolationLevel_Name(SqlTransactionIsolationLevel value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SqlTransactionIsolationLevel_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool SqlTransactionIsolationLevel_Parse(absl::string_view name, SqlTransactionIsolationLevel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SqlTransactionIsolationLevel>(
      SqlTransactionIsolationLevel_descriptor(), name, value);
}
enum SqlSupportedTransactions : int {
  SQL_TRANSACTION_UNSPECIFIED = 0,
  SQL_DATA_DEFINITION_TRANSACTIONS = 1,
  SQL_DATA_MANIPULATION_TRANSACTIONS = 2,
  SqlSupportedTransactions_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SqlSupportedTransactions_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

ARROW_FLIGHT_SQL_EXPORT bool SqlSupportedTransactions_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t SqlSupportedTransactions_internal_data_[];
inline constexpr SqlSupportedTransactions SqlSupportedTransactions_MIN =
    static_cast<SqlSupportedTransactions>(0);
inline constexpr SqlSupportedTransactions SqlSupportedTransactions_MAX =
    static_cast<SqlSupportedTransactions>(2);
inline constexpr int SqlSupportedTransactions_ARRAYSIZE = 2 + 1;
ARROW_FLIGHT_SQL_EXPORT const ::google::protobuf::EnumDescriptor*
SqlSupportedTransactions_descriptor();
template <typename T>
const std::string& SqlSupportedTransactions_Name(T value) {
  static_assert(std::is_same<T, SqlSupportedTransactions>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SqlSupportedTransactions_Name().");
  return SqlSupportedTransactions_Name(static_cast<SqlSupportedTransactions>(value));
}
template <>
inline const std::string& SqlSupportedTransactions_Name(SqlSupportedTransactions value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SqlSupportedTransactions_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool SqlSupportedTransactions_Parse(absl::string_view name, SqlSupportedTransactions* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SqlSupportedTransactions>(
      SqlSupportedTransactions_descriptor(), name, value);
}
enum SqlSupportedResultSetType : int {
  SQL_RESULT_SET_TYPE_UNSPECIFIED = 0,
  SQL_RESULT_SET_TYPE_FORWARD_ONLY = 1,
  SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE = 2,
  SQL_RESULT_SET_TYPE_SCROLL_SENSITIVE = 3,
  SqlSupportedResultSetType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SqlSupportedResultSetType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

ARROW_FLIGHT_SQL_EXPORT bool SqlSupportedResultSetType_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t SqlSupportedResultSetType_internal_data_[];
inline constexpr SqlSupportedResultSetType SqlSupportedResultSetType_MIN =
    static_cast<SqlSupportedResultSetType>(0);
inline constexpr SqlSupportedResultSetType SqlSupportedResultSetType_MAX =
    static_cast<SqlSupportedResultSetType>(3);
inline constexpr int SqlSupportedResultSetType_ARRAYSIZE = 3 + 1;
ARROW_FLIGHT_SQL_EXPORT const ::google::protobuf::EnumDescriptor*
SqlSupportedResultSetType_descriptor();
template <typename T>
const std::string& SqlSupportedResultSetType_Name(T value) {
  static_assert(std::is_same<T, SqlSupportedResultSetType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SqlSupportedResultSetType_Name().");
  return SqlSupportedResultSetType_Name(static_cast<SqlSupportedResultSetType>(value));
}
template <>
inline const std::string& SqlSupportedResultSetType_Name(SqlSupportedResultSetType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SqlSupportedResultSetType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool SqlSupportedResultSetType_Parse(absl::string_view name, SqlSupportedResultSetType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SqlSupportedResultSetType>(
      SqlSupportedResultSetType_descriptor(), name, value);
}
enum SqlSupportedResultSetConcurrency : int {
  SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED = 0,
  SQL_RESULT_SET_CONCURRENCY_READ_ONLY = 1,
  SQL_RESULT_SET_CONCURRENCY_UPDATABLE = 2,
  SqlSupportedResultSetConcurrency_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SqlSupportedResultSetConcurrency_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

ARROW_FLIGHT_SQL_EXPORT bool SqlSupportedResultSetConcurrency_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t SqlSupportedResultSetConcurrency_internal_data_[];
inline constexpr SqlSupportedResultSetConcurrency SqlSupportedResultSetConcurrency_MIN =
    static_cast<SqlSupportedResultSetConcurrency>(0);
inline constexpr SqlSupportedResultSetConcurrency SqlSupportedResultSetConcurrency_MAX =
    static_cast<SqlSupportedResultSetConcurrency>(2);
inline constexpr int SqlSupportedResultSetConcurrency_ARRAYSIZE = 2 + 1;
ARROW_FLIGHT_SQL_EXPORT const ::google::protobuf::EnumDescriptor*
SqlSupportedResultSetConcurrency_descriptor();
template <typename T>
const std::string& SqlSupportedResultSetConcurrency_Name(T value) {
  static_assert(std::is_same<T, SqlSupportedResultSetConcurrency>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SqlSupportedResultSetConcurrency_Name().");
  return SqlSupportedResultSetConcurrency_Name(static_cast<SqlSupportedResultSetConcurrency>(value));
}
template <>
inline const std::string& SqlSupportedResultSetConcurrency_Name(SqlSupportedResultSetConcurrency value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SqlSupportedResultSetConcurrency_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool SqlSupportedResultSetConcurrency_Parse(absl::string_view name, SqlSupportedResultSetConcurrency* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SqlSupportedResultSetConcurrency>(
      SqlSupportedResultSetConcurrency_descriptor(), name, value);
}
enum SqlSupportsConvert : int {
  SQL_CONVERT_BIGINT = 0,
  SQL_CONVERT_BINARY = 1,
  SQL_CONVERT_BIT = 2,
  SQL_CONVERT_CHAR = 3,
  SQL_CONVERT_DATE = 4,
  SQL_CONVERT_DECIMAL = 5,
  SQL_CONVERT_FLOAT = 6,
  SQL_CONVERT_INTEGER = 7,
  SQL_CONVERT_INTERVAL_DAY_TIME = 8,
  SQL_CONVERT_INTERVAL_YEAR_MONTH = 9,
  SQL_CONVERT_LONGVARBINARY = 10,
  SQL_CONVERT_LONGVARCHAR = 11,
  SQL_CONVERT_NUMERIC = 12,
  SQL_CONVERT_REAL = 13,
  SQL_CONVERT_SMALLINT = 14,
  SQL_CONVERT_TIME = 15,
  SQL_CONVERT_TIMESTAMP = 16,
  SQL_CONVERT_TINYINT = 17,
  SQL_CONVERT_VARBINARY = 18,
  SQL_CONVERT_VARCHAR = 19,
  SqlSupportsConvert_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SqlSupportsConvert_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

ARROW_FLIGHT_SQL_EXPORT bool SqlSupportsConvert_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t SqlSupportsConvert_internal_data_[];
inline constexpr SqlSupportsConvert SqlSupportsConvert_MIN =
    static_cast<SqlSupportsConvert>(0);
inline constexpr SqlSupportsConvert SqlSupportsConvert_MAX =
    static_cast<SqlSupportsConvert>(19);
inline constexpr int SqlSupportsConvert_ARRAYSIZE = 19 + 1;
ARROW_FLIGHT_SQL_EXPORT const ::google::protobuf::EnumDescriptor*
SqlSupportsConvert_descriptor();
template <typename T>
const std::string& SqlSupportsConvert_Name(T value) {
  static_assert(std::is_same<T, SqlSupportsConvert>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SqlSupportsConvert_Name().");
  return SqlSupportsConvert_Name(static_cast<SqlSupportsConvert>(value));
}
template <>
inline const std::string& SqlSupportsConvert_Name(SqlSupportsConvert value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SqlSupportsConvert_descriptor,
                                                 0, 19>(
      static_cast<int>(value));
}
inline bool SqlSupportsConvert_Parse(absl::string_view name, SqlSupportsConvert* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SqlSupportsConvert>(
      SqlSupportsConvert_descriptor(), name, value);
}
enum XdbcDataType : int {
  XDBC_UNKNOWN_TYPE = 0,
  XDBC_CHAR = 1,
  XDBC_NUMERIC = 2,
  XDBC_DECIMAL = 3,
  XDBC_INTEGER = 4,
  XDBC_SMALLINT = 5,
  XDBC_FLOAT = 6,
  XDBC_REAL = 7,
  XDBC_DOUBLE = 8,
  XDBC_DATETIME = 9,
  XDBC_INTERVAL = 10,
  XDBC_VARCHAR = 12,
  XDBC_DATE = 91,
  XDBC_TIME = 92,
  XDBC_TIMESTAMP = 93,
  XDBC_LONGVARCHAR = -1,
  XDBC_BINARY = -2,
  XDBC_VARBINARY = -3,
  XDBC_LONGVARBINARY = -4,
  XDBC_BIGINT = -5,
  XDBC_TINYINT = -6,
  XDBC_BIT = -7,
  XDBC_WCHAR = -8,
  XDBC_WVARCHAR = -9,
  XdbcDataType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  XdbcDataType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

ARROW_FLIGHT_SQL_EXPORT bool XdbcDataType_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t XdbcDataType_internal_data_[];
inline constexpr XdbcDataType XdbcDataType_MIN =
    static_cast<XdbcDataType>(-9);
inline constexpr XdbcDataType XdbcDataType_MAX =
    static_cast<XdbcDataType>(93);
inline constexpr int XdbcDataType_ARRAYSIZE = 93 + 1;
ARROW_FLIGHT_SQL_EXPORT const ::google::protobuf::EnumDescriptor*
XdbcDataType_descriptor();
template <typename T>
const std::string& XdbcDataType_Name(T value) {
  static_assert(std::is_same<T, XdbcDataType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to XdbcDataType_Name().");
  return ::google::protobuf::internal::NameOfEnum(XdbcDataType_descriptor(), value);
}
inline bool XdbcDataType_Parse(absl::string_view name, XdbcDataType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<XdbcDataType>(
      XdbcDataType_descriptor(), name, value);
}
enum XdbcDatetimeSubcode : int {
  XDBC_SUBCODE_UNKNOWN = 0,
  XDBC_SUBCODE_YEAR = 1,
  XDBC_SUBCODE_DATE = 1,
  XDBC_SUBCODE_TIME = 2,
  XDBC_SUBCODE_MONTH = 2,
  XDBC_SUBCODE_TIMESTAMP = 3,
  XDBC_SUBCODE_DAY = 3,
  XDBC_SUBCODE_TIME_WITH_TIMEZONE = 4,
  XDBC_SUBCODE_HOUR = 4,
  XDBC_SUBCODE_TIMESTAMP_WITH_TIMEZONE = 5,
  XDBC_SUBCODE_MINUTE = 5,
  XDBC_SUBCODE_SECOND = 6,
  XDBC_SUBCODE_YEAR_TO_MONTH = 7,
  XDBC_SUBCODE_DAY_TO_HOUR = 8,
  XDBC_SUBCODE_DAY_TO_MINUTE = 9,
  XDBC_SUBCODE_DAY_TO_SECOND = 10,
  XDBC_SUBCODE_HOUR_TO_MINUTE = 11,
  XDBC_SUBCODE_HOUR_TO_SECOND = 12,
  XDBC_SUBCODE_MINUTE_TO_SECOND = 13,
  XDBC_SUBCODE_INTERVAL_YEAR = 101,
  XDBC_SUBCODE_INTERVAL_MONTH = 102,
  XDBC_SUBCODE_INTERVAL_DAY = 103,
  XDBC_SUBCODE_INTERVAL_HOUR = 104,
  XDBC_SUBCODE_INTERVAL_MINUTE = 105,
  XDBC_SUBCODE_INTERVAL_SECOND = 106,
  XDBC_SUBCODE_INTERVAL_YEAR_TO_MONTH = 107,
  XDBC_SUBCODE_INTERVAL_DAY_TO_HOUR = 108,
  XDBC_SUBCODE_INTERVAL_DAY_TO_MINUTE = 109,
  XDBC_SUBCODE_INTERVAL_DAY_TO_SECOND = 110,
  XDBC_SUBCODE_INTERVAL_HOUR_TO_MINUTE = 111,
  XDBC_SUBCODE_INTERVAL_HOUR_TO_SECOND = 112,
  XDBC_SUBCODE_INTERVAL_MINUTE_TO_SECOND = 113,
  XdbcDatetimeSubcode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  XdbcDatetimeSubcode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

ARROW_FLIGHT_SQL_EXPORT bool XdbcDatetimeSubcode_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t XdbcDatetimeSubcode_internal_data_[];
inline constexpr XdbcDatetimeSubcode XdbcDatetimeSubcode_MIN =
    static_cast<XdbcDatetimeSubcode>(0);
inline constexpr XdbcDatetimeSubcode XdbcDatetimeSubcode_MAX =
    static_cast<XdbcDatetimeSubcode>(113);
inline constexpr int XdbcDatetimeSubcode_ARRAYSIZE = 113 + 1;
ARROW_FLIGHT_SQL_EXPORT const ::google::protobuf::EnumDescriptor*
XdbcDatetimeSubcode_descriptor();
template <typename T>
const std::string& XdbcDatetimeSubcode_Name(T value) {
  static_assert(std::is_same<T, XdbcDatetimeSubcode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to XdbcDatetimeSubcode_Name().");
  return ::google::protobuf::internal::NameOfEnum(XdbcDatetimeSubcode_descriptor(), value);
}
inline bool XdbcDatetimeSubcode_Parse(absl::string_view name, XdbcDatetimeSubcode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<XdbcDatetimeSubcode>(
      XdbcDatetimeSubcode_descriptor(), name, value);
}
enum Nullable : int {
  NULLABILITY_NO_NULLS = 0,
  NULLABILITY_NULLABLE = 1,
  NULLABILITY_UNKNOWN = 2,
  Nullable_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Nullable_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

ARROW_FLIGHT_SQL_EXPORT bool Nullable_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t Nullable_internal_data_[];
inline constexpr Nullable Nullable_MIN =
    static_cast<Nullable>(0);
inline constexpr Nullable Nullable_MAX =
    static_cast<Nullable>(2);
inline constexpr int Nullable_ARRAYSIZE = 2 + 1;
ARROW_FLIGHT_SQL_EXPORT const ::google::protobuf::EnumDescriptor*
Nullable_descriptor();
template <typename T>
const std::string& Nullable_Name(T value) {
  static_assert(std::is_same<T, Nullable>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Nullable_Name().");
  return Nullable_Name(static_cast<Nullable>(value));
}
template <>
inline const std::string& Nullable_Name(Nullable value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Nullable_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool Nullable_Parse(absl::string_view name, Nullable* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Nullable>(
      Nullable_descriptor(), name, value);
}
enum Searchable : int {
  SEARCHABLE_NONE = 0,
  SEARCHABLE_CHAR = 1,
  SEARCHABLE_BASIC = 2,
  SEARCHABLE_FULL = 3,
  Searchable_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Searchable_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

ARROW_FLIGHT_SQL_EXPORT bool Searchable_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t Searchable_internal_data_[];
inline constexpr Searchable Searchable_MIN =
    static_cast<Searchable>(0);
inline constexpr Searchable Searchable_MAX =
    static_cast<Searchable>(3);
inline constexpr int Searchable_ARRAYSIZE = 3 + 1;
ARROW_FLIGHT_SQL_EXPORT const ::google::protobuf::EnumDescriptor*
Searchable_descriptor();
template <typename T>
const std::string& Searchable_Name(T value) {
  static_assert(std::is_same<T, Searchable>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Searchable_Name().");
  return Searchable_Name(static_cast<Searchable>(value));
}
template <>
inline const std::string& Searchable_Name(Searchable value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Searchable_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool Searchable_Parse(absl::string_view name, Searchable* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Searchable>(
      Searchable_descriptor(), name, value);
}
enum UpdateDeleteRules : int {
  CASCADE = 0,
  RESTRICT = 1,
  SET_NULL = 2,
  NO_ACTION = 3,
  SET_DEFAULT = 4,
  UpdateDeleteRules_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UpdateDeleteRules_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

ARROW_FLIGHT_SQL_EXPORT bool UpdateDeleteRules_IsValid(int value);
ARROW_FLIGHT_SQL_EXPORT extern const uint32_t UpdateDeleteRules_internal_data_[];
inline constexpr UpdateDeleteRules UpdateDeleteRules_MIN =
    static_cast<UpdateDeleteRules>(0);
inline constexpr UpdateDeleteRules UpdateDeleteRules_MAX =
    static_cast<UpdateDeleteRules>(4);
inline constexpr int UpdateDeleteRules_ARRAYSIZE = 4 + 1;
ARROW_FLIGHT_SQL_EXPORT const ::google::protobuf::EnumDescriptor*
UpdateDeleteRules_descriptor();
template <typename T>
const std::string& UpdateDeleteRules_Name(T value) {
  static_assert(std::is_same<T, UpdateDeleteRules>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to UpdateDeleteRules_Name().");
  return UpdateDeleteRules_Name(static_cast<UpdateDeleteRules>(value));
}
template <>
inline const std::string& UpdateDeleteRules_Name(UpdateDeleteRules value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UpdateDeleteRules_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool UpdateDeleteRules_Parse(absl::string_view name, UpdateDeleteRules* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UpdateDeleteRules>(
      UpdateDeleteRules_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class ARROW_FLIGHT_SQL_EXPORT TicketStatementQuery final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.sql.TicketStatementQuery) */ {
 public:
  inline TicketStatementQuery() : TicketStatementQuery(nullptr) {}
  ~TicketStatementQuery() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TicketStatementQuery* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TicketStatementQuery));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TicketStatementQuery(
      ::google::protobuf::internal::ConstantInitialized);

  inline TicketStatementQuery(const TicketStatementQuery& from) : TicketStatementQuery(nullptr, from) {}
  inline TicketStatementQuery(TicketStatementQuery&& from) noexcept
      : TicketStatementQuery(nullptr, std::move(from)) {}
  inline TicketStatementQuery& operator=(const TicketStatementQuery& from) {
    CopyFrom(from);
    return *this;
  }
  inline TicketStatementQuery& operator=(TicketStatementQuery&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TicketStatementQuery& default_instance() {
    return *reinterpret_cast<const TicketStatementQuery*>(
        &_TicketStatementQuery_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(TicketStatementQuery& a, TicketStatementQuery& b) { a.Swap(&b); }
  inline void Swap(TicketStatementQuery* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TicketStatementQuery* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TicketStatementQuery* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TicketStatementQuery>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TicketStatementQuery& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TicketStatementQuery& from) { TicketStatementQuery::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TicketStatementQuery* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.sql.TicketStatementQuery"; }

 protected:
  explicit TicketStatementQuery(::google::protobuf::Arena* arena);
  TicketStatementQuery(::google::protobuf::Arena* arena, const TicketStatementQuery& from);
  TicketStatementQuery(::google::protobuf::Arena* arena, TicketStatementQuery&& from) noexcept
      : TicketStatementQuery(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStatementHandleFieldNumber = 1,
  };
  // bytes statement_handle = 1;
  void clear_statement_handle() ;
  const std::string& statement_handle() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_statement_handle(Arg_&& arg, Args_... args);
  std::string* mutable_statement_handle();
  [[nodiscard]] std::string* release_statement_handle();
  void set_allocated_statement_handle(std::string* value);

  private:
  const std::string& _internal_statement_handle() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_statement_handle(const std::string& value);
  std::string* _internal_mutable_statement_handle();

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.sql.TicketStatementQuery)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TicketStatementQuery& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr statement_handle_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_FlightSql_2eproto;
};

ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull TicketStatementQuery_class_data_;
// -------------------------------------------------------------------

class ARROW_FLIGHT_SQL_EXPORT SubstraitPlan final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.sql.SubstraitPlan) */ {
 public:
  inline SubstraitPlan() : SubstraitPlan(nullptr) {}
  ~SubstraitPlan() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SubstraitPlan* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SubstraitPlan));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubstraitPlan(
      ::google::protobuf::internal::ConstantInitialized);

  inline SubstraitPlan(const SubstraitPlan& from) : SubstraitPlan(nullptr, from) {}
  inline SubstraitPlan(SubstraitPlan&& from) noexcept
      : SubstraitPlan(nullptr, std::move(from)) {}
  inline SubstraitPlan& operator=(const SubstraitPlan& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubstraitPlan& operator=(SubstraitPlan&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubstraitPlan& default_instance() {
    return *reinterpret_cast<const SubstraitPlan*>(
        &_SubstraitPlan_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(SubstraitPlan& a, SubstraitPlan& b) { a.Swap(&b); }
  inline void Swap(SubstraitPlan* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubstraitPlan* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubstraitPlan* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SubstraitPlan>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SubstraitPlan& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SubstraitPlan& from) { SubstraitPlan::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SubstraitPlan* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.sql.SubstraitPlan"; }

 protected:
  explicit SubstraitPlan(::google::protobuf::Arena* arena);
  SubstraitPlan(::google::protobuf::Arena* arena, const SubstraitPlan& from);
  SubstraitPlan(::google::protobuf::Arena* arena, SubstraitPlan&& from) noexcept
      : SubstraitPlan(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPlanFieldNumber = 1,
    kVersionFieldNumber = 2,
  };
  // bytes plan = 1;
  void clear_plan() ;
  const std::string& plan() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_plan(Arg_&& arg, Args_... args);
  std::string* mutable_plan();
  [[nodiscard]] std::string* release_plan();
  void set_allocated_plan(std::string* value);

  private:
  const std::string& _internal_plan() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_plan(const std::string& value);
  std::string* _internal_mutable_plan();

  public:
  // string version = 2;
  void clear_version() ;
  const std::string& version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_version(Arg_&& arg, Args_... args);
  std::string* mutable_version();
  [[nodiscard]] std::string* release_version();
  void set_allocated_version(std::string* value);

  private:
  const std::string& _internal_version() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.sql.SubstraitPlan)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      55, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SubstraitPlan& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr plan_;
    ::google::protobuf::internal::ArenaStringPtr version_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_FlightSql_2eproto;
};

ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull SubstraitPlan_class_data_;
// -------------------------------------------------------------------

class ARROW_FLIGHT_SQL_EXPORT DoPutUpdateResult final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.sql.DoPutUpdateResult) */ {
 public:
  inline DoPutUpdateResult() : DoPutUpdateResult(nullptr) {}
  ~DoPutUpdateResult() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DoPutUpdateResult* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DoPutUpdateResult));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DoPutUpdateResult(
      ::google::protobuf::internal::ConstantInitialized);

  inline DoPutUpdateResult(const DoPutUpdateResult& from) : DoPutUpdateResult(nullptr, from) {}
  inline DoPutUpdateResult(DoPutUpdateResult&& from) noexcept
      : DoPutUpdateResult(nullptr, std::move(from)) {}
  inline DoPutUpdateResult& operator=(const DoPutUpdateResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoPutUpdateResult& operator=(DoPutUpdateResult&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DoPutUpdateResult& default_instance() {
    return *reinterpret_cast<const DoPutUpdateResult*>(
        &_DoPutUpdateResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 30;
  friend void swap(DoPutUpdateResult& a, DoPutUpdateResult& b) { a.Swap(&b); }
  inline void Swap(DoPutUpdateResult* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DoPutUpdateResult* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DoPutUpdateResult* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DoPutUpdateResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DoPutUpdateResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DoPutUpdateResult& from) { DoPutUpdateResult::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DoPutUpdateResult* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.sql.DoPutUpdateResult"; }

 protected:
  explicit DoPutUpdateResult(::google::protobuf::Arena* arena);
  DoPutUpdateResult(::google::protobuf::Arena* arena, const DoPutUpdateResult& from);
  DoPutUpdateResult(::google::protobuf::Arena* arena, DoPutUpdateResult&& from) noexcept
      : DoPutUpdateResult(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRecordCountFieldNumber = 1,
  };
  // int64 record_count = 1;
  void clear_record_count() ;
  ::int64_t record_count() const;
  void set_record_count(::int64_t value);

  private:
  ::int64_t _internal_record_count() const;
  void _internal_set_record_count(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.sql.DoPutUpdateResult)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DoPutUpdateResult& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t record_count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_FlightSql_2eproto;
};

ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull DoPutUpdateResult_class_data_;
// -------------------------------------------------------------------

class ARROW_FLIGHT_SQL_EXPORT DoPutPreparedStatementResult final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.sql.DoPutPreparedStatementResult) */ {
 public:
  inline DoPutPreparedStatementResult() : DoPutPreparedStatementResult(nullptr) {}
  ~DoPutPreparedStatementResult() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DoPutPreparedStatementResult* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DoPutPreparedStatementResult));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DoPutPreparedStatementResult(
      ::google::protobuf::internal::ConstantInitialized);

  inline DoPutPreparedStatementResult(const DoPutPreparedStatementResult& from) : DoPutPreparedStatementResult(nullptr, from) {}
  inline DoPutPreparedStatementResult(DoPutPreparedStatementResult&& from) noexcept
      : DoPutPreparedStatementResult(nullptr, std::move(from)) {}
  inline DoPutPreparedStatementResult& operator=(const DoPutPreparedStatementResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoPutPreparedStatementResult& operator=(DoPutPreparedStatementResult&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DoPutPreparedStatementResult& default_instance() {
    return *reinterpret_cast<const DoPutPreparedStatementResult*>(
        &_DoPutPreparedStatementResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 31;
  friend void swap(DoPutPreparedStatementResult& a, DoPutPreparedStatementResult& b) { a.Swap(&b); }
  inline void Swap(DoPutPreparedStatementResult* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DoPutPreparedStatementResult* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DoPutPreparedStatementResult* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DoPutPreparedStatementResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DoPutPreparedStatementResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DoPutPreparedStatementResult& from) { DoPutPreparedStatementResult::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DoPutPreparedStatementResult* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.sql.DoPutPreparedStatementResult"; }

 protected:
  explicit DoPutPreparedStatementResult(::google::protobuf::Arena* arena);
  DoPutPreparedStatementResult(::google::protobuf::Arena* arena, const DoPutPreparedStatementResult& from);
  DoPutPreparedStatementResult(::google::protobuf::Arena* arena, DoPutPreparedStatementResult&& from) noexcept
      : DoPutPreparedStatementResult(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPreparedStatementHandleFieldNumber = 1,
  };
  // optional bytes prepared_statement_handle = 1;
  bool has_prepared_statement_handle() const;
  void clear_prepared_statement_handle() ;
  const std::string& prepared_statement_handle() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_prepared_statement_handle(Arg_&& arg, Args_... args);
  std::string* mutable_prepared_statement_handle();
  [[nodiscard]] std::string* release_prepared_statement_handle();
  void set_allocated_prepared_statement_handle(std::string* value);

  private:
  const std::string& _internal_prepared_statement_handle() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_prepared_statement_handle(const std::string& value);
  std::string* _internal_mutable_prepared_statement_handle();

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.sql.DoPutPreparedStatementResult)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DoPutPreparedStatementResult& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr prepared_statement_handle_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_FlightSql_2eproto;
};

ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull DoPutPreparedStatementResult_class_data_;
// -------------------------------------------------------------------

class ARROW_FLIGHT_SQL_EXPORT CommandStatementUpdate final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.sql.CommandStatementUpdate) */ {
 public:
  inline CommandStatementUpdate() : CommandStatementUpdate(nullptr) {}
  ~CommandStatementUpdate() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CommandStatementUpdate* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CommandStatementUpdate));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CommandStatementUpdate(
      ::google::protobuf::internal::ConstantInitialized);

  inline CommandStatementUpdate(const CommandStatementUpdate& from) : CommandStatementUpdate(nullptr, from) {}
  inline CommandStatementUpdate(CommandStatementUpdate&& from) noexcept
      : CommandStatementUpdate(nullptr, std::move(from)) {}
  inline CommandStatementUpdate& operator=(const CommandStatementUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandStatementUpdate& operator=(CommandStatementUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommandStatementUpdate& default_instance() {
    return *reinterpret_cast<const CommandStatementUpdate*>(
        &_CommandStatementUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 25;
  friend void swap(CommandStatementUpdate& a, CommandStatementUpdate& b) { a.Swap(&b); }
  inline void Swap(CommandStatementUpdate* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandStatementUpdate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandStatementUpdate* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CommandStatementUpdate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CommandStatementUpdate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CommandStatementUpdate& from) { CommandStatementUpdate::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CommandStatementUpdate* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.sql.CommandStatementUpdate"; }

 protected:
  explicit CommandStatementUpdate(::google::protobuf::Arena* arena);
  CommandStatementUpdate(::google::protobuf::Arena* arena, const CommandStatementUpdate& from);
  CommandStatementUpdate(::google::protobuf::Arena* arena, CommandStatementUpdate&& from) noexcept
      : CommandStatementUpdate(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kQueryFieldNumber = 1,
    kTransactionIdFieldNumber = 2,
  };
  // string query = 1;
  void clear_query() ;
  const std::string& query() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_query(Arg_&& arg, Args_... args);
  std::string* mutable_query();
  [[nodiscard]] std::string* release_query();
  void set_allocated_query(std::string* value);

  private:
  const std::string& _internal_query() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_query(const std::string& value);
  std::string* _internal_mutable_query();

  public:
  // optional bytes transaction_id = 2;
  bool has_transaction_id() const;
  void clear_transaction_id() ;
  const std::string& transaction_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_transaction_id(Arg_&& arg, Args_... args);
  std::string* mutable_transaction_id();
  [[nodiscard]] std::string* release_transaction_id();
  void set_allocated_transaction_id(std::string* value);

  private:
  const std::string& _internal_transaction_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_transaction_id(const std::string& value);
  std::string* _internal_mutable_transaction_id();

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.sql.CommandStatementUpdate)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      62, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CommandStatementUpdate& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr query_;
    ::google::protobuf::internal::ArenaStringPtr transaction_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_FlightSql_2eproto;
};

ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull CommandStatementUpdate_class_data_;
// -------------------------------------------------------------------

class ARROW_FLIGHT_SQL_EXPORT CommandStatementQuery final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.sql.CommandStatementQuery) */ {
 public:
  inline CommandStatementQuery() : CommandStatementQuery(nullptr) {}
  ~CommandStatementQuery() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CommandStatementQuery* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CommandStatementQuery));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CommandStatementQuery(
      ::google::protobuf::internal::ConstantInitialized);

  inline CommandStatementQuery(const CommandStatementQuery& from) : CommandStatementQuery(nullptr, from) {}
  inline CommandStatementQuery(CommandStatementQuery&& from) noexcept
      : CommandStatementQuery(nullptr, std::move(from)) {}
  inline CommandStatementQuery& operator=(const CommandStatementQuery& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandStatementQuery& operator=(CommandStatementQuery&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommandStatementQuery& default_instance() {
    return *reinterpret_cast<const CommandStatementQuery*>(
        &_CommandStatementQuery_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(CommandStatementQuery& a, CommandStatementQuery& b) { a.Swap(&b); }
  inline void Swap(CommandStatementQuery* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandStatementQuery* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandStatementQuery* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CommandStatementQuery>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CommandStatementQuery& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CommandStatementQuery& from) { CommandStatementQuery::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CommandStatementQuery* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.sql.CommandStatementQuery"; }

 protected:
  explicit CommandStatementQuery(::google::protobuf::Arena* arena);
  CommandStatementQuery(::google::protobuf::Arena* arena, const CommandStatementQuery& from);
  CommandStatementQuery(::google::protobuf::Arena* arena, CommandStatementQuery&& from) noexcept
      : CommandStatementQuery(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kQueryFieldNumber = 1,
    kTransactionIdFieldNumber = 2,
  };
  // string query = 1;
  void clear_query() ;
  const std::string& query() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_query(Arg_&& arg, Args_... args);
  std::string* mutable_query();
  [[nodiscard]] std::string* release_query();
  void set_allocated_query(std::string* value);

  private:
  const std::string& _internal_query() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_query(const std::string& value);
  std::string* _internal_mutable_query();

  public:
  // optional bytes transaction_id = 2;
  bool has_transaction_id() const;
  void clear_transaction_id() ;
  const std::string& transaction_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_transaction_id(Arg_&& arg, Args_... args);
  std::string* mutable_transaction_id();
  [[nodiscard]] std::string* release_transaction_id();
  void set_allocated_transaction_id(std::string* value);

  private:
  const std::string& _internal_transaction_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_transaction_id(const std::string& value);
  std::string* _internal_mutable_transaction_id();

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.sql.CommandStatementQuery)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      61, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CommandStatementQuery& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr query_;
    ::google::protobuf::internal::ArenaStringPtr transaction_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_FlightSql_2eproto;
};

ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull CommandStatementQuery_class_data_;
// -------------------------------------------------------------------

class ARROW_FLIGHT_SQL_EXPORT CommandStatementIngest_TableDefinitionOptions final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.sql.CommandStatementIngest.TableDefinitionOptions) */ {
 public:
  inline CommandStatementIngest_TableDefinitionOptions() : CommandStatementIngest_TableDefinitionOptions(nullptr) {}
  ~CommandStatementIngest_TableDefinitionOptions() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CommandStatementIngest_TableDefinitionOptions* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CommandStatementIngest_TableDefinitionOptions));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CommandStatementIngest_TableDefinitionOptions(
      ::google::protobuf::internal::ConstantInitialized);

  inline CommandStatementIngest_TableDefinitionOptions(const CommandStatementIngest_TableDefinitionOptions& from) : CommandStatementIngest_TableDefinitionOptions(nullptr, from) {}
  inline CommandStatementIngest_TableDefinitionOptions(CommandStatementIngest_TableDefinitionOptions&& from) noexcept
      : CommandStatementIngest_TableDefinitionOptions(nullptr, std::move(from)) {}
  inline CommandStatementIngest_TableDefinitionOptions& operator=(const CommandStatementIngest_TableDefinitionOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandStatementIngest_TableDefinitionOptions& operator=(CommandStatementIngest_TableDefinitionOptions&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommandStatementIngest_TableDefinitionOptions& default_instance() {
    return *reinterpret_cast<const CommandStatementIngest_TableDefinitionOptions*>(
        &_CommandStatementIngest_TableDefinitionOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 27;
  friend void swap(CommandStatementIngest_TableDefinitionOptions& a, CommandStatementIngest_TableDefinitionOptions& b) { a.Swap(&b); }
  inline void Swap(CommandStatementIngest_TableDefinitionOptions* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandStatementIngest_TableDefinitionOptions* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandStatementIngest_TableDefinitionOptions* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CommandStatementIngest_TableDefinitionOptions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CommandStatementIngest_TableDefinitionOptions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CommandStatementIngest_TableDefinitionOptions& from) { CommandStatementIngest_TableDefinitionOptions::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CommandStatementIngest_TableDefinitionOptions* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.sql.CommandStatementIngest.TableDefinitionOptions"; }

 protected:
  explicit CommandStatementIngest_TableDefinitionOptions(::google::protobuf::Arena* arena);
  CommandStatementIngest_TableDefinitionOptions(::google::protobuf::Arena* arena, const CommandStatementIngest_TableDefinitionOptions& from);
  CommandStatementIngest_TableDefinitionOptions(::google::protobuf::Arena* arena, CommandStatementIngest_TableDefinitionOptions&& from) noexcept
      : CommandStatementIngest_TableDefinitionOptions(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using TableNotExistOption = CommandStatementIngest_TableDefinitionOptions_TableNotExistOption;
  static constexpr TableNotExistOption TABLE_NOT_EXIST_OPTION_UNSPECIFIED = CommandStatementIngest_TableDefinitionOptions_TableNotExistOption_TABLE_NOT_EXIST_OPTION_UNSPECIFIED;
  static constexpr TableNotExistOption TABLE_NOT_EXIST_OPTION_CREATE = CommandStatementIngest_TableDefinitionOptions_TableNotExistOption_TABLE_NOT_EXIST_OPTION_CREATE;
  static constexpr TableNotExistOption TABLE_NOT_EXIST_OPTION_FAIL = CommandStatementIngest_TableDefinitionOptions_TableNotExistOption_TABLE_NOT_EXIST_OPTION_FAIL;
  static inline bool TableNotExistOption_IsValid(int value) {
    return CommandStatementIngest_TableDefinitionOptions_TableNotExistOption_IsValid(value);
  }
  static constexpr TableNotExistOption TableNotExistOption_MIN = CommandStatementIngest_TableDefinitionOptions_TableNotExistOption_TableNotExistOption_MIN;
  static constexpr TableNotExistOption TableNotExistOption_MAX = CommandStatementIngest_TableDefinitionOptions_TableNotExistOption_TableNotExistOption_MAX;
  static constexpr int TableNotExistOption_ARRAYSIZE = CommandStatementIngest_TableDefinitionOptions_TableNotExistOption_TableNotExistOption_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* TableNotExistOption_descriptor() {
    return CommandStatementIngest_TableDefinitionOptions_TableNotExistOption_descriptor();
  }
  template <typename T>
  static inline const std::string& TableNotExistOption_Name(T value) {
    return CommandStatementIngest_TableDefinitionOptions_TableNotExistOption_Name(value);
  }
  static inline bool TableNotExistOption_Parse(absl::string_view name, TableNotExistOption* value) {
    return CommandStatementIngest_TableDefinitionOptions_TableNotExistOption_Parse(name, value);
  }
  using TableExistsOption = CommandStatementIngest_TableDefinitionOptions_TableExistsOption;
  static constexpr TableExistsOption TABLE_EXISTS_OPTION_UNSPECIFIED = CommandStatementIngest_TableDefinitionOptions_TableExistsOption_TABLE_EXISTS_OPTION_UNSPECIFIED;
  static constexpr TableExistsOption TABLE_EXISTS_OPTION_FAIL = CommandStatementIngest_TableDefinitionOptions_TableExistsOption_TABLE_EXISTS_OPTION_FAIL;
  static constexpr TableExistsOption TABLE_EXISTS_OPTION_APPEND = CommandStatementIngest_TableDefinitionOptions_TableExistsOption_TABLE_EXISTS_OPTION_APPEND;
  static constexpr TableExistsOption TABLE_EXISTS_OPTION_REPLACE = CommandStatementIngest_TableDefinitionOptions_TableExistsOption_TABLE_EXISTS_OPTION_REPLACE;
  static inline bool TableExistsOption_IsValid(int value) {
    return CommandStatementIngest_TableDefinitionOptions_TableExistsOption_IsValid(value);
  }
  static constexpr TableExistsOption TableExistsOption_MIN = CommandStatementIngest_TableDefinitionOptions_TableExistsOption_TableExistsOption_MIN;
  static constexpr TableExistsOption TableExistsOption_MAX = CommandStatementIngest_TableDefinitionOptions_TableExistsOption_TableExistsOption_MAX;
  static constexpr int TableExistsOption_ARRAYSIZE = CommandStatementIngest_TableDefinitionOptions_TableExistsOption_TableExistsOption_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* TableExistsOption_descriptor() {
    return CommandStatementIngest_TableDefinitionOptions_TableExistsOption_descriptor();
  }
  template <typename T>
  static inline const std::string& TableExistsOption_Name(T value) {
    return CommandStatementIngest_TableDefinitionOptions_TableExistsOption_Name(value);
  }
  static inline bool TableExistsOption_Parse(absl::string_view name, TableExistsOption* value) {
    return CommandStatementIngest_TableDefinitionOptions_TableExistsOption_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kIfNotExistFieldNumber = 1,
    kIfExistsFieldNumber = 2,
  };
  // .arrow.flight.protocol.sql.CommandStatementIngest.TableDefinitionOptions.TableNotExistOption if_not_exist = 1;
  void clear_if_not_exist() ;
  ::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions_TableNotExistOption if_not_exist() const;
  void set_if_not_exist(::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions_TableNotExistOption value);

  private:
  ::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions_TableNotExistOption _internal_if_not_exist() const;
  void _internal_set_if_not_exist(::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions_TableNotExistOption value);

  public:
  // .arrow.flight.protocol.sql.CommandStatementIngest.TableDefinitionOptions.TableExistsOption if_exists = 2;
  void clear_if_exists() ;
  ::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions_TableExistsOption if_exists() const;
  void set_if_exists(::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions_TableExistsOption value);

  private:
  ::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions_TableExistsOption _internal_if_exists() const;
  void _internal_set_if_exists(::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions_TableExistsOption value);

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.sql.CommandStatementIngest.TableDefinitionOptions)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CommandStatementIngest_TableDefinitionOptions& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int if_not_exist_;
    int if_exists_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_FlightSql_2eproto;
};

ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull CommandStatementIngest_TableDefinitionOptions_class_data_;
// -------------------------------------------------------------------

class CommandStatementIngest_OptionsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  CommandStatementIngest_OptionsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CommandStatementIngest_OptionsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit CommandStatementIngest_OptionsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const CommandStatementIngest_OptionsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const CommandStatementIngest_OptionsEntry_DoNotUse*>(
        &_CommandStatementIngest_OptionsEntry_DoNotUse_default_instance_);
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_FlightSql_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      78, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
};
ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull CommandStatementIngest_OptionsEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class ARROW_FLIGHT_SQL_EXPORT CommandPreparedStatementUpdate final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.sql.CommandPreparedStatementUpdate) */ {
 public:
  inline CommandPreparedStatementUpdate() : CommandPreparedStatementUpdate(nullptr) {}
  ~CommandPreparedStatementUpdate() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CommandPreparedStatementUpdate* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CommandPreparedStatementUpdate));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CommandPreparedStatementUpdate(
      ::google::protobuf::internal::ConstantInitialized);

  inline CommandPreparedStatementUpdate(const CommandPreparedStatementUpdate& from) : CommandPreparedStatementUpdate(nullptr, from) {}
  inline CommandPreparedStatementUpdate(CommandPreparedStatementUpdate&& from) noexcept
      : CommandPreparedStatementUpdate(nullptr, std::move(from)) {}
  inline CommandPreparedStatementUpdate& operator=(const CommandPreparedStatementUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandPreparedStatementUpdate& operator=(CommandPreparedStatementUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommandPreparedStatementUpdate& default_instance() {
    return *reinterpret_cast<const CommandPreparedStatementUpdate*>(
        &_CommandPreparedStatementUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 26;
  friend void swap(CommandPreparedStatementUpdate& a, CommandPreparedStatementUpdate& b) { a.Swap(&b); }
  inline void Swap(CommandPreparedStatementUpdate* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandPreparedStatementUpdate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandPreparedStatementUpdate* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CommandPreparedStatementUpdate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CommandPreparedStatementUpdate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CommandPreparedStatementUpdate& from) { CommandPreparedStatementUpdate::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CommandPreparedStatementUpdate* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.sql.CommandPreparedStatementUpdate"; }

 protected:
  explicit CommandPreparedStatementUpdate(::google::protobuf::Arena* arena);
  CommandPreparedStatementUpdate(::google::protobuf::Arena* arena, const CommandPreparedStatementUpdate& from);
  CommandPreparedStatementUpdate(::google::protobuf::Arena* arena, CommandPreparedStatementUpdate&& from) noexcept
      : CommandPreparedStatementUpdate(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPreparedStatementHandleFieldNumber = 1,
  };
  // bytes prepared_statement_handle = 1;
  void clear_prepared_statement_handle() ;
  const std::string& prepared_statement_handle() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_prepared_statement_handle(Arg_&& arg, Args_... args);
  std::string* mutable_prepared_statement_handle();
  [[nodiscard]] std::string* release_prepared_statement_handle();
  void set_allocated_prepared_statement_handle(std::string* value);

  private:
  const std::string& _internal_prepared_statement_handle() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_prepared_statement_handle(const std::string& value);
  std::string* _internal_mutable_prepared_statement_handle();

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.sql.CommandPreparedStatementUpdate)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CommandPreparedStatementUpdate& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr prepared_statement_handle_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_FlightSql_2eproto;
};

ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull CommandPreparedStatementUpdate_class_data_;
// -------------------------------------------------------------------

class ARROW_FLIGHT_SQL_EXPORT CommandPreparedStatementQuery final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.sql.CommandPreparedStatementQuery) */ {
 public:
  inline CommandPreparedStatementQuery() : CommandPreparedStatementQuery(nullptr) {}
  ~CommandPreparedStatementQuery() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CommandPreparedStatementQuery* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CommandPreparedStatementQuery));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CommandPreparedStatementQuery(
      ::google::protobuf::internal::ConstantInitialized);

  inline CommandPreparedStatementQuery(const CommandPreparedStatementQuery& from) : CommandPreparedStatementQuery(nullptr, from) {}
  inline CommandPreparedStatementQuery(CommandPreparedStatementQuery&& from) noexcept
      : CommandPreparedStatementQuery(nullptr, std::move(from)) {}
  inline CommandPreparedStatementQuery& operator=(const CommandPreparedStatementQuery& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandPreparedStatementQuery& operator=(CommandPreparedStatementQuery&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommandPreparedStatementQuery& default_instance() {
    return *reinterpret_cast<const CommandPreparedStatementQuery*>(
        &_CommandPreparedStatementQuery_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(CommandPreparedStatementQuery& a, CommandPreparedStatementQuery& b) { a.Swap(&b); }
  inline void Swap(CommandPreparedStatementQuery* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandPreparedStatementQuery* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandPreparedStatementQuery* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CommandPreparedStatementQuery>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CommandPreparedStatementQuery& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CommandPreparedStatementQuery& from) { CommandPreparedStatementQuery::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CommandPreparedStatementQuery* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.sql.CommandPreparedStatementQuery"; }

 protected:
  explicit CommandPreparedStatementQuery(::google::protobuf::Arena* arena);
  CommandPreparedStatementQuery(::google::protobuf::Arena* arena, const CommandPreparedStatementQuery& from);
  CommandPreparedStatementQuery(::google::protobuf::Arena* arena, CommandPreparedStatementQuery&& from) noexcept
      : CommandPreparedStatementQuery(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPreparedStatementHandleFieldNumber = 1,
  };
  // bytes prepared_statement_handle = 1;
  void clear_prepared_statement_handle() ;
  const std::string& prepared_statement_handle() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_prepared_statement_handle(Arg_&& arg, Args_... args);
  std::string* mutable_prepared_statement_handle();
  [[nodiscard]] std::string* release_prepared_statement_handle();
  void set_allocated_prepared_statement_handle(std::string* value);

  private:
  const std::string& _internal_prepared_statement_handle() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_prepared_statement_handle(const std::string& value);
  std::string* _internal_mutable_prepared_statement_handle();

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.sql.CommandPreparedStatementQuery)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CommandPreparedStatementQuery& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr prepared_statement_handle_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_FlightSql_2eproto;
};

ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull CommandPreparedStatementQuery_class_data_;
// -------------------------------------------------------------------

class ARROW_FLIGHT_SQL_EXPORT CommandGetXdbcTypeInfo final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.sql.CommandGetXdbcTypeInfo) */ {
 public:
  inline CommandGetXdbcTypeInfo() : CommandGetXdbcTypeInfo(nullptr) {}
  ~CommandGetXdbcTypeInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CommandGetXdbcTypeInfo* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CommandGetXdbcTypeInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CommandGetXdbcTypeInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline CommandGetXdbcTypeInfo(const CommandGetXdbcTypeInfo& from) : CommandGetXdbcTypeInfo(nullptr, from) {}
  inline CommandGetXdbcTypeInfo(CommandGetXdbcTypeInfo&& from) noexcept
      : CommandGetXdbcTypeInfo(nullptr, std::move(from)) {}
  inline CommandGetXdbcTypeInfo& operator=(const CommandGetXdbcTypeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandGetXdbcTypeInfo& operator=(CommandGetXdbcTypeInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommandGetXdbcTypeInfo& default_instance() {
    return *reinterpret_cast<const CommandGetXdbcTypeInfo*>(
        &_CommandGetXdbcTypeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(CommandGetXdbcTypeInfo& a, CommandGetXdbcTypeInfo& b) { a.Swap(&b); }
  inline void Swap(CommandGetXdbcTypeInfo* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandGetXdbcTypeInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandGetXdbcTypeInfo* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CommandGetXdbcTypeInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CommandGetXdbcTypeInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CommandGetXdbcTypeInfo& from) { CommandGetXdbcTypeInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CommandGetXdbcTypeInfo* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.sql.CommandGetXdbcTypeInfo"; }

 protected:
  explicit CommandGetXdbcTypeInfo(::google::protobuf::Arena* arena);
  CommandGetXdbcTypeInfo(::google::protobuf::Arena* arena, const CommandGetXdbcTypeInfo& from);
  CommandGetXdbcTypeInfo(::google::protobuf::Arena* arena, CommandGetXdbcTypeInfo&& from) noexcept
      : CommandGetXdbcTypeInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDataTypeFieldNumber = 1,
  };
  // optional int32 data_type = 1;
  bool has_data_type() const;
  void clear_data_type() ;
  ::int32_t data_type() const;
  void set_data_type(::int32_t value);

  private:
  ::int32_t _internal_data_type() const;
  void _internal_set_data_type(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.sql.CommandGetXdbcTypeInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CommandGetXdbcTypeInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t data_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_FlightSql_2eproto;
};

ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull CommandGetXdbcTypeInfo_class_data_;
// -------------------------------------------------------------------

class ARROW_FLIGHT_SQL_EXPORT CommandGetTables final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.sql.CommandGetTables) */ {
 public:
  inline CommandGetTables() : CommandGetTables(nullptr) {}
  ~CommandGetTables() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CommandGetTables* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CommandGetTables));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CommandGetTables(
      ::google::protobuf::internal::ConstantInitialized);

  inline CommandGetTables(const CommandGetTables& from) : CommandGetTables(nullptr, from) {}
  inline CommandGetTables(CommandGetTables&& from) noexcept
      : CommandGetTables(nullptr, std::move(from)) {}
  inline CommandGetTables& operator=(const CommandGetTables& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandGetTables& operator=(CommandGetTables&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommandGetTables& default_instance() {
    return *reinterpret_cast<const CommandGetTables*>(
        &_CommandGetTables_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(CommandGetTables& a, CommandGetTables& b) { a.Swap(&b); }
  inline void Swap(CommandGetTables* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandGetTables* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandGetTables* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CommandGetTables>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CommandGetTables& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CommandGetTables& from) { CommandGetTables::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CommandGetTables* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.sql.CommandGetTables"; }

 protected:
  explicit CommandGetTables(::google::protobuf::Arena* arena);
  CommandGetTables(::google::protobuf::Arena* arena, const CommandGetTables& from);
  CommandGetTables(::google::protobuf::Arena* arena, CommandGetTables&& from) noexcept
      : CommandGetTables(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTableTypesFieldNumber = 4,
    kCatalogFieldNumber = 1,
    kDbSchemaFilterPatternFieldNumber = 2,
    kTableNameFilterPatternFieldNumber = 3,
    kIncludeSchemaFieldNumber = 5,
  };
  // repeated string table_types = 4;
  int table_types_size() const;
  private:
  int _internal_table_types_size() const;

  public:
  void clear_table_types() ;
  const std::string& table_types(int index) const;
  std::string* mutable_table_types(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_table_types(int index, Arg_&& value, Args_... args);
  std::string* add_table_types();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_table_types(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& table_types() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_table_types();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_table_types() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_table_types();

  public:
  // optional string catalog = 1;
  bool has_catalog() const;
  void clear_catalog() ;
  const std::string& catalog() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_catalog(Arg_&& arg, Args_... args);
  std::string* mutable_catalog();
  [[nodiscard]] std::string* release_catalog();
  void set_allocated_catalog(std::string* value);

  private:
  const std::string& _internal_catalog() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_catalog(const std::string& value);
  std::string* _internal_mutable_catalog();

  public:
  // optional string db_schema_filter_pattern = 2;
  bool has_db_schema_filter_pattern() const;
  void clear_db_schema_filter_pattern() ;
  const std::string& db_schema_filter_pattern() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_db_schema_filter_pattern(Arg_&& arg, Args_... args);
  std::string* mutable_db_schema_filter_pattern();
  [[nodiscard]] std::string* release_db_schema_filter_pattern();
  void set_allocated_db_schema_filter_pattern(std::string* value);

  private:
  const std::string& _internal_db_schema_filter_pattern() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_db_schema_filter_pattern(const std::string& value);
  std::string* _internal_mutable_db_schema_filter_pattern();

  public:
  // optional string table_name_filter_pattern = 3;
  bool has_table_name_filter_pattern() const;
  void clear_table_name_filter_pattern() ;
  const std::string& table_name_filter_pattern() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_table_name_filter_pattern(Arg_&& arg, Args_... args);
  std::string* mutable_table_name_filter_pattern();
  [[nodiscard]] std::string* release_table_name_filter_pattern();
  void set_allocated_table_name_filter_pattern(std::string* value);

  private:
  const std::string& _internal_table_name_filter_pattern() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_table_name_filter_pattern(const std::string& value);
  std::string* _internal_mutable_table_name_filter_pattern();

  public:
  // bool include_schema = 5;
  void clear_include_schema() ;
  bool include_schema() const;
  void set_include_schema(bool value);

  private:
  bool _internal_include_schema() const;
  void _internal_set_include_schema(bool value);

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.sql.CommandGetTables)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      118, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CommandGetTables& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> table_types_;
    ::google::protobuf::internal::ArenaStringPtr catalog_;
    ::google::protobuf::internal::ArenaStringPtr db_schema_filter_pattern_;
    ::google::protobuf::internal::ArenaStringPtr table_name_filter_pattern_;
    bool include_schema_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_FlightSql_2eproto;
};

ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull CommandGetTables_class_data_;
// -------------------------------------------------------------------

class ARROW_FLIGHT_SQL_EXPORT CommandGetTableTypes final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.sql.CommandGetTableTypes) */ {
 public:
  inline CommandGetTableTypes() : CommandGetTableTypes(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CommandGetTableTypes* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CommandGetTableTypes));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CommandGetTableTypes(
      ::google::protobuf::internal::ConstantInitialized);

  inline CommandGetTableTypes(const CommandGetTableTypes& from) : CommandGetTableTypes(nullptr, from) {}
  inline CommandGetTableTypes(CommandGetTableTypes&& from) noexcept
      : CommandGetTableTypes(nullptr, std::move(from)) {}
  inline CommandGetTableTypes& operator=(const CommandGetTableTypes& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandGetTableTypes& operator=(CommandGetTableTypes&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommandGetTableTypes& default_instance() {
    return *reinterpret_cast<const CommandGetTableTypes*>(
        &_CommandGetTableTypes_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(CommandGetTableTypes& a, CommandGetTableTypes& b) { a.Swap(&b); }
  inline void Swap(CommandGetTableTypes* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandGetTableTypes* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandGetTableTypes* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<CommandGetTableTypes>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CommandGetTableTypes& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CommandGetTableTypes& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.sql.CommandGetTableTypes"; }

 protected:
  explicit CommandGetTableTypes(::google::protobuf::Arena* arena);
  CommandGetTableTypes(::google::protobuf::Arena* arena, const CommandGetTableTypes& from);
  CommandGetTableTypes(::google::protobuf::Arena* arena, CommandGetTableTypes&& from) noexcept
      : CommandGetTableTypes(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.sql.CommandGetTableTypes)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CommandGetTableTypes& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_FlightSql_2eproto;
};

ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull CommandGetTableTypes_class_data_;
// -------------------------------------------------------------------

class ARROW_FLIGHT_SQL_EXPORT CommandGetSqlInfo final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.sql.CommandGetSqlInfo) */ {
 public:
  inline CommandGetSqlInfo() : CommandGetSqlInfo(nullptr) {}
  ~CommandGetSqlInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CommandGetSqlInfo* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CommandGetSqlInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CommandGetSqlInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline CommandGetSqlInfo(const CommandGetSqlInfo& from) : CommandGetSqlInfo(nullptr, from) {}
  inline CommandGetSqlInfo(CommandGetSqlInfo&& from) noexcept
      : CommandGetSqlInfo(nullptr, std::move(from)) {}
  inline CommandGetSqlInfo& operator=(const CommandGetSqlInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandGetSqlInfo& operator=(CommandGetSqlInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommandGetSqlInfo& default_instance() {
    return *reinterpret_cast<const CommandGetSqlInfo*>(
        &_CommandGetSqlInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(CommandGetSqlInfo& a, CommandGetSqlInfo& b) { a.Swap(&b); }
  inline void Swap(CommandGetSqlInfo* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandGetSqlInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandGetSqlInfo* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CommandGetSqlInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CommandGetSqlInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CommandGetSqlInfo& from) { CommandGetSqlInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CommandGetSqlInfo* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.sql.CommandGetSqlInfo"; }

 protected:
  explicit CommandGetSqlInfo(::google::protobuf::Arena* arena);
  CommandGetSqlInfo(::google::protobuf::Arena* arena, const CommandGetSqlInfo& from);
  CommandGetSqlInfo(::google::protobuf::Arena* arena, CommandGetSqlInfo&& from) noexcept
      : CommandGetSqlInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInfoFieldNumber = 1,
  };
  // repeated uint32 info = 1;
  int info_size() const;
  private:
  int _internal_info_size() const;

  public:
  void clear_info() ;
  ::uint32_t info(int index) const;
  void set_info(int index, ::uint32_t value);
  void add_info(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& info() const;
  ::google::protobuf::RepeatedField<::uint32_t>* mutable_info();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_info() const;
  ::google::protobuf::RepeatedField<::uint32_t>* _internal_mutable_info();

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.sql.CommandGetSqlInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CommandGetSqlInfo& from_msg);
    ::google::protobuf::RepeatedField<::uint32_t> info_;
    ::google::protobuf::internal::CachedSize _info_cached_byte_size_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_FlightSql_2eproto;
};

ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull CommandGetSqlInfo_class_data_;
// -------------------------------------------------------------------

class ARROW_FLIGHT_SQL_EXPORT CommandGetPrimaryKeys final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.sql.CommandGetPrimaryKeys) */ {
 public:
  inline CommandGetPrimaryKeys() : CommandGetPrimaryKeys(nullptr) {}
  ~CommandGetPrimaryKeys() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CommandGetPrimaryKeys* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CommandGetPrimaryKeys));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CommandGetPrimaryKeys(
      ::google::protobuf::internal::ConstantInitialized);

  inline CommandGetPrimaryKeys(const CommandGetPrimaryKeys& from) : CommandGetPrimaryKeys(nullptr, from) {}
  inline CommandGetPrimaryKeys(CommandGetPrimaryKeys&& from) noexcept
      : CommandGetPrimaryKeys(nullptr, std::move(from)) {}
  inline CommandGetPrimaryKeys& operator=(const CommandGetPrimaryKeys& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandGetPrimaryKeys& operator=(CommandGetPrimaryKeys&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommandGetPrimaryKeys& default_instance() {
    return *reinterpret_cast<const CommandGetPrimaryKeys*>(
        &_CommandGetPrimaryKeys_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(CommandGetPrimaryKeys& a, CommandGetPrimaryKeys& b) { a.Swap(&b); }
  inline void Swap(CommandGetPrimaryKeys* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandGetPrimaryKeys* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandGetPrimaryKeys* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CommandGetPrimaryKeys>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CommandGetPrimaryKeys& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CommandGetPrimaryKeys& from) { CommandGetPrimaryKeys::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CommandGetPrimaryKeys* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.sql.CommandGetPrimaryKeys"; }

 protected:
  explicit CommandGetPrimaryKeys(::google::protobuf::Arena* arena);
  CommandGetPrimaryKeys(::google::protobuf::Arena* arena, const CommandGetPrimaryKeys& from);
  CommandGetPrimaryKeys(::google::protobuf::Arena* arena, CommandGetPrimaryKeys&& from) noexcept
      : CommandGetPrimaryKeys(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCatalogFieldNumber = 1,
    kDbSchemaFieldNumber = 2,
    kTableFieldNumber = 3,
  };
  // optional string catalog = 1;
  bool has_catalog() const;
  void clear_catalog() ;
  const std::string& catalog() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_catalog(Arg_&& arg, Args_... args);
  std::string* mutable_catalog();
  [[nodiscard]] std::string* release_catalog();
  void set_allocated_catalog(std::string* value);

  private:
  const std::string& _internal_catalog() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_catalog(const std::string& value);
  std::string* _internal_mutable_catalog();

  public:
  // optional string db_schema = 2;
  bool has_db_schema() const;
  void clear_db_schema() ;
  const std::string& db_schema() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_db_schema(Arg_&& arg, Args_... args);
  std::string* mutable_db_schema();
  [[nodiscard]] std::string* release_db_schema();
  void set_allocated_db_schema(std::string* value);

  private:
  const std::string& _internal_db_schema() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_db_schema(const std::string& value);
  std::string* _internal_mutable_db_schema();

  public:
  // string table = 3;
  void clear_table() ;
  const std::string& table() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_table(Arg_&& arg, Args_... args);
  std::string* mutable_table();
  [[nodiscard]] std::string* release_table();
  void set_allocated_table(std::string* value);

  private:
  const std::string& _internal_table() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_table(const std::string& value);
  std::string* _internal_mutable_table();

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.sql.CommandGetPrimaryKeys)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      77, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CommandGetPrimaryKeys& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr catalog_;
    ::google::protobuf::internal::ArenaStringPtr db_schema_;
    ::google::protobuf::internal::ArenaStringPtr table_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_FlightSql_2eproto;
};

ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull CommandGetPrimaryKeys_class_data_;
// -------------------------------------------------------------------

class ARROW_FLIGHT_SQL_EXPORT CommandGetImportedKeys final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.sql.CommandGetImportedKeys) */ {
 public:
  inline CommandGetImportedKeys() : CommandGetImportedKeys(nullptr) {}
  ~CommandGetImportedKeys() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CommandGetImportedKeys* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CommandGetImportedKeys));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CommandGetImportedKeys(
      ::google::protobuf::internal::ConstantInitialized);

  inline CommandGetImportedKeys(const CommandGetImportedKeys& from) : CommandGetImportedKeys(nullptr, from) {}
  inline CommandGetImportedKeys(CommandGetImportedKeys&& from) noexcept
      : CommandGetImportedKeys(nullptr, std::move(from)) {}
  inline CommandGetImportedKeys& operator=(const CommandGetImportedKeys& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandGetImportedKeys& operator=(CommandGetImportedKeys&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommandGetImportedKeys& default_instance() {
    return *reinterpret_cast<const CommandGetImportedKeys*>(
        &_CommandGetImportedKeys_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(CommandGetImportedKeys& a, CommandGetImportedKeys& b) { a.Swap(&b); }
  inline void Swap(CommandGetImportedKeys* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandGetImportedKeys* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandGetImportedKeys* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CommandGetImportedKeys>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CommandGetImportedKeys& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CommandGetImportedKeys& from) { CommandGetImportedKeys::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CommandGetImportedKeys* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.sql.CommandGetImportedKeys"; }

 protected:
  explicit CommandGetImportedKeys(::google::protobuf::Arena* arena);
  CommandGetImportedKeys(::google::protobuf::Arena* arena, const CommandGetImportedKeys& from);
  CommandGetImportedKeys(::google::protobuf::Arena* arena, CommandGetImportedKeys&& from) noexcept
      : CommandGetImportedKeys(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCatalogFieldNumber = 1,
    kDbSchemaFieldNumber = 2,
    kTableFieldNumber = 3,
  };
  // optional string catalog = 1;
  bool has_catalog() const;
  void clear_catalog() ;
  const std::string& catalog() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_catalog(Arg_&& arg, Args_... args);
  std::string* mutable_catalog();
  [[nodiscard]] std::string* release_catalog();
  void set_allocated_catalog(std::string* value);

  private:
  const std::string& _internal_catalog() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_catalog(const std::string& value);
  std::string* _internal_mutable_catalog();

  public:
  // optional string db_schema = 2;
  bool has_db_schema() const;
  void clear_db_schema() ;
  const std::string& db_schema() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_db_schema(Arg_&& arg, Args_... args);
  std::string* mutable_db_schema();
  [[nodiscard]] std::string* release_db_schema();
  void set_allocated_db_schema(std::string* value);

  private:
  const std::string& _internal_db_schema() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_db_schema(const std::string& value);
  std::string* _internal_mutable_db_schema();

  public:
  // string table = 3;
  void clear_table() ;
  const std::string& table() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_table(Arg_&& arg, Args_... args);
  std::string* mutable_table();
  [[nodiscard]] std::string* release_table();
  void set_allocated_table(std::string* value);

  private:
  const std::string& _internal_table() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_table(const std::string& value);
  std::string* _internal_mutable_table();

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.sql.CommandGetImportedKeys)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      78, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CommandGetImportedKeys& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr catalog_;
    ::google::protobuf::internal::ArenaStringPtr db_schema_;
    ::google::protobuf::internal::ArenaStringPtr table_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_FlightSql_2eproto;
};

ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull CommandGetImportedKeys_class_data_;
// -------------------------------------------------------------------

class ARROW_FLIGHT_SQL_EXPORT CommandGetExportedKeys final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.sql.CommandGetExportedKeys) */ {
 public:
  inline CommandGetExportedKeys() : CommandGetExportedKeys(nullptr) {}
  ~CommandGetExportedKeys() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CommandGetExportedKeys* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CommandGetExportedKeys));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CommandGetExportedKeys(
      ::google::protobuf::internal::ConstantInitialized);

  inline CommandGetExportedKeys(const CommandGetExportedKeys& from) : CommandGetExportedKeys(nullptr, from) {}
  inline CommandGetExportedKeys(CommandGetExportedKeys&& from) noexcept
      : CommandGetExportedKeys(nullptr, std::move(from)) {}
  inline CommandGetExportedKeys& operator=(const CommandGetExportedKeys& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandGetExportedKeys& operator=(CommandGetExportedKeys&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommandGetExportedKeys& default_instance() {
    return *reinterpret_cast<const CommandGetExportedKeys*>(
        &_CommandGetExportedKeys_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(CommandGetExportedKeys& a, CommandGetExportedKeys& b) { a.Swap(&b); }
  inline void Swap(CommandGetExportedKeys* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandGetExportedKeys* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandGetExportedKeys* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CommandGetExportedKeys>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CommandGetExportedKeys& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CommandGetExportedKeys& from) { CommandGetExportedKeys::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CommandGetExportedKeys* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.sql.CommandGetExportedKeys"; }

 protected:
  explicit CommandGetExportedKeys(::google::protobuf::Arena* arena);
  CommandGetExportedKeys(::google::protobuf::Arena* arena, const CommandGetExportedKeys& from);
  CommandGetExportedKeys(::google::protobuf::Arena* arena, CommandGetExportedKeys&& from) noexcept
      : CommandGetExportedKeys(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCatalogFieldNumber = 1,
    kDbSchemaFieldNumber = 2,
    kTableFieldNumber = 3,
  };
  // optional string catalog = 1;
  bool has_catalog() const;
  void clear_catalog() ;
  const std::string& catalog() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_catalog(Arg_&& arg, Args_... args);
  std::string* mutable_catalog();
  [[nodiscard]] std::string* release_catalog();
  void set_allocated_catalog(std::string* value);

  private:
  const std::string& _internal_catalog() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_catalog(const std::string& value);
  std::string* _internal_mutable_catalog();

  public:
  // optional string db_schema = 2;
  bool has_db_schema() const;
  void clear_db_schema() ;
  const std::string& db_schema() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_db_schema(Arg_&& arg, Args_... args);
  std::string* mutable_db_schema();
  [[nodiscard]] std::string* release_db_schema();
  void set_allocated_db_schema(std::string* value);

  private:
  const std::string& _internal_db_schema() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_db_schema(const std::string& value);
  std::string* _internal_mutable_db_schema();

  public:
  // string table = 3;
  void clear_table() ;
  const std::string& table() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_table(Arg_&& arg, Args_... args);
  std::string* mutable_table();
  [[nodiscard]] std::string* release_table();
  void set_allocated_table(std::string* value);

  private:
  const std::string& _internal_table() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_table(const std::string& value);
  std::string* _internal_mutable_table();

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.sql.CommandGetExportedKeys)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      78, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CommandGetExportedKeys& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr catalog_;
    ::google::protobuf::internal::ArenaStringPtr db_schema_;
    ::google::protobuf::internal::ArenaStringPtr table_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_FlightSql_2eproto;
};

ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull CommandGetExportedKeys_class_data_;
// -------------------------------------------------------------------

class ARROW_FLIGHT_SQL_EXPORT CommandGetDbSchemas final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.sql.CommandGetDbSchemas) */ {
 public:
  inline CommandGetDbSchemas() : CommandGetDbSchemas(nullptr) {}
  ~CommandGetDbSchemas() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CommandGetDbSchemas* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CommandGetDbSchemas));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CommandGetDbSchemas(
      ::google::protobuf::internal::ConstantInitialized);

  inline CommandGetDbSchemas(const CommandGetDbSchemas& from) : CommandGetDbSchemas(nullptr, from) {}
  inline CommandGetDbSchemas(CommandGetDbSchemas&& from) noexcept
      : CommandGetDbSchemas(nullptr, std::move(from)) {}
  inline CommandGetDbSchemas& operator=(const CommandGetDbSchemas& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandGetDbSchemas& operator=(CommandGetDbSchemas&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommandGetDbSchemas& default_instance() {
    return *reinterpret_cast<const CommandGetDbSchemas*>(
        &_CommandGetDbSchemas_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(CommandGetDbSchemas& a, CommandGetDbSchemas& b) { a.Swap(&b); }
  inline void Swap(CommandGetDbSchemas* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandGetDbSchemas* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandGetDbSchemas* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CommandGetDbSchemas>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CommandGetDbSchemas& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CommandGetDbSchemas& from) { CommandGetDbSchemas::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CommandGetDbSchemas* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.sql.CommandGetDbSchemas"; }

 protected:
  explicit CommandGetDbSchemas(::google::protobuf::Arena* arena);
  CommandGetDbSchemas(::google::protobuf::Arena* arena, const CommandGetDbSchemas& from);
  CommandGetDbSchemas(::google::protobuf::Arena* arena, CommandGetDbSchemas&& from) noexcept
      : CommandGetDbSchemas(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCatalogFieldNumber = 1,
    kDbSchemaFilterPatternFieldNumber = 2,
  };
  // optional string catalog = 1;
  bool has_catalog() const;
  void clear_catalog() ;
  const std::string& catalog() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_catalog(Arg_&& arg, Args_... args);
  std::string* mutable_catalog();
  [[nodiscard]] std::string* release_catalog();
  void set_allocated_catalog(std::string* value);

  private:
  const std::string& _internal_catalog() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_catalog(const std::string& value);
  std::string* _internal_mutable_catalog();

  public:
  // optional string db_schema_filter_pattern = 2;
  bool has_db_schema_filter_pattern() const;
  void clear_db_schema_filter_pattern() ;
  const std::string& db_schema_filter_pattern() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_db_schema_filter_pattern(Arg_&& arg, Args_... args);
  std::string* mutable_db_schema_filter_pattern();
  [[nodiscard]] std::string* release_db_schema_filter_pattern();
  void set_allocated_db_schema_filter_pattern(std::string* value);

  private:
  const std::string& _internal_db_schema_filter_pattern() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_db_schema_filter_pattern(const std::string& value);
  std::string* _internal_mutable_db_schema_filter_pattern();

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.sql.CommandGetDbSchemas)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      85, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CommandGetDbSchemas& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr catalog_;
    ::google::protobuf::internal::ArenaStringPtr db_schema_filter_pattern_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_FlightSql_2eproto;
};

ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull CommandGetDbSchemas_class_data_;
// -------------------------------------------------------------------

class ARROW_FLIGHT_SQL_EXPORT CommandGetCrossReference final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.sql.CommandGetCrossReference) */ {
 public:
  inline CommandGetCrossReference() : CommandGetCrossReference(nullptr) {}
  ~CommandGetCrossReference() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CommandGetCrossReference* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CommandGetCrossReference));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CommandGetCrossReference(
      ::google::protobuf::internal::ConstantInitialized);

  inline CommandGetCrossReference(const CommandGetCrossReference& from) : CommandGetCrossReference(nullptr, from) {}
  inline CommandGetCrossReference(CommandGetCrossReference&& from) noexcept
      : CommandGetCrossReference(nullptr, std::move(from)) {}
  inline CommandGetCrossReference& operator=(const CommandGetCrossReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandGetCrossReference& operator=(CommandGetCrossReference&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommandGetCrossReference& default_instance() {
    return *reinterpret_cast<const CommandGetCrossReference*>(
        &_CommandGetCrossReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(CommandGetCrossReference& a, CommandGetCrossReference& b) { a.Swap(&b); }
  inline void Swap(CommandGetCrossReference* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandGetCrossReference* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandGetCrossReference* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CommandGetCrossReference>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CommandGetCrossReference& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CommandGetCrossReference& from) { CommandGetCrossReference::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CommandGetCrossReference* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.sql.CommandGetCrossReference"; }

 protected:
  explicit CommandGetCrossReference(::google::protobuf::Arena* arena);
  CommandGetCrossReference(::google::protobuf::Arena* arena, const CommandGetCrossReference& from);
  CommandGetCrossReference(::google::protobuf::Arena* arena, CommandGetCrossReference&& from) noexcept
      : CommandGetCrossReference(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPkCatalogFieldNumber = 1,
    kPkDbSchemaFieldNumber = 2,
    kPkTableFieldNumber = 3,
    kFkCatalogFieldNumber = 4,
    kFkDbSchemaFieldNumber = 5,
    kFkTableFieldNumber = 6,
  };
  // optional string pk_catalog = 1;
  bool has_pk_catalog() const;
  void clear_pk_catalog() ;
  const std::string& pk_catalog() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pk_catalog(Arg_&& arg, Args_... args);
  std::string* mutable_pk_catalog();
  [[nodiscard]] std::string* release_pk_catalog();
  void set_allocated_pk_catalog(std::string* value);

  private:
  const std::string& _internal_pk_catalog() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_pk_catalog(const std::string& value);
  std::string* _internal_mutable_pk_catalog();

  public:
  // optional string pk_db_schema = 2;
  bool has_pk_db_schema() const;
  void clear_pk_db_schema() ;
  const std::string& pk_db_schema() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pk_db_schema(Arg_&& arg, Args_... args);
  std::string* mutable_pk_db_schema();
  [[nodiscard]] std::string* release_pk_db_schema();
  void set_allocated_pk_db_schema(std::string* value);

  private:
  const std::string& _internal_pk_db_schema() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_pk_db_schema(const std::string& value);
  std::string* _internal_mutable_pk_db_schema();

  public:
  // string pk_table = 3;
  void clear_pk_table() ;
  const std::string& pk_table() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pk_table(Arg_&& arg, Args_... args);
  std::string* mutable_pk_table();
  [[nodiscard]] std::string* release_pk_table();
  void set_allocated_pk_table(std::string* value);

  private:
  const std::string& _internal_pk_table() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_pk_table(const std::string& value);
  std::string* _internal_mutable_pk_table();

  public:
  // optional string fk_catalog = 4;
  bool has_fk_catalog() const;
  void clear_fk_catalog() ;
  const std::string& fk_catalog() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fk_catalog(Arg_&& arg, Args_... args);
  std::string* mutable_fk_catalog();
  [[nodiscard]] std::string* release_fk_catalog();
  void set_allocated_fk_catalog(std::string* value);

  private:
  const std::string& _internal_fk_catalog() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_fk_catalog(const std::string& value);
  std::string* _internal_mutable_fk_catalog();

  public:
  // optional string fk_db_schema = 5;
  bool has_fk_db_schema() const;
  void clear_fk_db_schema() ;
  const std::string& fk_db_schema() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fk_db_schema(Arg_&& arg, Args_... args);
  std::string* mutable_fk_db_schema();
  [[nodiscard]] std::string* release_fk_db_schema();
  void set_allocated_fk_db_schema(std::string* value);

  private:
  const std::string& _internal_fk_db_schema() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_fk_db_schema(const std::string& value);
  std::string* _internal_mutable_fk_db_schema();

  public:
  // string fk_table = 6;
  void clear_fk_table() ;
  const std::string& fk_table() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fk_table(Arg_&& arg, Args_... args);
  std::string* mutable_fk_table();
  [[nodiscard]] std::string* release_fk_table();
  void set_allocated_fk_table(std::string* value);

  private:
  const std::string& _internal_fk_table() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_fk_table(const std::string& value);
  std::string* _internal_mutable_fk_table();

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.sql.CommandGetCrossReference)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      119, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CommandGetCrossReference& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr pk_catalog_;
    ::google::protobuf::internal::ArenaStringPtr pk_db_schema_;
    ::google::protobuf::internal::ArenaStringPtr pk_table_;
    ::google::protobuf::internal::ArenaStringPtr fk_catalog_;
    ::google::protobuf::internal::ArenaStringPtr fk_db_schema_;
    ::google::protobuf::internal::ArenaStringPtr fk_table_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_FlightSql_2eproto;
};

ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull CommandGetCrossReference_class_data_;
// -------------------------------------------------------------------

class ARROW_FLIGHT_SQL_EXPORT CommandGetCatalogs final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.sql.CommandGetCatalogs) */ {
 public:
  inline CommandGetCatalogs() : CommandGetCatalogs(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CommandGetCatalogs* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CommandGetCatalogs));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CommandGetCatalogs(
      ::google::protobuf::internal::ConstantInitialized);

  inline CommandGetCatalogs(const CommandGetCatalogs& from) : CommandGetCatalogs(nullptr, from) {}
  inline CommandGetCatalogs(CommandGetCatalogs&& from) noexcept
      : CommandGetCatalogs(nullptr, std::move(from)) {}
  inline CommandGetCatalogs& operator=(const CommandGetCatalogs& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandGetCatalogs& operator=(CommandGetCatalogs&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommandGetCatalogs& default_instance() {
    return *reinterpret_cast<const CommandGetCatalogs*>(
        &_CommandGetCatalogs_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(CommandGetCatalogs& a, CommandGetCatalogs& b) { a.Swap(&b); }
  inline void Swap(CommandGetCatalogs* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandGetCatalogs* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandGetCatalogs* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<CommandGetCatalogs>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CommandGetCatalogs& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CommandGetCatalogs& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.sql.CommandGetCatalogs"; }

 protected:
  explicit CommandGetCatalogs(::google::protobuf::Arena* arena);
  CommandGetCatalogs(::google::protobuf::Arena* arena, const CommandGetCatalogs& from);
  CommandGetCatalogs(::google::protobuf::Arena* arena, CommandGetCatalogs&& from) noexcept
      : CommandGetCatalogs(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.sql.CommandGetCatalogs)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CommandGetCatalogs& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_FlightSql_2eproto;
};

ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull CommandGetCatalogs_class_data_;
// -------------------------------------------------------------------

class ARROW_FLIGHT_SQL_EXPORT ActionEndTransactionRequest final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.sql.ActionEndTransactionRequest) */ {
 public:
  inline ActionEndTransactionRequest() : ActionEndTransactionRequest(nullptr) {}
  ~ActionEndTransactionRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ActionEndTransactionRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ActionEndTransactionRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ActionEndTransactionRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ActionEndTransactionRequest(const ActionEndTransactionRequest& from) : ActionEndTransactionRequest(nullptr, from) {}
  inline ActionEndTransactionRequest(ActionEndTransactionRequest&& from) noexcept
      : ActionEndTransactionRequest(nullptr, std::move(from)) {}
  inline ActionEndTransactionRequest& operator=(const ActionEndTransactionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionEndTransactionRequest& operator=(ActionEndTransactionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionEndTransactionRequest& default_instance() {
    return *reinterpret_cast<const ActionEndTransactionRequest*>(
        &_ActionEndTransactionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(ActionEndTransactionRequest& a, ActionEndTransactionRequest& b) { a.Swap(&b); }
  inline void Swap(ActionEndTransactionRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionEndTransactionRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionEndTransactionRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ActionEndTransactionRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ActionEndTransactionRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ActionEndTransactionRequest& from) { ActionEndTransactionRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ActionEndTransactionRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.sql.ActionEndTransactionRequest"; }

 protected:
  explicit ActionEndTransactionRequest(::google::protobuf::Arena* arena);
  ActionEndTransactionRequest(::google::protobuf::Arena* arena, const ActionEndTransactionRequest& from);
  ActionEndTransactionRequest(::google::protobuf::Arena* arena, ActionEndTransactionRequest&& from) noexcept
      : ActionEndTransactionRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using EndTransaction = ActionEndTransactionRequest_EndTransaction;
  static constexpr EndTransaction END_TRANSACTION_UNSPECIFIED = ActionEndTransactionRequest_EndTransaction_END_TRANSACTION_UNSPECIFIED;
  static constexpr EndTransaction END_TRANSACTION_COMMIT = ActionEndTransactionRequest_EndTransaction_END_TRANSACTION_COMMIT;
  static constexpr EndTransaction END_TRANSACTION_ROLLBACK = ActionEndTransactionRequest_EndTransaction_END_TRANSACTION_ROLLBACK;
  static inline bool EndTransaction_IsValid(int value) {
    return ActionEndTransactionRequest_EndTransaction_IsValid(value);
  }
  static constexpr EndTransaction EndTransaction_MIN = ActionEndTransactionRequest_EndTransaction_EndTransaction_MIN;
  static constexpr EndTransaction EndTransaction_MAX = ActionEndTransactionRequest_EndTransaction_EndTransaction_MAX;
  static constexpr int EndTransaction_ARRAYSIZE = ActionEndTransactionRequest_EndTransaction_EndTransaction_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* EndTransaction_descriptor() {
    return ActionEndTransactionRequest_EndTransaction_descriptor();
  }
  template <typename T>
  static inline const std::string& EndTransaction_Name(T value) {
    return ActionEndTransactionRequest_EndTransaction_Name(value);
  }
  static inline bool EndTransaction_Parse(absl::string_view name, EndTransaction* value) {
    return ActionEndTransactionRequest_EndTransaction_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kTransactionIdFieldNumber = 1,
    kActionFieldNumber = 2,
  };
  // bytes transaction_id = 1;
  void clear_transaction_id() ;
  const std::string& transaction_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_transaction_id(Arg_&& arg, Args_... args);
  std::string* mutable_transaction_id();
  [[nodiscard]] std::string* release_transaction_id();
  void set_allocated_transaction_id(std::string* value);

  private:
  const std::string& _internal_transaction_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_transaction_id(const std::string& value);
  std::string* _internal_mutable_transaction_id();

  public:
  // .arrow.flight.protocol.sql.ActionEndTransactionRequest.EndTransaction action = 2;
  void clear_action() ;
  ::arrow::flight::protocol::sql::ActionEndTransactionRequest_EndTransaction action() const;
  void set_action(::arrow::flight::protocol::sql::ActionEndTransactionRequest_EndTransaction value);

  private:
  ::arrow::flight::protocol::sql::ActionEndTransactionRequest_EndTransaction _internal_action() const;
  void _internal_set_action(::arrow::flight::protocol::sql::ActionEndTransactionRequest_EndTransaction value);

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.sql.ActionEndTransactionRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ActionEndTransactionRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr transaction_id_;
    int action_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_FlightSql_2eproto;
};

ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull ActionEndTransactionRequest_class_data_;
// -------------------------------------------------------------------

class ARROW_FLIGHT_SQL_EXPORT ActionEndSavepointRequest final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.sql.ActionEndSavepointRequest) */ {
 public:
  inline ActionEndSavepointRequest() : ActionEndSavepointRequest(nullptr) {}
  ~ActionEndSavepointRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ActionEndSavepointRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ActionEndSavepointRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ActionEndSavepointRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ActionEndSavepointRequest(const ActionEndSavepointRequest& from) : ActionEndSavepointRequest(nullptr, from) {}
  inline ActionEndSavepointRequest(ActionEndSavepointRequest&& from) noexcept
      : ActionEndSavepointRequest(nullptr, std::move(from)) {}
  inline ActionEndSavepointRequest& operator=(const ActionEndSavepointRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionEndSavepointRequest& operator=(ActionEndSavepointRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionEndSavepointRequest& default_instance() {
    return *reinterpret_cast<const ActionEndSavepointRequest*>(
        &_ActionEndSavepointRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(ActionEndSavepointRequest& a, ActionEndSavepointRequest& b) { a.Swap(&b); }
  inline void Swap(ActionEndSavepointRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionEndSavepointRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionEndSavepointRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ActionEndSavepointRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ActionEndSavepointRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ActionEndSavepointRequest& from) { ActionEndSavepointRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ActionEndSavepointRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.sql.ActionEndSavepointRequest"; }

 protected:
  explicit ActionEndSavepointRequest(::google::protobuf::Arena* arena);
  ActionEndSavepointRequest(::google::protobuf::Arena* arena, const ActionEndSavepointRequest& from);
  ActionEndSavepointRequest(::google::protobuf::Arena* arena, ActionEndSavepointRequest&& from) noexcept
      : ActionEndSavepointRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using EndSavepoint = ActionEndSavepointRequest_EndSavepoint;
  static constexpr EndSavepoint END_SAVEPOINT_UNSPECIFIED = ActionEndSavepointRequest_EndSavepoint_END_SAVEPOINT_UNSPECIFIED;
  static constexpr EndSavepoint END_SAVEPOINT_RELEASE = ActionEndSavepointRequest_EndSavepoint_END_SAVEPOINT_RELEASE;
  static constexpr EndSavepoint END_SAVEPOINT_ROLLBACK = ActionEndSavepointRequest_EndSavepoint_END_SAVEPOINT_ROLLBACK;
  static inline bool EndSavepoint_IsValid(int value) {
    return ActionEndSavepointRequest_EndSavepoint_IsValid(value);
  }
  static constexpr EndSavepoint EndSavepoint_MIN = ActionEndSavepointRequest_EndSavepoint_EndSavepoint_MIN;
  static constexpr EndSavepoint EndSavepoint_MAX = ActionEndSavepointRequest_EndSavepoint_EndSavepoint_MAX;
  static constexpr int EndSavepoint_ARRAYSIZE = ActionEndSavepointRequest_EndSavepoint_EndSavepoint_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* EndSavepoint_descriptor() {
    return ActionEndSavepointRequest_EndSavepoint_descriptor();
  }
  template <typename T>
  static inline const std::string& EndSavepoint_Name(T value) {
    return ActionEndSavepointRequest_EndSavepoint_Name(value);
  }
  static inline bool EndSavepoint_Parse(absl::string_view name, EndSavepoint* value) {
    return ActionEndSavepointRequest_EndSavepoint_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kSavepointIdFieldNumber = 1,
    kActionFieldNumber = 2,
  };
  // bytes savepoint_id = 1;
  void clear_savepoint_id() ;
  const std::string& savepoint_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_savepoint_id(Arg_&& arg, Args_... args);
  std::string* mutable_savepoint_id();
  [[nodiscard]] std::string* release_savepoint_id();
  void set_allocated_savepoint_id(std::string* value);

  private:
  const std::string& _internal_savepoint_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_savepoint_id(const std::string& value);
  std::string* _internal_mutable_savepoint_id();

  public:
  // .arrow.flight.protocol.sql.ActionEndSavepointRequest.EndSavepoint action = 2;
  void clear_action() ;
  ::arrow::flight::protocol::sql::ActionEndSavepointRequest_EndSavepoint action() const;
  void set_action(::arrow::flight::protocol::sql::ActionEndSavepointRequest_EndSavepoint value);

  private:
  ::arrow::flight::protocol::sql::ActionEndSavepointRequest_EndSavepoint _internal_action() const;
  void _internal_set_action(::arrow::flight::protocol::sql::ActionEndSavepointRequest_EndSavepoint value);

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.sql.ActionEndSavepointRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ActionEndSavepointRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr savepoint_id_;
    int action_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_FlightSql_2eproto;
};

ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull ActionEndSavepointRequest_class_data_;
// -------------------------------------------------------------------

class ARROW_FLIGHT_SQL_EXPORT ActionCreatePreparedStatementResult final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.sql.ActionCreatePreparedStatementResult) */ {
 public:
  inline ActionCreatePreparedStatementResult() : ActionCreatePreparedStatementResult(nullptr) {}
  ~ActionCreatePreparedStatementResult() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ActionCreatePreparedStatementResult* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ActionCreatePreparedStatementResult));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ActionCreatePreparedStatementResult(
      ::google::protobuf::internal::ConstantInitialized);

  inline ActionCreatePreparedStatementResult(const ActionCreatePreparedStatementResult& from) : ActionCreatePreparedStatementResult(nullptr, from) {}
  inline ActionCreatePreparedStatementResult(ActionCreatePreparedStatementResult&& from) noexcept
      : ActionCreatePreparedStatementResult(nullptr, std::move(from)) {}
  inline ActionCreatePreparedStatementResult& operator=(const ActionCreatePreparedStatementResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionCreatePreparedStatementResult& operator=(ActionCreatePreparedStatementResult&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionCreatePreparedStatementResult& default_instance() {
    return *reinterpret_cast<const ActionCreatePreparedStatementResult*>(
        &_ActionCreatePreparedStatementResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(ActionCreatePreparedStatementResult& a, ActionCreatePreparedStatementResult& b) { a.Swap(&b); }
  inline void Swap(ActionCreatePreparedStatementResult* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionCreatePreparedStatementResult* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionCreatePreparedStatementResult* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ActionCreatePreparedStatementResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ActionCreatePreparedStatementResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ActionCreatePreparedStatementResult& from) { ActionCreatePreparedStatementResult::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ActionCreatePreparedStatementResult* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.sql.ActionCreatePreparedStatementResult"; }

 protected:
  explicit ActionCreatePreparedStatementResult(::google::protobuf::Arena* arena);
  ActionCreatePreparedStatementResult(::google::protobuf::Arena* arena, const ActionCreatePreparedStatementResult& from);
  ActionCreatePreparedStatementResult(::google::protobuf::Arena* arena, ActionCreatePreparedStatementResult&& from) noexcept
      : ActionCreatePreparedStatementResult(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPreparedStatementHandleFieldNumber = 1,
    kDatasetSchemaFieldNumber = 2,
    kParameterSchemaFieldNumber = 3,
  };
  // bytes prepared_statement_handle = 1;
  void clear_prepared_statement_handle() ;
  const std::string& prepared_statement_handle() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_prepared_statement_handle(Arg_&& arg, Args_... args);
  std::string* mutable_prepared_statement_handle();
  [[nodiscard]] std::string* release_prepared_statement_handle();
  void set_allocated_prepared_statement_handle(std::string* value);

  private:
  const std::string& _internal_prepared_statement_handle() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_prepared_statement_handle(const std::string& value);
  std::string* _internal_mutable_prepared_statement_handle();

  public:
  // bytes dataset_schema = 2;
  void clear_dataset_schema() ;
  const std::string& dataset_schema() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dataset_schema(Arg_&& arg, Args_... args);
  std::string* mutable_dataset_schema();
  [[nodiscard]] std::string* release_dataset_schema();
  void set_allocated_dataset_schema(std::string* value);

  private:
  const std::string& _internal_dataset_schema() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_dataset_schema(const std::string& value);
  std::string* _internal_mutable_dataset_schema();

  public:
  // bytes parameter_schema = 3;
  void clear_parameter_schema() ;
  const std::string& parameter_schema() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_parameter_schema(Arg_&& arg, Args_... args);
  std::string* mutable_parameter_schema();
  [[nodiscard]] std::string* release_parameter_schema();
  void set_allocated_parameter_schema(std::string* value);

  private:
  const std::string& _internal_parameter_schema() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_parameter_schema(const std::string& value);
  std::string* _internal_mutable_parameter_schema();

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.sql.ActionCreatePreparedStatementResult)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ActionCreatePreparedStatementResult& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr prepared_statement_handle_;
    ::google::protobuf::internal::ArenaStringPtr dataset_schema_;
    ::google::protobuf::internal::ArenaStringPtr parameter_schema_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_FlightSql_2eproto;
};

ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull ActionCreatePreparedStatementResult_class_data_;
// -------------------------------------------------------------------

class ARROW_FLIGHT_SQL_EXPORT ActionCreatePreparedStatementRequest final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.sql.ActionCreatePreparedStatementRequest) */ {
 public:
  inline ActionCreatePreparedStatementRequest() : ActionCreatePreparedStatementRequest(nullptr) {}
  ~ActionCreatePreparedStatementRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ActionCreatePreparedStatementRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ActionCreatePreparedStatementRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ActionCreatePreparedStatementRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ActionCreatePreparedStatementRequest(const ActionCreatePreparedStatementRequest& from) : ActionCreatePreparedStatementRequest(nullptr, from) {}
  inline ActionCreatePreparedStatementRequest(ActionCreatePreparedStatementRequest&& from) noexcept
      : ActionCreatePreparedStatementRequest(nullptr, std::move(from)) {}
  inline ActionCreatePreparedStatementRequest& operator=(const ActionCreatePreparedStatementRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionCreatePreparedStatementRequest& operator=(ActionCreatePreparedStatementRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionCreatePreparedStatementRequest& default_instance() {
    return *reinterpret_cast<const ActionCreatePreparedStatementRequest*>(
        &_ActionCreatePreparedStatementRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(ActionCreatePreparedStatementRequest& a, ActionCreatePreparedStatementRequest& b) { a.Swap(&b); }
  inline void Swap(ActionCreatePreparedStatementRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionCreatePreparedStatementRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionCreatePreparedStatementRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ActionCreatePreparedStatementRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ActionCreatePreparedStatementRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ActionCreatePreparedStatementRequest& from) { ActionCreatePreparedStatementRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ActionCreatePreparedStatementRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.sql.ActionCreatePreparedStatementRequest"; }

 protected:
  explicit ActionCreatePreparedStatementRequest(::google::protobuf::Arena* arena);
  ActionCreatePreparedStatementRequest(::google::protobuf::Arena* arena, const ActionCreatePreparedStatementRequest& from);
  ActionCreatePreparedStatementRequest(::google::protobuf::Arena* arena, ActionCreatePreparedStatementRequest&& from) noexcept
      : ActionCreatePreparedStatementRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kQueryFieldNumber = 1,
    kTransactionIdFieldNumber = 2,
  };
  // string query = 1;
  void clear_query() ;
  const std::string& query() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_query(Arg_&& arg, Args_... args);
  std::string* mutable_query();
  [[nodiscard]] std::string* release_query();
  void set_allocated_query(std::string* value);

  private:
  const std::string& _internal_query() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_query(const std::string& value);
  std::string* _internal_mutable_query();

  public:
  // optional bytes transaction_id = 2;
  bool has_transaction_id() const;
  void clear_transaction_id() ;
  const std::string& transaction_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_transaction_id(Arg_&& arg, Args_... args);
  std::string* mutable_transaction_id();
  [[nodiscard]] std::string* release_transaction_id();
  void set_allocated_transaction_id(std::string* value);

  private:
  const std::string& _internal_transaction_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_transaction_id(const std::string& value);
  std::string* _internal_mutable_transaction_id();

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.sql.ActionCreatePreparedStatementRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      76, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ActionCreatePreparedStatementRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr query_;
    ::google::protobuf::internal::ArenaStringPtr transaction_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_FlightSql_2eproto;
};

ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull ActionCreatePreparedStatementRequest_class_data_;
// -------------------------------------------------------------------

class ARROW_FLIGHT_SQL_EXPORT ActionClosePreparedStatementRequest final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.sql.ActionClosePreparedStatementRequest) */ {
 public:
  inline ActionClosePreparedStatementRequest() : ActionClosePreparedStatementRequest(nullptr) {}
  ~ActionClosePreparedStatementRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ActionClosePreparedStatementRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ActionClosePreparedStatementRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ActionClosePreparedStatementRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ActionClosePreparedStatementRequest(const ActionClosePreparedStatementRequest& from) : ActionClosePreparedStatementRequest(nullptr, from) {}
  inline ActionClosePreparedStatementRequest(ActionClosePreparedStatementRequest&& from) noexcept
      : ActionClosePreparedStatementRequest(nullptr, std::move(from)) {}
  inline ActionClosePreparedStatementRequest& operator=(const ActionClosePreparedStatementRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionClosePreparedStatementRequest& operator=(ActionClosePreparedStatementRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionClosePreparedStatementRequest& default_instance() {
    return *reinterpret_cast<const ActionClosePreparedStatementRequest*>(
        &_ActionClosePreparedStatementRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(ActionClosePreparedStatementRequest& a, ActionClosePreparedStatementRequest& b) { a.Swap(&b); }
  inline void Swap(ActionClosePreparedStatementRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionClosePreparedStatementRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionClosePreparedStatementRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ActionClosePreparedStatementRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ActionClosePreparedStatementRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ActionClosePreparedStatementRequest& from) { ActionClosePreparedStatementRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ActionClosePreparedStatementRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.sql.ActionClosePreparedStatementRequest"; }

 protected:
  explicit ActionClosePreparedStatementRequest(::google::protobuf::Arena* arena);
  ActionClosePreparedStatementRequest(::google::protobuf::Arena* arena, const ActionClosePreparedStatementRequest& from);
  ActionClosePreparedStatementRequest(::google::protobuf::Arena* arena, ActionClosePreparedStatementRequest&& from) noexcept
      : ActionClosePreparedStatementRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPreparedStatementHandleFieldNumber = 1,
  };
  // bytes prepared_statement_handle = 1;
  void clear_prepared_statement_handle() ;
  const std::string& prepared_statement_handle() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_prepared_statement_handle(Arg_&& arg, Args_... args);
  std::string* mutable_prepared_statement_handle();
  [[nodiscard]] std::string* release_prepared_statement_handle();
  void set_allocated_prepared_statement_handle(std::string* value);

  private:
  const std::string& _internal_prepared_statement_handle() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_prepared_statement_handle(const std::string& value);
  std::string* _internal_mutable_prepared_statement_handle();

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.sql.ActionClosePreparedStatementRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ActionClosePreparedStatementRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr prepared_statement_handle_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_FlightSql_2eproto;
};

ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull ActionClosePreparedStatementRequest_class_data_;
// -------------------------------------------------------------------

class ARROW_FLIGHT_SQL_EXPORT [[deprecated]] ActionCancelQueryResult final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.sql.ActionCancelQueryResult) */ {
 public:
  inline ActionCancelQueryResult() : ActionCancelQueryResult(nullptr) {}
  ~ActionCancelQueryResult() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ActionCancelQueryResult* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ActionCancelQueryResult));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ActionCancelQueryResult(
      ::google::protobuf::internal::ConstantInitialized);

  inline ActionCancelQueryResult(const ActionCancelQueryResult& from) : ActionCancelQueryResult(nullptr, from) {}
  inline ActionCancelQueryResult(ActionCancelQueryResult&& from) noexcept
      : ActionCancelQueryResult(nullptr, std::move(from)) {}
  inline ActionCancelQueryResult& operator=(const ActionCancelQueryResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionCancelQueryResult& operator=(ActionCancelQueryResult&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionCancelQueryResult& default_instance() {
    return *reinterpret_cast<const ActionCancelQueryResult*>(
        &_ActionCancelQueryResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 33;
  friend void swap(ActionCancelQueryResult& a, ActionCancelQueryResult& b) { a.Swap(&b); }
  inline void Swap(ActionCancelQueryResult* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionCancelQueryResult* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionCancelQueryResult* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ActionCancelQueryResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ActionCancelQueryResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ActionCancelQueryResult& from) { ActionCancelQueryResult::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ActionCancelQueryResult* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.sql.ActionCancelQueryResult"; }

 protected:
  explicit ActionCancelQueryResult(::google::protobuf::Arena* arena);
  ActionCancelQueryResult(::google::protobuf::Arena* arena, const ActionCancelQueryResult& from);
  ActionCancelQueryResult(::google::protobuf::Arena* arena, ActionCancelQueryResult&& from) noexcept
      : ActionCancelQueryResult(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using CancelResult = ActionCancelQueryResult_CancelResult;
  static constexpr CancelResult CANCEL_RESULT_UNSPECIFIED = ActionCancelQueryResult_CancelResult_CANCEL_RESULT_UNSPECIFIED;
  static constexpr CancelResult CANCEL_RESULT_CANCELLED = ActionCancelQueryResult_CancelResult_CANCEL_RESULT_CANCELLED;
  static constexpr CancelResult CANCEL_RESULT_CANCELLING = ActionCancelQueryResult_CancelResult_CANCEL_RESULT_CANCELLING;
  static constexpr CancelResult CANCEL_RESULT_NOT_CANCELLABLE = ActionCancelQueryResult_CancelResult_CANCEL_RESULT_NOT_CANCELLABLE;
  static inline bool CancelResult_IsValid(int value) {
    return ActionCancelQueryResult_CancelResult_IsValid(value);
  }
  static constexpr CancelResult CancelResult_MIN = ActionCancelQueryResult_CancelResult_CancelResult_MIN;
  static constexpr CancelResult CancelResult_MAX = ActionCancelQueryResult_CancelResult_CancelResult_MAX;
  static constexpr int CancelResult_ARRAYSIZE = ActionCancelQueryResult_CancelResult_CancelResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* CancelResult_descriptor() {
    return ActionCancelQueryResult_CancelResult_descriptor();
  }
  template <typename T>
  static inline const std::string& CancelResult_Name(T value) {
    return ActionCancelQueryResult_CancelResult_Name(value);
  }
  static inline bool CancelResult_Parse(absl::string_view name, CancelResult* value) {
    return ActionCancelQueryResult_CancelResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kResultFieldNumber = 1,
  };
  // .arrow.flight.protocol.sql.ActionCancelQueryResult.CancelResult result = 1;
  void clear_result() ;
  ::arrow::flight::protocol::sql::ActionCancelQueryResult_CancelResult result() const;
  void set_result(::arrow::flight::protocol::sql::ActionCancelQueryResult_CancelResult value);

  private:
  ::arrow::flight::protocol::sql::ActionCancelQueryResult_CancelResult _internal_result() const;
  void _internal_set_result(::arrow::flight::protocol::sql::ActionCancelQueryResult_CancelResult value);

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.sql.ActionCancelQueryResult)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ActionCancelQueryResult& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int result_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_FlightSql_2eproto;
};

ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull ActionCancelQueryResult_class_data_;
// -------------------------------------------------------------------

class ARROW_FLIGHT_SQL_EXPORT [[deprecated]] ActionCancelQueryRequest final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.sql.ActionCancelQueryRequest) */ {
 public:
  inline ActionCancelQueryRequest() : ActionCancelQueryRequest(nullptr) {}
  ~ActionCancelQueryRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ActionCancelQueryRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ActionCancelQueryRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ActionCancelQueryRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ActionCancelQueryRequest(const ActionCancelQueryRequest& from) : ActionCancelQueryRequest(nullptr, from) {}
  inline ActionCancelQueryRequest(ActionCancelQueryRequest&& from) noexcept
      : ActionCancelQueryRequest(nullptr, std::move(from)) {}
  inline ActionCancelQueryRequest& operator=(const ActionCancelQueryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionCancelQueryRequest& operator=(ActionCancelQueryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionCancelQueryRequest& default_instance() {
    return *reinterpret_cast<const ActionCancelQueryRequest*>(
        &_ActionCancelQueryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 32;
  friend void swap(ActionCancelQueryRequest& a, ActionCancelQueryRequest& b) { a.Swap(&b); }
  inline void Swap(ActionCancelQueryRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionCancelQueryRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionCancelQueryRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ActionCancelQueryRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ActionCancelQueryRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ActionCancelQueryRequest& from) { ActionCancelQueryRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ActionCancelQueryRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.sql.ActionCancelQueryRequest"; }

 protected:
  explicit ActionCancelQueryRequest(::google::protobuf::Arena* arena);
  ActionCancelQueryRequest(::google::protobuf::Arena* arena, const ActionCancelQueryRequest& from);
  ActionCancelQueryRequest(::google::protobuf::Arena* arena, ActionCancelQueryRequest&& from) noexcept
      : ActionCancelQueryRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInfoFieldNumber = 1,
  };
  // bytes info = 1;
  void clear_info() ;
  const std::string& info() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_info(Arg_&& arg, Args_... args);
  std::string* mutable_info();
  [[nodiscard]] std::string* release_info();
  void set_allocated_info(std::string* value);

  private:
  const std::string& _internal_info() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_info(const std::string& value);
  std::string* _internal_mutable_info();

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.sql.ActionCancelQueryRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ActionCancelQueryRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr info_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_FlightSql_2eproto;
};

ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull ActionCancelQueryRequest_class_data_;
// -------------------------------------------------------------------

class ARROW_FLIGHT_SQL_EXPORT ActionBeginTransactionResult final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.sql.ActionBeginTransactionResult) */ {
 public:
  inline ActionBeginTransactionResult() : ActionBeginTransactionResult(nullptr) {}
  ~ActionBeginTransactionResult() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ActionBeginTransactionResult* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ActionBeginTransactionResult));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ActionBeginTransactionResult(
      ::google::protobuf::internal::ConstantInitialized);

  inline ActionBeginTransactionResult(const ActionBeginTransactionResult& from) : ActionBeginTransactionResult(nullptr, from) {}
  inline ActionBeginTransactionResult(ActionBeginTransactionResult&& from) noexcept
      : ActionBeginTransactionResult(nullptr, std::move(from)) {}
  inline ActionBeginTransactionResult& operator=(const ActionBeginTransactionResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionBeginTransactionResult& operator=(ActionBeginTransactionResult&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionBeginTransactionResult& default_instance() {
    return *reinterpret_cast<const ActionBeginTransactionResult*>(
        &_ActionBeginTransactionResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(ActionBeginTransactionResult& a, ActionBeginTransactionResult& b) { a.Swap(&b); }
  inline void Swap(ActionBeginTransactionResult* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionBeginTransactionResult* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionBeginTransactionResult* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ActionBeginTransactionResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ActionBeginTransactionResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ActionBeginTransactionResult& from) { ActionBeginTransactionResult::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ActionBeginTransactionResult* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.sql.ActionBeginTransactionResult"; }

 protected:
  explicit ActionBeginTransactionResult(::google::protobuf::Arena* arena);
  ActionBeginTransactionResult(::google::protobuf::Arena* arena, const ActionBeginTransactionResult& from);
  ActionBeginTransactionResult(::google::protobuf::Arena* arena, ActionBeginTransactionResult&& from) noexcept
      : ActionBeginTransactionResult(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTransactionIdFieldNumber = 1,
  };
  // bytes transaction_id = 1;
  void clear_transaction_id() ;
  const std::string& transaction_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_transaction_id(Arg_&& arg, Args_... args);
  std::string* mutable_transaction_id();
  [[nodiscard]] std::string* release_transaction_id();
  void set_allocated_transaction_id(std::string* value);

  private:
  const std::string& _internal_transaction_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_transaction_id(const std::string& value);
  std::string* _internal_mutable_transaction_id();

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.sql.ActionBeginTransactionResult)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ActionBeginTransactionResult& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr transaction_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_FlightSql_2eproto;
};

ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull ActionBeginTransactionResult_class_data_;
// -------------------------------------------------------------------

class ARROW_FLIGHT_SQL_EXPORT ActionBeginTransactionRequest final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.sql.ActionBeginTransactionRequest) */ {
 public:
  inline ActionBeginTransactionRequest() : ActionBeginTransactionRequest(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ActionBeginTransactionRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ActionBeginTransactionRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ActionBeginTransactionRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ActionBeginTransactionRequest(const ActionBeginTransactionRequest& from) : ActionBeginTransactionRequest(nullptr, from) {}
  inline ActionBeginTransactionRequest(ActionBeginTransactionRequest&& from) noexcept
      : ActionBeginTransactionRequest(nullptr, std::move(from)) {}
  inline ActionBeginTransactionRequest& operator=(const ActionBeginTransactionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionBeginTransactionRequest& operator=(ActionBeginTransactionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionBeginTransactionRequest& default_instance() {
    return *reinterpret_cast<const ActionBeginTransactionRequest*>(
        &_ActionBeginTransactionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(ActionBeginTransactionRequest& a, ActionBeginTransactionRequest& b) { a.Swap(&b); }
  inline void Swap(ActionBeginTransactionRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionBeginTransactionRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionBeginTransactionRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ActionBeginTransactionRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ActionBeginTransactionRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ActionBeginTransactionRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.sql.ActionBeginTransactionRequest"; }

 protected:
  explicit ActionBeginTransactionRequest(::google::protobuf::Arena* arena);
  ActionBeginTransactionRequest(::google::protobuf::Arena* arena, const ActionBeginTransactionRequest& from);
  ActionBeginTransactionRequest(::google::protobuf::Arena* arena, ActionBeginTransactionRequest&& from) noexcept
      : ActionBeginTransactionRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.sql.ActionBeginTransactionRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ActionBeginTransactionRequest& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_FlightSql_2eproto;
};

ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull ActionBeginTransactionRequest_class_data_;
// -------------------------------------------------------------------

class ARROW_FLIGHT_SQL_EXPORT ActionBeginSavepointResult final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.sql.ActionBeginSavepointResult) */ {
 public:
  inline ActionBeginSavepointResult() : ActionBeginSavepointResult(nullptr) {}
  ~ActionBeginSavepointResult() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ActionBeginSavepointResult* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ActionBeginSavepointResult));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ActionBeginSavepointResult(
      ::google::protobuf::internal::ConstantInitialized);

  inline ActionBeginSavepointResult(const ActionBeginSavepointResult& from) : ActionBeginSavepointResult(nullptr, from) {}
  inline ActionBeginSavepointResult(ActionBeginSavepointResult&& from) noexcept
      : ActionBeginSavepointResult(nullptr, std::move(from)) {}
  inline ActionBeginSavepointResult& operator=(const ActionBeginSavepointResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionBeginSavepointResult& operator=(ActionBeginSavepointResult&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionBeginSavepointResult& default_instance() {
    return *reinterpret_cast<const ActionBeginSavepointResult*>(
        &_ActionBeginSavepointResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(ActionBeginSavepointResult& a, ActionBeginSavepointResult& b) { a.Swap(&b); }
  inline void Swap(ActionBeginSavepointResult* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionBeginSavepointResult* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionBeginSavepointResult* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ActionBeginSavepointResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ActionBeginSavepointResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ActionBeginSavepointResult& from) { ActionBeginSavepointResult::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ActionBeginSavepointResult* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.sql.ActionBeginSavepointResult"; }

 protected:
  explicit ActionBeginSavepointResult(::google::protobuf::Arena* arena);
  ActionBeginSavepointResult(::google::protobuf::Arena* arena, const ActionBeginSavepointResult& from);
  ActionBeginSavepointResult(::google::protobuf::Arena* arena, ActionBeginSavepointResult&& from) noexcept
      : ActionBeginSavepointResult(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSavepointIdFieldNumber = 1,
  };
  // bytes savepoint_id = 1;
  void clear_savepoint_id() ;
  const std::string& savepoint_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_savepoint_id(Arg_&& arg, Args_... args);
  std::string* mutable_savepoint_id();
  [[nodiscard]] std::string* release_savepoint_id();
  void set_allocated_savepoint_id(std::string* value);

  private:
  const std::string& _internal_savepoint_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_savepoint_id(const std::string& value);
  std::string* _internal_mutable_savepoint_id();

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.sql.ActionBeginSavepointResult)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ActionBeginSavepointResult& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr savepoint_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_FlightSql_2eproto;
};

ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull ActionBeginSavepointResult_class_data_;
// -------------------------------------------------------------------

class ARROW_FLIGHT_SQL_EXPORT ActionBeginSavepointRequest final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.sql.ActionBeginSavepointRequest) */ {
 public:
  inline ActionBeginSavepointRequest() : ActionBeginSavepointRequest(nullptr) {}
  ~ActionBeginSavepointRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ActionBeginSavepointRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ActionBeginSavepointRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ActionBeginSavepointRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ActionBeginSavepointRequest(const ActionBeginSavepointRequest& from) : ActionBeginSavepointRequest(nullptr, from) {}
  inline ActionBeginSavepointRequest(ActionBeginSavepointRequest&& from) noexcept
      : ActionBeginSavepointRequest(nullptr, std::move(from)) {}
  inline ActionBeginSavepointRequest& operator=(const ActionBeginSavepointRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionBeginSavepointRequest& operator=(ActionBeginSavepointRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionBeginSavepointRequest& default_instance() {
    return *reinterpret_cast<const ActionBeginSavepointRequest*>(
        &_ActionBeginSavepointRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(ActionBeginSavepointRequest& a, ActionBeginSavepointRequest& b) { a.Swap(&b); }
  inline void Swap(ActionBeginSavepointRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionBeginSavepointRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionBeginSavepointRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ActionBeginSavepointRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ActionBeginSavepointRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ActionBeginSavepointRequest& from) { ActionBeginSavepointRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ActionBeginSavepointRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.sql.ActionBeginSavepointRequest"; }

 protected:
  explicit ActionBeginSavepointRequest(::google::protobuf::Arena* arena);
  ActionBeginSavepointRequest(::google::protobuf::Arena* arena, const ActionBeginSavepointRequest& from);
  ActionBeginSavepointRequest(::google::protobuf::Arena* arena, ActionBeginSavepointRequest&& from) noexcept
      : ActionBeginSavepointRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTransactionIdFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // bytes transaction_id = 1;
  void clear_transaction_id() ;
  const std::string& transaction_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_transaction_id(Arg_&& arg, Args_... args);
  std::string* mutable_transaction_id();
  [[nodiscard]] std::string* release_transaction_id();
  void set_allocated_transaction_id(std::string* value);

  private:
  const std::string& _internal_transaction_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_transaction_id(const std::string& value);
  std::string* _internal_mutable_transaction_id();

  public:
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  [[nodiscard]] std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.sql.ActionBeginSavepointRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      66, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ActionBeginSavepointRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr transaction_id_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_FlightSql_2eproto;
};

ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull ActionBeginSavepointRequest_class_data_;
// -------------------------------------------------------------------

class ARROW_FLIGHT_SQL_EXPORT CommandStatementSubstraitPlan final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.sql.CommandStatementSubstraitPlan) */ {
 public:
  inline CommandStatementSubstraitPlan() : CommandStatementSubstraitPlan(nullptr) {}
  ~CommandStatementSubstraitPlan() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CommandStatementSubstraitPlan* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CommandStatementSubstraitPlan));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CommandStatementSubstraitPlan(
      ::google::protobuf::internal::ConstantInitialized);

  inline CommandStatementSubstraitPlan(const CommandStatementSubstraitPlan& from) : CommandStatementSubstraitPlan(nullptr, from) {}
  inline CommandStatementSubstraitPlan(CommandStatementSubstraitPlan&& from) noexcept
      : CommandStatementSubstraitPlan(nullptr, std::move(from)) {}
  inline CommandStatementSubstraitPlan& operator=(const CommandStatementSubstraitPlan& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandStatementSubstraitPlan& operator=(CommandStatementSubstraitPlan&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommandStatementSubstraitPlan& default_instance() {
    return *reinterpret_cast<const CommandStatementSubstraitPlan*>(
        &_CommandStatementSubstraitPlan_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(CommandStatementSubstraitPlan& a, CommandStatementSubstraitPlan& b) { a.Swap(&b); }
  inline void Swap(CommandStatementSubstraitPlan* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandStatementSubstraitPlan* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandStatementSubstraitPlan* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CommandStatementSubstraitPlan>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CommandStatementSubstraitPlan& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CommandStatementSubstraitPlan& from) { CommandStatementSubstraitPlan::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CommandStatementSubstraitPlan* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.sql.CommandStatementSubstraitPlan"; }

 protected:
  explicit CommandStatementSubstraitPlan(::google::protobuf::Arena* arena);
  CommandStatementSubstraitPlan(::google::protobuf::Arena* arena, const CommandStatementSubstraitPlan& from);
  CommandStatementSubstraitPlan(::google::protobuf::Arena* arena, CommandStatementSubstraitPlan&& from) noexcept
      : CommandStatementSubstraitPlan(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTransactionIdFieldNumber = 2,
    kPlanFieldNumber = 1,
  };
  // optional bytes transaction_id = 2;
  bool has_transaction_id() const;
  void clear_transaction_id() ;
  const std::string& transaction_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_transaction_id(Arg_&& arg, Args_... args);
  std::string* mutable_transaction_id();
  [[nodiscard]] std::string* release_transaction_id();
  void set_allocated_transaction_id(std::string* value);

  private:
  const std::string& _internal_transaction_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_transaction_id(const std::string& value);
  std::string* _internal_mutable_transaction_id();

  public:
  // .arrow.flight.protocol.sql.SubstraitPlan plan = 1;
  bool has_plan() const;
  void clear_plan() ;
  const ::arrow::flight::protocol::sql::SubstraitPlan& plan() const;
  [[nodiscard]] ::arrow::flight::protocol::sql::SubstraitPlan* release_plan();
  ::arrow::flight::protocol::sql::SubstraitPlan* mutable_plan();
  void set_allocated_plan(::arrow::flight::protocol::sql::SubstraitPlan* value);
  void unsafe_arena_set_allocated_plan(::arrow::flight::protocol::sql::SubstraitPlan* value);
  ::arrow::flight::protocol::sql::SubstraitPlan* unsafe_arena_release_plan();

  private:
  const ::arrow::flight::protocol::sql::SubstraitPlan& _internal_plan() const;
  ::arrow::flight::protocol::sql::SubstraitPlan* _internal_mutable_plan();

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.sql.CommandStatementSubstraitPlan)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CommandStatementSubstraitPlan& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr transaction_id_;
    ::arrow::flight::protocol::sql::SubstraitPlan* plan_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_FlightSql_2eproto;
};

ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull CommandStatementSubstraitPlan_class_data_;
// -------------------------------------------------------------------

class ARROW_FLIGHT_SQL_EXPORT CommandStatementIngest final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.sql.CommandStatementIngest) */ {
 public:
  inline CommandStatementIngest() : CommandStatementIngest(nullptr) {}
  ~CommandStatementIngest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CommandStatementIngest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CommandStatementIngest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CommandStatementIngest(
      ::google::protobuf::internal::ConstantInitialized);

  inline CommandStatementIngest(const CommandStatementIngest& from) : CommandStatementIngest(nullptr, from) {}
  inline CommandStatementIngest(CommandStatementIngest&& from) noexcept
      : CommandStatementIngest(nullptr, std::move(from)) {}
  inline CommandStatementIngest& operator=(const CommandStatementIngest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandStatementIngest& operator=(CommandStatementIngest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommandStatementIngest& default_instance() {
    return *reinterpret_cast<const CommandStatementIngest*>(
        &_CommandStatementIngest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 29;
  friend void swap(CommandStatementIngest& a, CommandStatementIngest& b) { a.Swap(&b); }
  inline void Swap(CommandStatementIngest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandStatementIngest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandStatementIngest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CommandStatementIngest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CommandStatementIngest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CommandStatementIngest& from) { CommandStatementIngest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CommandStatementIngest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.sql.CommandStatementIngest"; }

 protected:
  explicit CommandStatementIngest(::google::protobuf::Arena* arena);
  CommandStatementIngest(::google::protobuf::Arena* arena, const CommandStatementIngest& from);
  CommandStatementIngest(::google::protobuf::Arena* arena, CommandStatementIngest&& from) noexcept
      : CommandStatementIngest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using TableDefinitionOptions = CommandStatementIngest_TableDefinitionOptions;

  // accessors -------------------------------------------------------
  enum : int {
    kOptionsFieldNumber = 1000,
    kTableFieldNumber = 2,
    kSchemaFieldNumber = 3,
    kCatalogFieldNumber = 4,
    kTransactionIdFieldNumber = 6,
    kTableDefinitionOptionsFieldNumber = 1,
    kTemporaryFieldNumber = 5,
  };
  // map<string, string> options = 1000;
  int options_size() const;
  private:
  int _internal_options_size() const;

  public:
  void clear_options() ;
  const ::google::protobuf::Map<std::string, std::string>& options() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_options();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_options() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_options();

  public:
  // string table = 2;
  void clear_table() ;
  const std::string& table() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_table(Arg_&& arg, Args_... args);
  std::string* mutable_table();
  [[nodiscard]] std::string* release_table();
  void set_allocated_table(std::string* value);

  private:
  const std::string& _internal_table() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_table(const std::string& value);
  std::string* _internal_mutable_table();

  public:
  // optional string schema = 3;
  bool has_schema() const;
  void clear_schema() ;
  const std::string& schema() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_schema(Arg_&& arg, Args_... args);
  std::string* mutable_schema();
  [[nodiscard]] std::string* release_schema();
  void set_allocated_schema(std::string* value);

  private:
  const std::string& _internal_schema() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_schema(const std::string& value);
  std::string* _internal_mutable_schema();

  public:
  // optional string catalog = 4;
  bool has_catalog() const;
  void clear_catalog() ;
  const std::string& catalog() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_catalog(Arg_&& arg, Args_... args);
  std::string* mutable_catalog();
  [[nodiscard]] std::string* release_catalog();
  void set_allocated_catalog(std::string* value);

  private:
  const std::string& _internal_catalog() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_catalog(const std::string& value);
  std::string* _internal_mutable_catalog();

  public:
  // optional bytes transaction_id = 6;
  bool has_transaction_id() const;
  void clear_transaction_id() ;
  const std::string& transaction_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_transaction_id(Arg_&& arg, Args_... args);
  std::string* mutable_transaction_id();
  [[nodiscard]] std::string* release_transaction_id();
  void set_allocated_transaction_id(std::string* value);

  private:
  const std::string& _internal_transaction_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_transaction_id(const std::string& value);
  std::string* _internal_mutable_transaction_id();

  public:
  // .arrow.flight.protocol.sql.CommandStatementIngest.TableDefinitionOptions table_definition_options = 1;
  bool has_table_definition_options() const;
  void clear_table_definition_options() ;
  const ::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions& table_definition_options() const;
  [[nodiscard]] ::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions* release_table_definition_options();
  ::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions* mutable_table_definition_options();
  void set_allocated_table_definition_options(::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions* value);
  void unsafe_arena_set_allocated_table_definition_options(::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions* value);
  ::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions* unsafe_arena_release_table_definition_options();

  private:
  const ::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions& _internal_table_definition_options() const;
  ::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions* _internal_mutable_table_definition_options();

  public:
  // bool temporary = 5;
  void clear_temporary() ;
  bool temporary() const;
  void set_temporary(bool value);

  private:
  bool _internal_temporary() const;
  void _internal_set_temporary(bool value);

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.sql.CommandStatementIngest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 2,
      82, 7>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CommandStatementIngest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::MapField<CommandStatementIngest_OptionsEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        options_;
    ::google::protobuf::internal::ArenaStringPtr table_;
    ::google::protobuf::internal::ArenaStringPtr schema_;
    ::google::protobuf::internal::ArenaStringPtr catalog_;
    ::google::protobuf::internal::ArenaStringPtr transaction_id_;
    ::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions* table_definition_options_;
    bool temporary_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_FlightSql_2eproto;
};

ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull CommandStatementIngest_class_data_;
// -------------------------------------------------------------------

class ARROW_FLIGHT_SQL_EXPORT ActionCreatePreparedSubstraitPlanRequest final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.sql.ActionCreatePreparedSubstraitPlanRequest) */ {
 public:
  inline ActionCreatePreparedSubstraitPlanRequest() : ActionCreatePreparedSubstraitPlanRequest(nullptr) {}
  ~ActionCreatePreparedSubstraitPlanRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ActionCreatePreparedSubstraitPlanRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ActionCreatePreparedSubstraitPlanRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ActionCreatePreparedSubstraitPlanRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ActionCreatePreparedSubstraitPlanRequest(const ActionCreatePreparedSubstraitPlanRequest& from) : ActionCreatePreparedSubstraitPlanRequest(nullptr, from) {}
  inline ActionCreatePreparedSubstraitPlanRequest(ActionCreatePreparedSubstraitPlanRequest&& from) noexcept
      : ActionCreatePreparedSubstraitPlanRequest(nullptr, std::move(from)) {}
  inline ActionCreatePreparedSubstraitPlanRequest& operator=(const ActionCreatePreparedSubstraitPlanRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionCreatePreparedSubstraitPlanRequest& operator=(ActionCreatePreparedSubstraitPlanRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionCreatePreparedSubstraitPlanRequest& default_instance() {
    return *reinterpret_cast<const ActionCreatePreparedSubstraitPlanRequest*>(
        &_ActionCreatePreparedSubstraitPlanRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(ActionCreatePreparedSubstraitPlanRequest& a, ActionCreatePreparedSubstraitPlanRequest& b) { a.Swap(&b); }
  inline void Swap(ActionCreatePreparedSubstraitPlanRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionCreatePreparedSubstraitPlanRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionCreatePreparedSubstraitPlanRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ActionCreatePreparedSubstraitPlanRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ActionCreatePreparedSubstraitPlanRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ActionCreatePreparedSubstraitPlanRequest& from) { ActionCreatePreparedSubstraitPlanRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ActionCreatePreparedSubstraitPlanRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.sql.ActionCreatePreparedSubstraitPlanRequest"; }

 protected:
  explicit ActionCreatePreparedSubstraitPlanRequest(::google::protobuf::Arena* arena);
  ActionCreatePreparedSubstraitPlanRequest(::google::protobuf::Arena* arena, const ActionCreatePreparedSubstraitPlanRequest& from);
  ActionCreatePreparedSubstraitPlanRequest(::google::protobuf::Arena* arena, ActionCreatePreparedSubstraitPlanRequest&& from) noexcept
      : ActionCreatePreparedSubstraitPlanRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTransactionIdFieldNumber = 2,
    kPlanFieldNumber = 1,
  };
  // optional bytes transaction_id = 2;
  bool has_transaction_id() const;
  void clear_transaction_id() ;
  const std::string& transaction_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_transaction_id(Arg_&& arg, Args_... args);
  std::string* mutable_transaction_id();
  [[nodiscard]] std::string* release_transaction_id();
  void set_allocated_transaction_id(std::string* value);

  private:
  const std::string& _internal_transaction_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_transaction_id(const std::string& value);
  std::string* _internal_mutable_transaction_id();

  public:
  // .arrow.flight.protocol.sql.SubstraitPlan plan = 1;
  bool has_plan() const;
  void clear_plan() ;
  const ::arrow::flight::protocol::sql::SubstraitPlan& plan() const;
  [[nodiscard]] ::arrow::flight::protocol::sql::SubstraitPlan* release_plan();
  ::arrow::flight::protocol::sql::SubstraitPlan* mutable_plan();
  void set_allocated_plan(::arrow::flight::protocol::sql::SubstraitPlan* value);
  void unsafe_arena_set_allocated_plan(::arrow::flight::protocol::sql::SubstraitPlan* value);
  ::arrow::flight::protocol::sql::SubstraitPlan* unsafe_arena_release_plan();

  private:
  const ::arrow::flight::protocol::sql::SubstraitPlan& _internal_plan() const;
  ::arrow::flight::protocol::sql::SubstraitPlan* _internal_mutable_plan();

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.sql.ActionCreatePreparedSubstraitPlanRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ActionCreatePreparedSubstraitPlanRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr transaction_id_;
    ::arrow::flight::protocol::sql::SubstraitPlan* plan_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_FlightSql_2eproto;
};

ARROW_FLIGHT_SQL_EXPORT extern const ::google::protobuf::internal::ClassDataFull ActionCreatePreparedSubstraitPlanRequest_class_data_;

// ===================================================================



inline constexpr int kExperimentalFieldNumber =
    1000;
ARROW_FLIGHT_SQL_EXPORT extern ::google::protobuf::internal::ExtensionIdentifier<
    ::google::protobuf::MessageOptions, ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8,
    false>
    experimental;

// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// CommandGetSqlInfo

// repeated uint32 info = 1;
inline int CommandGetSqlInfo::_internal_info_size() const {
  return _internal_info().size();
}
inline int CommandGetSqlInfo::info_size() const {
  return _internal_info_size();
}
inline void CommandGetSqlInfo::clear_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.info_.Clear();
}
inline ::uint32_t CommandGetSqlInfo::info(int index) const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.CommandGetSqlInfo.info)
  return _internal_info().Get(index);
}
inline void CommandGetSqlInfo::set_info(int index, ::uint32_t value) {
  _internal_mutable_info()->Set(index, value);
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.CommandGetSqlInfo.info)
}
inline void CommandGetSqlInfo::add_info(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_info()->Add(value);
  // @@protoc_insertion_point(field_add:arrow.flight.protocol.sql.CommandGetSqlInfo.info)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& CommandGetSqlInfo::info() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:arrow.flight.protocol.sql.CommandGetSqlInfo.info)
  return _internal_info();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* CommandGetSqlInfo::mutable_info()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:arrow.flight.protocol.sql.CommandGetSqlInfo.info)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_info();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
CommandGetSqlInfo::_internal_info() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.info_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* CommandGetSqlInfo::_internal_mutable_info() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.info_;
}

// -------------------------------------------------------------------

// CommandGetXdbcTypeInfo

// optional int32 data_type = 1;
inline bool CommandGetXdbcTypeInfo::has_data_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandGetXdbcTypeInfo::clear_data_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t CommandGetXdbcTypeInfo::data_type() const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.CommandGetXdbcTypeInfo.data_type)
  return _internal_data_type();
}
inline void CommandGetXdbcTypeInfo::set_data_type(::int32_t value) {
  _internal_set_data_type(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.CommandGetXdbcTypeInfo.data_type)
}
inline ::int32_t CommandGetXdbcTypeInfo::_internal_data_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_type_;
}
inline void CommandGetXdbcTypeInfo::_internal_set_data_type(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_type_ = value;
}

// -------------------------------------------------------------------

// CommandGetCatalogs

// -------------------------------------------------------------------

// CommandGetDbSchemas

// optional string catalog = 1;
inline bool CommandGetDbSchemas::has_catalog() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandGetDbSchemas::clear_catalog() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.catalog_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandGetDbSchemas::catalog() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.CommandGetDbSchemas.catalog)
  return _internal_catalog();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CommandGetDbSchemas::set_catalog(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.catalog_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.CommandGetDbSchemas.catalog)
}
inline std::string* CommandGetDbSchemas::mutable_catalog() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_catalog();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.CommandGetDbSchemas.catalog)
  return _s;
}
inline const std::string& CommandGetDbSchemas::_internal_catalog() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.catalog_.Get();
}
inline void CommandGetDbSchemas::_internal_set_catalog(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.catalog_.Set(value, GetArena());
}
inline std::string* CommandGetDbSchemas::_internal_mutable_catalog() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.catalog_.Mutable( GetArena());
}
inline std::string* CommandGetDbSchemas::release_catalog() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.CommandGetDbSchemas.catalog)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.catalog_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.catalog_.Set("", GetArena());
  }
  return released;
}
inline void CommandGetDbSchemas::set_allocated_catalog(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.catalog_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.catalog_.IsDefault()) {
    _impl_.catalog_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.CommandGetDbSchemas.catalog)
}

// optional string db_schema_filter_pattern = 2;
inline bool CommandGetDbSchemas::has_db_schema_filter_pattern() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandGetDbSchemas::clear_db_schema_filter_pattern() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.db_schema_filter_pattern_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommandGetDbSchemas::db_schema_filter_pattern() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.CommandGetDbSchemas.db_schema_filter_pattern)
  return _internal_db_schema_filter_pattern();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CommandGetDbSchemas::set_db_schema_filter_pattern(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.db_schema_filter_pattern_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.CommandGetDbSchemas.db_schema_filter_pattern)
}
inline std::string* CommandGetDbSchemas::mutable_db_schema_filter_pattern() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_db_schema_filter_pattern();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.CommandGetDbSchemas.db_schema_filter_pattern)
  return _s;
}
inline const std::string& CommandGetDbSchemas::_internal_db_schema_filter_pattern() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.db_schema_filter_pattern_.Get();
}
inline void CommandGetDbSchemas::_internal_set_db_schema_filter_pattern(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.db_schema_filter_pattern_.Set(value, GetArena());
}
inline std::string* CommandGetDbSchemas::_internal_mutable_db_schema_filter_pattern() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.db_schema_filter_pattern_.Mutable( GetArena());
}
inline std::string* CommandGetDbSchemas::release_db_schema_filter_pattern() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.CommandGetDbSchemas.db_schema_filter_pattern)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.db_schema_filter_pattern_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.db_schema_filter_pattern_.Set("", GetArena());
  }
  return released;
}
inline void CommandGetDbSchemas::set_allocated_db_schema_filter_pattern(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.db_schema_filter_pattern_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.db_schema_filter_pattern_.IsDefault()) {
    _impl_.db_schema_filter_pattern_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.CommandGetDbSchemas.db_schema_filter_pattern)
}

// -------------------------------------------------------------------

// CommandGetTables

// optional string catalog = 1;
inline bool CommandGetTables::has_catalog() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandGetTables::clear_catalog() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.catalog_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandGetTables::catalog() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.CommandGetTables.catalog)
  return _internal_catalog();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CommandGetTables::set_catalog(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.catalog_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.CommandGetTables.catalog)
}
inline std::string* CommandGetTables::mutable_catalog() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_catalog();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.CommandGetTables.catalog)
  return _s;
}
inline const std::string& CommandGetTables::_internal_catalog() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.catalog_.Get();
}
inline void CommandGetTables::_internal_set_catalog(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.catalog_.Set(value, GetArena());
}
inline std::string* CommandGetTables::_internal_mutable_catalog() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.catalog_.Mutable( GetArena());
}
inline std::string* CommandGetTables::release_catalog() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.CommandGetTables.catalog)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.catalog_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.catalog_.Set("", GetArena());
  }
  return released;
}
inline void CommandGetTables::set_allocated_catalog(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.catalog_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.catalog_.IsDefault()) {
    _impl_.catalog_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.CommandGetTables.catalog)
}

// optional string db_schema_filter_pattern = 2;
inline bool CommandGetTables::has_db_schema_filter_pattern() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandGetTables::clear_db_schema_filter_pattern() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.db_schema_filter_pattern_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommandGetTables::db_schema_filter_pattern() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.CommandGetTables.db_schema_filter_pattern)
  return _internal_db_schema_filter_pattern();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CommandGetTables::set_db_schema_filter_pattern(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.db_schema_filter_pattern_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.CommandGetTables.db_schema_filter_pattern)
}
inline std::string* CommandGetTables::mutable_db_schema_filter_pattern() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_db_schema_filter_pattern();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.CommandGetTables.db_schema_filter_pattern)
  return _s;
}
inline const std::string& CommandGetTables::_internal_db_schema_filter_pattern() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.db_schema_filter_pattern_.Get();
}
inline void CommandGetTables::_internal_set_db_schema_filter_pattern(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.db_schema_filter_pattern_.Set(value, GetArena());
}
inline std::string* CommandGetTables::_internal_mutable_db_schema_filter_pattern() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.db_schema_filter_pattern_.Mutable( GetArena());
}
inline std::string* CommandGetTables::release_db_schema_filter_pattern() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.CommandGetTables.db_schema_filter_pattern)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.db_schema_filter_pattern_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.db_schema_filter_pattern_.Set("", GetArena());
  }
  return released;
}
inline void CommandGetTables::set_allocated_db_schema_filter_pattern(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.db_schema_filter_pattern_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.db_schema_filter_pattern_.IsDefault()) {
    _impl_.db_schema_filter_pattern_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.CommandGetTables.db_schema_filter_pattern)
}

// optional string table_name_filter_pattern = 3;
inline bool CommandGetTables::has_table_name_filter_pattern() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CommandGetTables::clear_table_name_filter_pattern() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.table_name_filter_pattern_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CommandGetTables::table_name_filter_pattern() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.CommandGetTables.table_name_filter_pattern)
  return _internal_table_name_filter_pattern();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CommandGetTables::set_table_name_filter_pattern(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.table_name_filter_pattern_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.CommandGetTables.table_name_filter_pattern)
}
inline std::string* CommandGetTables::mutable_table_name_filter_pattern() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_table_name_filter_pattern();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.CommandGetTables.table_name_filter_pattern)
  return _s;
}
inline const std::string& CommandGetTables::_internal_table_name_filter_pattern() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.table_name_filter_pattern_.Get();
}
inline void CommandGetTables::_internal_set_table_name_filter_pattern(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.table_name_filter_pattern_.Set(value, GetArena());
}
inline std::string* CommandGetTables::_internal_mutable_table_name_filter_pattern() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.table_name_filter_pattern_.Mutable( GetArena());
}
inline std::string* CommandGetTables::release_table_name_filter_pattern() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.CommandGetTables.table_name_filter_pattern)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.table_name_filter_pattern_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.table_name_filter_pattern_.Set("", GetArena());
  }
  return released;
}
inline void CommandGetTables::set_allocated_table_name_filter_pattern(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.table_name_filter_pattern_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.table_name_filter_pattern_.IsDefault()) {
    _impl_.table_name_filter_pattern_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.CommandGetTables.table_name_filter_pattern)
}

// repeated string table_types = 4;
inline int CommandGetTables::_internal_table_types_size() const {
  return _internal_table_types().size();
}
inline int CommandGetTables::table_types_size() const {
  return _internal_table_types_size();
}
inline void CommandGetTables::clear_table_types() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.table_types_.Clear();
}
inline std::string* CommandGetTables::add_table_types() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_table_types()->Add();
  // @@protoc_insertion_point(field_add_mutable:arrow.flight.protocol.sql.CommandGetTables.table_types)
  return _s;
}
inline const std::string& CommandGetTables::table_types(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.CommandGetTables.table_types)
  return _internal_table_types().Get(index);
}
inline std::string* CommandGetTables::mutable_table_types(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.CommandGetTables.table_types)
  return _internal_mutable_table_types()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void CommandGetTables::set_table_types(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_table_types()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.CommandGetTables.table_types)
}
template <typename Arg_, typename... Args_>
inline void CommandGetTables::add_table_types(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_table_types(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:arrow.flight.protocol.sql.CommandGetTables.table_types)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CommandGetTables::table_types() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:arrow.flight.protocol.sql.CommandGetTables.table_types)
  return _internal_table_types();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
CommandGetTables::mutable_table_types() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:arrow.flight.protocol.sql.CommandGetTables.table_types)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_table_types();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CommandGetTables::_internal_table_types() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.table_types_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
CommandGetTables::_internal_mutable_table_types() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.table_types_;
}

// bool include_schema = 5;
inline void CommandGetTables::clear_include_schema() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.include_schema_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool CommandGetTables::include_schema() const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.CommandGetTables.include_schema)
  return _internal_include_schema();
}
inline void CommandGetTables::set_include_schema(bool value) {
  _internal_set_include_schema(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.CommandGetTables.include_schema)
}
inline bool CommandGetTables::_internal_include_schema() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.include_schema_;
}
inline void CommandGetTables::_internal_set_include_schema(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.include_schema_ = value;
}

// -------------------------------------------------------------------

// CommandGetTableTypes

// -------------------------------------------------------------------

// CommandGetPrimaryKeys

// optional string catalog = 1;
inline bool CommandGetPrimaryKeys::has_catalog() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandGetPrimaryKeys::clear_catalog() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.catalog_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandGetPrimaryKeys::catalog() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.CommandGetPrimaryKeys.catalog)
  return _internal_catalog();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CommandGetPrimaryKeys::set_catalog(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.catalog_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.CommandGetPrimaryKeys.catalog)
}
inline std::string* CommandGetPrimaryKeys::mutable_catalog() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_catalog();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.CommandGetPrimaryKeys.catalog)
  return _s;
}
inline const std::string& CommandGetPrimaryKeys::_internal_catalog() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.catalog_.Get();
}
inline void CommandGetPrimaryKeys::_internal_set_catalog(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.catalog_.Set(value, GetArena());
}
inline std::string* CommandGetPrimaryKeys::_internal_mutable_catalog() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.catalog_.Mutable( GetArena());
}
inline std::string* CommandGetPrimaryKeys::release_catalog() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.CommandGetPrimaryKeys.catalog)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.catalog_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.catalog_.Set("", GetArena());
  }
  return released;
}
inline void CommandGetPrimaryKeys::set_allocated_catalog(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.catalog_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.catalog_.IsDefault()) {
    _impl_.catalog_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.CommandGetPrimaryKeys.catalog)
}

// optional string db_schema = 2;
inline bool CommandGetPrimaryKeys::has_db_schema() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandGetPrimaryKeys::clear_db_schema() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.db_schema_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommandGetPrimaryKeys::db_schema() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.CommandGetPrimaryKeys.db_schema)
  return _internal_db_schema();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CommandGetPrimaryKeys::set_db_schema(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.db_schema_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.CommandGetPrimaryKeys.db_schema)
}
inline std::string* CommandGetPrimaryKeys::mutable_db_schema() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_db_schema();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.CommandGetPrimaryKeys.db_schema)
  return _s;
}
inline const std::string& CommandGetPrimaryKeys::_internal_db_schema() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.db_schema_.Get();
}
inline void CommandGetPrimaryKeys::_internal_set_db_schema(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.db_schema_.Set(value, GetArena());
}
inline std::string* CommandGetPrimaryKeys::_internal_mutable_db_schema() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.db_schema_.Mutable( GetArena());
}
inline std::string* CommandGetPrimaryKeys::release_db_schema() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.CommandGetPrimaryKeys.db_schema)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.db_schema_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.db_schema_.Set("", GetArena());
  }
  return released;
}
inline void CommandGetPrimaryKeys::set_allocated_db_schema(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.db_schema_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.db_schema_.IsDefault()) {
    _impl_.db_schema_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.CommandGetPrimaryKeys.db_schema)
}

// string table = 3;
inline void CommandGetPrimaryKeys::clear_table() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.table_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CommandGetPrimaryKeys::table() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.CommandGetPrimaryKeys.table)
  return _internal_table();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CommandGetPrimaryKeys::set_table(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.table_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.CommandGetPrimaryKeys.table)
}
inline std::string* CommandGetPrimaryKeys::mutable_table() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_table();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.CommandGetPrimaryKeys.table)
  return _s;
}
inline const std::string& CommandGetPrimaryKeys::_internal_table() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.table_.Get();
}
inline void CommandGetPrimaryKeys::_internal_set_table(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.table_.Set(value, GetArena());
}
inline std::string* CommandGetPrimaryKeys::_internal_mutable_table() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.table_.Mutable( GetArena());
}
inline std::string* CommandGetPrimaryKeys::release_table() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.CommandGetPrimaryKeys.table)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.table_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.table_.Set("", GetArena());
  }
  return released;
}
inline void CommandGetPrimaryKeys::set_allocated_table(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.table_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.table_.IsDefault()) {
    _impl_.table_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.CommandGetPrimaryKeys.table)
}

// -------------------------------------------------------------------

// CommandGetExportedKeys

// optional string catalog = 1;
inline bool CommandGetExportedKeys::has_catalog() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandGetExportedKeys::clear_catalog() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.catalog_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandGetExportedKeys::catalog() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.CommandGetExportedKeys.catalog)
  return _internal_catalog();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CommandGetExportedKeys::set_catalog(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.catalog_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.CommandGetExportedKeys.catalog)
}
inline std::string* CommandGetExportedKeys::mutable_catalog() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_catalog();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.CommandGetExportedKeys.catalog)
  return _s;
}
inline const std::string& CommandGetExportedKeys::_internal_catalog() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.catalog_.Get();
}
inline void CommandGetExportedKeys::_internal_set_catalog(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.catalog_.Set(value, GetArena());
}
inline std::string* CommandGetExportedKeys::_internal_mutable_catalog() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.catalog_.Mutable( GetArena());
}
inline std::string* CommandGetExportedKeys::release_catalog() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.CommandGetExportedKeys.catalog)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.catalog_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.catalog_.Set("", GetArena());
  }
  return released;
}
inline void CommandGetExportedKeys::set_allocated_catalog(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.catalog_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.catalog_.IsDefault()) {
    _impl_.catalog_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.CommandGetExportedKeys.catalog)
}

// optional string db_schema = 2;
inline bool CommandGetExportedKeys::has_db_schema() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandGetExportedKeys::clear_db_schema() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.db_schema_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommandGetExportedKeys::db_schema() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.CommandGetExportedKeys.db_schema)
  return _internal_db_schema();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CommandGetExportedKeys::set_db_schema(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.db_schema_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.CommandGetExportedKeys.db_schema)
}
inline std::string* CommandGetExportedKeys::mutable_db_schema() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_db_schema();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.CommandGetExportedKeys.db_schema)
  return _s;
}
inline const std::string& CommandGetExportedKeys::_internal_db_schema() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.db_schema_.Get();
}
inline void CommandGetExportedKeys::_internal_set_db_schema(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.db_schema_.Set(value, GetArena());
}
inline std::string* CommandGetExportedKeys::_internal_mutable_db_schema() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.db_schema_.Mutable( GetArena());
}
inline std::string* CommandGetExportedKeys::release_db_schema() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.CommandGetExportedKeys.db_schema)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.db_schema_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.db_schema_.Set("", GetArena());
  }
  return released;
}
inline void CommandGetExportedKeys::set_allocated_db_schema(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.db_schema_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.db_schema_.IsDefault()) {
    _impl_.db_schema_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.CommandGetExportedKeys.db_schema)
}

// string table = 3;
inline void CommandGetExportedKeys::clear_table() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.table_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CommandGetExportedKeys::table() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.CommandGetExportedKeys.table)
  return _internal_table();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CommandGetExportedKeys::set_table(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.table_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.CommandGetExportedKeys.table)
}
inline std::string* CommandGetExportedKeys::mutable_table() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_table();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.CommandGetExportedKeys.table)
  return _s;
}
inline const std::string& CommandGetExportedKeys::_internal_table() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.table_.Get();
}
inline void CommandGetExportedKeys::_internal_set_table(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.table_.Set(value, GetArena());
}
inline std::string* CommandGetExportedKeys::_internal_mutable_table() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.table_.Mutable( GetArena());
}
inline std::string* CommandGetExportedKeys::release_table() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.CommandGetExportedKeys.table)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.table_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.table_.Set("", GetArena());
  }
  return released;
}
inline void CommandGetExportedKeys::set_allocated_table(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.table_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.table_.IsDefault()) {
    _impl_.table_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.CommandGetExportedKeys.table)
}

// -------------------------------------------------------------------

// CommandGetImportedKeys

// optional string catalog = 1;
inline bool CommandGetImportedKeys::has_catalog() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandGetImportedKeys::clear_catalog() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.catalog_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandGetImportedKeys::catalog() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.CommandGetImportedKeys.catalog)
  return _internal_catalog();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CommandGetImportedKeys::set_catalog(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.catalog_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.CommandGetImportedKeys.catalog)
}
inline std::string* CommandGetImportedKeys::mutable_catalog() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_catalog();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.CommandGetImportedKeys.catalog)
  return _s;
}
inline const std::string& CommandGetImportedKeys::_internal_catalog() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.catalog_.Get();
}
inline void CommandGetImportedKeys::_internal_set_catalog(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.catalog_.Set(value, GetArena());
}
inline std::string* CommandGetImportedKeys::_internal_mutable_catalog() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.catalog_.Mutable( GetArena());
}
inline std::string* CommandGetImportedKeys::release_catalog() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.CommandGetImportedKeys.catalog)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.catalog_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.catalog_.Set("", GetArena());
  }
  return released;
}
inline void CommandGetImportedKeys::set_allocated_catalog(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.catalog_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.catalog_.IsDefault()) {
    _impl_.catalog_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.CommandGetImportedKeys.catalog)
}

// optional string db_schema = 2;
inline bool CommandGetImportedKeys::has_db_schema() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandGetImportedKeys::clear_db_schema() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.db_schema_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommandGetImportedKeys::db_schema() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.CommandGetImportedKeys.db_schema)
  return _internal_db_schema();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CommandGetImportedKeys::set_db_schema(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.db_schema_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.CommandGetImportedKeys.db_schema)
}
inline std::string* CommandGetImportedKeys::mutable_db_schema() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_db_schema();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.CommandGetImportedKeys.db_schema)
  return _s;
}
inline const std::string& CommandGetImportedKeys::_internal_db_schema() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.db_schema_.Get();
}
inline void CommandGetImportedKeys::_internal_set_db_schema(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.db_schema_.Set(value, GetArena());
}
inline std::string* CommandGetImportedKeys::_internal_mutable_db_schema() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.db_schema_.Mutable( GetArena());
}
inline std::string* CommandGetImportedKeys::release_db_schema() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.CommandGetImportedKeys.db_schema)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.db_schema_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.db_schema_.Set("", GetArena());
  }
  return released;
}
inline void CommandGetImportedKeys::set_allocated_db_schema(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.db_schema_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.db_schema_.IsDefault()) {
    _impl_.db_schema_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.CommandGetImportedKeys.db_schema)
}

// string table = 3;
inline void CommandGetImportedKeys::clear_table() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.table_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CommandGetImportedKeys::table() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.CommandGetImportedKeys.table)
  return _internal_table();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CommandGetImportedKeys::set_table(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.table_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.CommandGetImportedKeys.table)
}
inline std::string* CommandGetImportedKeys::mutable_table() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_table();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.CommandGetImportedKeys.table)
  return _s;
}
inline const std::string& CommandGetImportedKeys::_internal_table() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.table_.Get();
}
inline void CommandGetImportedKeys::_internal_set_table(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.table_.Set(value, GetArena());
}
inline std::string* CommandGetImportedKeys::_internal_mutable_table() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.table_.Mutable( GetArena());
}
inline std::string* CommandGetImportedKeys::release_table() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.CommandGetImportedKeys.table)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.table_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.table_.Set("", GetArena());
  }
  return released;
}
inline void CommandGetImportedKeys::set_allocated_table(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.table_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.table_.IsDefault()) {
    _impl_.table_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.CommandGetImportedKeys.table)
}

// -------------------------------------------------------------------

// CommandGetCrossReference

// optional string pk_catalog = 1;
inline bool CommandGetCrossReference::has_pk_catalog() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandGetCrossReference::clear_pk_catalog() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pk_catalog_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandGetCrossReference::pk_catalog() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.CommandGetCrossReference.pk_catalog)
  return _internal_pk_catalog();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CommandGetCrossReference::set_pk_catalog(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.pk_catalog_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.CommandGetCrossReference.pk_catalog)
}
inline std::string* CommandGetCrossReference::mutable_pk_catalog() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_pk_catalog();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.CommandGetCrossReference.pk_catalog)
  return _s;
}
inline const std::string& CommandGetCrossReference::_internal_pk_catalog() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pk_catalog_.Get();
}
inline void CommandGetCrossReference::_internal_set_pk_catalog(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.pk_catalog_.Set(value, GetArena());
}
inline std::string* CommandGetCrossReference::_internal_mutable_pk_catalog() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.pk_catalog_.Mutable( GetArena());
}
inline std::string* CommandGetCrossReference::release_pk_catalog() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.CommandGetCrossReference.pk_catalog)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.pk_catalog_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.pk_catalog_.Set("", GetArena());
  }
  return released;
}
inline void CommandGetCrossReference::set_allocated_pk_catalog(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.pk_catalog_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.pk_catalog_.IsDefault()) {
    _impl_.pk_catalog_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.CommandGetCrossReference.pk_catalog)
}

// optional string pk_db_schema = 2;
inline bool CommandGetCrossReference::has_pk_db_schema() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandGetCrossReference::clear_pk_db_schema() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pk_db_schema_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommandGetCrossReference::pk_db_schema() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.CommandGetCrossReference.pk_db_schema)
  return _internal_pk_db_schema();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CommandGetCrossReference::set_pk_db_schema(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pk_db_schema_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.CommandGetCrossReference.pk_db_schema)
}
inline std::string* CommandGetCrossReference::mutable_pk_db_schema() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_pk_db_schema();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.CommandGetCrossReference.pk_db_schema)
  return _s;
}
inline const std::string& CommandGetCrossReference::_internal_pk_db_schema() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pk_db_schema_.Get();
}
inline void CommandGetCrossReference::_internal_set_pk_db_schema(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pk_db_schema_.Set(value, GetArena());
}
inline std::string* CommandGetCrossReference::_internal_mutable_pk_db_schema() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.pk_db_schema_.Mutable( GetArena());
}
inline std::string* CommandGetCrossReference::release_pk_db_schema() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.CommandGetCrossReference.pk_db_schema)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.pk_db_schema_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.pk_db_schema_.Set("", GetArena());
  }
  return released;
}
inline void CommandGetCrossReference::set_allocated_pk_db_schema(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.pk_db_schema_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.pk_db_schema_.IsDefault()) {
    _impl_.pk_db_schema_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.CommandGetCrossReference.pk_db_schema)
}

// string pk_table = 3;
inline void CommandGetCrossReference::clear_pk_table() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pk_table_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CommandGetCrossReference::pk_table() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.CommandGetCrossReference.pk_table)
  return _internal_pk_table();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CommandGetCrossReference::set_pk_table(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.pk_table_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.CommandGetCrossReference.pk_table)
}
inline std::string* CommandGetCrossReference::mutable_pk_table() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_pk_table();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.CommandGetCrossReference.pk_table)
  return _s;
}
inline const std::string& CommandGetCrossReference::_internal_pk_table() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pk_table_.Get();
}
inline void CommandGetCrossReference::_internal_set_pk_table(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.pk_table_.Set(value, GetArena());
}
inline std::string* CommandGetCrossReference::_internal_mutable_pk_table() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.pk_table_.Mutable( GetArena());
}
inline std::string* CommandGetCrossReference::release_pk_table() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.CommandGetCrossReference.pk_table)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.pk_table_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.pk_table_.Set("", GetArena());
  }
  return released;
}
inline void CommandGetCrossReference::set_allocated_pk_table(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.pk_table_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.pk_table_.IsDefault()) {
    _impl_.pk_table_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.CommandGetCrossReference.pk_table)
}

// optional string fk_catalog = 4;
inline bool CommandGetCrossReference::has_fk_catalog() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CommandGetCrossReference::clear_fk_catalog() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fk_catalog_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CommandGetCrossReference::fk_catalog() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.CommandGetCrossReference.fk_catalog)
  return _internal_fk_catalog();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CommandGetCrossReference::set_fk_catalog(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.fk_catalog_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.CommandGetCrossReference.fk_catalog)
}
inline std::string* CommandGetCrossReference::mutable_fk_catalog() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_fk_catalog();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.CommandGetCrossReference.fk_catalog)
  return _s;
}
inline const std::string& CommandGetCrossReference::_internal_fk_catalog() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fk_catalog_.Get();
}
inline void CommandGetCrossReference::_internal_set_fk_catalog(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.fk_catalog_.Set(value, GetArena());
}
inline std::string* CommandGetCrossReference::_internal_mutable_fk_catalog() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.fk_catalog_.Mutable( GetArena());
}
inline std::string* CommandGetCrossReference::release_fk_catalog() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.CommandGetCrossReference.fk_catalog)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.fk_catalog_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.fk_catalog_.Set("", GetArena());
  }
  return released;
}
inline void CommandGetCrossReference::set_allocated_fk_catalog(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.fk_catalog_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.fk_catalog_.IsDefault()) {
    _impl_.fk_catalog_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.CommandGetCrossReference.fk_catalog)
}

// optional string fk_db_schema = 5;
inline bool CommandGetCrossReference::has_fk_db_schema() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void CommandGetCrossReference::clear_fk_db_schema() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fk_db_schema_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& CommandGetCrossReference::fk_db_schema() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.CommandGetCrossReference.fk_db_schema)
  return _internal_fk_db_schema();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CommandGetCrossReference::set_fk_db_schema(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.fk_db_schema_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.CommandGetCrossReference.fk_db_schema)
}
inline std::string* CommandGetCrossReference::mutable_fk_db_schema() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_fk_db_schema();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.CommandGetCrossReference.fk_db_schema)
  return _s;
}
inline const std::string& CommandGetCrossReference::_internal_fk_db_schema() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fk_db_schema_.Get();
}
inline void CommandGetCrossReference::_internal_set_fk_db_schema(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.fk_db_schema_.Set(value, GetArena());
}
inline std::string* CommandGetCrossReference::_internal_mutable_fk_db_schema() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.fk_db_schema_.Mutable( GetArena());
}
inline std::string* CommandGetCrossReference::release_fk_db_schema() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.CommandGetCrossReference.fk_db_schema)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.fk_db_schema_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.fk_db_schema_.Set("", GetArena());
  }
  return released;
}
inline void CommandGetCrossReference::set_allocated_fk_db_schema(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.fk_db_schema_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.fk_db_schema_.IsDefault()) {
    _impl_.fk_db_schema_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.CommandGetCrossReference.fk_db_schema)
}

// string fk_table = 6;
inline void CommandGetCrossReference::clear_fk_table() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fk_table_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& CommandGetCrossReference::fk_table() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.CommandGetCrossReference.fk_table)
  return _internal_fk_table();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CommandGetCrossReference::set_fk_table(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.fk_table_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.CommandGetCrossReference.fk_table)
}
inline std::string* CommandGetCrossReference::mutable_fk_table() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_fk_table();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.CommandGetCrossReference.fk_table)
  return _s;
}
inline const std::string& CommandGetCrossReference::_internal_fk_table() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fk_table_.Get();
}
inline void CommandGetCrossReference::_internal_set_fk_table(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.fk_table_.Set(value, GetArena());
}
inline std::string* CommandGetCrossReference::_internal_mutable_fk_table() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.fk_table_.Mutable( GetArena());
}
inline std::string* CommandGetCrossReference::release_fk_table() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.CommandGetCrossReference.fk_table)
  if ((_impl_._has_bits_[0] & 0x00000020u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* released = _impl_.fk_table_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.fk_table_.Set("", GetArena());
  }
  return released;
}
inline void CommandGetCrossReference::set_allocated_fk_table(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.fk_table_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.fk_table_.IsDefault()) {
    _impl_.fk_table_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.CommandGetCrossReference.fk_table)
}

// -------------------------------------------------------------------

// ActionCreatePreparedStatementRequest

// string query = 1;
inline void ActionCreatePreparedStatementRequest::clear_query() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.query_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ActionCreatePreparedStatementRequest::query() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.ActionCreatePreparedStatementRequest.query)
  return _internal_query();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ActionCreatePreparedStatementRequest::set_query(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.query_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.ActionCreatePreparedStatementRequest.query)
}
inline std::string* ActionCreatePreparedStatementRequest::mutable_query() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_query();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.ActionCreatePreparedStatementRequest.query)
  return _s;
}
inline const std::string& ActionCreatePreparedStatementRequest::_internal_query() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.query_.Get();
}
inline void ActionCreatePreparedStatementRequest::_internal_set_query(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.query_.Set(value, GetArena());
}
inline std::string* ActionCreatePreparedStatementRequest::_internal_mutable_query() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.query_.Mutable( GetArena());
}
inline std::string* ActionCreatePreparedStatementRequest::release_query() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.ActionCreatePreparedStatementRequest.query)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.query_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.query_.Set("", GetArena());
  }
  return released;
}
inline void ActionCreatePreparedStatementRequest::set_allocated_query(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.query_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.query_.IsDefault()) {
    _impl_.query_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.ActionCreatePreparedStatementRequest.query)
}

// optional bytes transaction_id = 2;
inline bool ActionCreatePreparedStatementRequest::has_transaction_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ActionCreatePreparedStatementRequest::clear_transaction_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.transaction_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ActionCreatePreparedStatementRequest::transaction_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.ActionCreatePreparedStatementRequest.transaction_id)
  return _internal_transaction_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ActionCreatePreparedStatementRequest::set_transaction_id(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.transaction_id_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.ActionCreatePreparedStatementRequest.transaction_id)
}
inline std::string* ActionCreatePreparedStatementRequest::mutable_transaction_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_transaction_id();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.ActionCreatePreparedStatementRequest.transaction_id)
  return _s;
}
inline const std::string& ActionCreatePreparedStatementRequest::_internal_transaction_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.transaction_id_.Get();
}
inline void ActionCreatePreparedStatementRequest::_internal_set_transaction_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.transaction_id_.Set(value, GetArena());
}
inline std::string* ActionCreatePreparedStatementRequest::_internal_mutable_transaction_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.transaction_id_.Mutable( GetArena());
}
inline std::string* ActionCreatePreparedStatementRequest::release_transaction_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.ActionCreatePreparedStatementRequest.transaction_id)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.transaction_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.transaction_id_.Set("", GetArena());
  }
  return released;
}
inline void ActionCreatePreparedStatementRequest::set_allocated_transaction_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.transaction_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.transaction_id_.IsDefault()) {
    _impl_.transaction_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.ActionCreatePreparedStatementRequest.transaction_id)
}

// -------------------------------------------------------------------

// SubstraitPlan

// bytes plan = 1;
inline void SubstraitPlan::clear_plan() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.plan_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SubstraitPlan::plan() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.SubstraitPlan.plan)
  return _internal_plan();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SubstraitPlan::set_plan(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.plan_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.SubstraitPlan.plan)
}
inline std::string* SubstraitPlan::mutable_plan() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_plan();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.SubstraitPlan.plan)
  return _s;
}
inline const std::string& SubstraitPlan::_internal_plan() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.plan_.Get();
}
inline void SubstraitPlan::_internal_set_plan(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.plan_.Set(value, GetArena());
}
inline std::string* SubstraitPlan::_internal_mutable_plan() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.plan_.Mutable( GetArena());
}
inline std::string* SubstraitPlan::release_plan() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.SubstraitPlan.plan)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.plan_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.plan_.Set("", GetArena());
  }
  return released;
}
inline void SubstraitPlan::set_allocated_plan(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.plan_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.plan_.IsDefault()) {
    _impl_.plan_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.SubstraitPlan.plan)
}

// string version = 2;
inline void SubstraitPlan::clear_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SubstraitPlan::version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.SubstraitPlan.version)
  return _internal_version();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SubstraitPlan::set_version(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.SubstraitPlan.version)
}
inline std::string* SubstraitPlan::mutable_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.SubstraitPlan.version)
  return _s;
}
inline const std::string& SubstraitPlan::_internal_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.version_.Get();
}
inline void SubstraitPlan::_internal_set_version(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.version_.Set(value, GetArena());
}
inline std::string* SubstraitPlan::_internal_mutable_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.version_.Mutable( GetArena());
}
inline std::string* SubstraitPlan::release_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.SubstraitPlan.version)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.version_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.version_.Set("", GetArena());
  }
  return released;
}
inline void SubstraitPlan::set_allocated_version(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.version_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.SubstraitPlan.version)
}

// -------------------------------------------------------------------

// ActionCreatePreparedSubstraitPlanRequest

// .arrow.flight.protocol.sql.SubstraitPlan plan = 1;
inline bool ActionCreatePreparedSubstraitPlanRequest::has_plan() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.plan_ != nullptr);
  return value;
}
inline void ActionCreatePreparedSubstraitPlanRequest::clear_plan() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.plan_ != nullptr) _impl_.plan_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::arrow::flight::protocol::sql::SubstraitPlan& ActionCreatePreparedSubstraitPlanRequest::_internal_plan() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::arrow::flight::protocol::sql::SubstraitPlan* p = _impl_.plan_;
  return p != nullptr ? *p : reinterpret_cast<const ::arrow::flight::protocol::sql::SubstraitPlan&>(::arrow::flight::protocol::sql::_SubstraitPlan_default_instance_);
}
inline const ::arrow::flight::protocol::sql::SubstraitPlan& ActionCreatePreparedSubstraitPlanRequest::plan() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.ActionCreatePreparedSubstraitPlanRequest.plan)
  return _internal_plan();
}
inline void ActionCreatePreparedSubstraitPlanRequest::unsafe_arena_set_allocated_plan(::arrow::flight::protocol::sql::SubstraitPlan* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.plan_);
  }
  _impl_.plan_ = reinterpret_cast<::arrow::flight::protocol::sql::SubstraitPlan*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:arrow.flight.protocol.sql.ActionCreatePreparedSubstraitPlanRequest.plan)
}
inline ::arrow::flight::protocol::sql::SubstraitPlan* ActionCreatePreparedSubstraitPlanRequest::release_plan() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::arrow::flight::protocol::sql::SubstraitPlan* released = _impl_.plan_;
  _impl_.plan_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::arrow::flight::protocol::sql::SubstraitPlan* ActionCreatePreparedSubstraitPlanRequest::unsafe_arena_release_plan() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.ActionCreatePreparedSubstraitPlanRequest.plan)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::arrow::flight::protocol::sql::SubstraitPlan* temp = _impl_.plan_;
  _impl_.plan_ = nullptr;
  return temp;
}
inline ::arrow::flight::protocol::sql::SubstraitPlan* ActionCreatePreparedSubstraitPlanRequest::_internal_mutable_plan() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.plan_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::arrow::flight::protocol::sql::SubstraitPlan>(GetArena());
    _impl_.plan_ = reinterpret_cast<::arrow::flight::protocol::sql::SubstraitPlan*>(p);
  }
  return _impl_.plan_;
}
inline ::arrow::flight::protocol::sql::SubstraitPlan* ActionCreatePreparedSubstraitPlanRequest::mutable_plan() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::arrow::flight::protocol::sql::SubstraitPlan* _msg = _internal_mutable_plan();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.ActionCreatePreparedSubstraitPlanRequest.plan)
  return _msg;
}
inline void ActionCreatePreparedSubstraitPlanRequest::set_allocated_plan(::arrow::flight::protocol::sql::SubstraitPlan* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.plan_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.plan_ = reinterpret_cast<::arrow::flight::protocol::sql::SubstraitPlan*>(value);
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.ActionCreatePreparedSubstraitPlanRequest.plan)
}

// optional bytes transaction_id = 2;
inline bool ActionCreatePreparedSubstraitPlanRequest::has_transaction_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ActionCreatePreparedSubstraitPlanRequest::clear_transaction_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.transaction_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ActionCreatePreparedSubstraitPlanRequest::transaction_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.ActionCreatePreparedSubstraitPlanRequest.transaction_id)
  return _internal_transaction_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ActionCreatePreparedSubstraitPlanRequest::set_transaction_id(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.transaction_id_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.ActionCreatePreparedSubstraitPlanRequest.transaction_id)
}
inline std::string* ActionCreatePreparedSubstraitPlanRequest::mutable_transaction_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_transaction_id();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.ActionCreatePreparedSubstraitPlanRequest.transaction_id)
  return _s;
}
inline const std::string& ActionCreatePreparedSubstraitPlanRequest::_internal_transaction_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.transaction_id_.Get();
}
inline void ActionCreatePreparedSubstraitPlanRequest::_internal_set_transaction_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.transaction_id_.Set(value, GetArena());
}
inline std::string* ActionCreatePreparedSubstraitPlanRequest::_internal_mutable_transaction_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.transaction_id_.Mutable( GetArena());
}
inline std::string* ActionCreatePreparedSubstraitPlanRequest::release_transaction_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.ActionCreatePreparedSubstraitPlanRequest.transaction_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.transaction_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.transaction_id_.Set("", GetArena());
  }
  return released;
}
inline void ActionCreatePreparedSubstraitPlanRequest::set_allocated_transaction_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.transaction_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.transaction_id_.IsDefault()) {
    _impl_.transaction_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.ActionCreatePreparedSubstraitPlanRequest.transaction_id)
}

// -------------------------------------------------------------------

// ActionCreatePreparedStatementResult

// bytes prepared_statement_handle = 1;
inline void ActionCreatePreparedStatementResult::clear_prepared_statement_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prepared_statement_handle_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ActionCreatePreparedStatementResult::prepared_statement_handle() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.ActionCreatePreparedStatementResult.prepared_statement_handle)
  return _internal_prepared_statement_handle();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ActionCreatePreparedStatementResult::set_prepared_statement_handle(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.prepared_statement_handle_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.ActionCreatePreparedStatementResult.prepared_statement_handle)
}
inline std::string* ActionCreatePreparedStatementResult::mutable_prepared_statement_handle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_prepared_statement_handle();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.ActionCreatePreparedStatementResult.prepared_statement_handle)
  return _s;
}
inline const std::string& ActionCreatePreparedStatementResult::_internal_prepared_statement_handle() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.prepared_statement_handle_.Get();
}
inline void ActionCreatePreparedStatementResult::_internal_set_prepared_statement_handle(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.prepared_statement_handle_.Set(value, GetArena());
}
inline std::string* ActionCreatePreparedStatementResult::_internal_mutable_prepared_statement_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.prepared_statement_handle_.Mutable( GetArena());
}
inline std::string* ActionCreatePreparedStatementResult::release_prepared_statement_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.ActionCreatePreparedStatementResult.prepared_statement_handle)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.prepared_statement_handle_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.prepared_statement_handle_.Set("", GetArena());
  }
  return released;
}
inline void ActionCreatePreparedStatementResult::set_allocated_prepared_statement_handle(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.prepared_statement_handle_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.prepared_statement_handle_.IsDefault()) {
    _impl_.prepared_statement_handle_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.ActionCreatePreparedStatementResult.prepared_statement_handle)
}

// bytes dataset_schema = 2;
inline void ActionCreatePreparedStatementResult::clear_dataset_schema() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dataset_schema_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ActionCreatePreparedStatementResult::dataset_schema() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.ActionCreatePreparedStatementResult.dataset_schema)
  return _internal_dataset_schema();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ActionCreatePreparedStatementResult::set_dataset_schema(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.dataset_schema_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.ActionCreatePreparedStatementResult.dataset_schema)
}
inline std::string* ActionCreatePreparedStatementResult::mutable_dataset_schema() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_dataset_schema();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.ActionCreatePreparedStatementResult.dataset_schema)
  return _s;
}
inline const std::string& ActionCreatePreparedStatementResult::_internal_dataset_schema() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dataset_schema_.Get();
}
inline void ActionCreatePreparedStatementResult::_internal_set_dataset_schema(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.dataset_schema_.Set(value, GetArena());
}
inline std::string* ActionCreatePreparedStatementResult::_internal_mutable_dataset_schema() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.dataset_schema_.Mutable( GetArena());
}
inline std::string* ActionCreatePreparedStatementResult::release_dataset_schema() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.ActionCreatePreparedStatementResult.dataset_schema)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.dataset_schema_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.dataset_schema_.Set("", GetArena());
  }
  return released;
}
inline void ActionCreatePreparedStatementResult::set_allocated_dataset_schema(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.dataset_schema_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.dataset_schema_.IsDefault()) {
    _impl_.dataset_schema_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.ActionCreatePreparedStatementResult.dataset_schema)
}

// bytes parameter_schema = 3;
inline void ActionCreatePreparedStatementResult::clear_parameter_schema() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parameter_schema_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ActionCreatePreparedStatementResult::parameter_schema() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.ActionCreatePreparedStatementResult.parameter_schema)
  return _internal_parameter_schema();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ActionCreatePreparedStatementResult::set_parameter_schema(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.parameter_schema_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.ActionCreatePreparedStatementResult.parameter_schema)
}
inline std::string* ActionCreatePreparedStatementResult::mutable_parameter_schema() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_parameter_schema();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.ActionCreatePreparedStatementResult.parameter_schema)
  return _s;
}
inline const std::string& ActionCreatePreparedStatementResult::_internal_parameter_schema() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.parameter_schema_.Get();
}
inline void ActionCreatePreparedStatementResult::_internal_set_parameter_schema(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.parameter_schema_.Set(value, GetArena());
}
inline std::string* ActionCreatePreparedStatementResult::_internal_mutable_parameter_schema() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.parameter_schema_.Mutable( GetArena());
}
inline std::string* ActionCreatePreparedStatementResult::release_parameter_schema() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.ActionCreatePreparedStatementResult.parameter_schema)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.parameter_schema_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.parameter_schema_.Set("", GetArena());
  }
  return released;
}
inline void ActionCreatePreparedStatementResult::set_allocated_parameter_schema(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.parameter_schema_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.parameter_schema_.IsDefault()) {
    _impl_.parameter_schema_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.ActionCreatePreparedStatementResult.parameter_schema)
}

// -------------------------------------------------------------------

// ActionClosePreparedStatementRequest

// bytes prepared_statement_handle = 1;
inline void ActionClosePreparedStatementRequest::clear_prepared_statement_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prepared_statement_handle_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ActionClosePreparedStatementRequest::prepared_statement_handle() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.ActionClosePreparedStatementRequest.prepared_statement_handle)
  return _internal_prepared_statement_handle();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ActionClosePreparedStatementRequest::set_prepared_statement_handle(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.prepared_statement_handle_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.ActionClosePreparedStatementRequest.prepared_statement_handle)
}
inline std::string* ActionClosePreparedStatementRequest::mutable_prepared_statement_handle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_prepared_statement_handle();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.ActionClosePreparedStatementRequest.prepared_statement_handle)
  return _s;
}
inline const std::string& ActionClosePreparedStatementRequest::_internal_prepared_statement_handle() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.prepared_statement_handle_.Get();
}
inline void ActionClosePreparedStatementRequest::_internal_set_prepared_statement_handle(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.prepared_statement_handle_.Set(value, GetArena());
}
inline std::string* ActionClosePreparedStatementRequest::_internal_mutable_prepared_statement_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.prepared_statement_handle_.Mutable( GetArena());
}
inline std::string* ActionClosePreparedStatementRequest::release_prepared_statement_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.ActionClosePreparedStatementRequest.prepared_statement_handle)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.prepared_statement_handle_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.prepared_statement_handle_.Set("", GetArena());
  }
  return released;
}
inline void ActionClosePreparedStatementRequest::set_allocated_prepared_statement_handle(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.prepared_statement_handle_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.prepared_statement_handle_.IsDefault()) {
    _impl_.prepared_statement_handle_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.ActionClosePreparedStatementRequest.prepared_statement_handle)
}

// -------------------------------------------------------------------

// ActionBeginTransactionRequest

// -------------------------------------------------------------------

// ActionBeginSavepointRequest

// bytes transaction_id = 1;
inline void ActionBeginSavepointRequest::clear_transaction_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.transaction_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ActionBeginSavepointRequest::transaction_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.ActionBeginSavepointRequest.transaction_id)
  return _internal_transaction_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ActionBeginSavepointRequest::set_transaction_id(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.transaction_id_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.ActionBeginSavepointRequest.transaction_id)
}
inline std::string* ActionBeginSavepointRequest::mutable_transaction_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_transaction_id();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.ActionBeginSavepointRequest.transaction_id)
  return _s;
}
inline const std::string& ActionBeginSavepointRequest::_internal_transaction_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.transaction_id_.Get();
}
inline void ActionBeginSavepointRequest::_internal_set_transaction_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.transaction_id_.Set(value, GetArena());
}
inline std::string* ActionBeginSavepointRequest::_internal_mutable_transaction_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.transaction_id_.Mutable( GetArena());
}
inline std::string* ActionBeginSavepointRequest::release_transaction_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.ActionBeginSavepointRequest.transaction_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.transaction_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.transaction_id_.Set("", GetArena());
  }
  return released;
}
inline void ActionBeginSavepointRequest::set_allocated_transaction_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.transaction_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.transaction_id_.IsDefault()) {
    _impl_.transaction_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.ActionBeginSavepointRequest.transaction_id)
}

// string name = 2;
inline void ActionBeginSavepointRequest::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ActionBeginSavepointRequest::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.ActionBeginSavepointRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ActionBeginSavepointRequest::set_name(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.ActionBeginSavepointRequest.name)
}
inline std::string* ActionBeginSavepointRequest::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.ActionBeginSavepointRequest.name)
  return _s;
}
inline const std::string& ActionBeginSavepointRequest::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void ActionBeginSavepointRequest::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* ActionBeginSavepointRequest::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* ActionBeginSavepointRequest::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.ActionBeginSavepointRequest.name)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void ActionBeginSavepointRequest::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.ActionBeginSavepointRequest.name)
}

// -------------------------------------------------------------------

// ActionBeginTransactionResult

// bytes transaction_id = 1;
inline void ActionBeginTransactionResult::clear_transaction_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.transaction_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ActionBeginTransactionResult::transaction_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.ActionBeginTransactionResult.transaction_id)
  return _internal_transaction_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ActionBeginTransactionResult::set_transaction_id(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.transaction_id_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.ActionBeginTransactionResult.transaction_id)
}
inline std::string* ActionBeginTransactionResult::mutable_transaction_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_transaction_id();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.ActionBeginTransactionResult.transaction_id)
  return _s;
}
inline const std::string& ActionBeginTransactionResult::_internal_transaction_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.transaction_id_.Get();
}
inline void ActionBeginTransactionResult::_internal_set_transaction_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.transaction_id_.Set(value, GetArena());
}
inline std::string* ActionBeginTransactionResult::_internal_mutable_transaction_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.transaction_id_.Mutable( GetArena());
}
inline std::string* ActionBeginTransactionResult::release_transaction_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.ActionBeginTransactionResult.transaction_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.transaction_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.transaction_id_.Set("", GetArena());
  }
  return released;
}
inline void ActionBeginTransactionResult::set_allocated_transaction_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.transaction_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.transaction_id_.IsDefault()) {
    _impl_.transaction_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.ActionBeginTransactionResult.transaction_id)
}

// -------------------------------------------------------------------

// ActionBeginSavepointResult

// bytes savepoint_id = 1;
inline void ActionBeginSavepointResult::clear_savepoint_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.savepoint_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ActionBeginSavepointResult::savepoint_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.ActionBeginSavepointResult.savepoint_id)
  return _internal_savepoint_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ActionBeginSavepointResult::set_savepoint_id(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.savepoint_id_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.ActionBeginSavepointResult.savepoint_id)
}
inline std::string* ActionBeginSavepointResult::mutable_savepoint_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_savepoint_id();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.ActionBeginSavepointResult.savepoint_id)
  return _s;
}
inline const std::string& ActionBeginSavepointResult::_internal_savepoint_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.savepoint_id_.Get();
}
inline void ActionBeginSavepointResult::_internal_set_savepoint_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.savepoint_id_.Set(value, GetArena());
}
inline std::string* ActionBeginSavepointResult::_internal_mutable_savepoint_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.savepoint_id_.Mutable( GetArena());
}
inline std::string* ActionBeginSavepointResult::release_savepoint_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.ActionBeginSavepointResult.savepoint_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.savepoint_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.savepoint_id_.Set("", GetArena());
  }
  return released;
}
inline void ActionBeginSavepointResult::set_allocated_savepoint_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.savepoint_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.savepoint_id_.IsDefault()) {
    _impl_.savepoint_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.ActionBeginSavepointResult.savepoint_id)
}

// -------------------------------------------------------------------

// ActionEndTransactionRequest

// bytes transaction_id = 1;
inline void ActionEndTransactionRequest::clear_transaction_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.transaction_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ActionEndTransactionRequest::transaction_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.ActionEndTransactionRequest.transaction_id)
  return _internal_transaction_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ActionEndTransactionRequest::set_transaction_id(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.transaction_id_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.ActionEndTransactionRequest.transaction_id)
}
inline std::string* ActionEndTransactionRequest::mutable_transaction_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_transaction_id();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.ActionEndTransactionRequest.transaction_id)
  return _s;
}
inline const std::string& ActionEndTransactionRequest::_internal_transaction_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.transaction_id_.Get();
}
inline void ActionEndTransactionRequest::_internal_set_transaction_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.transaction_id_.Set(value, GetArena());
}
inline std::string* ActionEndTransactionRequest::_internal_mutable_transaction_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.transaction_id_.Mutable( GetArena());
}
inline std::string* ActionEndTransactionRequest::release_transaction_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.ActionEndTransactionRequest.transaction_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.transaction_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.transaction_id_.Set("", GetArena());
  }
  return released;
}
inline void ActionEndTransactionRequest::set_allocated_transaction_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.transaction_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.transaction_id_.IsDefault()) {
    _impl_.transaction_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.ActionEndTransactionRequest.transaction_id)
}

// .arrow.flight.protocol.sql.ActionEndTransactionRequest.EndTransaction action = 2;
inline void ActionEndTransactionRequest::clear_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::arrow::flight::protocol::sql::ActionEndTransactionRequest_EndTransaction ActionEndTransactionRequest::action() const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.ActionEndTransactionRequest.action)
  return _internal_action();
}
inline void ActionEndTransactionRequest::set_action(::arrow::flight::protocol::sql::ActionEndTransactionRequest_EndTransaction value) {
  _internal_set_action(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.ActionEndTransactionRequest.action)
}
inline ::arrow::flight::protocol::sql::ActionEndTransactionRequest_EndTransaction ActionEndTransactionRequest::_internal_action() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::arrow::flight::protocol::sql::ActionEndTransactionRequest_EndTransaction>(_impl_.action_);
}
inline void ActionEndTransactionRequest::_internal_set_action(::arrow::flight::protocol::sql::ActionEndTransactionRequest_EndTransaction value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_ = value;
}

// -------------------------------------------------------------------

// ActionEndSavepointRequest

// bytes savepoint_id = 1;
inline void ActionEndSavepointRequest::clear_savepoint_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.savepoint_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ActionEndSavepointRequest::savepoint_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.ActionEndSavepointRequest.savepoint_id)
  return _internal_savepoint_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ActionEndSavepointRequest::set_savepoint_id(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.savepoint_id_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.ActionEndSavepointRequest.savepoint_id)
}
inline std::string* ActionEndSavepointRequest::mutable_savepoint_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_savepoint_id();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.ActionEndSavepointRequest.savepoint_id)
  return _s;
}
inline const std::string& ActionEndSavepointRequest::_internal_savepoint_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.savepoint_id_.Get();
}
inline void ActionEndSavepointRequest::_internal_set_savepoint_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.savepoint_id_.Set(value, GetArena());
}
inline std::string* ActionEndSavepointRequest::_internal_mutable_savepoint_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.savepoint_id_.Mutable( GetArena());
}
inline std::string* ActionEndSavepointRequest::release_savepoint_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.ActionEndSavepointRequest.savepoint_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.savepoint_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.savepoint_id_.Set("", GetArena());
  }
  return released;
}
inline void ActionEndSavepointRequest::set_allocated_savepoint_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.savepoint_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.savepoint_id_.IsDefault()) {
    _impl_.savepoint_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.ActionEndSavepointRequest.savepoint_id)
}

// .arrow.flight.protocol.sql.ActionEndSavepointRequest.EndSavepoint action = 2;
inline void ActionEndSavepointRequest::clear_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::arrow::flight::protocol::sql::ActionEndSavepointRequest_EndSavepoint ActionEndSavepointRequest::action() const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.ActionEndSavepointRequest.action)
  return _internal_action();
}
inline void ActionEndSavepointRequest::set_action(::arrow::flight::protocol::sql::ActionEndSavepointRequest_EndSavepoint value) {
  _internal_set_action(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.ActionEndSavepointRequest.action)
}
inline ::arrow::flight::protocol::sql::ActionEndSavepointRequest_EndSavepoint ActionEndSavepointRequest::_internal_action() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::arrow::flight::protocol::sql::ActionEndSavepointRequest_EndSavepoint>(_impl_.action_);
}
inline void ActionEndSavepointRequest::_internal_set_action(::arrow::flight::protocol::sql::ActionEndSavepointRequest_EndSavepoint value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_ = value;
}

// -------------------------------------------------------------------

// CommandStatementQuery

// string query = 1;
inline void CommandStatementQuery::clear_query() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.query_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandStatementQuery::query() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.CommandStatementQuery.query)
  return _internal_query();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CommandStatementQuery::set_query(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.query_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.CommandStatementQuery.query)
}
inline std::string* CommandStatementQuery::mutable_query() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_query();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.CommandStatementQuery.query)
  return _s;
}
inline const std::string& CommandStatementQuery::_internal_query() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.query_.Get();
}
inline void CommandStatementQuery::_internal_set_query(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.query_.Set(value, GetArena());
}
inline std::string* CommandStatementQuery::_internal_mutable_query() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.query_.Mutable( GetArena());
}
inline std::string* CommandStatementQuery::release_query() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.CommandStatementQuery.query)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.query_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.query_.Set("", GetArena());
  }
  return released;
}
inline void CommandStatementQuery::set_allocated_query(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.query_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.query_.IsDefault()) {
    _impl_.query_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.CommandStatementQuery.query)
}

// optional bytes transaction_id = 2;
inline bool CommandStatementQuery::has_transaction_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandStatementQuery::clear_transaction_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.transaction_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommandStatementQuery::transaction_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.CommandStatementQuery.transaction_id)
  return _internal_transaction_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CommandStatementQuery::set_transaction_id(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.transaction_id_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.CommandStatementQuery.transaction_id)
}
inline std::string* CommandStatementQuery::mutable_transaction_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_transaction_id();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.CommandStatementQuery.transaction_id)
  return _s;
}
inline const std::string& CommandStatementQuery::_internal_transaction_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.transaction_id_.Get();
}
inline void CommandStatementQuery::_internal_set_transaction_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.transaction_id_.Set(value, GetArena());
}
inline std::string* CommandStatementQuery::_internal_mutable_transaction_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.transaction_id_.Mutable( GetArena());
}
inline std::string* CommandStatementQuery::release_transaction_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.CommandStatementQuery.transaction_id)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.transaction_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.transaction_id_.Set("", GetArena());
  }
  return released;
}
inline void CommandStatementQuery::set_allocated_transaction_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.transaction_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.transaction_id_.IsDefault()) {
    _impl_.transaction_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.CommandStatementQuery.transaction_id)
}

// -------------------------------------------------------------------

// CommandStatementSubstraitPlan

// .arrow.flight.protocol.sql.SubstraitPlan plan = 1;
inline bool CommandStatementSubstraitPlan::has_plan() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.plan_ != nullptr);
  return value;
}
inline void CommandStatementSubstraitPlan::clear_plan() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.plan_ != nullptr) _impl_.plan_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::arrow::flight::protocol::sql::SubstraitPlan& CommandStatementSubstraitPlan::_internal_plan() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::arrow::flight::protocol::sql::SubstraitPlan* p = _impl_.plan_;
  return p != nullptr ? *p : reinterpret_cast<const ::arrow::flight::protocol::sql::SubstraitPlan&>(::arrow::flight::protocol::sql::_SubstraitPlan_default_instance_);
}
inline const ::arrow::flight::protocol::sql::SubstraitPlan& CommandStatementSubstraitPlan::plan() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.CommandStatementSubstraitPlan.plan)
  return _internal_plan();
}
inline void CommandStatementSubstraitPlan::unsafe_arena_set_allocated_plan(::arrow::flight::protocol::sql::SubstraitPlan* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.plan_);
  }
  _impl_.plan_ = reinterpret_cast<::arrow::flight::protocol::sql::SubstraitPlan*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:arrow.flight.protocol.sql.CommandStatementSubstraitPlan.plan)
}
inline ::arrow::flight::protocol::sql::SubstraitPlan* CommandStatementSubstraitPlan::release_plan() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::arrow::flight::protocol::sql::SubstraitPlan* released = _impl_.plan_;
  _impl_.plan_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::arrow::flight::protocol::sql::SubstraitPlan* CommandStatementSubstraitPlan::unsafe_arena_release_plan() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.CommandStatementSubstraitPlan.plan)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::arrow::flight::protocol::sql::SubstraitPlan* temp = _impl_.plan_;
  _impl_.plan_ = nullptr;
  return temp;
}
inline ::arrow::flight::protocol::sql::SubstraitPlan* CommandStatementSubstraitPlan::_internal_mutable_plan() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.plan_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::arrow::flight::protocol::sql::SubstraitPlan>(GetArena());
    _impl_.plan_ = reinterpret_cast<::arrow::flight::protocol::sql::SubstraitPlan*>(p);
  }
  return _impl_.plan_;
}
inline ::arrow::flight::protocol::sql::SubstraitPlan* CommandStatementSubstraitPlan::mutable_plan() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::arrow::flight::protocol::sql::SubstraitPlan* _msg = _internal_mutable_plan();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.CommandStatementSubstraitPlan.plan)
  return _msg;
}
inline void CommandStatementSubstraitPlan::set_allocated_plan(::arrow::flight::protocol::sql::SubstraitPlan* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.plan_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.plan_ = reinterpret_cast<::arrow::flight::protocol::sql::SubstraitPlan*>(value);
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.CommandStatementSubstraitPlan.plan)
}

// optional bytes transaction_id = 2;
inline bool CommandStatementSubstraitPlan::has_transaction_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CommandStatementSubstraitPlan::clear_transaction_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.transaction_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandStatementSubstraitPlan::transaction_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.CommandStatementSubstraitPlan.transaction_id)
  return _internal_transaction_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CommandStatementSubstraitPlan::set_transaction_id(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.transaction_id_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.CommandStatementSubstraitPlan.transaction_id)
}
inline std::string* CommandStatementSubstraitPlan::mutable_transaction_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_transaction_id();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.CommandStatementSubstraitPlan.transaction_id)
  return _s;
}
inline const std::string& CommandStatementSubstraitPlan::_internal_transaction_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.transaction_id_.Get();
}
inline void CommandStatementSubstraitPlan::_internal_set_transaction_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.transaction_id_.Set(value, GetArena());
}
inline std::string* CommandStatementSubstraitPlan::_internal_mutable_transaction_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.transaction_id_.Mutable( GetArena());
}
inline std::string* CommandStatementSubstraitPlan::release_transaction_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.CommandStatementSubstraitPlan.transaction_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.transaction_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.transaction_id_.Set("", GetArena());
  }
  return released;
}
inline void CommandStatementSubstraitPlan::set_allocated_transaction_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.transaction_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.transaction_id_.IsDefault()) {
    _impl_.transaction_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.CommandStatementSubstraitPlan.transaction_id)
}

// -------------------------------------------------------------------

// TicketStatementQuery

// bytes statement_handle = 1;
inline void TicketStatementQuery::clear_statement_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.statement_handle_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TicketStatementQuery::statement_handle() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.TicketStatementQuery.statement_handle)
  return _internal_statement_handle();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void TicketStatementQuery::set_statement_handle(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.statement_handle_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.TicketStatementQuery.statement_handle)
}
inline std::string* TicketStatementQuery::mutable_statement_handle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_statement_handle();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.TicketStatementQuery.statement_handle)
  return _s;
}
inline const std::string& TicketStatementQuery::_internal_statement_handle() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.statement_handle_.Get();
}
inline void TicketStatementQuery::_internal_set_statement_handle(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.statement_handle_.Set(value, GetArena());
}
inline std::string* TicketStatementQuery::_internal_mutable_statement_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.statement_handle_.Mutable( GetArena());
}
inline std::string* TicketStatementQuery::release_statement_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.TicketStatementQuery.statement_handle)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.statement_handle_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.statement_handle_.Set("", GetArena());
  }
  return released;
}
inline void TicketStatementQuery::set_allocated_statement_handle(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.statement_handle_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.statement_handle_.IsDefault()) {
    _impl_.statement_handle_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.TicketStatementQuery.statement_handle)
}

// -------------------------------------------------------------------

// CommandPreparedStatementQuery

// bytes prepared_statement_handle = 1;
inline void CommandPreparedStatementQuery::clear_prepared_statement_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prepared_statement_handle_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandPreparedStatementQuery::prepared_statement_handle() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.CommandPreparedStatementQuery.prepared_statement_handle)
  return _internal_prepared_statement_handle();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CommandPreparedStatementQuery::set_prepared_statement_handle(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.prepared_statement_handle_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.CommandPreparedStatementQuery.prepared_statement_handle)
}
inline std::string* CommandPreparedStatementQuery::mutable_prepared_statement_handle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_prepared_statement_handle();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.CommandPreparedStatementQuery.prepared_statement_handle)
  return _s;
}
inline const std::string& CommandPreparedStatementQuery::_internal_prepared_statement_handle() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.prepared_statement_handle_.Get();
}
inline void CommandPreparedStatementQuery::_internal_set_prepared_statement_handle(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.prepared_statement_handle_.Set(value, GetArena());
}
inline std::string* CommandPreparedStatementQuery::_internal_mutable_prepared_statement_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.prepared_statement_handle_.Mutable( GetArena());
}
inline std::string* CommandPreparedStatementQuery::release_prepared_statement_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.CommandPreparedStatementQuery.prepared_statement_handle)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.prepared_statement_handle_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.prepared_statement_handle_.Set("", GetArena());
  }
  return released;
}
inline void CommandPreparedStatementQuery::set_allocated_prepared_statement_handle(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.prepared_statement_handle_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.prepared_statement_handle_.IsDefault()) {
    _impl_.prepared_statement_handle_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.CommandPreparedStatementQuery.prepared_statement_handle)
}

// -------------------------------------------------------------------

// CommandStatementUpdate

// string query = 1;
inline void CommandStatementUpdate::clear_query() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.query_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandStatementUpdate::query() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.CommandStatementUpdate.query)
  return _internal_query();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CommandStatementUpdate::set_query(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.query_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.CommandStatementUpdate.query)
}
inline std::string* CommandStatementUpdate::mutable_query() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_query();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.CommandStatementUpdate.query)
  return _s;
}
inline const std::string& CommandStatementUpdate::_internal_query() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.query_.Get();
}
inline void CommandStatementUpdate::_internal_set_query(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.query_.Set(value, GetArena());
}
inline std::string* CommandStatementUpdate::_internal_mutable_query() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.query_.Mutable( GetArena());
}
inline std::string* CommandStatementUpdate::release_query() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.CommandStatementUpdate.query)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.query_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.query_.Set("", GetArena());
  }
  return released;
}
inline void CommandStatementUpdate::set_allocated_query(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.query_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.query_.IsDefault()) {
    _impl_.query_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.CommandStatementUpdate.query)
}

// optional bytes transaction_id = 2;
inline bool CommandStatementUpdate::has_transaction_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandStatementUpdate::clear_transaction_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.transaction_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommandStatementUpdate::transaction_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.CommandStatementUpdate.transaction_id)
  return _internal_transaction_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CommandStatementUpdate::set_transaction_id(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.transaction_id_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.CommandStatementUpdate.transaction_id)
}
inline std::string* CommandStatementUpdate::mutable_transaction_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_transaction_id();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.CommandStatementUpdate.transaction_id)
  return _s;
}
inline const std::string& CommandStatementUpdate::_internal_transaction_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.transaction_id_.Get();
}
inline void CommandStatementUpdate::_internal_set_transaction_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.transaction_id_.Set(value, GetArena());
}
inline std::string* CommandStatementUpdate::_internal_mutable_transaction_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.transaction_id_.Mutable( GetArena());
}
inline std::string* CommandStatementUpdate::release_transaction_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.CommandStatementUpdate.transaction_id)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.transaction_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.transaction_id_.Set("", GetArena());
  }
  return released;
}
inline void CommandStatementUpdate::set_allocated_transaction_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.transaction_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.transaction_id_.IsDefault()) {
    _impl_.transaction_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.CommandStatementUpdate.transaction_id)
}

// -------------------------------------------------------------------

// CommandPreparedStatementUpdate

// bytes prepared_statement_handle = 1;
inline void CommandPreparedStatementUpdate::clear_prepared_statement_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prepared_statement_handle_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandPreparedStatementUpdate::prepared_statement_handle() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.CommandPreparedStatementUpdate.prepared_statement_handle)
  return _internal_prepared_statement_handle();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CommandPreparedStatementUpdate::set_prepared_statement_handle(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.prepared_statement_handle_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.CommandPreparedStatementUpdate.prepared_statement_handle)
}
inline std::string* CommandPreparedStatementUpdate::mutable_prepared_statement_handle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_prepared_statement_handle();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.CommandPreparedStatementUpdate.prepared_statement_handle)
  return _s;
}
inline const std::string& CommandPreparedStatementUpdate::_internal_prepared_statement_handle() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.prepared_statement_handle_.Get();
}
inline void CommandPreparedStatementUpdate::_internal_set_prepared_statement_handle(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.prepared_statement_handle_.Set(value, GetArena());
}
inline std::string* CommandPreparedStatementUpdate::_internal_mutable_prepared_statement_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.prepared_statement_handle_.Mutable( GetArena());
}
inline std::string* CommandPreparedStatementUpdate::release_prepared_statement_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.CommandPreparedStatementUpdate.prepared_statement_handle)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.prepared_statement_handle_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.prepared_statement_handle_.Set("", GetArena());
  }
  return released;
}
inline void CommandPreparedStatementUpdate::set_allocated_prepared_statement_handle(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.prepared_statement_handle_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.prepared_statement_handle_.IsDefault()) {
    _impl_.prepared_statement_handle_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.CommandPreparedStatementUpdate.prepared_statement_handle)
}

// -------------------------------------------------------------------

// CommandStatementIngest_TableDefinitionOptions

// .arrow.flight.protocol.sql.CommandStatementIngest.TableDefinitionOptions.TableNotExistOption if_not_exist = 1;
inline void CommandStatementIngest_TableDefinitionOptions::clear_if_not_exist() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.if_not_exist_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions_TableNotExistOption CommandStatementIngest_TableDefinitionOptions::if_not_exist() const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.CommandStatementIngest.TableDefinitionOptions.if_not_exist)
  return _internal_if_not_exist();
}
inline void CommandStatementIngest_TableDefinitionOptions::set_if_not_exist(::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions_TableNotExistOption value) {
  _internal_set_if_not_exist(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.CommandStatementIngest.TableDefinitionOptions.if_not_exist)
}
inline ::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions_TableNotExistOption CommandStatementIngest_TableDefinitionOptions::_internal_if_not_exist() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions_TableNotExistOption>(_impl_.if_not_exist_);
}
inline void CommandStatementIngest_TableDefinitionOptions::_internal_set_if_not_exist(::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions_TableNotExistOption value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.if_not_exist_ = value;
}

// .arrow.flight.protocol.sql.CommandStatementIngest.TableDefinitionOptions.TableExistsOption if_exists = 2;
inline void CommandStatementIngest_TableDefinitionOptions::clear_if_exists() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.if_exists_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions_TableExistsOption CommandStatementIngest_TableDefinitionOptions::if_exists() const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.CommandStatementIngest.TableDefinitionOptions.if_exists)
  return _internal_if_exists();
}
inline void CommandStatementIngest_TableDefinitionOptions::set_if_exists(::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions_TableExistsOption value) {
  _internal_set_if_exists(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.CommandStatementIngest.TableDefinitionOptions.if_exists)
}
inline ::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions_TableExistsOption CommandStatementIngest_TableDefinitionOptions::_internal_if_exists() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions_TableExistsOption>(_impl_.if_exists_);
}
inline void CommandStatementIngest_TableDefinitionOptions::_internal_set_if_exists(::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions_TableExistsOption value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.if_exists_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CommandStatementIngest

// .arrow.flight.protocol.sql.CommandStatementIngest.TableDefinitionOptions table_definition_options = 1;
inline bool CommandStatementIngest::has_table_definition_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.table_definition_options_ != nullptr);
  return value;
}
inline void CommandStatementIngest::clear_table_definition_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.table_definition_options_ != nullptr) _impl_.table_definition_options_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions& CommandStatementIngest::_internal_table_definition_options() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions* p = _impl_.table_definition_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions&>(::arrow::flight::protocol::sql::_CommandStatementIngest_TableDefinitionOptions_default_instance_);
}
inline const ::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions& CommandStatementIngest::table_definition_options() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.CommandStatementIngest.table_definition_options)
  return _internal_table_definition_options();
}
inline void CommandStatementIngest::unsafe_arena_set_allocated_table_definition_options(::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.table_definition_options_);
  }
  _impl_.table_definition_options_ = reinterpret_cast<::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:arrow.flight.protocol.sql.CommandStatementIngest.table_definition_options)
}
inline ::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions* CommandStatementIngest::release_table_definition_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions* released = _impl_.table_definition_options_;
  _impl_.table_definition_options_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions* CommandStatementIngest::unsafe_arena_release_table_definition_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.CommandStatementIngest.table_definition_options)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions* temp = _impl_.table_definition_options_;
  _impl_.table_definition_options_ = nullptr;
  return temp;
}
inline ::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions* CommandStatementIngest::_internal_mutable_table_definition_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.table_definition_options_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions>(GetArena());
    _impl_.table_definition_options_ = reinterpret_cast<::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions*>(p);
  }
  return _impl_.table_definition_options_;
}
inline ::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions* CommandStatementIngest::mutable_table_definition_options() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions* _msg = _internal_mutable_table_definition_options();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.CommandStatementIngest.table_definition_options)
  return _msg;
}
inline void CommandStatementIngest::set_allocated_table_definition_options(::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.table_definition_options_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.table_definition_options_ = reinterpret_cast<::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions*>(value);
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.CommandStatementIngest.table_definition_options)
}

// string table = 2;
inline void CommandStatementIngest::clear_table() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.table_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandStatementIngest::table() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.CommandStatementIngest.table)
  return _internal_table();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CommandStatementIngest::set_table(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.table_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.CommandStatementIngest.table)
}
inline std::string* CommandStatementIngest::mutable_table() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_table();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.CommandStatementIngest.table)
  return _s;
}
inline const std::string& CommandStatementIngest::_internal_table() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.table_.Get();
}
inline void CommandStatementIngest::_internal_set_table(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.table_.Set(value, GetArena());
}
inline std::string* CommandStatementIngest::_internal_mutable_table() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.table_.Mutable( GetArena());
}
inline std::string* CommandStatementIngest::release_table() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.CommandStatementIngest.table)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.table_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.table_.Set("", GetArena());
  }
  return released;
}
inline void CommandStatementIngest::set_allocated_table(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.table_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.table_.IsDefault()) {
    _impl_.table_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.CommandStatementIngest.table)
}

// optional string schema = 3;
inline bool CommandStatementIngest::has_schema() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CommandStatementIngest::clear_schema() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.schema_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommandStatementIngest::schema() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.CommandStatementIngest.schema)
  return _internal_schema();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CommandStatementIngest::set_schema(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.schema_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.CommandStatementIngest.schema)
}
inline std::string* CommandStatementIngest::mutable_schema() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_schema();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.CommandStatementIngest.schema)
  return _s;
}
inline const std::string& CommandStatementIngest::_internal_schema() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.schema_.Get();
}
inline void CommandStatementIngest::_internal_set_schema(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.schema_.Set(value, GetArena());
}
inline std::string* CommandStatementIngest::_internal_mutable_schema() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.schema_.Mutable( GetArena());
}
inline std::string* CommandStatementIngest::release_schema() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.CommandStatementIngest.schema)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.schema_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.schema_.Set("", GetArena());
  }
  return released;
}
inline void CommandStatementIngest::set_allocated_schema(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.schema_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.schema_.IsDefault()) {
    _impl_.schema_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.CommandStatementIngest.schema)
}

// optional string catalog = 4;
inline bool CommandStatementIngest::has_catalog() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CommandStatementIngest::clear_catalog() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.catalog_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CommandStatementIngest::catalog() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.CommandStatementIngest.catalog)
  return _internal_catalog();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CommandStatementIngest::set_catalog(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.catalog_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.CommandStatementIngest.catalog)
}
inline std::string* CommandStatementIngest::mutable_catalog() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_catalog();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.CommandStatementIngest.catalog)
  return _s;
}
inline const std::string& CommandStatementIngest::_internal_catalog() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.catalog_.Get();
}
inline void CommandStatementIngest::_internal_set_catalog(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.catalog_.Set(value, GetArena());
}
inline std::string* CommandStatementIngest::_internal_mutable_catalog() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.catalog_.Mutable( GetArena());
}
inline std::string* CommandStatementIngest::release_catalog() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.CommandStatementIngest.catalog)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.catalog_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.catalog_.Set("", GetArena());
  }
  return released;
}
inline void CommandStatementIngest::set_allocated_catalog(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.catalog_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.catalog_.IsDefault()) {
    _impl_.catalog_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.CommandStatementIngest.catalog)
}

// bool temporary = 5;
inline void CommandStatementIngest::clear_temporary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.temporary_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool CommandStatementIngest::temporary() const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.CommandStatementIngest.temporary)
  return _internal_temporary();
}
inline void CommandStatementIngest::set_temporary(bool value) {
  _internal_set_temporary(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.CommandStatementIngest.temporary)
}
inline bool CommandStatementIngest::_internal_temporary() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.temporary_;
}
inline void CommandStatementIngest::_internal_set_temporary(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.temporary_ = value;
}

// optional bytes transaction_id = 6;
inline bool CommandStatementIngest::has_transaction_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CommandStatementIngest::clear_transaction_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.transaction_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CommandStatementIngest::transaction_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.CommandStatementIngest.transaction_id)
  return _internal_transaction_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CommandStatementIngest::set_transaction_id(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.transaction_id_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.CommandStatementIngest.transaction_id)
}
inline std::string* CommandStatementIngest::mutable_transaction_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_transaction_id();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.CommandStatementIngest.transaction_id)
  return _s;
}
inline const std::string& CommandStatementIngest::_internal_transaction_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.transaction_id_.Get();
}
inline void CommandStatementIngest::_internal_set_transaction_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.transaction_id_.Set(value, GetArena());
}
inline std::string* CommandStatementIngest::_internal_mutable_transaction_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.transaction_id_.Mutable( GetArena());
}
inline std::string* CommandStatementIngest::release_transaction_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.CommandStatementIngest.transaction_id)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.transaction_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.transaction_id_.Set("", GetArena());
  }
  return released;
}
inline void CommandStatementIngest::set_allocated_transaction_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.transaction_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.transaction_id_.IsDefault()) {
    _impl_.transaction_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.CommandStatementIngest.transaction_id)
}

// map<string, string> options = 1000;
inline int CommandStatementIngest::_internal_options_size() const {
  return _internal_options().size();
}
inline int CommandStatementIngest::options_size() const {
  return _internal_options_size();
}
inline void CommandStatementIngest::clear_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.options_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& CommandStatementIngest::_internal_options() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.options_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& CommandStatementIngest::options() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:arrow.flight.protocol.sql.CommandStatementIngest.options)
  return _internal_options();
}
inline ::google::protobuf::Map<std::string, std::string>* CommandStatementIngest::_internal_mutable_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.options_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* CommandStatementIngest::mutable_options() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:arrow.flight.protocol.sql.CommandStatementIngest.options)
  return _internal_mutable_options();
}

// -------------------------------------------------------------------

// DoPutUpdateResult

// int64 record_count = 1;
inline void DoPutUpdateResult::clear_record_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.record_count_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t DoPutUpdateResult::record_count() const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.DoPutUpdateResult.record_count)
  return _internal_record_count();
}
inline void DoPutUpdateResult::set_record_count(::int64_t value) {
  _internal_set_record_count(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.DoPutUpdateResult.record_count)
}
inline ::int64_t DoPutUpdateResult::_internal_record_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.record_count_;
}
inline void DoPutUpdateResult::_internal_set_record_count(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.record_count_ = value;
}

// -------------------------------------------------------------------

// DoPutPreparedStatementResult

// optional bytes prepared_statement_handle = 1;
inline bool DoPutPreparedStatementResult::has_prepared_statement_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void DoPutPreparedStatementResult::clear_prepared_statement_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prepared_statement_handle_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DoPutPreparedStatementResult::prepared_statement_handle() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.DoPutPreparedStatementResult.prepared_statement_handle)
  return _internal_prepared_statement_handle();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DoPutPreparedStatementResult::set_prepared_statement_handle(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.prepared_statement_handle_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.DoPutPreparedStatementResult.prepared_statement_handle)
}
inline std::string* DoPutPreparedStatementResult::mutable_prepared_statement_handle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_prepared_statement_handle();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.DoPutPreparedStatementResult.prepared_statement_handle)
  return _s;
}
inline const std::string& DoPutPreparedStatementResult::_internal_prepared_statement_handle() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.prepared_statement_handle_.Get();
}
inline void DoPutPreparedStatementResult::_internal_set_prepared_statement_handle(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.prepared_statement_handle_.Set(value, GetArena());
}
inline std::string* DoPutPreparedStatementResult::_internal_mutable_prepared_statement_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.prepared_statement_handle_.Mutable( GetArena());
}
inline std::string* DoPutPreparedStatementResult::release_prepared_statement_handle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.DoPutPreparedStatementResult.prepared_statement_handle)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.prepared_statement_handle_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.prepared_statement_handle_.Set("", GetArena());
  }
  return released;
}
inline void DoPutPreparedStatementResult::set_allocated_prepared_statement_handle(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.prepared_statement_handle_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.prepared_statement_handle_.IsDefault()) {
    _impl_.prepared_statement_handle_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.DoPutPreparedStatementResult.prepared_statement_handle)
}

// -------------------------------------------------------------------

// ActionCancelQueryRequest

// bytes info = 1;
inline void ActionCancelQueryRequest::clear_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.info_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ActionCancelQueryRequest::info() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.ActionCancelQueryRequest.info)
  return _internal_info();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ActionCancelQueryRequest::set_info(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.info_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.ActionCancelQueryRequest.info)
}
inline std::string* ActionCancelQueryRequest::mutable_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.sql.ActionCancelQueryRequest.info)
  return _s;
}
inline const std::string& ActionCancelQueryRequest::_internal_info() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.info_.Get();
}
inline void ActionCancelQueryRequest::_internal_set_info(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.info_.Set(value, GetArena());
}
inline std::string* ActionCancelQueryRequest::_internal_mutable_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.info_.Mutable( GetArena());
}
inline std::string* ActionCancelQueryRequest::release_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.sql.ActionCancelQueryRequest.info)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.info_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.info_.Set("", GetArena());
  }
  return released;
}
inline void ActionCancelQueryRequest::set_allocated_info(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.info_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.info_.IsDefault()) {
    _impl_.info_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.sql.ActionCancelQueryRequest.info)
}

// -------------------------------------------------------------------

// ActionCancelQueryResult

// .arrow.flight.protocol.sql.ActionCancelQueryResult.CancelResult result = 1;
inline void ActionCancelQueryResult::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::arrow::flight::protocol::sql::ActionCancelQueryResult_CancelResult ActionCancelQueryResult::result() const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.sql.ActionCancelQueryResult.result)
  return _internal_result();
}
inline void ActionCancelQueryResult::set_result(::arrow::flight::protocol::sql::ActionCancelQueryResult_CancelResult value) {
  _internal_set_result(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.sql.ActionCancelQueryResult.result)
}
inline ::arrow::flight::protocol::sql::ActionCancelQueryResult_CancelResult ActionCancelQueryResult::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::arrow::flight::protocol::sql::ActionCancelQueryResult_CancelResult>(_impl_.result_);
}
inline void ActionCancelQueryResult::_internal_set_result(::arrow::flight::protocol::sql::ActionCancelQueryResult_CancelResult value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace sql
}  // namespace protocol
}  // namespace flight
}  // namespace arrow


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::arrow::flight::protocol::sql::ActionEndTransactionRequest_EndTransaction> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::arrow::flight::protocol::sql::ActionEndTransactionRequest_EndTransaction>() {
  return ::arrow::flight::protocol::sql::ActionEndTransactionRequest_EndTransaction_descriptor();
}
template <>
struct is_proto_enum<::arrow::flight::protocol::sql::ActionEndSavepointRequest_EndSavepoint> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::arrow::flight::protocol::sql::ActionEndSavepointRequest_EndSavepoint>() {
  return ::arrow::flight::protocol::sql::ActionEndSavepointRequest_EndSavepoint_descriptor();
}
template <>
struct is_proto_enum<::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions_TableNotExistOption> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions_TableNotExistOption>() {
  return ::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions_TableNotExistOption_descriptor();
}
template <>
struct is_proto_enum<::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions_TableExistsOption> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions_TableExistsOption>() {
  return ::arrow::flight::protocol::sql::CommandStatementIngest_TableDefinitionOptions_TableExistsOption_descriptor();
}
template <>
struct is_proto_enum<::arrow::flight::protocol::sql::ActionCancelQueryResult_CancelResult> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::arrow::flight::protocol::sql::ActionCancelQueryResult_CancelResult>() {
  return ::arrow::flight::protocol::sql::ActionCancelQueryResult_CancelResult_descriptor();
}
template <>
struct is_proto_enum<::arrow::flight::protocol::sql::SqlInfo> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::arrow::flight::protocol::sql::SqlInfo>() {
  return ::arrow::flight::protocol::sql::SqlInfo_descriptor();
}
template <>
struct is_proto_enum<::arrow::flight::protocol::sql::SqlSupportedTransaction> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::arrow::flight::protocol::sql::SqlSupportedTransaction>() {
  return ::arrow::flight::protocol::sql::SqlSupportedTransaction_descriptor();
}
template <>
struct is_proto_enum<::arrow::flight::protocol::sql::SqlSupportedCaseSensitivity> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::arrow::flight::protocol::sql::SqlSupportedCaseSensitivity>() {
  return ::arrow::flight::protocol::sql::SqlSupportedCaseSensitivity_descriptor();
}
template <>
struct is_proto_enum<::arrow::flight::protocol::sql::SqlNullOrdering> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::arrow::flight::protocol::sql::SqlNullOrdering>() {
  return ::arrow::flight::protocol::sql::SqlNullOrdering_descriptor();
}
template <>
struct is_proto_enum<::arrow::flight::protocol::sql::SupportedSqlGrammar> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::arrow::flight::protocol::sql::SupportedSqlGrammar>() {
  return ::arrow::flight::protocol::sql::SupportedSqlGrammar_descriptor();
}
template <>
struct is_proto_enum<::arrow::flight::protocol::sql::SupportedAnsi92SqlGrammarLevel> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::arrow::flight::protocol::sql::SupportedAnsi92SqlGrammarLevel>() {
  return ::arrow::flight::protocol::sql::SupportedAnsi92SqlGrammarLevel_descriptor();
}
template <>
struct is_proto_enum<::arrow::flight::protocol::sql::SqlOuterJoinsSupportLevel> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::arrow::flight::protocol::sql::SqlOuterJoinsSupportLevel>() {
  return ::arrow::flight::protocol::sql::SqlOuterJoinsSupportLevel_descriptor();
}
template <>
struct is_proto_enum<::arrow::flight::protocol::sql::SqlSupportedGroupBy> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::arrow::flight::protocol::sql::SqlSupportedGroupBy>() {
  return ::arrow::flight::protocol::sql::SqlSupportedGroupBy_descriptor();
}
template <>
struct is_proto_enum<::arrow::flight::protocol::sql::SqlSupportedElementActions> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::arrow::flight::protocol::sql::SqlSupportedElementActions>() {
  return ::arrow::flight::protocol::sql::SqlSupportedElementActions_descriptor();
}
template <>
struct is_proto_enum<::arrow::flight::protocol::sql::SqlSupportedPositionedCommands> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::arrow::flight::protocol::sql::SqlSupportedPositionedCommands>() {
  return ::arrow::flight::protocol::sql::SqlSupportedPositionedCommands_descriptor();
}
template <>
struct is_proto_enum<::arrow::flight::protocol::sql::SqlSupportedSubqueries> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::arrow::flight::protocol::sql::SqlSupportedSubqueries>() {
  return ::arrow::flight::protocol::sql::SqlSupportedSubqueries_descriptor();
}
template <>
struct is_proto_enum<::arrow::flight::protocol::sql::SqlSupportedUnions> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::arrow::flight::protocol::sql::SqlSupportedUnions>() {
  return ::arrow::flight::protocol::sql::SqlSupportedUnions_descriptor();
}
template <>
struct is_proto_enum<::arrow::flight::protocol::sql::SqlTransactionIsolationLevel> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::arrow::flight::protocol::sql::SqlTransactionIsolationLevel>() {
  return ::arrow::flight::protocol::sql::SqlTransactionIsolationLevel_descriptor();
}
template <>
struct is_proto_enum<::arrow::flight::protocol::sql::SqlSupportedTransactions> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::arrow::flight::protocol::sql::SqlSupportedTransactions>() {
  return ::arrow::flight::protocol::sql::SqlSupportedTransactions_descriptor();
}
template <>
struct is_proto_enum<::arrow::flight::protocol::sql::SqlSupportedResultSetType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::arrow::flight::protocol::sql::SqlSupportedResultSetType>() {
  return ::arrow::flight::protocol::sql::SqlSupportedResultSetType_descriptor();
}
template <>
struct is_proto_enum<::arrow::flight::protocol::sql::SqlSupportedResultSetConcurrency> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::arrow::flight::protocol::sql::SqlSupportedResultSetConcurrency>() {
  return ::arrow::flight::protocol::sql::SqlSupportedResultSetConcurrency_descriptor();
}
template <>
struct is_proto_enum<::arrow::flight::protocol::sql::SqlSupportsConvert> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::arrow::flight::protocol::sql::SqlSupportsConvert>() {
  return ::arrow::flight::protocol::sql::SqlSupportsConvert_descriptor();
}
template <>
struct is_proto_enum<::arrow::flight::protocol::sql::XdbcDataType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::arrow::flight::protocol::sql::XdbcDataType>() {
  return ::arrow::flight::protocol::sql::XdbcDataType_descriptor();
}
template <>
struct is_proto_enum<::arrow::flight::protocol::sql::XdbcDatetimeSubcode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::arrow::flight::protocol::sql::XdbcDatetimeSubcode>() {
  return ::arrow::flight::protocol::sql::XdbcDatetimeSubcode_descriptor();
}
template <>
struct is_proto_enum<::arrow::flight::protocol::sql::Nullable> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::arrow::flight::protocol::sql::Nullable>() {
  return ::arrow::flight::protocol::sql::Nullable_descriptor();
}
template <>
struct is_proto_enum<::arrow::flight::protocol::sql::Searchable> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::arrow::flight::protocol::sql::Searchable>() {
  return ::arrow::flight::protocol::sql::Searchable_descriptor();
}
template <>
struct is_proto_enum<::arrow::flight::protocol::sql::UpdateDeleteRules> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::arrow::flight::protocol::sql::UpdateDeleteRules>() {
  return ::arrow::flight::protocol::sql::UpdateDeleteRules_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // FlightSql_2eproto_2epb_2eh
