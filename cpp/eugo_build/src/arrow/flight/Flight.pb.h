// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: Flight.proto
// Protobuf C++ Version: 5.30.0-dev

#ifndef Flight_2eproto_2epb_2eh
#define Flight_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5030000
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_type_handler.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/timestamp.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_Flight_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_Flight_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_Flight_2eproto;
}  // extern "C"
namespace arrow {
namespace flight {
namespace protocol {
enum CancelStatus : int;
bool CancelStatus_IsValid(int value);
extern const uint32_t CancelStatus_internal_data_[];
enum CloseSessionResult_Status : int;
bool CloseSessionResult_Status_IsValid(int value);
extern const uint32_t CloseSessionResult_Status_internal_data_[];
enum FlightDescriptor_DescriptorType : int;
bool FlightDescriptor_DescriptorType_IsValid(int value);
extern const uint32_t FlightDescriptor_DescriptorType_internal_data_[];
enum SetSessionOptionsResult_ErrorValue : int;
bool SetSessionOptionsResult_ErrorValue_IsValid(int value);
extern const uint32_t SetSessionOptionsResult_ErrorValue_internal_data_[];
class Action;
struct ActionDefaultTypeInternal;
extern ActionDefaultTypeInternal _Action_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Action_class_data_;
class ActionType;
struct ActionTypeDefaultTypeInternal;
extern ActionTypeDefaultTypeInternal _ActionType_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ActionType_class_data_;
class BasicAuth;
struct BasicAuthDefaultTypeInternal;
extern BasicAuthDefaultTypeInternal _BasicAuth_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull BasicAuth_class_data_;
class CancelFlightInfoRequest;
struct CancelFlightInfoRequestDefaultTypeInternal;
extern CancelFlightInfoRequestDefaultTypeInternal _CancelFlightInfoRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CancelFlightInfoRequest_class_data_;
class CancelFlightInfoResult;
struct CancelFlightInfoResultDefaultTypeInternal;
extern CancelFlightInfoResultDefaultTypeInternal _CancelFlightInfoResult_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CancelFlightInfoResult_class_data_;
class CloseSessionRequest;
struct CloseSessionRequestDefaultTypeInternal;
extern CloseSessionRequestDefaultTypeInternal _CloseSessionRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CloseSessionRequest_class_data_;
class CloseSessionResult;
struct CloseSessionResultDefaultTypeInternal;
extern CloseSessionResultDefaultTypeInternal _CloseSessionResult_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CloseSessionResult_class_data_;
class Criteria;
struct CriteriaDefaultTypeInternal;
extern CriteriaDefaultTypeInternal _Criteria_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Criteria_class_data_;
class Empty;
struct EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Empty_class_data_;
class FlightData;
struct FlightDataDefaultTypeInternal;
extern FlightDataDefaultTypeInternal _FlightData_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull FlightData_class_data_;
class FlightDescriptor;
struct FlightDescriptorDefaultTypeInternal;
extern FlightDescriptorDefaultTypeInternal _FlightDescriptor_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull FlightDescriptor_class_data_;
class FlightEndpoint;
struct FlightEndpointDefaultTypeInternal;
extern FlightEndpointDefaultTypeInternal _FlightEndpoint_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull FlightEndpoint_class_data_;
class FlightInfo;
struct FlightInfoDefaultTypeInternal;
extern FlightInfoDefaultTypeInternal _FlightInfo_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull FlightInfo_class_data_;
class GetSessionOptionsRequest;
struct GetSessionOptionsRequestDefaultTypeInternal;
extern GetSessionOptionsRequestDefaultTypeInternal _GetSessionOptionsRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GetSessionOptionsRequest_class_data_;
class GetSessionOptionsResult;
struct GetSessionOptionsResultDefaultTypeInternal;
extern GetSessionOptionsResultDefaultTypeInternal _GetSessionOptionsResult_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GetSessionOptionsResult_class_data_;
class GetSessionOptionsResult_SessionOptionsEntry_DoNotUse;
struct GetSessionOptionsResult_SessionOptionsEntry_DoNotUseDefaultTypeInternal;
extern GetSessionOptionsResult_SessionOptionsEntry_DoNotUseDefaultTypeInternal _GetSessionOptionsResult_SessionOptionsEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GetSessionOptionsResult_SessionOptionsEntry_DoNotUse_class_data_;
class HandshakeRequest;
struct HandshakeRequestDefaultTypeInternal;
extern HandshakeRequestDefaultTypeInternal _HandshakeRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull HandshakeRequest_class_data_;
class HandshakeResponse;
struct HandshakeResponseDefaultTypeInternal;
extern HandshakeResponseDefaultTypeInternal _HandshakeResponse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull HandshakeResponse_class_data_;
class Location;
struct LocationDefaultTypeInternal;
extern LocationDefaultTypeInternal _Location_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Location_class_data_;
class PollInfo;
struct PollInfoDefaultTypeInternal;
extern PollInfoDefaultTypeInternal _PollInfo_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PollInfo_class_data_;
class PutResult;
struct PutResultDefaultTypeInternal;
extern PutResultDefaultTypeInternal _PutResult_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PutResult_class_data_;
class RenewFlightEndpointRequest;
struct RenewFlightEndpointRequestDefaultTypeInternal;
extern RenewFlightEndpointRequestDefaultTypeInternal _RenewFlightEndpointRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RenewFlightEndpointRequest_class_data_;
class Result;
struct ResultDefaultTypeInternal;
extern ResultDefaultTypeInternal _Result_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Result_class_data_;
class SchemaResult;
struct SchemaResultDefaultTypeInternal;
extern SchemaResultDefaultTypeInternal _SchemaResult_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SchemaResult_class_data_;
class SessionOptionValue;
struct SessionOptionValueDefaultTypeInternal;
extern SessionOptionValueDefaultTypeInternal _SessionOptionValue_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SessionOptionValue_class_data_;
class SessionOptionValue_StringListValue;
struct SessionOptionValue_StringListValueDefaultTypeInternal;
extern SessionOptionValue_StringListValueDefaultTypeInternal _SessionOptionValue_StringListValue_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SessionOptionValue_StringListValue_class_data_;
class SetSessionOptionsRequest;
struct SetSessionOptionsRequestDefaultTypeInternal;
extern SetSessionOptionsRequestDefaultTypeInternal _SetSessionOptionsRequest_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SetSessionOptionsRequest_class_data_;
class SetSessionOptionsRequest_SessionOptionsEntry_DoNotUse;
struct SetSessionOptionsRequest_SessionOptionsEntry_DoNotUseDefaultTypeInternal;
extern SetSessionOptionsRequest_SessionOptionsEntry_DoNotUseDefaultTypeInternal _SetSessionOptionsRequest_SessionOptionsEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SetSessionOptionsRequest_SessionOptionsEntry_DoNotUse_class_data_;
class SetSessionOptionsResult;
struct SetSessionOptionsResultDefaultTypeInternal;
extern SetSessionOptionsResultDefaultTypeInternal _SetSessionOptionsResult_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SetSessionOptionsResult_class_data_;
class SetSessionOptionsResult_Error;
struct SetSessionOptionsResult_ErrorDefaultTypeInternal;
extern SetSessionOptionsResult_ErrorDefaultTypeInternal _SetSessionOptionsResult_Error_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SetSessionOptionsResult_Error_class_data_;
class SetSessionOptionsResult_ErrorsEntry_DoNotUse;
struct SetSessionOptionsResult_ErrorsEntry_DoNotUseDefaultTypeInternal;
extern SetSessionOptionsResult_ErrorsEntry_DoNotUseDefaultTypeInternal _SetSessionOptionsResult_ErrorsEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SetSessionOptionsResult_ErrorsEntry_DoNotUse_class_data_;
class Ticket;
struct TicketDefaultTypeInternal;
extern TicketDefaultTypeInternal _Ticket_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Ticket_class_data_;
}  // namespace protocol
}  // namespace flight
}  // namespace arrow
namespace google {
namespace protobuf {
template <>
internal::EnumTraitsT<::arrow::flight::protocol::CancelStatus_internal_data_>
    internal::EnumTraitsImpl::value<::arrow::flight::protocol::CancelStatus>;
template <>
internal::EnumTraitsT<::arrow::flight::protocol::CloseSessionResult_Status_internal_data_>
    internal::EnumTraitsImpl::value<::arrow::flight::protocol::CloseSessionResult_Status>;
template <>
internal::EnumTraitsT<::arrow::flight::protocol::FlightDescriptor_DescriptorType_internal_data_>
    internal::EnumTraitsImpl::value<::arrow::flight::protocol::FlightDescriptor_DescriptorType>;
template <>
internal::EnumTraitsT<::arrow::flight::protocol::SetSessionOptionsResult_ErrorValue_internal_data_>
    internal::EnumTraitsImpl::value<::arrow::flight::protocol::SetSessionOptionsResult_ErrorValue>;
}  // namespace protobuf
}  // namespace google

namespace arrow {
namespace flight {
namespace protocol {
enum FlightDescriptor_DescriptorType : int {
  FlightDescriptor_DescriptorType_UNKNOWN = 0,
  FlightDescriptor_DescriptorType_PATH = 1,
  FlightDescriptor_DescriptorType_CMD = 2,
  FlightDescriptor_DescriptorType_FlightDescriptor_DescriptorType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  FlightDescriptor_DescriptorType_FlightDescriptor_DescriptorType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool FlightDescriptor_DescriptorType_IsValid(int value);
extern const uint32_t FlightDescriptor_DescriptorType_internal_data_[];
inline constexpr FlightDescriptor_DescriptorType FlightDescriptor_DescriptorType_DescriptorType_MIN =
    static_cast<FlightDescriptor_DescriptorType>(0);
inline constexpr FlightDescriptor_DescriptorType FlightDescriptor_DescriptorType_DescriptorType_MAX =
    static_cast<FlightDescriptor_DescriptorType>(2);
inline constexpr int FlightDescriptor_DescriptorType_DescriptorType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
FlightDescriptor_DescriptorType_descriptor();
template <typename T>
const std::string& FlightDescriptor_DescriptorType_Name(T value) {
  static_assert(std::is_same<T, FlightDescriptor_DescriptorType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DescriptorType_Name().");
  return FlightDescriptor_DescriptorType_Name(static_cast<FlightDescriptor_DescriptorType>(value));
}
template <>
inline const std::string& FlightDescriptor_DescriptorType_Name(FlightDescriptor_DescriptorType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<FlightDescriptor_DescriptorType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool FlightDescriptor_DescriptorType_Parse(absl::string_view name, FlightDescriptor_DescriptorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FlightDescriptor_DescriptorType>(
      FlightDescriptor_DescriptorType_descriptor(), name, value);
}
enum SetSessionOptionsResult_ErrorValue : int {
  SetSessionOptionsResult_ErrorValue_UNSPECIFIED = 0,
  SetSessionOptionsResult_ErrorValue_INVALID_NAME = 1,
  SetSessionOptionsResult_ErrorValue_INVALID_VALUE = 2,
  SetSessionOptionsResult_ErrorValue_ERROR = 3,
  SetSessionOptionsResult_ErrorValue_SetSessionOptionsResult_ErrorValue_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SetSessionOptionsResult_ErrorValue_SetSessionOptionsResult_ErrorValue_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool SetSessionOptionsResult_ErrorValue_IsValid(int value);
extern const uint32_t SetSessionOptionsResult_ErrorValue_internal_data_[];
inline constexpr SetSessionOptionsResult_ErrorValue SetSessionOptionsResult_ErrorValue_ErrorValue_MIN =
    static_cast<SetSessionOptionsResult_ErrorValue>(0);
inline constexpr SetSessionOptionsResult_ErrorValue SetSessionOptionsResult_ErrorValue_ErrorValue_MAX =
    static_cast<SetSessionOptionsResult_ErrorValue>(3);
inline constexpr int SetSessionOptionsResult_ErrorValue_ErrorValue_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
SetSessionOptionsResult_ErrorValue_descriptor();
template <typename T>
const std::string& SetSessionOptionsResult_ErrorValue_Name(T value) {
  static_assert(std::is_same<T, SetSessionOptionsResult_ErrorValue>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ErrorValue_Name().");
  return SetSessionOptionsResult_ErrorValue_Name(static_cast<SetSessionOptionsResult_ErrorValue>(value));
}
template <>
inline const std::string& SetSessionOptionsResult_ErrorValue_Name(SetSessionOptionsResult_ErrorValue value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SetSessionOptionsResult_ErrorValue_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool SetSessionOptionsResult_ErrorValue_Parse(absl::string_view name, SetSessionOptionsResult_ErrorValue* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SetSessionOptionsResult_ErrorValue>(
      SetSessionOptionsResult_ErrorValue_descriptor(), name, value);
}
enum CloseSessionResult_Status : int {
  CloseSessionResult_Status_UNSPECIFIED = 0,
  CloseSessionResult_Status_CLOSED = 1,
  CloseSessionResult_Status_CLOSING = 2,
  CloseSessionResult_Status_NOT_CLOSEABLE = 3,
  CloseSessionResult_Status_CloseSessionResult_Status_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  CloseSessionResult_Status_CloseSessionResult_Status_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool CloseSessionResult_Status_IsValid(int value);
extern const uint32_t CloseSessionResult_Status_internal_data_[];
inline constexpr CloseSessionResult_Status CloseSessionResult_Status_Status_MIN =
    static_cast<CloseSessionResult_Status>(0);
inline constexpr CloseSessionResult_Status CloseSessionResult_Status_Status_MAX =
    static_cast<CloseSessionResult_Status>(3);
inline constexpr int CloseSessionResult_Status_Status_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
CloseSessionResult_Status_descriptor();
template <typename T>
const std::string& CloseSessionResult_Status_Name(T value) {
  static_assert(std::is_same<T, CloseSessionResult_Status>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Status_Name().");
  return CloseSessionResult_Status_Name(static_cast<CloseSessionResult_Status>(value));
}
template <>
inline const std::string& CloseSessionResult_Status_Name(CloseSessionResult_Status value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CloseSessionResult_Status_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool CloseSessionResult_Status_Parse(absl::string_view name, CloseSessionResult_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CloseSessionResult_Status>(
      CloseSessionResult_Status_descriptor(), name, value);
}
enum CancelStatus : int {
  CANCEL_STATUS_UNSPECIFIED = 0,
  CANCEL_STATUS_CANCELLED = 1,
  CANCEL_STATUS_CANCELLING = 2,
  CANCEL_STATUS_NOT_CANCELLABLE = 3,
  CancelStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  CancelStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool CancelStatus_IsValid(int value);
extern const uint32_t CancelStatus_internal_data_[];
inline constexpr CancelStatus CancelStatus_MIN =
    static_cast<CancelStatus>(0);
inline constexpr CancelStatus CancelStatus_MAX =
    static_cast<CancelStatus>(3);
inline constexpr int CancelStatus_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
CancelStatus_descriptor();
template <typename T>
const std::string& CancelStatus_Name(T value) {
  static_assert(std::is_same<T, CancelStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CancelStatus_Name().");
  return CancelStatus_Name(static_cast<CancelStatus>(value));
}
template <>
inline const std::string& CancelStatus_Name(CancelStatus value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CancelStatus_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool CancelStatus_Parse(absl::string_view name, CancelStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CancelStatus>(
      CancelStatus_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Ticket final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.Ticket) */ {
 public:
  inline Ticket() : Ticket(nullptr) {}
  ~Ticket() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Ticket* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Ticket));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Ticket(
      ::google::protobuf::internal::ConstantInitialized);

  inline Ticket(const Ticket& from) : Ticket(nullptr, from) {}
  inline Ticket(Ticket&& from) noexcept
      : Ticket(nullptr, std::move(from)) {}
  inline Ticket& operator=(const Ticket& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ticket& operator=(Ticket&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ticket& default_instance() {
    return *reinterpret_cast<const Ticket*>(
        &_Ticket_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(Ticket& a, Ticket& b) { a.Swap(&b); }
  inline void Swap(Ticket* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ticket* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ticket* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Ticket>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Ticket& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Ticket& from) { Ticket::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Ticket* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.Ticket"; }

 protected:
  explicit Ticket(::google::protobuf::Arena* arena);
  Ticket(::google::protobuf::Arena* arena, const Ticket& from);
  Ticket(::google::protobuf::Arena* arena, Ticket&& from) noexcept
      : Ticket(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTicketFieldNumber = 1,
  };
  // bytes ticket = 1;
  void clear_ticket() ;
  const std::string& ticket() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ticket(Arg_&& arg, Args_... args);
  std::string* mutable_ticket();
  [[nodiscard]] std::string* release_ticket();
  void set_allocated_ticket(std::string* value);

  private:
  const std::string& _internal_ticket() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_ticket(const std::string& value);
  std::string* _internal_mutable_ticket();

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.Ticket)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Ticket& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr ticket_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Flight_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Ticket_class_data_;
// -------------------------------------------------------------------

class SetSessionOptionsResult_Error final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.SetSessionOptionsResult.Error) */ {
 public:
  inline SetSessionOptionsResult_Error() : SetSessionOptionsResult_Error(nullptr) {}
  ~SetSessionOptionsResult_Error() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SetSessionOptionsResult_Error* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SetSessionOptionsResult_Error));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SetSessionOptionsResult_Error(
      ::google::protobuf::internal::ConstantInitialized);

  inline SetSessionOptionsResult_Error(const SetSessionOptionsResult_Error& from) : SetSessionOptionsResult_Error(nullptr, from) {}
  inline SetSessionOptionsResult_Error(SetSessionOptionsResult_Error&& from) noexcept
      : SetSessionOptionsResult_Error(nullptr, std::move(from)) {}
  inline SetSessionOptionsResult_Error& operator=(const SetSessionOptionsResult_Error& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetSessionOptionsResult_Error& operator=(SetSessionOptionsResult_Error&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetSessionOptionsResult_Error& default_instance() {
    return *reinterpret_cast<const SetSessionOptionsResult_Error*>(
        &_SetSessionOptionsResult_Error_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(SetSessionOptionsResult_Error& a, SetSessionOptionsResult_Error& b) { a.Swap(&b); }
  inline void Swap(SetSessionOptionsResult_Error* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetSessionOptionsResult_Error* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetSessionOptionsResult_Error* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SetSessionOptionsResult_Error>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SetSessionOptionsResult_Error& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SetSessionOptionsResult_Error& from) { SetSessionOptionsResult_Error::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SetSessionOptionsResult_Error* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.SetSessionOptionsResult.Error"; }

 protected:
  explicit SetSessionOptionsResult_Error(::google::protobuf::Arena* arena);
  SetSessionOptionsResult_Error(::google::protobuf::Arena* arena, const SetSessionOptionsResult_Error& from);
  SetSessionOptionsResult_Error(::google::protobuf::Arena* arena, SetSessionOptionsResult_Error&& from) noexcept
      : SetSessionOptionsResult_Error(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValueFieldNumber = 1,
  };
  // .arrow.flight.protocol.SetSessionOptionsResult.ErrorValue value = 1;
  void clear_value() ;
  ::arrow::flight::protocol::SetSessionOptionsResult_ErrorValue value() const;
  void set_value(::arrow::flight::protocol::SetSessionOptionsResult_ErrorValue value);

  private:
  ::arrow::flight::protocol::SetSessionOptionsResult_ErrorValue _internal_value() const;
  void _internal_set_value(::arrow::flight::protocol::SetSessionOptionsResult_ErrorValue value);

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.SetSessionOptionsResult.Error)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SetSessionOptionsResult_Error& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int value_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Flight_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SetSessionOptionsResult_Error_class_data_;
// -------------------------------------------------------------------

class SessionOptionValue_StringListValue final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.SessionOptionValue.StringListValue) */ {
 public:
  inline SessionOptionValue_StringListValue() : SessionOptionValue_StringListValue(nullptr) {}
  ~SessionOptionValue_StringListValue() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SessionOptionValue_StringListValue* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SessionOptionValue_StringListValue));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SessionOptionValue_StringListValue(
      ::google::protobuf::internal::ConstantInitialized);

  inline SessionOptionValue_StringListValue(const SessionOptionValue_StringListValue& from) : SessionOptionValue_StringListValue(nullptr, from) {}
  inline SessionOptionValue_StringListValue(SessionOptionValue_StringListValue&& from) noexcept
      : SessionOptionValue_StringListValue(nullptr, std::move(from)) {}
  inline SessionOptionValue_StringListValue& operator=(const SessionOptionValue_StringListValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionOptionValue_StringListValue& operator=(SessionOptionValue_StringListValue&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SessionOptionValue_StringListValue& default_instance() {
    return *reinterpret_cast<const SessionOptionValue_StringListValue*>(
        &_SessionOptionValue_StringListValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(SessionOptionValue_StringListValue& a, SessionOptionValue_StringListValue& b) { a.Swap(&b); }
  inline void Swap(SessionOptionValue_StringListValue* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionOptionValue_StringListValue* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionOptionValue_StringListValue* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SessionOptionValue_StringListValue>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SessionOptionValue_StringListValue& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SessionOptionValue_StringListValue& from) { SessionOptionValue_StringListValue::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SessionOptionValue_StringListValue* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.SessionOptionValue.StringListValue"; }

 protected:
  explicit SessionOptionValue_StringListValue(::google::protobuf::Arena* arena);
  SessionOptionValue_StringListValue(::google::protobuf::Arena* arena, const SessionOptionValue_StringListValue& from);
  SessionOptionValue_StringListValue(::google::protobuf::Arena* arena, SessionOptionValue_StringListValue&& from) noexcept
      : SessionOptionValue_StringListValue(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated string values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  const std::string& values(int index) const;
  std::string* mutable_values(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_values(int index, Arg_&& value, Args_... args);
  std::string* add_values();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_values(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& values() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_values();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_values() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_values();

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.SessionOptionValue.StringListValue)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      71, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SessionOptionValue_StringListValue& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> values_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Flight_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SessionOptionValue_StringListValue_class_data_;
// -------------------------------------------------------------------

class SchemaResult final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.SchemaResult) */ {
 public:
  inline SchemaResult() : SchemaResult(nullptr) {}
  ~SchemaResult() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SchemaResult* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SchemaResult));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SchemaResult(
      ::google::protobuf::internal::ConstantInitialized);

  inline SchemaResult(const SchemaResult& from) : SchemaResult(nullptr, from) {}
  inline SchemaResult(SchemaResult&& from) noexcept
      : SchemaResult(nullptr, std::move(from)) {}
  inline SchemaResult& operator=(const SchemaResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchemaResult& operator=(SchemaResult&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SchemaResult& default_instance() {
    return *reinterpret_cast<const SchemaResult*>(
        &_SchemaResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(SchemaResult& a, SchemaResult& b) { a.Swap(&b); }
  inline void Swap(SchemaResult* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchemaResult* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchemaResult* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SchemaResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SchemaResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SchemaResult& from) { SchemaResult::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SchemaResult* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.SchemaResult"; }

 protected:
  explicit SchemaResult(::google::protobuf::Arena* arena);
  SchemaResult(::google::protobuf::Arena* arena, const SchemaResult& from);
  SchemaResult(::google::protobuf::Arena* arena, SchemaResult&& from) noexcept
      : SchemaResult(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSchemaFieldNumber = 1,
  };
  // bytes schema = 1;
  void clear_schema() ;
  const std::string& schema() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_schema(Arg_&& arg, Args_... args);
  std::string* mutable_schema();
  [[nodiscard]] std::string* release_schema();
  void set_allocated_schema(std::string* value);

  private:
  const std::string& _internal_schema() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_schema(const std::string& value);
  std::string* _internal_mutable_schema();

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.SchemaResult)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SchemaResult& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr schema_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Flight_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SchemaResult_class_data_;
// -------------------------------------------------------------------

class Result final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.Result) */ {
 public:
  inline Result() : Result(nullptr) {}
  ~Result() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Result* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Result));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Result(
      ::google::protobuf::internal::ConstantInitialized);

  inline Result(const Result& from) : Result(nullptr, from) {}
  inline Result(Result&& from) noexcept
      : Result(nullptr, std::move(from)) {}
  inline Result& operator=(const Result& from) {
    CopyFrom(from);
    return *this;
  }
  inline Result& operator=(Result&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Result& default_instance() {
    return *reinterpret_cast<const Result*>(
        &_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(Result& a, Result& b) { a.Swap(&b); }
  inline void Swap(Result* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Result* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Result* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Result>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Result& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Result& from) { Result::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Result* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.Result"; }

 protected:
  explicit Result(::google::protobuf::Arena* arena);
  Result(::google::protobuf::Arena* arena, const Result& from);
  Result(::google::protobuf::Arena* arena, Result&& from) noexcept
      : Result(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBodyFieldNumber = 1,
  };
  // bytes body = 1;
  void clear_body() ;
  const std::string& body() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_body(Arg_&& arg, Args_... args);
  std::string* mutable_body();
  [[nodiscard]] std::string* release_body();
  void set_allocated_body(std::string* value);

  private:
  const std::string& _internal_body() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_body(const std::string& value);
  std::string* _internal_mutable_body();

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.Result)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Result& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr body_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Flight_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Result_class_data_;
// -------------------------------------------------------------------

class PutResult final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.PutResult) */ {
 public:
  inline PutResult() : PutResult(nullptr) {}
  ~PutResult() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PutResult* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PutResult));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PutResult(
      ::google::protobuf::internal::ConstantInitialized);

  inline PutResult(const PutResult& from) : PutResult(nullptr, from) {}
  inline PutResult(PutResult&& from) noexcept
      : PutResult(nullptr, std::move(from)) {}
  inline PutResult& operator=(const PutResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline PutResult& operator=(PutResult&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PutResult& default_instance() {
    return *reinterpret_cast<const PutResult*>(
        &_PutResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(PutResult& a, PutResult& b) { a.Swap(&b); }
  inline void Swap(PutResult* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PutResult* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PutResult* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PutResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PutResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PutResult& from) { PutResult::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PutResult* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.PutResult"; }

 protected:
  explicit PutResult(::google::protobuf::Arena* arena);
  PutResult(::google::protobuf::Arena* arena, const PutResult& from);
  PutResult(::google::protobuf::Arena* arena, PutResult&& from) noexcept
      : PutResult(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAppMetadataFieldNumber = 1,
  };
  // bytes app_metadata = 1;
  void clear_app_metadata() ;
  const std::string& app_metadata() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_app_metadata(Arg_&& arg, Args_... args);
  std::string* mutable_app_metadata();
  [[nodiscard]] std::string* release_app_metadata();
  void set_allocated_app_metadata(std::string* value);

  private:
  const std::string& _internal_app_metadata() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_app_metadata(const std::string& value);
  std::string* _internal_mutable_app_metadata();

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.PutResult)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PutResult& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr app_metadata_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Flight_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PutResult_class_data_;
// -------------------------------------------------------------------

class Location final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.Location) */ {
 public:
  inline Location() : Location(nullptr) {}
  ~Location() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Location* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Location));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Location(
      ::google::protobuf::internal::ConstantInitialized);

  inline Location(const Location& from) : Location(nullptr, from) {}
  inline Location(Location&& from) noexcept
      : Location(nullptr, std::move(from)) {}
  inline Location& operator=(const Location& from) {
    CopyFrom(from);
    return *this;
  }
  inline Location& operator=(Location&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Location& default_instance() {
    return *reinterpret_cast<const Location*>(
        &_Location_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(Location& a, Location& b) { a.Swap(&b); }
  inline void Swap(Location* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Location* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Location* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Location>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Location& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Location& from) { Location::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Location* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.Location"; }

 protected:
  explicit Location(::google::protobuf::Arena* arena);
  Location(::google::protobuf::Arena* arena, const Location& from);
  Location(::google::protobuf::Arena* arena, Location&& from) noexcept
      : Location(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUriFieldNumber = 1,
  };
  // string uri = 1;
  void clear_uri() ;
  const std::string& uri() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_uri(Arg_&& arg, Args_... args);
  std::string* mutable_uri();
  [[nodiscard]] std::string* release_uri();
  void set_allocated_uri(std::string* value);

  private:
  const std::string& _internal_uri() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.Location)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      42, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Location& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr uri_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Flight_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Location_class_data_;
// -------------------------------------------------------------------

class HandshakeResponse final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.HandshakeResponse) */ {
 public:
  inline HandshakeResponse() : HandshakeResponse(nullptr) {}
  ~HandshakeResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(HandshakeResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(HandshakeResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HandshakeResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline HandshakeResponse(const HandshakeResponse& from) : HandshakeResponse(nullptr, from) {}
  inline HandshakeResponse(HandshakeResponse&& from) noexcept
      : HandshakeResponse(nullptr, std::move(from)) {}
  inline HandshakeResponse& operator=(const HandshakeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HandshakeResponse& operator=(HandshakeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HandshakeResponse& default_instance() {
    return *reinterpret_cast<const HandshakeResponse*>(
        &_HandshakeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(HandshakeResponse& a, HandshakeResponse& b) { a.Swap(&b); }
  inline void Swap(HandshakeResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HandshakeResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HandshakeResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<HandshakeResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HandshakeResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HandshakeResponse& from) { HandshakeResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(HandshakeResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.HandshakeResponse"; }

 protected:
  explicit HandshakeResponse(::google::protobuf::Arena* arena);
  HandshakeResponse(::google::protobuf::Arena* arena, const HandshakeResponse& from);
  HandshakeResponse(::google::protobuf::Arena* arena, HandshakeResponse&& from) noexcept
      : HandshakeResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPayloadFieldNumber = 2,
    kProtocolVersionFieldNumber = 1,
  };
  // bytes payload = 2;
  void clear_payload() ;
  const std::string& payload() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_payload(Arg_&& arg, Args_... args);
  std::string* mutable_payload();
  [[nodiscard]] std::string* release_payload();
  void set_allocated_payload(std::string* value);

  private:
  const std::string& _internal_payload() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();

  public:
  // uint64 protocol_version = 1;
  void clear_protocol_version() ;
  ::uint64_t protocol_version() const;
  void set_protocol_version(::uint64_t value);

  private:
  ::uint64_t _internal_protocol_version() const;
  void _internal_set_protocol_version(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.HandshakeResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const HandshakeResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr payload_;
    ::uint64_t protocol_version_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Flight_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull HandshakeResponse_class_data_;
// -------------------------------------------------------------------

class HandshakeRequest final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.HandshakeRequest) */ {
 public:
  inline HandshakeRequest() : HandshakeRequest(nullptr) {}
  ~HandshakeRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(HandshakeRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(HandshakeRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HandshakeRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline HandshakeRequest(const HandshakeRequest& from) : HandshakeRequest(nullptr, from) {}
  inline HandshakeRequest(HandshakeRequest&& from) noexcept
      : HandshakeRequest(nullptr, std::move(from)) {}
  inline HandshakeRequest& operator=(const HandshakeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HandshakeRequest& operator=(HandshakeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HandshakeRequest& default_instance() {
    return *reinterpret_cast<const HandshakeRequest*>(
        &_HandshakeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(HandshakeRequest& a, HandshakeRequest& b) { a.Swap(&b); }
  inline void Swap(HandshakeRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HandshakeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HandshakeRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<HandshakeRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HandshakeRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HandshakeRequest& from) { HandshakeRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(HandshakeRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.HandshakeRequest"; }

 protected:
  explicit HandshakeRequest(::google::protobuf::Arena* arena);
  HandshakeRequest(::google::protobuf::Arena* arena, const HandshakeRequest& from);
  HandshakeRequest(::google::protobuf::Arena* arena, HandshakeRequest&& from) noexcept
      : HandshakeRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPayloadFieldNumber = 2,
    kProtocolVersionFieldNumber = 1,
  };
  // bytes payload = 2;
  void clear_payload() ;
  const std::string& payload() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_payload(Arg_&& arg, Args_... args);
  std::string* mutable_payload();
  [[nodiscard]] std::string* release_payload();
  void set_allocated_payload(std::string* value);

  private:
  const std::string& _internal_payload() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();

  public:
  // uint64 protocol_version = 1;
  void clear_protocol_version() ;
  ::uint64_t protocol_version() const;
  void set_protocol_version(::uint64_t value);

  private:
  ::uint64_t _internal_protocol_version() const;
  void _internal_set_protocol_version(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.HandshakeRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const HandshakeRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr payload_;
    ::uint64_t protocol_version_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Flight_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull HandshakeRequest_class_data_;
// -------------------------------------------------------------------

class GetSessionOptionsRequest final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.GetSessionOptionsRequest) */ {
 public:
  inline GetSessionOptionsRequest() : GetSessionOptionsRequest(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetSessionOptionsRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetSessionOptionsRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetSessionOptionsRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetSessionOptionsRequest(const GetSessionOptionsRequest& from) : GetSessionOptionsRequest(nullptr, from) {}
  inline GetSessionOptionsRequest(GetSessionOptionsRequest&& from) noexcept
      : GetSessionOptionsRequest(nullptr, std::move(from)) {}
  inline GetSessionOptionsRequest& operator=(const GetSessionOptionsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSessionOptionsRequest& operator=(GetSessionOptionsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSessionOptionsRequest& default_instance() {
    return *reinterpret_cast<const GetSessionOptionsRequest*>(
        &_GetSessionOptionsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 27;
  friend void swap(GetSessionOptionsRequest& a, GetSessionOptionsRequest& b) { a.Swap(&b); }
  inline void Swap(GetSessionOptionsRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSessionOptionsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSessionOptionsRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<GetSessionOptionsRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetSessionOptionsRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetSessionOptionsRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.GetSessionOptionsRequest"; }

 protected:
  explicit GetSessionOptionsRequest(::google::protobuf::Arena* arena);
  GetSessionOptionsRequest(::google::protobuf::Arena* arena, const GetSessionOptionsRequest& from);
  GetSessionOptionsRequest(::google::protobuf::Arena* arena, GetSessionOptionsRequest&& from) noexcept
      : GetSessionOptionsRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.GetSessionOptionsRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetSessionOptionsRequest& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_Flight_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GetSessionOptionsRequest_class_data_;
// -------------------------------------------------------------------

class FlightDescriptor final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.FlightDescriptor) */ {
 public:
  inline FlightDescriptor() : FlightDescriptor(nullptr) {}
  ~FlightDescriptor() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FlightDescriptor* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FlightDescriptor));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FlightDescriptor(
      ::google::protobuf::internal::ConstantInitialized);

  inline FlightDescriptor(const FlightDescriptor& from) : FlightDescriptor(nullptr, from) {}
  inline FlightDescriptor(FlightDescriptor&& from) noexcept
      : FlightDescriptor(nullptr, std::move(from)) {}
  inline FlightDescriptor& operator=(const FlightDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlightDescriptor& operator=(FlightDescriptor&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlightDescriptor& default_instance() {
    return *reinterpret_cast<const FlightDescriptor*>(
        &_FlightDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(FlightDescriptor& a, FlightDescriptor& b) { a.Swap(&b); }
  inline void Swap(FlightDescriptor* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlightDescriptor* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlightDescriptor* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FlightDescriptor>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FlightDescriptor& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FlightDescriptor& from) { FlightDescriptor::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FlightDescriptor* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.FlightDescriptor"; }

 protected:
  explicit FlightDescriptor(::google::protobuf::Arena* arena);
  FlightDescriptor(::google::protobuf::Arena* arena, const FlightDescriptor& from);
  FlightDescriptor(::google::protobuf::Arena* arena, FlightDescriptor&& from) noexcept
      : FlightDescriptor(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using DescriptorType = FlightDescriptor_DescriptorType;
  static constexpr DescriptorType UNKNOWN = FlightDescriptor_DescriptorType_UNKNOWN;
  static constexpr DescriptorType PATH = FlightDescriptor_DescriptorType_PATH;
  static constexpr DescriptorType CMD = FlightDescriptor_DescriptorType_CMD;
  static inline bool DescriptorType_IsValid(int value) {
    return FlightDescriptor_DescriptorType_IsValid(value);
  }
  static constexpr DescriptorType DescriptorType_MIN = FlightDescriptor_DescriptorType_DescriptorType_MIN;
  static constexpr DescriptorType DescriptorType_MAX = FlightDescriptor_DescriptorType_DescriptorType_MAX;
  static constexpr int DescriptorType_ARRAYSIZE = FlightDescriptor_DescriptorType_DescriptorType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* DescriptorType_descriptor() {
    return FlightDescriptor_DescriptorType_descriptor();
  }
  template <typename T>
  static inline const std::string& DescriptorType_Name(T value) {
    return FlightDescriptor_DescriptorType_Name(value);
  }
  static inline bool DescriptorType_Parse(absl::string_view name, DescriptorType* value) {
    return FlightDescriptor_DescriptorType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kPathFieldNumber = 3,
    kCmdFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // repeated string path = 3;
  int path_size() const;
  private:
  int _internal_path_size() const;

  public:
  void clear_path() ;
  const std::string& path(int index) const;
  std::string* mutable_path(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_path(int index, Arg_&& value, Args_... args);
  std::string* add_path();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_path(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& path() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_path();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_path() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_path();

  public:
  // bytes cmd = 2;
  void clear_cmd() ;
  const std::string& cmd() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cmd(Arg_&& arg, Args_... args);
  std::string* mutable_cmd();
  [[nodiscard]] std::string* release_cmd();
  void set_allocated_cmd(std::string* value);

  private:
  const std::string& _internal_cmd() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_cmd(const std::string& value);
  std::string* _internal_mutable_cmd();

  public:
  // .arrow.flight.protocol.FlightDescriptor.DescriptorType type = 1;
  void clear_type() ;
  ::arrow::flight::protocol::FlightDescriptor_DescriptorType type() const;
  void set_type(::arrow::flight::protocol::FlightDescriptor_DescriptorType value);

  private:
  ::arrow::flight::protocol::FlightDescriptor_DescriptorType _internal_type() const;
  void _internal_set_type(::arrow::flight::protocol::FlightDescriptor_DescriptorType value);

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.FlightDescriptor)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      51, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FlightDescriptor& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> path_;
    ::google::protobuf::internal::ArenaStringPtr cmd_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Flight_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull FlightDescriptor_class_data_;
// -------------------------------------------------------------------

class Empty final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.Empty) */ {
 public:
  inline Empty() : Empty(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Empty* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Empty));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Empty(
      ::google::protobuf::internal::ConstantInitialized);

  inline Empty(const Empty& from) : Empty(nullptr, from) {}
  inline Empty(Empty&& from) noexcept
      : Empty(nullptr, std::move(from)) {}
  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  inline Empty& operator=(Empty&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Empty& default_instance() {
    return *reinterpret_cast<const Empty*>(
        &_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(Empty& a, Empty& b) { a.Swap(&b); }
  inline void Swap(Empty* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Empty* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Empty* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<Empty>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Empty& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Empty& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.Empty"; }

 protected:
  explicit Empty(::google::protobuf::Arena* arena);
  Empty(::google::protobuf::Arena* arena, const Empty& from);
  Empty(::google::protobuf::Arena* arena, Empty&& from) noexcept
      : Empty(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.Empty)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Empty& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_Flight_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Empty_class_data_;
// -------------------------------------------------------------------

class Criteria final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.Criteria) */ {
 public:
  inline Criteria() : Criteria(nullptr) {}
  ~Criteria() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Criteria* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Criteria));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Criteria(
      ::google::protobuf::internal::ConstantInitialized);

  inline Criteria(const Criteria& from) : Criteria(nullptr, from) {}
  inline Criteria(Criteria&& from) noexcept
      : Criteria(nullptr, std::move(from)) {}
  inline Criteria& operator=(const Criteria& from) {
    CopyFrom(from);
    return *this;
  }
  inline Criteria& operator=(Criteria&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Criteria& default_instance() {
    return *reinterpret_cast<const Criteria*>(
        &_Criteria_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(Criteria& a, Criteria& b) { a.Swap(&b); }
  inline void Swap(Criteria* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Criteria* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Criteria* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Criteria>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Criteria& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Criteria& from) { Criteria::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Criteria* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.Criteria"; }

 protected:
  explicit Criteria(::google::protobuf::Arena* arena);
  Criteria(::google::protobuf::Arena* arena, const Criteria& from);
  Criteria(::google::protobuf::Arena* arena, Criteria&& from) noexcept
      : Criteria(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kExpressionFieldNumber = 1,
  };
  // bytes expression = 1;
  void clear_expression() ;
  const std::string& expression() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_expression(Arg_&& arg, Args_... args);
  std::string* mutable_expression();
  [[nodiscard]] std::string* release_expression();
  void set_allocated_expression(std::string* value);

  private:
  const std::string& _internal_expression() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_expression(const std::string& value);
  std::string* _internal_mutable_expression();

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.Criteria)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Criteria& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr expression_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Flight_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Criteria_class_data_;
// -------------------------------------------------------------------

class CloseSessionResult final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.CloseSessionResult) */ {
 public:
  inline CloseSessionResult() : CloseSessionResult(nullptr) {}
  ~CloseSessionResult() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CloseSessionResult* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CloseSessionResult));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CloseSessionResult(
      ::google::protobuf::internal::ConstantInitialized);

  inline CloseSessionResult(const CloseSessionResult& from) : CloseSessionResult(nullptr, from) {}
  inline CloseSessionResult(CloseSessionResult&& from) noexcept
      : CloseSessionResult(nullptr, std::move(from)) {}
  inline CloseSessionResult& operator=(const CloseSessionResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline CloseSessionResult& operator=(CloseSessionResult&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CloseSessionResult& default_instance() {
    return *reinterpret_cast<const CloseSessionResult*>(
        &_CloseSessionResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 31;
  friend void swap(CloseSessionResult& a, CloseSessionResult& b) { a.Swap(&b); }
  inline void Swap(CloseSessionResult* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CloseSessionResult* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CloseSessionResult* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CloseSessionResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CloseSessionResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CloseSessionResult& from) { CloseSessionResult::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CloseSessionResult* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.CloseSessionResult"; }

 protected:
  explicit CloseSessionResult(::google::protobuf::Arena* arena);
  CloseSessionResult(::google::protobuf::Arena* arena, const CloseSessionResult& from);
  CloseSessionResult(::google::protobuf::Arena* arena, CloseSessionResult&& from) noexcept
      : CloseSessionResult(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Status = CloseSessionResult_Status;
  static constexpr Status UNSPECIFIED = CloseSessionResult_Status_UNSPECIFIED;
  static constexpr Status CLOSED = CloseSessionResult_Status_CLOSED;
  static constexpr Status CLOSING = CloseSessionResult_Status_CLOSING;
  static constexpr Status NOT_CLOSEABLE = CloseSessionResult_Status_NOT_CLOSEABLE;
  static inline bool Status_IsValid(int value) {
    return CloseSessionResult_Status_IsValid(value);
  }
  static constexpr Status Status_MIN = CloseSessionResult_Status_Status_MIN;
  static constexpr Status Status_MAX = CloseSessionResult_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE = CloseSessionResult_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Status_descriptor() {
    return CloseSessionResult_Status_descriptor();
  }
  template <typename T>
  static inline const std::string& Status_Name(T value) {
    return CloseSessionResult_Status_Name(value);
  }
  static inline bool Status_Parse(absl::string_view name, Status* value) {
    return CloseSessionResult_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kStatusFieldNumber = 1,
  };
  // .arrow.flight.protocol.CloseSessionResult.Status status = 1;
  void clear_status() ;
  ::arrow::flight::protocol::CloseSessionResult_Status status() const;
  void set_status(::arrow::flight::protocol::CloseSessionResult_Status value);

  private:
  ::arrow::flight::protocol::CloseSessionResult_Status _internal_status() const;
  void _internal_set_status(::arrow::flight::protocol::CloseSessionResult_Status value);

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.CloseSessionResult)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CloseSessionResult& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Flight_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CloseSessionResult_class_data_;
// -------------------------------------------------------------------

class CloseSessionRequest final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.CloseSessionRequest) */ {
 public:
  inline CloseSessionRequest() : CloseSessionRequest(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CloseSessionRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CloseSessionRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CloseSessionRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline CloseSessionRequest(const CloseSessionRequest& from) : CloseSessionRequest(nullptr, from) {}
  inline CloseSessionRequest(CloseSessionRequest&& from) noexcept
      : CloseSessionRequest(nullptr, std::move(from)) {}
  inline CloseSessionRequest& operator=(const CloseSessionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CloseSessionRequest& operator=(CloseSessionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CloseSessionRequest& default_instance() {
    return *reinterpret_cast<const CloseSessionRequest*>(
        &_CloseSessionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 30;
  friend void swap(CloseSessionRequest& a, CloseSessionRequest& b) { a.Swap(&b); }
  inline void Swap(CloseSessionRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CloseSessionRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CloseSessionRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<CloseSessionRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CloseSessionRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CloseSessionRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.CloseSessionRequest"; }

 protected:
  explicit CloseSessionRequest(::google::protobuf::Arena* arena);
  CloseSessionRequest(::google::protobuf::Arena* arena, const CloseSessionRequest& from);
  CloseSessionRequest(::google::protobuf::Arena* arena, CloseSessionRequest&& from) noexcept
      : CloseSessionRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.CloseSessionRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CloseSessionRequest& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_Flight_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CloseSessionRequest_class_data_;
// -------------------------------------------------------------------

class CancelFlightInfoResult final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.CancelFlightInfoResult) */ {
 public:
  inline CancelFlightInfoResult() : CancelFlightInfoResult(nullptr) {}
  ~CancelFlightInfoResult() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CancelFlightInfoResult* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CancelFlightInfoResult));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CancelFlightInfoResult(
      ::google::protobuf::internal::ConstantInitialized);

  inline CancelFlightInfoResult(const CancelFlightInfoResult& from) : CancelFlightInfoResult(nullptr, from) {}
  inline CancelFlightInfoResult(CancelFlightInfoResult&& from) noexcept
      : CancelFlightInfoResult(nullptr, std::move(from)) {}
  inline CancelFlightInfoResult& operator=(const CancelFlightInfoResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelFlightInfoResult& operator=(CancelFlightInfoResult&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelFlightInfoResult& default_instance() {
    return *reinterpret_cast<const CancelFlightInfoResult*>(
        &_CancelFlightInfoResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(CancelFlightInfoResult& a, CancelFlightInfoResult& b) { a.Swap(&b); }
  inline void Swap(CancelFlightInfoResult* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelFlightInfoResult* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CancelFlightInfoResult* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CancelFlightInfoResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CancelFlightInfoResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CancelFlightInfoResult& from) { CancelFlightInfoResult::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CancelFlightInfoResult* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.CancelFlightInfoResult"; }

 protected:
  explicit CancelFlightInfoResult(::google::protobuf::Arena* arena);
  CancelFlightInfoResult(::google::protobuf::Arena* arena, const CancelFlightInfoResult& from);
  CancelFlightInfoResult(::google::protobuf::Arena* arena, CancelFlightInfoResult&& from) noexcept
      : CancelFlightInfoResult(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStatusFieldNumber = 1,
  };
  // .arrow.flight.protocol.CancelStatus status = 1;
  void clear_status() ;
  ::arrow::flight::protocol::CancelStatus status() const;
  void set_status(::arrow::flight::protocol::CancelStatus value);

  private:
  ::arrow::flight::protocol::CancelStatus _internal_status() const;
  void _internal_set_status(::arrow::flight::protocol::CancelStatus value);

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.CancelFlightInfoResult)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CancelFlightInfoResult& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Flight_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CancelFlightInfoResult_class_data_;
// -------------------------------------------------------------------

class BasicAuth final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.BasicAuth) */ {
 public:
  inline BasicAuth() : BasicAuth(nullptr) {}
  ~BasicAuth() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BasicAuth* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BasicAuth));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BasicAuth(
      ::google::protobuf::internal::ConstantInitialized);

  inline BasicAuth(const BasicAuth& from) : BasicAuth(nullptr, from) {}
  inline BasicAuth(BasicAuth&& from) noexcept
      : BasicAuth(nullptr, std::move(from)) {}
  inline BasicAuth& operator=(const BasicAuth& from) {
    CopyFrom(from);
    return *this;
  }
  inline BasicAuth& operator=(BasicAuth&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BasicAuth& default_instance() {
    return *reinterpret_cast<const BasicAuth*>(
        &_BasicAuth_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(BasicAuth& a, BasicAuth& b) { a.Swap(&b); }
  inline void Swap(BasicAuth* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BasicAuth* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BasicAuth* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BasicAuth>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BasicAuth& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BasicAuth& from) { BasicAuth::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BasicAuth* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.BasicAuth"; }

 protected:
  explicit BasicAuth(::google::protobuf::Arena* arena);
  BasicAuth(::google::protobuf::Arena* arena, const BasicAuth& from);
  BasicAuth(::google::protobuf::Arena* arena, BasicAuth&& from) noexcept
      : BasicAuth(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUsernameFieldNumber = 2,
    kPasswordFieldNumber = 3,
  };
  // string username = 2;
  void clear_username() ;
  const std::string& username() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_username(Arg_&& arg, Args_... args);
  std::string* mutable_username();
  [[nodiscard]] std::string* release_username();
  void set_allocated_username(std::string* value);

  private:
  const std::string& _internal_username() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();

  public:
  // string password = 3;
  void clear_password() ;
  const std::string& password() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_password(Arg_&& arg, Args_... args);
  std::string* mutable_password();
  [[nodiscard]] std::string* release_password();
  void set_allocated_password(std::string* value);

  private:
  const std::string& _internal_password() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.BasicAuth)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      56, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BasicAuth& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr username_;
    ::google::protobuf::internal::ArenaStringPtr password_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Flight_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull BasicAuth_class_data_;
// -------------------------------------------------------------------

class ActionType final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.ActionType) */ {
 public:
  inline ActionType() : ActionType(nullptr) {}
  ~ActionType() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ActionType* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ActionType));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ActionType(
      ::google::protobuf::internal::ConstantInitialized);

  inline ActionType(const ActionType& from) : ActionType(nullptr, from) {}
  inline ActionType(ActionType&& from) noexcept
      : ActionType(nullptr, std::move(from)) {}
  inline ActionType& operator=(const ActionType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionType& operator=(ActionType&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionType& default_instance() {
    return *reinterpret_cast<const ActionType*>(
        &_ActionType_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(ActionType& a, ActionType& b) { a.Swap(&b); }
  inline void Swap(ActionType* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionType* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionType* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ActionType>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ActionType& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ActionType& from) { ActionType::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ActionType* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.ActionType"; }

 protected:
  explicit ActionType(::google::protobuf::Arena* arena);
  ActionType(::google::protobuf::Arena* arena, const ActionType& from);
  ActionType(::google::protobuf::Arena* arena, ActionType&& from) noexcept
      : ActionType(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTypeFieldNumber = 1,
    kDescriptionFieldNumber = 2,
  };
  // string type = 1;
  void clear_type() ;
  const std::string& type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  std::string* mutable_type();
  [[nodiscard]] std::string* release_type();
  void set_allocated_type(std::string* value);

  private:
  const std::string& _internal_type() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();

  public:
  // string description = 2;
  void clear_description() ;
  const std::string& description() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  [[nodiscard]] std::string* release_description();
  void set_allocated_description(std::string* value);

  private:
  const std::string& _internal_description() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.ActionType)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      56, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ActionType& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr type_;
    ::google::protobuf::internal::ArenaStringPtr description_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Flight_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ActionType_class_data_;
// -------------------------------------------------------------------

class Action final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.Action) */ {
 public:
  inline Action() : Action(nullptr) {}
  ~Action() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Action* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Action));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Action(
      ::google::protobuf::internal::ConstantInitialized);

  inline Action(const Action& from) : Action(nullptr, from) {}
  inline Action(Action&& from) noexcept
      : Action(nullptr, std::move(from)) {}
  inline Action& operator=(const Action& from) {
    CopyFrom(from);
    return *this;
  }
  inline Action& operator=(Action&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Action& default_instance() {
    return *reinterpret_cast<const Action*>(
        &_Action_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(Action& a, Action& b) { a.Swap(&b); }
  inline void Swap(Action* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Action* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Action* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Action>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Action& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Action& from) { Action::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Action* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.Action"; }

 protected:
  explicit Action(::google::protobuf::Arena* arena);
  Action(::google::protobuf::Arena* arena, const Action& from);
  Action(::google::protobuf::Arena* arena, Action&& from) noexcept
      : Action(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTypeFieldNumber = 1,
    kBodyFieldNumber = 2,
  };
  // string type = 1;
  void clear_type() ;
  const std::string& type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  std::string* mutable_type();
  [[nodiscard]] std::string* release_type();
  void set_allocated_type(std::string* value);

  private:
  const std::string& _internal_type() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();

  public:
  // bytes body = 2;
  void clear_body() ;
  const std::string& body() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_body(Arg_&& arg, Args_... args);
  std::string* mutable_body();
  [[nodiscard]] std::string* release_body();
  void set_allocated_body(std::string* value);

  private:
  const std::string& _internal_body() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_body(const std::string& value);
  std::string* _internal_mutable_body();

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.Action)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      41, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Action& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr type_;
    ::google::protobuf::internal::ArenaStringPtr body_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Flight_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Action_class_data_;
// -------------------------------------------------------------------

class SetSessionOptionsResult_ErrorsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, ::google::protobuf::Message,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, ::google::protobuf::Message,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  SetSessionOptionsResult_ErrorsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SetSessionOptionsResult_ErrorsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit SetSessionOptionsResult_ErrorsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const SetSessionOptionsResult_ErrorsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const SetSessionOptionsResult_ErrorsEntry_DoNotUse*>(
        &_SetSessionOptionsResult_ErrorsEntry_DoNotUse_default_instance_);
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_Flight_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      69, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull SetSessionOptionsResult_ErrorsEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class SessionOptionValue final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.SessionOptionValue) */ {
 public:
  inline SessionOptionValue() : SessionOptionValue(nullptr) {}
  ~SessionOptionValue() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SessionOptionValue* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SessionOptionValue));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SessionOptionValue(
      ::google::protobuf::internal::ConstantInitialized);

  inline SessionOptionValue(const SessionOptionValue& from) : SessionOptionValue(nullptr, from) {}
  inline SessionOptionValue(SessionOptionValue&& from) noexcept
      : SessionOptionValue(nullptr, std::move(from)) {}
  inline SessionOptionValue& operator=(const SessionOptionValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionOptionValue& operator=(SessionOptionValue&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SessionOptionValue& default_instance() {
    return *reinterpret_cast<const SessionOptionValue*>(
        &_SessionOptionValue_default_instance_);
  }
  enum OptionValueCase {
    kStringValue = 1,
    kBoolValue = 2,
    kInt64Value = 3,
    kDoubleValue = 4,
    kStringListValue = 5,
    OPTION_VALUE_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(SessionOptionValue& a, SessionOptionValue& b) { a.Swap(&b); }
  inline void Swap(SessionOptionValue* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionOptionValue* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionOptionValue* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SessionOptionValue>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SessionOptionValue& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SessionOptionValue& from) { SessionOptionValue::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SessionOptionValue* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.SessionOptionValue"; }

 protected:
  explicit SessionOptionValue(::google::protobuf::Arena* arena);
  SessionOptionValue(::google::protobuf::Arena* arena, const SessionOptionValue& from);
  SessionOptionValue(::google::protobuf::Arena* arena, SessionOptionValue&& from) noexcept
      : SessionOptionValue(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using StringListValue = SessionOptionValue_StringListValue;

  // accessors -------------------------------------------------------
  enum : int {
    kStringValueFieldNumber = 1,
    kBoolValueFieldNumber = 2,
    kInt64ValueFieldNumber = 3,
    kDoubleValueFieldNumber = 4,
    kStringListValueFieldNumber = 5,
  };
  // string string_value = 1;
  bool has_string_value() const;
  void clear_string_value() ;
  const std::string& string_value() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_string_value(Arg_&& arg, Args_... args);
  std::string* mutable_string_value();
  [[nodiscard]] std::string* release_string_value();
  void set_allocated_string_value(std::string* value);

  private:
  const std::string& _internal_string_value() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_string_value(const std::string& value);
  std::string* _internal_mutable_string_value();

  public:
  // bool bool_value = 2;
  bool has_bool_value() const;
  void clear_bool_value() ;
  bool bool_value() const;
  void set_bool_value(bool value);

  private:
  bool _internal_bool_value() const;
  void _internal_set_bool_value(bool value);

  public:
  // sfixed64 int64_value = 3;
  bool has_int64_value() const;
  void clear_int64_value() ;
  ::int64_t int64_value() const;
  void set_int64_value(::int64_t value);

  private:
  ::int64_t _internal_int64_value() const;
  void _internal_set_int64_value(::int64_t value);

  public:
  // double double_value = 4;
  bool has_double_value() const;
  void clear_double_value() ;
  double double_value() const;
  void set_double_value(double value);

  private:
  double _internal_double_value() const;
  void _internal_set_double_value(double value);

  public:
  // .arrow.flight.protocol.SessionOptionValue.StringListValue string_list_value = 5;
  bool has_string_list_value() const;
  private:
  bool _internal_has_string_list_value() const;

  public:
  void clear_string_list_value() ;
  const ::arrow::flight::protocol::SessionOptionValue_StringListValue& string_list_value() const;
  [[nodiscard]] ::arrow::flight::protocol::SessionOptionValue_StringListValue* release_string_list_value();
  ::arrow::flight::protocol::SessionOptionValue_StringListValue* mutable_string_list_value();
  void set_allocated_string_list_value(::arrow::flight::protocol::SessionOptionValue_StringListValue* value);
  void unsafe_arena_set_allocated_string_list_value(::arrow::flight::protocol::SessionOptionValue_StringListValue* value);
  ::arrow::flight::protocol::SessionOptionValue_StringListValue* unsafe_arena_release_string_list_value();

  private:
  const ::arrow::flight::protocol::SessionOptionValue_StringListValue& _internal_string_list_value() const;
  ::arrow::flight::protocol::SessionOptionValue_StringListValue* _internal_mutable_string_list_value();

  public:
  void clear_option_value();
  OptionValueCase option_value_case() const;
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.SessionOptionValue)
 private:
  class _Internal;
  void set_has_string_value();
  void set_has_bool_value();
  void set_has_int64_value();
  void set_has_double_value();
  void set_has_string_list_value();
  inline bool has_option_value() const;
  inline void clear_has_option_value();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 5, 1,
      61, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SessionOptionValue& from_msg);
    union OptionValueUnion {
      constexpr OptionValueUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::internal::ArenaStringPtr string_value_;
      bool bool_value_;
      ::int64_t int64_value_;
      double double_value_;
      ::arrow::flight::protocol::SessionOptionValue_StringListValue* string_list_value_;
    } option_value_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Flight_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SessionOptionValue_class_data_;
// -------------------------------------------------------------------

class FlightEndpoint final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.FlightEndpoint) */ {
 public:
  inline FlightEndpoint() : FlightEndpoint(nullptr) {}
  ~FlightEndpoint() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FlightEndpoint* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FlightEndpoint));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FlightEndpoint(
      ::google::protobuf::internal::ConstantInitialized);

  inline FlightEndpoint(const FlightEndpoint& from) : FlightEndpoint(nullptr, from) {}
  inline FlightEndpoint(FlightEndpoint&& from) noexcept
      : FlightEndpoint(nullptr, std::move(from)) {}
  inline FlightEndpoint& operator=(const FlightEndpoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlightEndpoint& operator=(FlightEndpoint&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlightEndpoint& default_instance() {
    return *reinterpret_cast<const FlightEndpoint*>(
        &_FlightEndpoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(FlightEndpoint& a, FlightEndpoint& b) { a.Swap(&b); }
  inline void Swap(FlightEndpoint* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlightEndpoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlightEndpoint* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FlightEndpoint>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FlightEndpoint& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FlightEndpoint& from) { FlightEndpoint::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FlightEndpoint* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.FlightEndpoint"; }

 protected:
  explicit FlightEndpoint(::google::protobuf::Arena* arena);
  FlightEndpoint(::google::protobuf::Arena* arena, const FlightEndpoint& from);
  FlightEndpoint(::google::protobuf::Arena* arena, FlightEndpoint&& from) noexcept
      : FlightEndpoint(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLocationFieldNumber = 2,
    kAppMetadataFieldNumber = 4,
    kTicketFieldNumber = 1,
    kExpirationTimeFieldNumber = 3,
  };
  // repeated .arrow.flight.protocol.Location location = 2;
  int location_size() const;
  private:
  int _internal_location_size() const;

  public:
  void clear_location() ;
  ::arrow::flight::protocol::Location* mutable_location(int index);
  ::google::protobuf::RepeatedPtrField<::arrow::flight::protocol::Location>* mutable_location();

  private:
  const ::google::protobuf::RepeatedPtrField<::arrow::flight::protocol::Location>& _internal_location() const;
  ::google::protobuf::RepeatedPtrField<::arrow::flight::protocol::Location>* _internal_mutable_location();
  public:
  const ::arrow::flight::protocol::Location& location(int index) const;
  ::arrow::flight::protocol::Location* add_location();
  const ::google::protobuf::RepeatedPtrField<::arrow::flight::protocol::Location>& location() const;
  // bytes app_metadata = 4;
  void clear_app_metadata() ;
  const std::string& app_metadata() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_app_metadata(Arg_&& arg, Args_... args);
  std::string* mutable_app_metadata();
  [[nodiscard]] std::string* release_app_metadata();
  void set_allocated_app_metadata(std::string* value);

  private:
  const std::string& _internal_app_metadata() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_app_metadata(const std::string& value);
  std::string* _internal_mutable_app_metadata();

  public:
  // .arrow.flight.protocol.Ticket ticket = 1;
  bool has_ticket() const;
  void clear_ticket() ;
  const ::arrow::flight::protocol::Ticket& ticket() const;
  [[nodiscard]] ::arrow::flight::protocol::Ticket* release_ticket();
  ::arrow::flight::protocol::Ticket* mutable_ticket();
  void set_allocated_ticket(::arrow::flight::protocol::Ticket* value);
  void unsafe_arena_set_allocated_ticket(::arrow::flight::protocol::Ticket* value);
  ::arrow::flight::protocol::Ticket* unsafe_arena_release_ticket();

  private:
  const ::arrow::flight::protocol::Ticket& _internal_ticket() const;
  ::arrow::flight::protocol::Ticket* _internal_mutable_ticket();

  public:
  // .google.protobuf.Timestamp expiration_time = 3;
  bool has_expiration_time() const;
  void clear_expiration_time() ;
  const ::google::protobuf::Timestamp& expiration_time() const;
  [[nodiscard]] ::google::protobuf::Timestamp* release_expiration_time();
  ::google::protobuf::Timestamp* mutable_expiration_time();
  void set_allocated_expiration_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_expiration_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_expiration_time();

  private:
  const ::google::protobuf::Timestamp& _internal_expiration_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_expiration_time();

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.FlightEndpoint)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 3,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FlightEndpoint& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::arrow::flight::protocol::Location > location_;
    ::google::protobuf::internal::ArenaStringPtr app_metadata_;
    ::arrow::flight::protocol::Ticket* ticket_;
    ::google::protobuf::Timestamp* expiration_time_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Flight_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull FlightEndpoint_class_data_;
// -------------------------------------------------------------------

class FlightData final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.FlightData) */ {
 public:
  inline FlightData() : FlightData(nullptr) {}
  ~FlightData() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FlightData* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FlightData));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FlightData(
      ::google::protobuf::internal::ConstantInitialized);

  inline FlightData(const FlightData& from) : FlightData(nullptr, from) {}
  inline FlightData(FlightData&& from) noexcept
      : FlightData(nullptr, std::move(from)) {}
  inline FlightData& operator=(const FlightData& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlightData& operator=(FlightData&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlightData& default_instance() {
    return *reinterpret_cast<const FlightData*>(
        &_FlightData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(FlightData& a, FlightData& b) { a.Swap(&b); }
  inline void Swap(FlightData* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlightData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlightData* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FlightData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FlightData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FlightData& from) { FlightData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FlightData* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.FlightData"; }

 protected:
  explicit FlightData(::google::protobuf::Arena* arena);
  FlightData(::google::protobuf::Arena* arena, const FlightData& from);
  FlightData(::google::protobuf::Arena* arena, FlightData&& from) noexcept
      : FlightData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDataHeaderFieldNumber = 2,
    kAppMetadataFieldNumber = 3,
    kDataBodyFieldNumber = 1000,
    kFlightDescriptorFieldNumber = 1,
  };
  // bytes data_header = 2;
  void clear_data_header() ;
  const std::string& data_header() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data_header(Arg_&& arg, Args_... args);
  std::string* mutable_data_header();
  [[nodiscard]] std::string* release_data_header();
  void set_allocated_data_header(std::string* value);

  private:
  const std::string& _internal_data_header() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_data_header(const std::string& value);
  std::string* _internal_mutable_data_header();

  public:
  // bytes app_metadata = 3;
  void clear_app_metadata() ;
  const std::string& app_metadata() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_app_metadata(Arg_&& arg, Args_... args);
  std::string* mutable_app_metadata();
  [[nodiscard]] std::string* release_app_metadata();
  void set_allocated_app_metadata(std::string* value);

  private:
  const std::string& _internal_app_metadata() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_app_metadata(const std::string& value);
  std::string* _internal_mutable_app_metadata();

  public:
  // bytes data_body = 1000;
  void clear_data_body() ;
  const std::string& data_body() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data_body(Arg_&& arg, Args_... args);
  std::string* mutable_data_body();
  [[nodiscard]] std::string* release_data_body();
  void set_allocated_data_body(std::string* value);

  private:
  const std::string& _internal_data_body() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_data_body(const std::string& value);
  std::string* _internal_mutable_data_body();

  public:
  // .arrow.flight.protocol.FlightDescriptor flight_descriptor = 1;
  bool has_flight_descriptor() const;
  void clear_flight_descriptor() ;
  const ::arrow::flight::protocol::FlightDescriptor& flight_descriptor() const;
  [[nodiscard]] ::arrow::flight::protocol::FlightDescriptor* release_flight_descriptor();
  ::arrow::flight::protocol::FlightDescriptor* mutable_flight_descriptor();
  void set_allocated_flight_descriptor(::arrow::flight::protocol::FlightDescriptor* value);
  void unsafe_arena_set_allocated_flight_descriptor(::arrow::flight::protocol::FlightDescriptor* value);
  ::arrow::flight::protocol::FlightDescriptor* unsafe_arena_release_flight_descriptor();

  private:
  const ::arrow::flight::protocol::FlightDescriptor& _internal_flight_descriptor() const;
  ::arrow::flight::protocol::FlightDescriptor* _internal_mutable_flight_descriptor();

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.FlightData)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 7>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FlightData& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr data_header_;
    ::google::protobuf::internal::ArenaStringPtr app_metadata_;
    ::google::protobuf::internal::ArenaStringPtr data_body_;
    ::arrow::flight::protocol::FlightDescriptor* flight_descriptor_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Flight_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull FlightData_class_data_;
// -------------------------------------------------------------------

class SetSessionOptionsResult final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.SetSessionOptionsResult) */ {
 public:
  inline SetSessionOptionsResult() : SetSessionOptionsResult(nullptr) {}
  ~SetSessionOptionsResult() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SetSessionOptionsResult* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SetSessionOptionsResult));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SetSessionOptionsResult(
      ::google::protobuf::internal::ConstantInitialized);

  inline SetSessionOptionsResult(const SetSessionOptionsResult& from) : SetSessionOptionsResult(nullptr, from) {}
  inline SetSessionOptionsResult(SetSessionOptionsResult&& from) noexcept
      : SetSessionOptionsResult(nullptr, std::move(from)) {}
  inline SetSessionOptionsResult& operator=(const SetSessionOptionsResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetSessionOptionsResult& operator=(SetSessionOptionsResult&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetSessionOptionsResult& default_instance() {
    return *reinterpret_cast<const SetSessionOptionsResult*>(
        &_SetSessionOptionsResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 26;
  friend void swap(SetSessionOptionsResult& a, SetSessionOptionsResult& b) { a.Swap(&b); }
  inline void Swap(SetSessionOptionsResult* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetSessionOptionsResult* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetSessionOptionsResult* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SetSessionOptionsResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SetSessionOptionsResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SetSessionOptionsResult& from) { SetSessionOptionsResult::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SetSessionOptionsResult* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.SetSessionOptionsResult"; }

 protected:
  explicit SetSessionOptionsResult(::google::protobuf::Arena* arena);
  SetSessionOptionsResult(::google::protobuf::Arena* arena, const SetSessionOptionsResult& from);
  SetSessionOptionsResult(::google::protobuf::Arena* arena, SetSessionOptionsResult&& from) noexcept
      : SetSessionOptionsResult(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Error = SetSessionOptionsResult_Error;
  using ErrorValue = SetSessionOptionsResult_ErrorValue;
  static constexpr ErrorValue UNSPECIFIED = SetSessionOptionsResult_ErrorValue_UNSPECIFIED;
  static constexpr ErrorValue INVALID_NAME = SetSessionOptionsResult_ErrorValue_INVALID_NAME;
  static constexpr ErrorValue INVALID_VALUE = SetSessionOptionsResult_ErrorValue_INVALID_VALUE;
  static constexpr ErrorValue ERROR = SetSessionOptionsResult_ErrorValue_ERROR;
  static inline bool ErrorValue_IsValid(int value) {
    return SetSessionOptionsResult_ErrorValue_IsValid(value);
  }
  static constexpr ErrorValue ErrorValue_MIN = SetSessionOptionsResult_ErrorValue_ErrorValue_MIN;
  static constexpr ErrorValue ErrorValue_MAX = SetSessionOptionsResult_ErrorValue_ErrorValue_MAX;
  static constexpr int ErrorValue_ARRAYSIZE = SetSessionOptionsResult_ErrorValue_ErrorValue_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ErrorValue_descriptor() {
    return SetSessionOptionsResult_ErrorValue_descriptor();
  }
  template <typename T>
  static inline const std::string& ErrorValue_Name(T value) {
    return SetSessionOptionsResult_ErrorValue_Name(value);
  }
  static inline bool ErrorValue_Parse(absl::string_view name, ErrorValue* value) {
    return SetSessionOptionsResult_ErrorValue_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kErrorsFieldNumber = 1,
  };
  // map<string, .arrow.flight.protocol.SetSessionOptionsResult.Error> errors = 1;
  int errors_size() const;
  private:
  int _internal_errors_size() const;

  public:
  void clear_errors() ;
  const ::google::protobuf::Map<std::string, ::arrow::flight::protocol::SetSessionOptionsResult_Error>& errors() const;
  ::google::protobuf::Map<std::string, ::arrow::flight::protocol::SetSessionOptionsResult_Error>* mutable_errors();

  private:
  const ::google::protobuf::Map<std::string, ::arrow::flight::protocol::SetSessionOptionsResult_Error>& _internal_errors() const;
  ::google::protobuf::Map<std::string, ::arrow::flight::protocol::SetSessionOptionsResult_Error>* _internal_mutable_errors();

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.SetSessionOptionsResult)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 2,
      60, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SetSessionOptionsResult& from_msg);
    ::google::protobuf::internal::MapField<SetSessionOptionsResult_ErrorsEntry_DoNotUse, std::string, ::arrow::flight::protocol::SetSessionOptionsResult_Error,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        errors_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Flight_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SetSessionOptionsResult_class_data_;
// -------------------------------------------------------------------

class SetSessionOptionsRequest_SessionOptionsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, ::google::protobuf::Message,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, ::google::protobuf::Message,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  SetSessionOptionsRequest_SessionOptionsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SetSessionOptionsRequest_SessionOptionsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit SetSessionOptionsRequest_SessionOptionsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const SetSessionOptionsRequest_SessionOptionsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const SetSessionOptionsRequest_SessionOptionsEntry_DoNotUse*>(
        &_SetSessionOptionsRequest_SessionOptionsEntry_DoNotUse_default_instance_);
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_Flight_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      78, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull SetSessionOptionsRequest_SessionOptionsEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class RenewFlightEndpointRequest final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.RenewFlightEndpointRequest) */ {
 public:
  inline RenewFlightEndpointRequest() : RenewFlightEndpointRequest(nullptr) {}
  ~RenewFlightEndpointRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RenewFlightEndpointRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RenewFlightEndpointRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RenewFlightEndpointRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline RenewFlightEndpointRequest(const RenewFlightEndpointRequest& from) : RenewFlightEndpointRequest(nullptr, from) {}
  inline RenewFlightEndpointRequest(RenewFlightEndpointRequest&& from) noexcept
      : RenewFlightEndpointRequest(nullptr, std::move(from)) {}
  inline RenewFlightEndpointRequest& operator=(const RenewFlightEndpointRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RenewFlightEndpointRequest& operator=(RenewFlightEndpointRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RenewFlightEndpointRequest& default_instance() {
    return *reinterpret_cast<const RenewFlightEndpointRequest*>(
        &_RenewFlightEndpointRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(RenewFlightEndpointRequest& a, RenewFlightEndpointRequest& b) { a.Swap(&b); }
  inline void Swap(RenewFlightEndpointRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RenewFlightEndpointRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RenewFlightEndpointRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RenewFlightEndpointRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RenewFlightEndpointRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RenewFlightEndpointRequest& from) { RenewFlightEndpointRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RenewFlightEndpointRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.RenewFlightEndpointRequest"; }

 protected:
  explicit RenewFlightEndpointRequest(::google::protobuf::Arena* arena);
  RenewFlightEndpointRequest(::google::protobuf::Arena* arena, const RenewFlightEndpointRequest& from);
  RenewFlightEndpointRequest(::google::protobuf::Arena* arena, RenewFlightEndpointRequest&& from) noexcept
      : RenewFlightEndpointRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEndpointFieldNumber = 1,
  };
  // .arrow.flight.protocol.FlightEndpoint endpoint = 1;
  bool has_endpoint() const;
  void clear_endpoint() ;
  const ::arrow::flight::protocol::FlightEndpoint& endpoint() const;
  [[nodiscard]] ::arrow::flight::protocol::FlightEndpoint* release_endpoint();
  ::arrow::flight::protocol::FlightEndpoint* mutable_endpoint();
  void set_allocated_endpoint(::arrow::flight::protocol::FlightEndpoint* value);
  void unsafe_arena_set_allocated_endpoint(::arrow::flight::protocol::FlightEndpoint* value);
  ::arrow::flight::protocol::FlightEndpoint* unsafe_arena_release_endpoint();

  private:
  const ::arrow::flight::protocol::FlightEndpoint& _internal_endpoint() const;
  ::arrow::flight::protocol::FlightEndpoint* _internal_mutable_endpoint();

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.RenewFlightEndpointRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RenewFlightEndpointRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::arrow::flight::protocol::FlightEndpoint* endpoint_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Flight_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RenewFlightEndpointRequest_class_data_;
// -------------------------------------------------------------------

class GetSessionOptionsResult_SessionOptionsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          std::string, ::google::protobuf::Message,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      std::string, ::google::protobuf::Message,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  GetSessionOptionsResult_SessionOptionsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetSessionOptionsResult_SessionOptionsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit GetSessionOptionsResult_SessionOptionsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const GetSessionOptionsResult_SessionOptionsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const GetSessionOptionsResult_SessionOptionsEntry_DoNotUse*>(
        &_GetSessionOptionsResult_SessionOptionsEntry_DoNotUse_default_instance_);
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_Flight_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      77, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull GetSessionOptionsResult_SessionOptionsEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class FlightInfo final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.FlightInfo) */ {
 public:
  inline FlightInfo() : FlightInfo(nullptr) {}
  ~FlightInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FlightInfo* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FlightInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FlightInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline FlightInfo(const FlightInfo& from) : FlightInfo(nullptr, from) {}
  inline FlightInfo(FlightInfo&& from) noexcept
      : FlightInfo(nullptr, std::move(from)) {}
  inline FlightInfo& operator=(const FlightInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlightInfo& operator=(FlightInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlightInfo& default_instance() {
    return *reinterpret_cast<const FlightInfo*>(
        &_FlightInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(FlightInfo& a, FlightInfo& b) { a.Swap(&b); }
  inline void Swap(FlightInfo* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlightInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlightInfo* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FlightInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FlightInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FlightInfo& from) { FlightInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FlightInfo* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.FlightInfo"; }

 protected:
  explicit FlightInfo(::google::protobuf::Arena* arena);
  FlightInfo(::google::protobuf::Arena* arena, const FlightInfo& from);
  FlightInfo(::google::protobuf::Arena* arena, FlightInfo&& from) noexcept
      : FlightInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEndpointFieldNumber = 3,
    kSchemaFieldNumber = 1,
    kAppMetadataFieldNumber = 7,
    kFlightDescriptorFieldNumber = 2,
    kTotalRecordsFieldNumber = 4,
    kTotalBytesFieldNumber = 5,
    kOrderedFieldNumber = 6,
  };
  // repeated .arrow.flight.protocol.FlightEndpoint endpoint = 3;
  int endpoint_size() const;
  private:
  int _internal_endpoint_size() const;

  public:
  void clear_endpoint() ;
  ::arrow::flight::protocol::FlightEndpoint* mutable_endpoint(int index);
  ::google::protobuf::RepeatedPtrField<::arrow::flight::protocol::FlightEndpoint>* mutable_endpoint();

  private:
  const ::google::protobuf::RepeatedPtrField<::arrow::flight::protocol::FlightEndpoint>& _internal_endpoint() const;
  ::google::protobuf::RepeatedPtrField<::arrow::flight::protocol::FlightEndpoint>* _internal_mutable_endpoint();
  public:
  const ::arrow::flight::protocol::FlightEndpoint& endpoint(int index) const;
  ::arrow::flight::protocol::FlightEndpoint* add_endpoint();
  const ::google::protobuf::RepeatedPtrField<::arrow::flight::protocol::FlightEndpoint>& endpoint() const;
  // bytes schema = 1;
  void clear_schema() ;
  const std::string& schema() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_schema(Arg_&& arg, Args_... args);
  std::string* mutable_schema();
  [[nodiscard]] std::string* release_schema();
  void set_allocated_schema(std::string* value);

  private:
  const std::string& _internal_schema() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_schema(const std::string& value);
  std::string* _internal_mutable_schema();

  public:
  // bytes app_metadata = 7;
  void clear_app_metadata() ;
  const std::string& app_metadata() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_app_metadata(Arg_&& arg, Args_... args);
  std::string* mutable_app_metadata();
  [[nodiscard]] std::string* release_app_metadata();
  void set_allocated_app_metadata(std::string* value);

  private:
  const std::string& _internal_app_metadata() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_app_metadata(const std::string& value);
  std::string* _internal_mutable_app_metadata();

  public:
  // .arrow.flight.protocol.FlightDescriptor flight_descriptor = 2;
  bool has_flight_descriptor() const;
  void clear_flight_descriptor() ;
  const ::arrow::flight::protocol::FlightDescriptor& flight_descriptor() const;
  [[nodiscard]] ::arrow::flight::protocol::FlightDescriptor* release_flight_descriptor();
  ::arrow::flight::protocol::FlightDescriptor* mutable_flight_descriptor();
  void set_allocated_flight_descriptor(::arrow::flight::protocol::FlightDescriptor* value);
  void unsafe_arena_set_allocated_flight_descriptor(::arrow::flight::protocol::FlightDescriptor* value);
  ::arrow::flight::protocol::FlightDescriptor* unsafe_arena_release_flight_descriptor();

  private:
  const ::arrow::flight::protocol::FlightDescriptor& _internal_flight_descriptor() const;
  ::arrow::flight::protocol::FlightDescriptor* _internal_mutable_flight_descriptor();

  public:
  // int64 total_records = 4;
  void clear_total_records() ;
  ::int64_t total_records() const;
  void set_total_records(::int64_t value);

  private:
  ::int64_t _internal_total_records() const;
  void _internal_set_total_records(::int64_t value);

  public:
  // int64 total_bytes = 5;
  void clear_total_bytes() ;
  ::int64_t total_bytes() const;
  void set_total_bytes(::int64_t value);

  private:
  ::int64_t _internal_total_bytes() const;
  void _internal_set_total_bytes(::int64_t value);

  public:
  // bool ordered = 6;
  void clear_ordered() ;
  bool ordered() const;
  void set_ordered(bool value);

  private:
  bool _internal_ordered() const;
  void _internal_set_ordered(bool value);

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.FlightInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FlightInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::arrow::flight::protocol::FlightEndpoint > endpoint_;
    ::google::protobuf::internal::ArenaStringPtr schema_;
    ::google::protobuf::internal::ArenaStringPtr app_metadata_;
    ::arrow::flight::protocol::FlightDescriptor* flight_descriptor_;
    ::int64_t total_records_;
    ::int64_t total_bytes_;
    bool ordered_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Flight_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull FlightInfo_class_data_;
// -------------------------------------------------------------------

class SetSessionOptionsRequest final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.SetSessionOptionsRequest) */ {
 public:
  inline SetSessionOptionsRequest() : SetSessionOptionsRequest(nullptr) {}
  ~SetSessionOptionsRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SetSessionOptionsRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SetSessionOptionsRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SetSessionOptionsRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline SetSessionOptionsRequest(const SetSessionOptionsRequest& from) : SetSessionOptionsRequest(nullptr, from) {}
  inline SetSessionOptionsRequest(SetSessionOptionsRequest&& from) noexcept
      : SetSessionOptionsRequest(nullptr, std::move(from)) {}
  inline SetSessionOptionsRequest& operator=(const SetSessionOptionsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetSessionOptionsRequest& operator=(SetSessionOptionsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetSessionOptionsRequest& default_instance() {
    return *reinterpret_cast<const SetSessionOptionsRequest*>(
        &_SetSessionOptionsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(SetSessionOptionsRequest& a, SetSessionOptionsRequest& b) { a.Swap(&b); }
  inline void Swap(SetSessionOptionsRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetSessionOptionsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetSessionOptionsRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SetSessionOptionsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SetSessionOptionsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SetSessionOptionsRequest& from) { SetSessionOptionsRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SetSessionOptionsRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.SetSessionOptionsRequest"; }

 protected:
  explicit SetSessionOptionsRequest(::google::protobuf::Arena* arena);
  SetSessionOptionsRequest(::google::protobuf::Arena* arena, const SetSessionOptionsRequest& from);
  SetSessionOptionsRequest(::google::protobuf::Arena* arena, SetSessionOptionsRequest&& from) noexcept
      : SetSessionOptionsRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSessionOptionsFieldNumber = 1,
  };
  // map<string, .arrow.flight.protocol.SessionOptionValue> session_options = 1;
  int session_options_size() const;
  private:
  int _internal_session_options_size() const;

  public:
  void clear_session_options() ;
  const ::google::protobuf::Map<std::string, ::arrow::flight::protocol::SessionOptionValue>& session_options() const;
  ::google::protobuf::Map<std::string, ::arrow::flight::protocol::SessionOptionValue>* mutable_session_options();

  private:
  const ::google::protobuf::Map<std::string, ::arrow::flight::protocol::SessionOptionValue>& _internal_session_options() const;
  ::google::protobuf::Map<std::string, ::arrow::flight::protocol::SessionOptionValue>* _internal_mutable_session_options();

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.SetSessionOptionsRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 2,
      70, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SetSessionOptionsRequest& from_msg);
    ::google::protobuf::internal::MapField<SetSessionOptionsRequest_SessionOptionsEntry_DoNotUse, std::string, ::arrow::flight::protocol::SessionOptionValue,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        session_options_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Flight_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SetSessionOptionsRequest_class_data_;
// -------------------------------------------------------------------

class PollInfo final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.PollInfo) */ {
 public:
  inline PollInfo() : PollInfo(nullptr) {}
  ~PollInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PollInfo* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PollInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PollInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline PollInfo(const PollInfo& from) : PollInfo(nullptr, from) {}
  inline PollInfo(PollInfo&& from) noexcept
      : PollInfo(nullptr, std::move(from)) {}
  inline PollInfo& operator=(const PollInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PollInfo& operator=(PollInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PollInfo& default_instance() {
    return *reinterpret_cast<const PollInfo*>(
        &_PollInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(PollInfo& a, PollInfo& b) { a.Swap(&b); }
  inline void Swap(PollInfo* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PollInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PollInfo* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PollInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PollInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PollInfo& from) { PollInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PollInfo* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.PollInfo"; }

 protected:
  explicit PollInfo(::google::protobuf::Arena* arena);
  PollInfo(::google::protobuf::Arena* arena, const PollInfo& from);
  PollInfo(::google::protobuf::Arena* arena, PollInfo&& from) noexcept
      : PollInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInfoFieldNumber = 1,
    kFlightDescriptorFieldNumber = 2,
    kExpirationTimeFieldNumber = 4,
    kProgressFieldNumber = 3,
  };
  // .arrow.flight.protocol.FlightInfo info = 1;
  bool has_info() const;
  void clear_info() ;
  const ::arrow::flight::protocol::FlightInfo& info() const;
  [[nodiscard]] ::arrow::flight::protocol::FlightInfo* release_info();
  ::arrow::flight::protocol::FlightInfo* mutable_info();
  void set_allocated_info(::arrow::flight::protocol::FlightInfo* value);
  void unsafe_arena_set_allocated_info(::arrow::flight::protocol::FlightInfo* value);
  ::arrow::flight::protocol::FlightInfo* unsafe_arena_release_info();

  private:
  const ::arrow::flight::protocol::FlightInfo& _internal_info() const;
  ::arrow::flight::protocol::FlightInfo* _internal_mutable_info();

  public:
  // .arrow.flight.protocol.FlightDescriptor flight_descriptor = 2;
  bool has_flight_descriptor() const;
  void clear_flight_descriptor() ;
  const ::arrow::flight::protocol::FlightDescriptor& flight_descriptor() const;
  [[nodiscard]] ::arrow::flight::protocol::FlightDescriptor* release_flight_descriptor();
  ::arrow::flight::protocol::FlightDescriptor* mutable_flight_descriptor();
  void set_allocated_flight_descriptor(::arrow::flight::protocol::FlightDescriptor* value);
  void unsafe_arena_set_allocated_flight_descriptor(::arrow::flight::protocol::FlightDescriptor* value);
  ::arrow::flight::protocol::FlightDescriptor* unsafe_arena_release_flight_descriptor();

  private:
  const ::arrow::flight::protocol::FlightDescriptor& _internal_flight_descriptor() const;
  ::arrow::flight::protocol::FlightDescriptor* _internal_mutable_flight_descriptor();

  public:
  // .google.protobuf.Timestamp expiration_time = 4;
  bool has_expiration_time() const;
  void clear_expiration_time() ;
  const ::google::protobuf::Timestamp& expiration_time() const;
  [[nodiscard]] ::google::protobuf::Timestamp* release_expiration_time();
  ::google::protobuf::Timestamp* mutable_expiration_time();
  void set_allocated_expiration_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_expiration_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_expiration_time();

  private:
  const ::google::protobuf::Timestamp& _internal_expiration_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_expiration_time();

  public:
  // optional double progress = 3;
  bool has_progress() const;
  void clear_progress() ;
  double progress() const;
  void set_progress(double value);

  private:
  double _internal_progress() const;
  void _internal_set_progress(double value);

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.PollInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 3,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PollInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::arrow::flight::protocol::FlightInfo* info_;
    ::arrow::flight::protocol::FlightDescriptor* flight_descriptor_;
    ::google::protobuf::Timestamp* expiration_time_;
    double progress_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Flight_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PollInfo_class_data_;
// -------------------------------------------------------------------

class GetSessionOptionsResult final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.GetSessionOptionsResult) */ {
 public:
  inline GetSessionOptionsResult() : GetSessionOptionsResult(nullptr) {}
  ~GetSessionOptionsResult() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetSessionOptionsResult* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetSessionOptionsResult));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetSessionOptionsResult(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetSessionOptionsResult(const GetSessionOptionsResult& from) : GetSessionOptionsResult(nullptr, from) {}
  inline GetSessionOptionsResult(GetSessionOptionsResult&& from) noexcept
      : GetSessionOptionsResult(nullptr, std::move(from)) {}
  inline GetSessionOptionsResult& operator=(const GetSessionOptionsResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSessionOptionsResult& operator=(GetSessionOptionsResult&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSessionOptionsResult& default_instance() {
    return *reinterpret_cast<const GetSessionOptionsResult*>(
        &_GetSessionOptionsResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 29;
  friend void swap(GetSessionOptionsResult& a, GetSessionOptionsResult& b) { a.Swap(&b); }
  inline void Swap(GetSessionOptionsResult* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSessionOptionsResult* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSessionOptionsResult* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetSessionOptionsResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetSessionOptionsResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetSessionOptionsResult& from) { GetSessionOptionsResult::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetSessionOptionsResult* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.GetSessionOptionsResult"; }

 protected:
  explicit GetSessionOptionsResult(::google::protobuf::Arena* arena);
  GetSessionOptionsResult(::google::protobuf::Arena* arena, const GetSessionOptionsResult& from);
  GetSessionOptionsResult(::google::protobuf::Arena* arena, GetSessionOptionsResult&& from) noexcept
      : GetSessionOptionsResult(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSessionOptionsFieldNumber = 1,
  };
  // map<string, .arrow.flight.protocol.SessionOptionValue> session_options = 1;
  int session_options_size() const;
  private:
  int _internal_session_options_size() const;

  public:
  void clear_session_options() ;
  const ::google::protobuf::Map<std::string, ::arrow::flight::protocol::SessionOptionValue>& session_options() const;
  ::google::protobuf::Map<std::string, ::arrow::flight::protocol::SessionOptionValue>* mutable_session_options();

  private:
  const ::google::protobuf::Map<std::string, ::arrow::flight::protocol::SessionOptionValue>& _internal_session_options() const;
  ::google::protobuf::Map<std::string, ::arrow::flight::protocol::SessionOptionValue>* _internal_mutable_session_options();

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.GetSessionOptionsResult)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 2,
      69, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetSessionOptionsResult& from_msg);
    ::google::protobuf::internal::MapField<GetSessionOptionsResult_SessionOptionsEntry_DoNotUse, std::string, ::arrow::flight::protocol::SessionOptionValue,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        session_options_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Flight_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GetSessionOptionsResult_class_data_;
// -------------------------------------------------------------------

class CancelFlightInfoRequest final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:arrow.flight.protocol.CancelFlightInfoRequest) */ {
 public:
  inline CancelFlightInfoRequest() : CancelFlightInfoRequest(nullptr) {}
  ~CancelFlightInfoRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CancelFlightInfoRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CancelFlightInfoRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CancelFlightInfoRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline CancelFlightInfoRequest(const CancelFlightInfoRequest& from) : CancelFlightInfoRequest(nullptr, from) {}
  inline CancelFlightInfoRequest(CancelFlightInfoRequest&& from) noexcept
      : CancelFlightInfoRequest(nullptr, std::move(from)) {}
  inline CancelFlightInfoRequest& operator=(const CancelFlightInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelFlightInfoRequest& operator=(CancelFlightInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelFlightInfoRequest& default_instance() {
    return *reinterpret_cast<const CancelFlightInfoRequest*>(
        &_CancelFlightInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(CancelFlightInfoRequest& a, CancelFlightInfoRequest& b) { a.Swap(&b); }
  inline void Swap(CancelFlightInfoRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelFlightInfoRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CancelFlightInfoRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CancelFlightInfoRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CancelFlightInfoRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CancelFlightInfoRequest& from) { CancelFlightInfoRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CancelFlightInfoRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "arrow.flight.protocol.CancelFlightInfoRequest"; }

 protected:
  explicit CancelFlightInfoRequest(::google::protobuf::Arena* arena);
  CancelFlightInfoRequest(::google::protobuf::Arena* arena, const CancelFlightInfoRequest& from);
  CancelFlightInfoRequest(::google::protobuf::Arena* arena, CancelFlightInfoRequest&& from) noexcept
      : CancelFlightInfoRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInfoFieldNumber = 1,
  };
  // .arrow.flight.protocol.FlightInfo info = 1;
  bool has_info() const;
  void clear_info() ;
  const ::arrow::flight::protocol::FlightInfo& info() const;
  [[nodiscard]] ::arrow::flight::protocol::FlightInfo* release_info();
  ::arrow::flight::protocol::FlightInfo* mutable_info();
  void set_allocated_info(::arrow::flight::protocol::FlightInfo* value);
  void unsafe_arena_set_allocated_info(::arrow::flight::protocol::FlightInfo* value);
  ::arrow::flight::protocol::FlightInfo* unsafe_arena_release_info();

  private:
  const ::arrow::flight::protocol::FlightInfo& _internal_info() const;
  ::arrow::flight::protocol::FlightInfo* _internal_mutable_info();

  public:
  // @@protoc_insertion_point(class_scope:arrow.flight.protocol.CancelFlightInfoRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CancelFlightInfoRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::arrow::flight::protocol::FlightInfo* info_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Flight_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CancelFlightInfoRequest_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// HandshakeRequest

// uint64 protocol_version = 1;
inline void HandshakeRequest::clear_protocol_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.protocol_version_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t HandshakeRequest::protocol_version() const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.HandshakeRequest.protocol_version)
  return _internal_protocol_version();
}
inline void HandshakeRequest::set_protocol_version(::uint64_t value) {
  _internal_set_protocol_version(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.HandshakeRequest.protocol_version)
}
inline ::uint64_t HandshakeRequest::_internal_protocol_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.protocol_version_;
}
inline void HandshakeRequest::_internal_set_protocol_version(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.protocol_version_ = value;
}

// bytes payload = 2;
inline void HandshakeRequest::clear_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.payload_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HandshakeRequest::payload() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.HandshakeRequest.payload)
  return _internal_payload();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void HandshakeRequest::set_payload(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.payload_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.HandshakeRequest.payload)
}
inline std::string* HandshakeRequest::mutable_payload() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.HandshakeRequest.payload)
  return _s;
}
inline const std::string& HandshakeRequest::_internal_payload() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.payload_.Get();
}
inline void HandshakeRequest::_internal_set_payload(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.payload_.Set(value, GetArena());
}
inline std::string* HandshakeRequest::_internal_mutable_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.payload_.Mutable( GetArena());
}
inline std::string* HandshakeRequest::release_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.HandshakeRequest.payload)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.payload_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.payload_.Set("", GetArena());
  }
  return released;
}
inline void HandshakeRequest::set_allocated_payload(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.payload_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.payload_.IsDefault()) {
    _impl_.payload_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.HandshakeRequest.payload)
}

// -------------------------------------------------------------------

// HandshakeResponse

// uint64 protocol_version = 1;
inline void HandshakeResponse::clear_protocol_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.protocol_version_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t HandshakeResponse::protocol_version() const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.HandshakeResponse.protocol_version)
  return _internal_protocol_version();
}
inline void HandshakeResponse::set_protocol_version(::uint64_t value) {
  _internal_set_protocol_version(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.HandshakeResponse.protocol_version)
}
inline ::uint64_t HandshakeResponse::_internal_protocol_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.protocol_version_;
}
inline void HandshakeResponse::_internal_set_protocol_version(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.protocol_version_ = value;
}

// bytes payload = 2;
inline void HandshakeResponse::clear_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.payload_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HandshakeResponse::payload() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.HandshakeResponse.payload)
  return _internal_payload();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void HandshakeResponse::set_payload(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.payload_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.HandshakeResponse.payload)
}
inline std::string* HandshakeResponse::mutable_payload() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.HandshakeResponse.payload)
  return _s;
}
inline const std::string& HandshakeResponse::_internal_payload() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.payload_.Get();
}
inline void HandshakeResponse::_internal_set_payload(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.payload_.Set(value, GetArena());
}
inline std::string* HandshakeResponse::_internal_mutable_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.payload_.Mutable( GetArena());
}
inline std::string* HandshakeResponse::release_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.HandshakeResponse.payload)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.payload_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.payload_.Set("", GetArena());
  }
  return released;
}
inline void HandshakeResponse::set_allocated_payload(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.payload_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.payload_.IsDefault()) {
    _impl_.payload_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.HandshakeResponse.payload)
}

// -------------------------------------------------------------------

// BasicAuth

// string username = 2;
inline void BasicAuth::clear_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BasicAuth::username() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.BasicAuth.username)
  return _internal_username();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void BasicAuth::set_username(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.username_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.BasicAuth.username)
}
inline std::string* BasicAuth::mutable_username() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.BasicAuth.username)
  return _s;
}
inline const std::string& BasicAuth::_internal_username() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.username_.Get();
}
inline void BasicAuth::_internal_set_username(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.username_.Set(value, GetArena());
}
inline std::string* BasicAuth::_internal_mutable_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.username_.Mutable( GetArena());
}
inline std::string* BasicAuth::release_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.BasicAuth.username)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.username_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.username_.Set("", GetArena());
  }
  return released;
}
inline void BasicAuth::set_allocated_username(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.username_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.BasicAuth.username)
}

// string password = 3;
inline void BasicAuth::clear_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BasicAuth::password() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.BasicAuth.password)
  return _internal_password();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void BasicAuth::set_password(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.password_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.BasicAuth.password)
}
inline std::string* BasicAuth::mutable_password() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.BasicAuth.password)
  return _s;
}
inline const std::string& BasicAuth::_internal_password() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.password_.Get();
}
inline void BasicAuth::_internal_set_password(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.password_.Set(value, GetArena());
}
inline std::string* BasicAuth::_internal_mutable_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.password_.Mutable( GetArena());
}
inline std::string* BasicAuth::release_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.BasicAuth.password)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.password_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.password_.Set("", GetArena());
  }
  return released;
}
inline void BasicAuth::set_allocated_password(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.password_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.BasicAuth.password)
}

// -------------------------------------------------------------------

// Empty

// -------------------------------------------------------------------

// ActionType

// string type = 1;
inline void ActionType::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ActionType::type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.ActionType.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ActionType::set_type(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.ActionType.type)
}
inline std::string* ActionType::mutable_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.ActionType.type)
  return _s;
}
inline const std::string& ActionType::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.type_.Get();
}
inline void ActionType::_internal_set_type(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_.Set(value, GetArena());
}
inline std::string* ActionType::_internal_mutable_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.type_.Mutable( GetArena());
}
inline std::string* ActionType::release_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.ActionType.type)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.type_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.type_.Set("", GetArena());
  }
  return released;
}
inline void ActionType::set_allocated_type(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.ActionType.type)
}

// string description = 2;
inline void ActionType::clear_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ActionType::description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.ActionType.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ActionType::set_description(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.ActionType.description)
}
inline std::string* ActionType::mutable_description() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.ActionType.description)
  return _s;
}
inline const std::string& ActionType::_internal_description() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.description_.Get();
}
inline void ActionType::_internal_set_description(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.description_.Set(value, GetArena());
}
inline std::string* ActionType::_internal_mutable_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.description_.Mutable( GetArena());
}
inline std::string* ActionType::release_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.ActionType.description)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.description_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.description_.Set("", GetArena());
  }
  return released;
}
inline void ActionType::set_allocated_description(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.description_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.ActionType.description)
}

// -------------------------------------------------------------------

// Criteria

// bytes expression = 1;
inline void Criteria::clear_expression() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expression_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Criteria::expression() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.Criteria.expression)
  return _internal_expression();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Criteria::set_expression(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.expression_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.Criteria.expression)
}
inline std::string* Criteria::mutable_expression() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_expression();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.Criteria.expression)
  return _s;
}
inline const std::string& Criteria::_internal_expression() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.expression_.Get();
}
inline void Criteria::_internal_set_expression(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.expression_.Set(value, GetArena());
}
inline std::string* Criteria::_internal_mutable_expression() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.expression_.Mutable( GetArena());
}
inline std::string* Criteria::release_expression() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.Criteria.expression)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.expression_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.expression_.Set("", GetArena());
  }
  return released;
}
inline void Criteria::set_allocated_expression(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.expression_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.expression_.IsDefault()) {
    _impl_.expression_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.Criteria.expression)
}

// -------------------------------------------------------------------

// Action

// string type = 1;
inline void Action::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Action::type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.Action.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Action::set_type(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.Action.type)
}
inline std::string* Action::mutable_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.Action.type)
  return _s;
}
inline const std::string& Action::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.type_.Get();
}
inline void Action::_internal_set_type(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_.Set(value, GetArena());
}
inline std::string* Action::_internal_mutable_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.type_.Mutable( GetArena());
}
inline std::string* Action::release_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.Action.type)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.type_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.type_.Set("", GetArena());
  }
  return released;
}
inline void Action::set_allocated_type(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.Action.type)
}

// bytes body = 2;
inline void Action::clear_body() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.body_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Action::body() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.Action.body)
  return _internal_body();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Action::set_body(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.body_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.Action.body)
}
inline std::string* Action::mutable_body() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.Action.body)
  return _s;
}
inline const std::string& Action::_internal_body() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.body_.Get();
}
inline void Action::_internal_set_body(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.body_.Set(value, GetArena());
}
inline std::string* Action::_internal_mutable_body() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.body_.Mutable( GetArena());
}
inline std::string* Action::release_body() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.Action.body)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.body_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.body_.Set("", GetArena());
  }
  return released;
}
inline void Action::set_allocated_body(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.body_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.body_.IsDefault()) {
    _impl_.body_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.Action.body)
}

// -------------------------------------------------------------------

// Result

// bytes body = 1;
inline void Result::clear_body() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.body_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Result::body() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.Result.body)
  return _internal_body();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Result::set_body(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.body_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.Result.body)
}
inline std::string* Result::mutable_body() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.Result.body)
  return _s;
}
inline const std::string& Result::_internal_body() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.body_.Get();
}
inline void Result::_internal_set_body(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.body_.Set(value, GetArena());
}
inline std::string* Result::_internal_mutable_body() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.body_.Mutable( GetArena());
}
inline std::string* Result::release_body() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.Result.body)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.body_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.body_.Set("", GetArena());
  }
  return released;
}
inline void Result::set_allocated_body(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.body_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.body_.IsDefault()) {
    _impl_.body_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.Result.body)
}

// -------------------------------------------------------------------

// SchemaResult

// bytes schema = 1;
inline void SchemaResult::clear_schema() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.schema_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SchemaResult::schema() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.SchemaResult.schema)
  return _internal_schema();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SchemaResult::set_schema(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.schema_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.SchemaResult.schema)
}
inline std::string* SchemaResult::mutable_schema() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_schema();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.SchemaResult.schema)
  return _s;
}
inline const std::string& SchemaResult::_internal_schema() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.schema_.Get();
}
inline void SchemaResult::_internal_set_schema(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.schema_.Set(value, GetArena());
}
inline std::string* SchemaResult::_internal_mutable_schema() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.schema_.Mutable( GetArena());
}
inline std::string* SchemaResult::release_schema() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.SchemaResult.schema)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.schema_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.schema_.Set("", GetArena());
  }
  return released;
}
inline void SchemaResult::set_allocated_schema(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.schema_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.schema_.IsDefault()) {
    _impl_.schema_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.SchemaResult.schema)
}

// -------------------------------------------------------------------

// FlightDescriptor

// .arrow.flight.protocol.FlightDescriptor.DescriptorType type = 1;
inline void FlightDescriptor::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::arrow::flight::protocol::FlightDescriptor_DescriptorType FlightDescriptor::type() const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.FlightDescriptor.type)
  return _internal_type();
}
inline void FlightDescriptor::set_type(::arrow::flight::protocol::FlightDescriptor_DescriptorType value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.FlightDescriptor.type)
}
inline ::arrow::flight::protocol::FlightDescriptor_DescriptorType FlightDescriptor::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::arrow::flight::protocol::FlightDescriptor_DescriptorType>(_impl_.type_);
}
inline void FlightDescriptor::_internal_set_type(::arrow::flight::protocol::FlightDescriptor_DescriptorType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// bytes cmd = 2;
inline void FlightDescriptor::clear_cmd() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cmd_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FlightDescriptor::cmd() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.FlightDescriptor.cmd)
  return _internal_cmd();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void FlightDescriptor::set_cmd(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.cmd_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.FlightDescriptor.cmd)
}
inline std::string* FlightDescriptor::mutable_cmd() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_cmd();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.FlightDescriptor.cmd)
  return _s;
}
inline const std::string& FlightDescriptor::_internal_cmd() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cmd_.Get();
}
inline void FlightDescriptor::_internal_set_cmd(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.cmd_.Set(value, GetArena());
}
inline std::string* FlightDescriptor::_internal_mutable_cmd() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.cmd_.Mutable( GetArena());
}
inline std::string* FlightDescriptor::release_cmd() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.FlightDescriptor.cmd)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.cmd_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.cmd_.Set("", GetArena());
  }
  return released;
}
inline void FlightDescriptor::set_allocated_cmd(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.cmd_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.cmd_.IsDefault()) {
    _impl_.cmd_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.FlightDescriptor.cmd)
}

// repeated string path = 3;
inline int FlightDescriptor::_internal_path_size() const {
  return _internal_path().size();
}
inline int FlightDescriptor::path_size() const {
  return _internal_path_size();
}
inline void FlightDescriptor::clear_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.path_.Clear();
}
inline std::string* FlightDescriptor::add_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_path()->Add();
  // @@protoc_insertion_point(field_add_mutable:arrow.flight.protocol.FlightDescriptor.path)
  return _s;
}
inline const std::string& FlightDescriptor::path(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.FlightDescriptor.path)
  return _internal_path().Get(index);
}
inline std::string* FlightDescriptor::mutable_path(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.FlightDescriptor.path)
  return _internal_mutable_path()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void FlightDescriptor::set_path(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_path()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.FlightDescriptor.path)
}
template <typename Arg_, typename... Args_>
inline void FlightDescriptor::add_path(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_path(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:arrow.flight.protocol.FlightDescriptor.path)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
FlightDescriptor::path() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:arrow.flight.protocol.FlightDescriptor.path)
  return _internal_path();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
FlightDescriptor::mutable_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:arrow.flight.protocol.FlightDescriptor.path)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_path();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
FlightDescriptor::_internal_path() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.path_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
FlightDescriptor::_internal_mutable_path() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.path_;
}

// -------------------------------------------------------------------

// FlightInfo

// bytes schema = 1;
inline void FlightInfo::clear_schema() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.schema_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FlightInfo::schema() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.FlightInfo.schema)
  return _internal_schema();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void FlightInfo::set_schema(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.schema_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.FlightInfo.schema)
}
inline std::string* FlightInfo::mutable_schema() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_schema();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.FlightInfo.schema)
  return _s;
}
inline const std::string& FlightInfo::_internal_schema() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.schema_.Get();
}
inline void FlightInfo::_internal_set_schema(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.schema_.Set(value, GetArena());
}
inline std::string* FlightInfo::_internal_mutable_schema() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.schema_.Mutable( GetArena());
}
inline std::string* FlightInfo::release_schema() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.FlightInfo.schema)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.schema_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.schema_.Set("", GetArena());
  }
  return released;
}
inline void FlightInfo::set_allocated_schema(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.schema_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.schema_.IsDefault()) {
    _impl_.schema_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.FlightInfo.schema)
}

// .arrow.flight.protocol.FlightDescriptor flight_descriptor = 2;
inline bool FlightInfo::has_flight_descriptor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.flight_descriptor_ != nullptr);
  return value;
}
inline void FlightInfo::clear_flight_descriptor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.flight_descriptor_ != nullptr) _impl_.flight_descriptor_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::arrow::flight::protocol::FlightDescriptor& FlightInfo::_internal_flight_descriptor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::arrow::flight::protocol::FlightDescriptor* p = _impl_.flight_descriptor_;
  return p != nullptr ? *p : reinterpret_cast<const ::arrow::flight::protocol::FlightDescriptor&>(::arrow::flight::protocol::_FlightDescriptor_default_instance_);
}
inline const ::arrow::flight::protocol::FlightDescriptor& FlightInfo::flight_descriptor() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.FlightInfo.flight_descriptor)
  return _internal_flight_descriptor();
}
inline void FlightInfo::unsafe_arena_set_allocated_flight_descriptor(::arrow::flight::protocol::FlightDescriptor* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.flight_descriptor_);
  }
  _impl_.flight_descriptor_ = reinterpret_cast<::arrow::flight::protocol::FlightDescriptor*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:arrow.flight.protocol.FlightInfo.flight_descriptor)
}
inline ::arrow::flight::protocol::FlightDescriptor* FlightInfo::release_flight_descriptor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::arrow::flight::protocol::FlightDescriptor* released = _impl_.flight_descriptor_;
  _impl_.flight_descriptor_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::arrow::flight::protocol::FlightDescriptor* FlightInfo::unsafe_arena_release_flight_descriptor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.FlightInfo.flight_descriptor)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::arrow::flight::protocol::FlightDescriptor* temp = _impl_.flight_descriptor_;
  _impl_.flight_descriptor_ = nullptr;
  return temp;
}
inline ::arrow::flight::protocol::FlightDescriptor* FlightInfo::_internal_mutable_flight_descriptor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.flight_descriptor_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::arrow::flight::protocol::FlightDescriptor>(GetArena());
    _impl_.flight_descriptor_ = reinterpret_cast<::arrow::flight::protocol::FlightDescriptor*>(p);
  }
  return _impl_.flight_descriptor_;
}
inline ::arrow::flight::protocol::FlightDescriptor* FlightInfo::mutable_flight_descriptor() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::arrow::flight::protocol::FlightDescriptor* _msg = _internal_mutable_flight_descriptor();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.FlightInfo.flight_descriptor)
  return _msg;
}
inline void FlightInfo::set_allocated_flight_descriptor(::arrow::flight::protocol::FlightDescriptor* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.flight_descriptor_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.flight_descriptor_ = reinterpret_cast<::arrow::flight::protocol::FlightDescriptor*>(value);
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.FlightInfo.flight_descriptor)
}

// repeated .arrow.flight.protocol.FlightEndpoint endpoint = 3;
inline int FlightInfo::_internal_endpoint_size() const {
  return _internal_endpoint().size();
}
inline int FlightInfo::endpoint_size() const {
  return _internal_endpoint_size();
}
inline void FlightInfo::clear_endpoint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.endpoint_.Clear();
}
inline ::arrow::flight::protocol::FlightEndpoint* FlightInfo::mutable_endpoint(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.FlightInfo.endpoint)
  return _internal_mutable_endpoint()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::arrow::flight::protocol::FlightEndpoint>* FlightInfo::mutable_endpoint()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:arrow.flight.protocol.FlightInfo.endpoint)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_endpoint();
}
inline const ::arrow::flight::protocol::FlightEndpoint& FlightInfo::endpoint(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.FlightInfo.endpoint)
  return _internal_endpoint().Get(index);
}
inline ::arrow::flight::protocol::FlightEndpoint* FlightInfo::add_endpoint() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::arrow::flight::protocol::FlightEndpoint* _add = _internal_mutable_endpoint()->Add();
  // @@protoc_insertion_point(field_add:arrow.flight.protocol.FlightInfo.endpoint)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::arrow::flight::protocol::FlightEndpoint>& FlightInfo::endpoint() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:arrow.flight.protocol.FlightInfo.endpoint)
  return _internal_endpoint();
}
inline const ::google::protobuf::RepeatedPtrField<::arrow::flight::protocol::FlightEndpoint>&
FlightInfo::_internal_endpoint() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.endpoint_;
}
inline ::google::protobuf::RepeatedPtrField<::arrow::flight::protocol::FlightEndpoint>*
FlightInfo::_internal_mutable_endpoint() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.endpoint_;
}

// int64 total_records = 4;
inline void FlightInfo::clear_total_records() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_records_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int64_t FlightInfo::total_records() const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.FlightInfo.total_records)
  return _internal_total_records();
}
inline void FlightInfo::set_total_records(::int64_t value) {
  _internal_set_total_records(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.FlightInfo.total_records)
}
inline ::int64_t FlightInfo::_internal_total_records() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_records_;
}
inline void FlightInfo::_internal_set_total_records(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_records_ = value;
}

// int64 total_bytes = 5;
inline void FlightInfo::clear_total_bytes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_bytes_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int64_t FlightInfo::total_bytes() const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.FlightInfo.total_bytes)
  return _internal_total_bytes();
}
inline void FlightInfo::set_total_bytes(::int64_t value) {
  _internal_set_total_bytes(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.FlightInfo.total_bytes)
}
inline ::int64_t FlightInfo::_internal_total_bytes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_bytes_;
}
inline void FlightInfo::_internal_set_total_bytes(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_bytes_ = value;
}

// bool ordered = 6;
inline void FlightInfo::clear_ordered() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ordered_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool FlightInfo::ordered() const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.FlightInfo.ordered)
  return _internal_ordered();
}
inline void FlightInfo::set_ordered(bool value) {
  _internal_set_ordered(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.FlightInfo.ordered)
}
inline bool FlightInfo::_internal_ordered() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ordered_;
}
inline void FlightInfo::_internal_set_ordered(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ordered_ = value;
}

// bytes app_metadata = 7;
inline void FlightInfo::clear_app_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.app_metadata_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& FlightInfo::app_metadata() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.FlightInfo.app_metadata)
  return _internal_app_metadata();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void FlightInfo::set_app_metadata(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.app_metadata_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.FlightInfo.app_metadata)
}
inline std::string* FlightInfo::mutable_app_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_app_metadata();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.FlightInfo.app_metadata)
  return _s;
}
inline const std::string& FlightInfo::_internal_app_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.app_metadata_.Get();
}
inline void FlightInfo::_internal_set_app_metadata(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.app_metadata_.Set(value, GetArena());
}
inline std::string* FlightInfo::_internal_mutable_app_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.app_metadata_.Mutable( GetArena());
}
inline std::string* FlightInfo::release_app_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.FlightInfo.app_metadata)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.app_metadata_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.app_metadata_.Set("", GetArena());
  }
  return released;
}
inline void FlightInfo::set_allocated_app_metadata(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.app_metadata_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.app_metadata_.IsDefault()) {
    _impl_.app_metadata_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.FlightInfo.app_metadata)
}

// -------------------------------------------------------------------

// PollInfo

// .arrow.flight.protocol.FlightInfo info = 1;
inline bool PollInfo::has_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.info_ != nullptr);
  return value;
}
inline void PollInfo::clear_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.info_ != nullptr) _impl_.info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::arrow::flight::protocol::FlightInfo& PollInfo::_internal_info() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::arrow::flight::protocol::FlightInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::arrow::flight::protocol::FlightInfo&>(::arrow::flight::protocol::_FlightInfo_default_instance_);
}
inline const ::arrow::flight::protocol::FlightInfo& PollInfo::info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.PollInfo.info)
  return _internal_info();
}
inline void PollInfo::unsafe_arena_set_allocated_info(::arrow::flight::protocol::FlightInfo* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = reinterpret_cast<::arrow::flight::protocol::FlightInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:arrow.flight.protocol.PollInfo.info)
}
inline ::arrow::flight::protocol::FlightInfo* PollInfo::release_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::arrow::flight::protocol::FlightInfo* released = _impl_.info_;
  _impl_.info_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::arrow::flight::protocol::FlightInfo* PollInfo::unsafe_arena_release_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.PollInfo.info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::arrow::flight::protocol::FlightInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::arrow::flight::protocol::FlightInfo* PollInfo::_internal_mutable_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.info_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::arrow::flight::protocol::FlightInfo>(GetArena());
    _impl_.info_ = reinterpret_cast<::arrow::flight::protocol::FlightInfo*>(p);
  }
  return _impl_.info_;
}
inline ::arrow::flight::protocol::FlightInfo* PollInfo::mutable_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::arrow::flight::protocol::FlightInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.PollInfo.info)
  return _msg;
}
inline void PollInfo::set_allocated_info(::arrow::flight::protocol::FlightInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.info_ = reinterpret_cast<::arrow::flight::protocol::FlightInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.PollInfo.info)
}

// .arrow.flight.protocol.FlightDescriptor flight_descriptor = 2;
inline bool PollInfo::has_flight_descriptor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.flight_descriptor_ != nullptr);
  return value;
}
inline void PollInfo::clear_flight_descriptor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.flight_descriptor_ != nullptr) _impl_.flight_descriptor_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::arrow::flight::protocol::FlightDescriptor& PollInfo::_internal_flight_descriptor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::arrow::flight::protocol::FlightDescriptor* p = _impl_.flight_descriptor_;
  return p != nullptr ? *p : reinterpret_cast<const ::arrow::flight::protocol::FlightDescriptor&>(::arrow::flight::protocol::_FlightDescriptor_default_instance_);
}
inline const ::arrow::flight::protocol::FlightDescriptor& PollInfo::flight_descriptor() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.PollInfo.flight_descriptor)
  return _internal_flight_descriptor();
}
inline void PollInfo::unsafe_arena_set_allocated_flight_descriptor(::arrow::flight::protocol::FlightDescriptor* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.flight_descriptor_);
  }
  _impl_.flight_descriptor_ = reinterpret_cast<::arrow::flight::protocol::FlightDescriptor*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:arrow.flight.protocol.PollInfo.flight_descriptor)
}
inline ::arrow::flight::protocol::FlightDescriptor* PollInfo::release_flight_descriptor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::arrow::flight::protocol::FlightDescriptor* released = _impl_.flight_descriptor_;
  _impl_.flight_descriptor_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::arrow::flight::protocol::FlightDescriptor* PollInfo::unsafe_arena_release_flight_descriptor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.PollInfo.flight_descriptor)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::arrow::flight::protocol::FlightDescriptor* temp = _impl_.flight_descriptor_;
  _impl_.flight_descriptor_ = nullptr;
  return temp;
}
inline ::arrow::flight::protocol::FlightDescriptor* PollInfo::_internal_mutable_flight_descriptor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.flight_descriptor_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::arrow::flight::protocol::FlightDescriptor>(GetArena());
    _impl_.flight_descriptor_ = reinterpret_cast<::arrow::flight::protocol::FlightDescriptor*>(p);
  }
  return _impl_.flight_descriptor_;
}
inline ::arrow::flight::protocol::FlightDescriptor* PollInfo::mutable_flight_descriptor() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::arrow::flight::protocol::FlightDescriptor* _msg = _internal_mutable_flight_descriptor();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.PollInfo.flight_descriptor)
  return _msg;
}
inline void PollInfo::set_allocated_flight_descriptor(::arrow::flight::protocol::FlightDescriptor* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.flight_descriptor_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.flight_descriptor_ = reinterpret_cast<::arrow::flight::protocol::FlightDescriptor*>(value);
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.PollInfo.flight_descriptor)
}

// optional double progress = 3;
inline bool PollInfo::has_progress() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void PollInfo::clear_progress() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.progress_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double PollInfo::progress() const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.PollInfo.progress)
  return _internal_progress();
}
inline void PollInfo::set_progress(double value) {
  _internal_set_progress(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.PollInfo.progress)
}
inline double PollInfo::_internal_progress() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.progress_;
}
inline void PollInfo::_internal_set_progress(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.progress_ = value;
}

// .google.protobuf.Timestamp expiration_time = 4;
inline bool PollInfo::has_expiration_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.expiration_time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& PollInfo::_internal_expiration_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.expiration_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& PollInfo::expiration_time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.PollInfo.expiration_time)
  return _internal_expiration_time();
}
inline void PollInfo::unsafe_arena_set_allocated_expiration_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.expiration_time_);
  }
  _impl_.expiration_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:arrow.flight.protocol.PollInfo.expiration_time)
}
inline ::google::protobuf::Timestamp* PollInfo::release_expiration_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Timestamp* released = _impl_.expiration_time_;
  _impl_.expiration_time_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* PollInfo::unsafe_arena_release_expiration_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.PollInfo.expiration_time)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Timestamp* temp = _impl_.expiration_time_;
  _impl_.expiration_time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* PollInfo::_internal_mutable_expiration_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.expiration_time_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.expiration_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.expiration_time_;
}
inline ::google::protobuf::Timestamp* PollInfo::mutable_expiration_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_expiration_time();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.PollInfo.expiration_time)
  return _msg;
}
inline void PollInfo::set_allocated_expiration_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.expiration_time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.expiration_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.PollInfo.expiration_time)
}

// -------------------------------------------------------------------

// CancelFlightInfoRequest

// .arrow.flight.protocol.FlightInfo info = 1;
inline bool CancelFlightInfoRequest::has_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.info_ != nullptr);
  return value;
}
inline void CancelFlightInfoRequest::clear_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.info_ != nullptr) _impl_.info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::arrow::flight::protocol::FlightInfo& CancelFlightInfoRequest::_internal_info() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::arrow::flight::protocol::FlightInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::arrow::flight::protocol::FlightInfo&>(::arrow::flight::protocol::_FlightInfo_default_instance_);
}
inline const ::arrow::flight::protocol::FlightInfo& CancelFlightInfoRequest::info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.CancelFlightInfoRequest.info)
  return _internal_info();
}
inline void CancelFlightInfoRequest::unsafe_arena_set_allocated_info(::arrow::flight::protocol::FlightInfo* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = reinterpret_cast<::arrow::flight::protocol::FlightInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:arrow.flight.protocol.CancelFlightInfoRequest.info)
}
inline ::arrow::flight::protocol::FlightInfo* CancelFlightInfoRequest::release_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::arrow::flight::protocol::FlightInfo* released = _impl_.info_;
  _impl_.info_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::arrow::flight::protocol::FlightInfo* CancelFlightInfoRequest::unsafe_arena_release_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.CancelFlightInfoRequest.info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::arrow::flight::protocol::FlightInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::arrow::flight::protocol::FlightInfo* CancelFlightInfoRequest::_internal_mutable_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.info_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::arrow::flight::protocol::FlightInfo>(GetArena());
    _impl_.info_ = reinterpret_cast<::arrow::flight::protocol::FlightInfo*>(p);
  }
  return _impl_.info_;
}
inline ::arrow::flight::protocol::FlightInfo* CancelFlightInfoRequest::mutable_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::arrow::flight::protocol::FlightInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.CancelFlightInfoRequest.info)
  return _msg;
}
inline void CancelFlightInfoRequest::set_allocated_info(::arrow::flight::protocol::FlightInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.info_ = reinterpret_cast<::arrow::flight::protocol::FlightInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.CancelFlightInfoRequest.info)
}

// -------------------------------------------------------------------

// CancelFlightInfoResult

// .arrow.flight.protocol.CancelStatus status = 1;
inline void CancelFlightInfoResult::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::arrow::flight::protocol::CancelStatus CancelFlightInfoResult::status() const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.CancelFlightInfoResult.status)
  return _internal_status();
}
inline void CancelFlightInfoResult::set_status(::arrow::flight::protocol::CancelStatus value) {
  _internal_set_status(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.CancelFlightInfoResult.status)
}
inline ::arrow::flight::protocol::CancelStatus CancelFlightInfoResult::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::arrow::flight::protocol::CancelStatus>(_impl_.status_);
}
inline void CancelFlightInfoResult::_internal_set_status(::arrow::flight::protocol::CancelStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = value;
}

// -------------------------------------------------------------------

// Ticket

// bytes ticket = 1;
inline void Ticket::clear_ticket() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ticket_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Ticket::ticket() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.Ticket.ticket)
  return _internal_ticket();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Ticket::set_ticket(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ticket_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.Ticket.ticket)
}
inline std::string* Ticket::mutable_ticket() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ticket();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.Ticket.ticket)
  return _s;
}
inline const std::string& Ticket::_internal_ticket() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ticket_.Get();
}
inline void Ticket::_internal_set_ticket(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ticket_.Set(value, GetArena());
}
inline std::string* Ticket::_internal_mutable_ticket() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.ticket_.Mutable( GetArena());
}
inline std::string* Ticket::release_ticket() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.Ticket.ticket)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.ticket_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.ticket_.Set("", GetArena());
  }
  return released;
}
inline void Ticket::set_allocated_ticket(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.ticket_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.ticket_.IsDefault()) {
    _impl_.ticket_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.Ticket.ticket)
}

// -------------------------------------------------------------------

// Location

// string uri = 1;
inline void Location::clear_uri() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uri_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Location::uri() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.Location.uri)
  return _internal_uri();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Location::set_uri(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.uri_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.Location.uri)
}
inline std::string* Location::mutable_uri() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.Location.uri)
  return _s;
}
inline const std::string& Location::_internal_uri() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.uri_.Get();
}
inline void Location::_internal_set_uri(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.uri_.Set(value, GetArena());
}
inline std::string* Location::_internal_mutable_uri() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.uri_.Mutable( GetArena());
}
inline std::string* Location::release_uri() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.Location.uri)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.uri_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.uri_.Set("", GetArena());
  }
  return released;
}
inline void Location::set_allocated_uri(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.uri_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.uri_.IsDefault()) {
    _impl_.uri_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.Location.uri)
}

// -------------------------------------------------------------------

// FlightEndpoint

// .arrow.flight.protocol.Ticket ticket = 1;
inline bool FlightEndpoint::has_ticket() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ticket_ != nullptr);
  return value;
}
inline void FlightEndpoint::clear_ticket() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ticket_ != nullptr) _impl_.ticket_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::arrow::flight::protocol::Ticket& FlightEndpoint::_internal_ticket() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::arrow::flight::protocol::Ticket* p = _impl_.ticket_;
  return p != nullptr ? *p : reinterpret_cast<const ::arrow::flight::protocol::Ticket&>(::arrow::flight::protocol::_Ticket_default_instance_);
}
inline const ::arrow::flight::protocol::Ticket& FlightEndpoint::ticket() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.FlightEndpoint.ticket)
  return _internal_ticket();
}
inline void FlightEndpoint::unsafe_arena_set_allocated_ticket(::arrow::flight::protocol::Ticket* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ticket_);
  }
  _impl_.ticket_ = reinterpret_cast<::arrow::flight::protocol::Ticket*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:arrow.flight.protocol.FlightEndpoint.ticket)
}
inline ::arrow::flight::protocol::Ticket* FlightEndpoint::release_ticket() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::arrow::flight::protocol::Ticket* released = _impl_.ticket_;
  _impl_.ticket_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::arrow::flight::protocol::Ticket* FlightEndpoint::unsafe_arena_release_ticket() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.FlightEndpoint.ticket)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::arrow::flight::protocol::Ticket* temp = _impl_.ticket_;
  _impl_.ticket_ = nullptr;
  return temp;
}
inline ::arrow::flight::protocol::Ticket* FlightEndpoint::_internal_mutable_ticket() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ticket_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::arrow::flight::protocol::Ticket>(GetArena());
    _impl_.ticket_ = reinterpret_cast<::arrow::flight::protocol::Ticket*>(p);
  }
  return _impl_.ticket_;
}
inline ::arrow::flight::protocol::Ticket* FlightEndpoint::mutable_ticket() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::arrow::flight::protocol::Ticket* _msg = _internal_mutable_ticket();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.FlightEndpoint.ticket)
  return _msg;
}
inline void FlightEndpoint::set_allocated_ticket(::arrow::flight::protocol::Ticket* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.ticket_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.ticket_ = reinterpret_cast<::arrow::flight::protocol::Ticket*>(value);
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.FlightEndpoint.ticket)
}

// repeated .arrow.flight.protocol.Location location = 2;
inline int FlightEndpoint::_internal_location_size() const {
  return _internal_location().size();
}
inline int FlightEndpoint::location_size() const {
  return _internal_location_size();
}
inline void FlightEndpoint::clear_location() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.location_.Clear();
}
inline ::arrow::flight::protocol::Location* FlightEndpoint::mutable_location(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.FlightEndpoint.location)
  return _internal_mutable_location()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::arrow::flight::protocol::Location>* FlightEndpoint::mutable_location()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:arrow.flight.protocol.FlightEndpoint.location)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_location();
}
inline const ::arrow::flight::protocol::Location& FlightEndpoint::location(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.FlightEndpoint.location)
  return _internal_location().Get(index);
}
inline ::arrow::flight::protocol::Location* FlightEndpoint::add_location() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::arrow::flight::protocol::Location* _add = _internal_mutable_location()->Add();
  // @@protoc_insertion_point(field_add:arrow.flight.protocol.FlightEndpoint.location)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::arrow::flight::protocol::Location>& FlightEndpoint::location() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:arrow.flight.protocol.FlightEndpoint.location)
  return _internal_location();
}
inline const ::google::protobuf::RepeatedPtrField<::arrow::flight::protocol::Location>&
FlightEndpoint::_internal_location() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.location_;
}
inline ::google::protobuf::RepeatedPtrField<::arrow::flight::protocol::Location>*
FlightEndpoint::_internal_mutable_location() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.location_;
}

// .google.protobuf.Timestamp expiration_time = 3;
inline bool FlightEndpoint::has_expiration_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.expiration_time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& FlightEndpoint::_internal_expiration_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.expiration_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& FlightEndpoint::expiration_time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.FlightEndpoint.expiration_time)
  return _internal_expiration_time();
}
inline void FlightEndpoint::unsafe_arena_set_allocated_expiration_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.expiration_time_);
  }
  _impl_.expiration_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:arrow.flight.protocol.FlightEndpoint.expiration_time)
}
inline ::google::protobuf::Timestamp* FlightEndpoint::release_expiration_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Timestamp* released = _impl_.expiration_time_;
  _impl_.expiration_time_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* FlightEndpoint::unsafe_arena_release_expiration_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.FlightEndpoint.expiration_time)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Timestamp* temp = _impl_.expiration_time_;
  _impl_.expiration_time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* FlightEndpoint::_internal_mutable_expiration_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.expiration_time_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.expiration_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.expiration_time_;
}
inline ::google::protobuf::Timestamp* FlightEndpoint::mutable_expiration_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_expiration_time();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.FlightEndpoint.expiration_time)
  return _msg;
}
inline void FlightEndpoint::set_allocated_expiration_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.expiration_time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.expiration_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.FlightEndpoint.expiration_time)
}

// bytes app_metadata = 4;
inline void FlightEndpoint::clear_app_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.app_metadata_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FlightEndpoint::app_metadata() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.FlightEndpoint.app_metadata)
  return _internal_app_metadata();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void FlightEndpoint::set_app_metadata(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.app_metadata_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.FlightEndpoint.app_metadata)
}
inline std::string* FlightEndpoint::mutable_app_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_app_metadata();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.FlightEndpoint.app_metadata)
  return _s;
}
inline const std::string& FlightEndpoint::_internal_app_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.app_metadata_.Get();
}
inline void FlightEndpoint::_internal_set_app_metadata(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.app_metadata_.Set(value, GetArena());
}
inline std::string* FlightEndpoint::_internal_mutable_app_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.app_metadata_.Mutable( GetArena());
}
inline std::string* FlightEndpoint::release_app_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.FlightEndpoint.app_metadata)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.app_metadata_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.app_metadata_.Set("", GetArena());
  }
  return released;
}
inline void FlightEndpoint::set_allocated_app_metadata(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.app_metadata_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.app_metadata_.IsDefault()) {
    _impl_.app_metadata_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.FlightEndpoint.app_metadata)
}

// -------------------------------------------------------------------

// RenewFlightEndpointRequest

// .arrow.flight.protocol.FlightEndpoint endpoint = 1;
inline bool RenewFlightEndpointRequest::has_endpoint() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.endpoint_ != nullptr);
  return value;
}
inline void RenewFlightEndpointRequest::clear_endpoint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.endpoint_ != nullptr) _impl_.endpoint_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::arrow::flight::protocol::FlightEndpoint& RenewFlightEndpointRequest::_internal_endpoint() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::arrow::flight::protocol::FlightEndpoint* p = _impl_.endpoint_;
  return p != nullptr ? *p : reinterpret_cast<const ::arrow::flight::protocol::FlightEndpoint&>(::arrow::flight::protocol::_FlightEndpoint_default_instance_);
}
inline const ::arrow::flight::protocol::FlightEndpoint& RenewFlightEndpointRequest::endpoint() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.RenewFlightEndpointRequest.endpoint)
  return _internal_endpoint();
}
inline void RenewFlightEndpointRequest::unsafe_arena_set_allocated_endpoint(::arrow::flight::protocol::FlightEndpoint* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.endpoint_);
  }
  _impl_.endpoint_ = reinterpret_cast<::arrow::flight::protocol::FlightEndpoint*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:arrow.flight.protocol.RenewFlightEndpointRequest.endpoint)
}
inline ::arrow::flight::protocol::FlightEndpoint* RenewFlightEndpointRequest::release_endpoint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::arrow::flight::protocol::FlightEndpoint* released = _impl_.endpoint_;
  _impl_.endpoint_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::arrow::flight::protocol::FlightEndpoint* RenewFlightEndpointRequest::unsafe_arena_release_endpoint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.RenewFlightEndpointRequest.endpoint)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::arrow::flight::protocol::FlightEndpoint* temp = _impl_.endpoint_;
  _impl_.endpoint_ = nullptr;
  return temp;
}
inline ::arrow::flight::protocol::FlightEndpoint* RenewFlightEndpointRequest::_internal_mutable_endpoint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.endpoint_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::arrow::flight::protocol::FlightEndpoint>(GetArena());
    _impl_.endpoint_ = reinterpret_cast<::arrow::flight::protocol::FlightEndpoint*>(p);
  }
  return _impl_.endpoint_;
}
inline ::arrow::flight::protocol::FlightEndpoint* RenewFlightEndpointRequest::mutable_endpoint() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::arrow::flight::protocol::FlightEndpoint* _msg = _internal_mutable_endpoint();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.RenewFlightEndpointRequest.endpoint)
  return _msg;
}
inline void RenewFlightEndpointRequest::set_allocated_endpoint(::arrow::flight::protocol::FlightEndpoint* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.endpoint_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.endpoint_ = reinterpret_cast<::arrow::flight::protocol::FlightEndpoint*>(value);
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.RenewFlightEndpointRequest.endpoint)
}

// -------------------------------------------------------------------

// FlightData

// .arrow.flight.protocol.FlightDescriptor flight_descriptor = 1;
inline bool FlightData::has_flight_descriptor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.flight_descriptor_ != nullptr);
  return value;
}
inline void FlightData::clear_flight_descriptor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.flight_descriptor_ != nullptr) _impl_.flight_descriptor_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::arrow::flight::protocol::FlightDescriptor& FlightData::_internal_flight_descriptor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::arrow::flight::protocol::FlightDescriptor* p = _impl_.flight_descriptor_;
  return p != nullptr ? *p : reinterpret_cast<const ::arrow::flight::protocol::FlightDescriptor&>(::arrow::flight::protocol::_FlightDescriptor_default_instance_);
}
inline const ::arrow::flight::protocol::FlightDescriptor& FlightData::flight_descriptor() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.FlightData.flight_descriptor)
  return _internal_flight_descriptor();
}
inline void FlightData::unsafe_arena_set_allocated_flight_descriptor(::arrow::flight::protocol::FlightDescriptor* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.flight_descriptor_);
  }
  _impl_.flight_descriptor_ = reinterpret_cast<::arrow::flight::protocol::FlightDescriptor*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:arrow.flight.protocol.FlightData.flight_descriptor)
}
inline ::arrow::flight::protocol::FlightDescriptor* FlightData::release_flight_descriptor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::arrow::flight::protocol::FlightDescriptor* released = _impl_.flight_descriptor_;
  _impl_.flight_descriptor_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::arrow::flight::protocol::FlightDescriptor* FlightData::unsafe_arena_release_flight_descriptor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.FlightData.flight_descriptor)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::arrow::flight::protocol::FlightDescriptor* temp = _impl_.flight_descriptor_;
  _impl_.flight_descriptor_ = nullptr;
  return temp;
}
inline ::arrow::flight::protocol::FlightDescriptor* FlightData::_internal_mutable_flight_descriptor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.flight_descriptor_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::arrow::flight::protocol::FlightDescriptor>(GetArena());
    _impl_.flight_descriptor_ = reinterpret_cast<::arrow::flight::protocol::FlightDescriptor*>(p);
  }
  return _impl_.flight_descriptor_;
}
inline ::arrow::flight::protocol::FlightDescriptor* FlightData::mutable_flight_descriptor() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::arrow::flight::protocol::FlightDescriptor* _msg = _internal_mutable_flight_descriptor();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.FlightData.flight_descriptor)
  return _msg;
}
inline void FlightData::set_allocated_flight_descriptor(::arrow::flight::protocol::FlightDescriptor* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.flight_descriptor_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.flight_descriptor_ = reinterpret_cast<::arrow::flight::protocol::FlightDescriptor*>(value);
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.FlightData.flight_descriptor)
}

// bytes data_header = 2;
inline void FlightData::clear_data_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_header_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FlightData::data_header() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.FlightData.data_header)
  return _internal_data_header();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void FlightData::set_data_header(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.data_header_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.FlightData.data_header)
}
inline std::string* FlightData::mutable_data_header() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_data_header();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.FlightData.data_header)
  return _s;
}
inline const std::string& FlightData::_internal_data_header() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_header_.Get();
}
inline void FlightData::_internal_set_data_header(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.data_header_.Set(value, GetArena());
}
inline std::string* FlightData::_internal_mutable_data_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.data_header_.Mutable( GetArena());
}
inline std::string* FlightData::release_data_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.FlightData.data_header)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.data_header_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.data_header_.Set("", GetArena());
  }
  return released;
}
inline void FlightData::set_allocated_data_header(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.data_header_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.data_header_.IsDefault()) {
    _impl_.data_header_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.FlightData.data_header)
}

// bytes app_metadata = 3;
inline void FlightData::clear_app_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.app_metadata_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& FlightData::app_metadata() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.FlightData.app_metadata)
  return _internal_app_metadata();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void FlightData::set_app_metadata(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.app_metadata_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.FlightData.app_metadata)
}
inline std::string* FlightData::mutable_app_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_app_metadata();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.FlightData.app_metadata)
  return _s;
}
inline const std::string& FlightData::_internal_app_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.app_metadata_.Get();
}
inline void FlightData::_internal_set_app_metadata(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.app_metadata_.Set(value, GetArena());
}
inline std::string* FlightData::_internal_mutable_app_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.app_metadata_.Mutable( GetArena());
}
inline std::string* FlightData::release_app_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.FlightData.app_metadata)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.app_metadata_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.app_metadata_.Set("", GetArena());
  }
  return released;
}
inline void FlightData::set_allocated_app_metadata(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.app_metadata_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.app_metadata_.IsDefault()) {
    _impl_.app_metadata_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.FlightData.app_metadata)
}

// bytes data_body = 1000;
inline void FlightData::clear_data_body() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_body_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& FlightData::data_body() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.FlightData.data_body)
  return _internal_data_body();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void FlightData::set_data_body(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.data_body_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.FlightData.data_body)
}
inline std::string* FlightData::mutable_data_body() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_data_body();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.FlightData.data_body)
  return _s;
}
inline const std::string& FlightData::_internal_data_body() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_body_.Get();
}
inline void FlightData::_internal_set_data_body(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.data_body_.Set(value, GetArena());
}
inline std::string* FlightData::_internal_mutable_data_body() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.data_body_.Mutable( GetArena());
}
inline std::string* FlightData::release_data_body() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.FlightData.data_body)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.data_body_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.data_body_.Set("", GetArena());
  }
  return released;
}
inline void FlightData::set_allocated_data_body(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.data_body_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.data_body_.IsDefault()) {
    _impl_.data_body_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.FlightData.data_body)
}

// -------------------------------------------------------------------

// PutResult

// bytes app_metadata = 1;
inline void PutResult::clear_app_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.app_metadata_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PutResult::app_metadata() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.PutResult.app_metadata)
  return _internal_app_metadata();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void PutResult::set_app_metadata(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.app_metadata_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.PutResult.app_metadata)
}
inline std::string* PutResult::mutable_app_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_app_metadata();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.PutResult.app_metadata)
  return _s;
}
inline const std::string& PutResult::_internal_app_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.app_metadata_.Get();
}
inline void PutResult::_internal_set_app_metadata(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.app_metadata_.Set(value, GetArena());
}
inline std::string* PutResult::_internal_mutable_app_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.app_metadata_.Mutable( GetArena());
}
inline std::string* PutResult::release_app_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.PutResult.app_metadata)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.app_metadata_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.app_metadata_.Set("", GetArena());
  }
  return released;
}
inline void PutResult::set_allocated_app_metadata(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.app_metadata_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.app_metadata_.IsDefault()) {
    _impl_.app_metadata_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.PutResult.app_metadata)
}

// -------------------------------------------------------------------

// SessionOptionValue_StringListValue

// repeated string values = 1;
inline int SessionOptionValue_StringListValue::_internal_values_size() const {
  return _internal_values().size();
}
inline int SessionOptionValue_StringListValue::values_size() const {
  return _internal_values_size();
}
inline void SessionOptionValue_StringListValue::clear_values() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.values_.Clear();
}
inline std::string* SessionOptionValue_StringListValue::add_values() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_values()->Add();
  // @@protoc_insertion_point(field_add_mutable:arrow.flight.protocol.SessionOptionValue.StringListValue.values)
  return _s;
}
inline const std::string& SessionOptionValue_StringListValue::values(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.SessionOptionValue.StringListValue.values)
  return _internal_values().Get(index);
}
inline std::string* SessionOptionValue_StringListValue::mutable_values(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.SessionOptionValue.StringListValue.values)
  return _internal_mutable_values()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void SessionOptionValue_StringListValue::set_values(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_values()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.SessionOptionValue.StringListValue.values)
}
template <typename Arg_, typename... Args_>
inline void SessionOptionValue_StringListValue::add_values(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_values(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:arrow.flight.protocol.SessionOptionValue.StringListValue.values)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SessionOptionValue_StringListValue::values() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:arrow.flight.protocol.SessionOptionValue.StringListValue.values)
  return _internal_values();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SessionOptionValue_StringListValue::mutable_values() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:arrow.flight.protocol.SessionOptionValue.StringListValue.values)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_values();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SessionOptionValue_StringListValue::_internal_values() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SessionOptionValue_StringListValue::_internal_mutable_values() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// SessionOptionValue

// string string_value = 1;
inline bool SessionOptionValue::has_string_value() const {
  return option_value_case() == kStringValue;
}
inline void SessionOptionValue::set_has_string_value() {
  _impl_._oneof_case_[0] = kStringValue;
}
inline void SessionOptionValue::clear_string_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (option_value_case() == kStringValue) {
    _impl_.option_value_.string_value_.Destroy();
    clear_has_option_value();
  }
}
inline const std::string& SessionOptionValue::string_value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.SessionOptionValue.string_value)
  return _internal_string_value();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SessionOptionValue::set_string_value(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (option_value_case() != kStringValue) {
    clear_option_value();

    set_has_string_value();
    _impl_.option_value_.string_value_.InitDefault();
  }
  _impl_.option_value_.string_value_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.SessionOptionValue.string_value)
}
inline std::string* SessionOptionValue::mutable_string_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_string_value();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.SessionOptionValue.string_value)
  return _s;
}
inline const std::string& SessionOptionValue::_internal_string_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (option_value_case() != kStringValue) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.option_value_.string_value_.Get();
}
inline void SessionOptionValue::_internal_set_string_value(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (option_value_case() != kStringValue) {
    clear_option_value();

    set_has_string_value();
    _impl_.option_value_.string_value_.InitDefault();
  }
  _impl_.option_value_.string_value_.Set(value, GetArena());
}
inline std::string* SessionOptionValue::_internal_mutable_string_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (option_value_case() != kStringValue) {
    clear_option_value();

    set_has_string_value();
    _impl_.option_value_.string_value_.InitDefault();
  }
  return _impl_.option_value_.string_value_.Mutable( GetArena());
}
inline std::string* SessionOptionValue::release_string_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.SessionOptionValue.string_value)
  if (option_value_case() != kStringValue) {
    return nullptr;
  }
  clear_has_option_value();
  return _impl_.option_value_.string_value_.Release();
}
inline void SessionOptionValue::set_allocated_string_value(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_option_value()) {
    clear_option_value();
  }
  if (value != nullptr) {
    set_has_string_value();
    _impl_.option_value_.string_value_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:arrow.flight.protocol.SessionOptionValue.string_value)
}

// bool bool_value = 2;
inline bool SessionOptionValue::has_bool_value() const {
  return option_value_case() == kBoolValue;
}
inline void SessionOptionValue::set_has_bool_value() {
  _impl_._oneof_case_[0] = kBoolValue;
}
inline void SessionOptionValue::clear_bool_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (option_value_case() == kBoolValue) {
    _impl_.option_value_.bool_value_ = false;
    clear_has_option_value();
  }
}
inline bool SessionOptionValue::bool_value() const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.SessionOptionValue.bool_value)
  return _internal_bool_value();
}
inline void SessionOptionValue::set_bool_value(bool value) {
  if (option_value_case() != kBoolValue) {
    clear_option_value();
    set_has_bool_value();
  }
  _impl_.option_value_.bool_value_ = value;
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.SessionOptionValue.bool_value)
}
inline bool SessionOptionValue::_internal_bool_value() const {
  if (option_value_case() == kBoolValue) {
    return _impl_.option_value_.bool_value_;
  }
  return false;
}

// sfixed64 int64_value = 3;
inline bool SessionOptionValue::has_int64_value() const {
  return option_value_case() == kInt64Value;
}
inline void SessionOptionValue::set_has_int64_value() {
  _impl_._oneof_case_[0] = kInt64Value;
}
inline void SessionOptionValue::clear_int64_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (option_value_case() == kInt64Value) {
    _impl_.option_value_.int64_value_ = ::int64_t{0};
    clear_has_option_value();
  }
}
inline ::int64_t SessionOptionValue::int64_value() const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.SessionOptionValue.int64_value)
  return _internal_int64_value();
}
inline void SessionOptionValue::set_int64_value(::int64_t value) {
  if (option_value_case() != kInt64Value) {
    clear_option_value();
    set_has_int64_value();
  }
  _impl_.option_value_.int64_value_ = value;
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.SessionOptionValue.int64_value)
}
inline ::int64_t SessionOptionValue::_internal_int64_value() const {
  if (option_value_case() == kInt64Value) {
    return _impl_.option_value_.int64_value_;
  }
  return ::int64_t{0};
}

// double double_value = 4;
inline bool SessionOptionValue::has_double_value() const {
  return option_value_case() == kDoubleValue;
}
inline void SessionOptionValue::set_has_double_value() {
  _impl_._oneof_case_[0] = kDoubleValue;
}
inline void SessionOptionValue::clear_double_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (option_value_case() == kDoubleValue) {
    _impl_.option_value_.double_value_ = 0;
    clear_has_option_value();
  }
}
inline double SessionOptionValue::double_value() const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.SessionOptionValue.double_value)
  return _internal_double_value();
}
inline void SessionOptionValue::set_double_value(double value) {
  if (option_value_case() != kDoubleValue) {
    clear_option_value();
    set_has_double_value();
  }
  _impl_.option_value_.double_value_ = value;
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.SessionOptionValue.double_value)
}
inline double SessionOptionValue::_internal_double_value() const {
  if (option_value_case() == kDoubleValue) {
    return _impl_.option_value_.double_value_;
  }
  return 0;
}

// .arrow.flight.protocol.SessionOptionValue.StringListValue string_list_value = 5;
inline bool SessionOptionValue::has_string_list_value() const {
  return option_value_case() == kStringListValue;
}
inline bool SessionOptionValue::_internal_has_string_list_value() const {
  return option_value_case() == kStringListValue;
}
inline void SessionOptionValue::set_has_string_list_value() {
  _impl_._oneof_case_[0] = kStringListValue;
}
inline void SessionOptionValue::clear_string_list_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (option_value_case() == kStringListValue) {
    if (GetArena() == nullptr) {
      delete _impl_.option_value_.string_list_value_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.option_value_.string_list_value_);
    }
    clear_has_option_value();
  }
}
inline ::arrow::flight::protocol::SessionOptionValue_StringListValue* SessionOptionValue::release_string_list_value() {
  // @@protoc_insertion_point(field_release:arrow.flight.protocol.SessionOptionValue.string_list_value)
  if (option_value_case() == kStringListValue) {
    clear_has_option_value();
    auto* temp = _impl_.option_value_.string_list_value_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.option_value_.string_list_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::arrow::flight::protocol::SessionOptionValue_StringListValue& SessionOptionValue::_internal_string_list_value() const {
  return option_value_case() == kStringListValue ? *_impl_.option_value_.string_list_value_ : reinterpret_cast<::arrow::flight::protocol::SessionOptionValue_StringListValue&>(::arrow::flight::protocol::_SessionOptionValue_StringListValue_default_instance_);
}
inline const ::arrow::flight::protocol::SessionOptionValue_StringListValue& SessionOptionValue::string_list_value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.SessionOptionValue.string_list_value)
  return _internal_string_list_value();
}
inline ::arrow::flight::protocol::SessionOptionValue_StringListValue* SessionOptionValue::unsafe_arena_release_string_list_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:arrow.flight.protocol.SessionOptionValue.string_list_value)
  if (option_value_case() == kStringListValue) {
    clear_has_option_value();
    auto* temp = _impl_.option_value_.string_list_value_;
    _impl_.option_value_.string_list_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SessionOptionValue::unsafe_arena_set_allocated_string_list_value(::arrow::flight::protocol::SessionOptionValue_StringListValue* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_option_value();
  if (value) {
    set_has_string_list_value();
    _impl_.option_value_.string_list_value_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:arrow.flight.protocol.SessionOptionValue.string_list_value)
}
inline ::arrow::flight::protocol::SessionOptionValue_StringListValue* SessionOptionValue::_internal_mutable_string_list_value() {
  if (option_value_case() != kStringListValue) {
    clear_option_value();
    set_has_string_list_value();
    _impl_.option_value_.string_list_value_ =
        ::google::protobuf::Message::DefaultConstruct<::arrow::flight::protocol::SessionOptionValue_StringListValue>(GetArena());
  }
  return _impl_.option_value_.string_list_value_;
}
inline ::arrow::flight::protocol::SessionOptionValue_StringListValue* SessionOptionValue::mutable_string_list_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::arrow::flight::protocol::SessionOptionValue_StringListValue* _msg = _internal_mutable_string_list_value();
  // @@protoc_insertion_point(field_mutable:arrow.flight.protocol.SessionOptionValue.string_list_value)
  return _msg;
}

inline bool SessionOptionValue::has_option_value() const {
  return option_value_case() != OPTION_VALUE_NOT_SET;
}
inline void SessionOptionValue::clear_has_option_value() {
  _impl_._oneof_case_[0] = OPTION_VALUE_NOT_SET;
}
inline SessionOptionValue::OptionValueCase SessionOptionValue::option_value_case() const {
  return SessionOptionValue::OptionValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SetSessionOptionsRequest

// map<string, .arrow.flight.protocol.SessionOptionValue> session_options = 1;
inline int SetSessionOptionsRequest::_internal_session_options_size() const {
  return _internal_session_options().size();
}
inline int SetSessionOptionsRequest::session_options_size() const {
  return _internal_session_options_size();
}
inline void SetSessionOptionsRequest::clear_session_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_options_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::arrow::flight::protocol::SessionOptionValue>& SetSessionOptionsRequest::_internal_session_options() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.session_options_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::arrow::flight::protocol::SessionOptionValue>& SetSessionOptionsRequest::session_options() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:arrow.flight.protocol.SetSessionOptionsRequest.session_options)
  return _internal_session_options();
}
inline ::google::protobuf::Map<std::string, ::arrow::flight::protocol::SessionOptionValue>* SetSessionOptionsRequest::_internal_mutable_session_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.session_options_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::arrow::flight::protocol::SessionOptionValue>* SetSessionOptionsRequest::mutable_session_options() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:arrow.flight.protocol.SetSessionOptionsRequest.session_options)
  return _internal_mutable_session_options();
}

// -------------------------------------------------------------------

// SetSessionOptionsResult_Error

// .arrow.flight.protocol.SetSessionOptionsResult.ErrorValue value = 1;
inline void SetSessionOptionsResult_Error::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::arrow::flight::protocol::SetSessionOptionsResult_ErrorValue SetSessionOptionsResult_Error::value() const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.SetSessionOptionsResult.Error.value)
  return _internal_value();
}
inline void SetSessionOptionsResult_Error::set_value(::arrow::flight::protocol::SetSessionOptionsResult_ErrorValue value) {
  _internal_set_value(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.SetSessionOptionsResult.Error.value)
}
inline ::arrow::flight::protocol::SetSessionOptionsResult_ErrorValue SetSessionOptionsResult_Error::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::arrow::flight::protocol::SetSessionOptionsResult_ErrorValue>(_impl_.value_);
}
inline void SetSessionOptionsResult_Error::_internal_set_value(::arrow::flight::protocol::SetSessionOptionsResult_ErrorValue value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SetSessionOptionsResult

// map<string, .arrow.flight.protocol.SetSessionOptionsResult.Error> errors = 1;
inline int SetSessionOptionsResult::_internal_errors_size() const {
  return _internal_errors().size();
}
inline int SetSessionOptionsResult::errors_size() const {
  return _internal_errors_size();
}
inline void SetSessionOptionsResult::clear_errors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.errors_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::arrow::flight::protocol::SetSessionOptionsResult_Error>& SetSessionOptionsResult::_internal_errors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.errors_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::arrow::flight::protocol::SetSessionOptionsResult_Error>& SetSessionOptionsResult::errors() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:arrow.flight.protocol.SetSessionOptionsResult.errors)
  return _internal_errors();
}
inline ::google::protobuf::Map<std::string, ::arrow::flight::protocol::SetSessionOptionsResult_Error>* SetSessionOptionsResult::_internal_mutable_errors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.errors_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::arrow::flight::protocol::SetSessionOptionsResult_Error>* SetSessionOptionsResult::mutable_errors() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:arrow.flight.protocol.SetSessionOptionsResult.errors)
  return _internal_mutable_errors();
}

// -------------------------------------------------------------------

// GetSessionOptionsRequest

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GetSessionOptionsResult

// map<string, .arrow.flight.protocol.SessionOptionValue> session_options = 1;
inline int GetSessionOptionsResult::_internal_session_options_size() const {
  return _internal_session_options().size();
}
inline int GetSessionOptionsResult::session_options_size() const {
  return _internal_session_options_size();
}
inline void GetSessionOptionsResult::clear_session_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_options_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::arrow::flight::protocol::SessionOptionValue>& GetSessionOptionsResult::_internal_session_options() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.session_options_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::arrow::flight::protocol::SessionOptionValue>& GetSessionOptionsResult::session_options() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:arrow.flight.protocol.GetSessionOptionsResult.session_options)
  return _internal_session_options();
}
inline ::google::protobuf::Map<std::string, ::arrow::flight::protocol::SessionOptionValue>* GetSessionOptionsResult::_internal_mutable_session_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.session_options_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::arrow::flight::protocol::SessionOptionValue>* GetSessionOptionsResult::mutable_session_options() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:arrow.flight.protocol.GetSessionOptionsResult.session_options)
  return _internal_mutable_session_options();
}

// -------------------------------------------------------------------

// CloseSessionRequest

// -------------------------------------------------------------------

// CloseSessionResult

// .arrow.flight.protocol.CloseSessionResult.Status status = 1;
inline void CloseSessionResult::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::arrow::flight::protocol::CloseSessionResult_Status CloseSessionResult::status() const {
  // @@protoc_insertion_point(field_get:arrow.flight.protocol.CloseSessionResult.status)
  return _internal_status();
}
inline void CloseSessionResult::set_status(::arrow::flight::protocol::CloseSessionResult_Status value) {
  _internal_set_status(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:arrow.flight.protocol.CloseSessionResult.status)
}
inline ::arrow::flight::protocol::CloseSessionResult_Status CloseSessionResult::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::arrow::flight::protocol::CloseSessionResult_Status>(_impl_.status_);
}
inline void CloseSessionResult::_internal_set_status(::arrow::flight::protocol::CloseSessionResult_Status value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace protocol
}  // namespace flight
}  // namespace arrow


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::arrow::flight::protocol::FlightDescriptor_DescriptorType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::arrow::flight::protocol::FlightDescriptor_DescriptorType>() {
  return ::arrow::flight::protocol::FlightDescriptor_DescriptorType_descriptor();
}
template <>
struct is_proto_enum<::arrow::flight::protocol::SetSessionOptionsResult_ErrorValue> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::arrow::flight::protocol::SetSessionOptionsResult_ErrorValue>() {
  return ::arrow::flight::protocol::SetSessionOptionsResult_ErrorValue_descriptor();
}
template <>
struct is_proto_enum<::arrow::flight::protocol::CloseSessionResult_Status> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::arrow::flight::protocol::CloseSessionResult_Status>() {
  return ::arrow::flight::protocol::CloseSessionResult_Status_descriptor();
}
template <>
struct is_proto_enum<::arrow::flight::protocol::CancelStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::arrow::flight::protocol::CancelStatus>() {
  return ::arrow::flight::protocol::CancelStatus_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // Flight_2eproto_2epb_2eh
