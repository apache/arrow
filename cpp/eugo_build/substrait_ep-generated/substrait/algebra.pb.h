// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: substrait/algebra.proto
// Protobuf C++ Version: 5.30.0-dev

#ifndef substrait_2falgebra_2eproto_2epb_2eh
#define substrait_2falgebra_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5030000
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/any.pb.h"
#include "substrait/extensions/extensions.pb.h"
#include "substrait/type.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_substrait_2falgebra_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_substrait_2falgebra_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_substrait_2falgebra_2eproto;
}  // extern "C"
namespace substrait {
enum AggregateFunction_AggregationInvocation : int;
bool AggregateFunction_AggregationInvocation_IsValid(int value);
extern const uint32_t AggregateFunction_AggregationInvocation_internal_data_[];
enum AggregationPhase : int;
bool AggregationPhase_IsValid(int value);
extern const uint32_t AggregationPhase_internal_data_[];
enum ComparisonJoinKey_SimpleComparisonType : int;
bool ComparisonJoinKey_SimpleComparisonType_IsValid(int value);
extern const uint32_t ComparisonJoinKey_SimpleComparisonType_internal_data_[];
enum DdlRel_DdlObject : int;
bool DdlRel_DdlObject_IsValid(int value);
extern const uint32_t DdlRel_DdlObject_internal_data_[];
enum DdlRel_DdlOp : int;
bool DdlRel_DdlOp_IsValid(int value);
extern const uint32_t DdlRel_DdlOp_internal_data_[];
enum Expression_Cast_FailureBehavior : int;
bool Expression_Cast_FailureBehavior_IsValid(int value);
extern const uint32_t Expression_Cast_FailureBehavior_internal_data_[];
enum Expression_Subquery_SetComparison_ComparisonOp : int;
bool Expression_Subquery_SetComparison_ComparisonOp_IsValid(int value);
extern const uint32_t Expression_Subquery_SetComparison_ComparisonOp_internal_data_[];
enum Expression_Subquery_SetComparison_ReductionOp : int;
bool Expression_Subquery_SetComparison_ReductionOp_IsValid(int value);
extern const uint32_t Expression_Subquery_SetComparison_ReductionOp_internal_data_[];
enum Expression_Subquery_SetPredicate_PredicateOp : int;
bool Expression_Subquery_SetPredicate_PredicateOp_IsValid(int value);
extern const uint32_t Expression_Subquery_SetPredicate_PredicateOp_internal_data_[];
enum Expression_WindowFunction_BoundsType : int;
bool Expression_WindowFunction_BoundsType_IsValid(int value);
extern const uint32_t Expression_WindowFunction_BoundsType_internal_data_[];
enum HashJoinRel_JoinType : int;
bool HashJoinRel_JoinType_IsValid(int value);
extern const uint32_t HashJoinRel_JoinType_internal_data_[];
enum JoinRel_JoinType : int;
bool JoinRel_JoinType_IsValid(int value);
extern const uint32_t JoinRel_JoinType_internal_data_[];
enum MergeJoinRel_JoinType : int;
bool MergeJoinRel_JoinType_IsValid(int value);
extern const uint32_t MergeJoinRel_JoinType_internal_data_[];
enum NestedLoopJoinRel_JoinType : int;
bool NestedLoopJoinRel_JoinType_IsValid(int value);
extern const uint32_t NestedLoopJoinRel_JoinType_internal_data_[];
enum SetRel_SetOp : int;
bool SetRel_SetOp_IsValid(int value);
extern const uint32_t SetRel_SetOp_internal_data_[];
enum SortField_SortDirection : int;
bool SortField_SortDirection_IsValid(int value);
extern const uint32_t SortField_SortDirection_internal_data_[];
enum WriteRel_OutputMode : int;
bool WriteRel_OutputMode_IsValid(int value);
extern const uint32_t WriteRel_OutputMode_internal_data_[];
enum WriteRel_WriteOp : int;
bool WriteRel_WriteOp_IsValid(int value);
extern const uint32_t WriteRel_WriteOp_internal_data_[];
class AggregateFunction;
struct AggregateFunctionDefaultTypeInternal;
extern AggregateFunctionDefaultTypeInternal _AggregateFunction_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull AggregateFunction_class_data_;
class AggregateRel;
struct AggregateRelDefaultTypeInternal;
extern AggregateRelDefaultTypeInternal _AggregateRel_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull AggregateRel_class_data_;
class AggregateRel_Grouping;
struct AggregateRel_GroupingDefaultTypeInternal;
extern AggregateRel_GroupingDefaultTypeInternal _AggregateRel_Grouping_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull AggregateRel_Grouping_class_data_;
class AggregateRel_Measure;
struct AggregateRel_MeasureDefaultTypeInternal;
extern AggregateRel_MeasureDefaultTypeInternal _AggregateRel_Measure_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull AggregateRel_Measure_class_data_;
class ComparisonJoinKey;
struct ComparisonJoinKeyDefaultTypeInternal;
extern ComparisonJoinKeyDefaultTypeInternal _ComparisonJoinKey_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ComparisonJoinKey_class_data_;
class ComparisonJoinKey_ComparisonType;
struct ComparisonJoinKey_ComparisonTypeDefaultTypeInternal;
extern ComparisonJoinKey_ComparisonTypeDefaultTypeInternal _ComparisonJoinKey_ComparisonType_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ComparisonJoinKey_ComparisonType_class_data_;
class ConsistentPartitionWindowRel;
struct ConsistentPartitionWindowRelDefaultTypeInternal;
extern ConsistentPartitionWindowRelDefaultTypeInternal _ConsistentPartitionWindowRel_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ConsistentPartitionWindowRel_class_data_;
class ConsistentPartitionWindowRel_WindowRelFunction;
struct ConsistentPartitionWindowRel_WindowRelFunctionDefaultTypeInternal;
extern ConsistentPartitionWindowRel_WindowRelFunctionDefaultTypeInternal _ConsistentPartitionWindowRel_WindowRelFunction_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ConsistentPartitionWindowRel_WindowRelFunction_class_data_;
class CrossRel;
struct CrossRelDefaultTypeInternal;
extern CrossRelDefaultTypeInternal _CrossRel_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CrossRel_class_data_;
class DdlRel;
struct DdlRelDefaultTypeInternal;
extern DdlRelDefaultTypeInternal _DdlRel_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DdlRel_class_data_;
class ExchangeRel;
struct ExchangeRelDefaultTypeInternal;
extern ExchangeRelDefaultTypeInternal _ExchangeRel_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ExchangeRel_class_data_;
class ExchangeRel_Broadcast;
struct ExchangeRel_BroadcastDefaultTypeInternal;
extern ExchangeRel_BroadcastDefaultTypeInternal _ExchangeRel_Broadcast_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ExchangeRel_Broadcast_class_data_;
class ExchangeRel_ExchangeTarget;
struct ExchangeRel_ExchangeTargetDefaultTypeInternal;
extern ExchangeRel_ExchangeTargetDefaultTypeInternal _ExchangeRel_ExchangeTarget_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ExchangeRel_ExchangeTarget_class_data_;
class ExchangeRel_MultiBucketExpression;
struct ExchangeRel_MultiBucketExpressionDefaultTypeInternal;
extern ExchangeRel_MultiBucketExpressionDefaultTypeInternal _ExchangeRel_MultiBucketExpression_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ExchangeRel_MultiBucketExpression_class_data_;
class ExchangeRel_RoundRobin;
struct ExchangeRel_RoundRobinDefaultTypeInternal;
extern ExchangeRel_RoundRobinDefaultTypeInternal _ExchangeRel_RoundRobin_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ExchangeRel_RoundRobin_class_data_;
class ExchangeRel_ScatterFields;
struct ExchangeRel_ScatterFieldsDefaultTypeInternal;
extern ExchangeRel_ScatterFieldsDefaultTypeInternal _ExchangeRel_ScatterFields_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ExchangeRel_ScatterFields_class_data_;
class ExchangeRel_SingleBucketExpression;
struct ExchangeRel_SingleBucketExpressionDefaultTypeInternal;
extern ExchangeRel_SingleBucketExpressionDefaultTypeInternal _ExchangeRel_SingleBucketExpression_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ExchangeRel_SingleBucketExpression_class_data_;
class ExpandRel;
struct ExpandRelDefaultTypeInternal;
extern ExpandRelDefaultTypeInternal _ExpandRel_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ExpandRel_class_data_;
class ExpandRel_ExpandField;
struct ExpandRel_ExpandFieldDefaultTypeInternal;
extern ExpandRel_ExpandFieldDefaultTypeInternal _ExpandRel_ExpandField_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ExpandRel_ExpandField_class_data_;
class ExpandRel_SwitchingField;
struct ExpandRel_SwitchingFieldDefaultTypeInternal;
extern ExpandRel_SwitchingFieldDefaultTypeInternal _ExpandRel_SwitchingField_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ExpandRel_SwitchingField_class_data_;
class Expression;
struct ExpressionDefaultTypeInternal;
extern ExpressionDefaultTypeInternal _Expression_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_class_data_;
class Expression_Cast;
struct Expression_CastDefaultTypeInternal;
extern Expression_CastDefaultTypeInternal _Expression_Cast_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_Cast_class_data_;
class Expression_EmbeddedFunction;
struct Expression_EmbeddedFunctionDefaultTypeInternal;
extern Expression_EmbeddedFunctionDefaultTypeInternal _Expression_EmbeddedFunction_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_EmbeddedFunction_class_data_;
class Expression_EmbeddedFunction_PythonPickleFunction;
struct Expression_EmbeddedFunction_PythonPickleFunctionDefaultTypeInternal;
extern Expression_EmbeddedFunction_PythonPickleFunctionDefaultTypeInternal _Expression_EmbeddedFunction_PythonPickleFunction_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_EmbeddedFunction_PythonPickleFunction_class_data_;
class Expression_EmbeddedFunction_WebAssemblyFunction;
struct Expression_EmbeddedFunction_WebAssemblyFunctionDefaultTypeInternal;
extern Expression_EmbeddedFunction_WebAssemblyFunctionDefaultTypeInternal _Expression_EmbeddedFunction_WebAssemblyFunction_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_EmbeddedFunction_WebAssemblyFunction_class_data_;
class Expression_Enum;
struct Expression_EnumDefaultTypeInternal;
extern Expression_EnumDefaultTypeInternal _Expression_Enum_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_Enum_class_data_;
class Expression_Enum_Empty;
struct Expression_Enum_EmptyDefaultTypeInternal;
extern Expression_Enum_EmptyDefaultTypeInternal _Expression_Enum_Empty_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_Enum_Empty_class_data_;
class Expression_FieldReference;
struct Expression_FieldReferenceDefaultTypeInternal;
extern Expression_FieldReferenceDefaultTypeInternal _Expression_FieldReference_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_FieldReference_class_data_;
class Expression_FieldReference_OuterReference;
struct Expression_FieldReference_OuterReferenceDefaultTypeInternal;
extern Expression_FieldReference_OuterReferenceDefaultTypeInternal _Expression_FieldReference_OuterReference_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_FieldReference_OuterReference_class_data_;
class Expression_FieldReference_RootReference;
struct Expression_FieldReference_RootReferenceDefaultTypeInternal;
extern Expression_FieldReference_RootReferenceDefaultTypeInternal _Expression_FieldReference_RootReference_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_FieldReference_RootReference_class_data_;
class Expression_IfThen;
struct Expression_IfThenDefaultTypeInternal;
extern Expression_IfThenDefaultTypeInternal _Expression_IfThen_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_IfThen_class_data_;
class Expression_IfThen_IfClause;
struct Expression_IfThen_IfClauseDefaultTypeInternal;
extern Expression_IfThen_IfClauseDefaultTypeInternal _Expression_IfThen_IfClause_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_IfThen_IfClause_class_data_;
class Expression_Literal;
struct Expression_LiteralDefaultTypeInternal;
extern Expression_LiteralDefaultTypeInternal _Expression_Literal_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_Literal_class_data_;
class Expression_Literal_Decimal;
struct Expression_Literal_DecimalDefaultTypeInternal;
extern Expression_Literal_DecimalDefaultTypeInternal _Expression_Literal_Decimal_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_Literal_Decimal_class_data_;
class Expression_Literal_IntervalDayToSecond;
struct Expression_Literal_IntervalDayToSecondDefaultTypeInternal;
extern Expression_Literal_IntervalDayToSecondDefaultTypeInternal _Expression_Literal_IntervalDayToSecond_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_Literal_IntervalDayToSecond_class_data_;
class Expression_Literal_IntervalYearToMonth;
struct Expression_Literal_IntervalYearToMonthDefaultTypeInternal;
extern Expression_Literal_IntervalYearToMonthDefaultTypeInternal _Expression_Literal_IntervalYearToMonth_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_Literal_IntervalYearToMonth_class_data_;
class Expression_Literal_List;
struct Expression_Literal_ListDefaultTypeInternal;
extern Expression_Literal_ListDefaultTypeInternal _Expression_Literal_List_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_Literal_List_class_data_;
class Expression_Literal_Map;
struct Expression_Literal_MapDefaultTypeInternal;
extern Expression_Literal_MapDefaultTypeInternal _Expression_Literal_Map_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_Literal_Map_class_data_;
class Expression_Literal_Map_KeyValue;
struct Expression_Literal_Map_KeyValueDefaultTypeInternal;
extern Expression_Literal_Map_KeyValueDefaultTypeInternal _Expression_Literal_Map_KeyValue_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_Literal_Map_KeyValue_class_data_;
class Expression_Literal_Struct;
struct Expression_Literal_StructDefaultTypeInternal;
extern Expression_Literal_StructDefaultTypeInternal _Expression_Literal_Struct_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_Literal_Struct_class_data_;
class Expression_Literal_UserDefined;
struct Expression_Literal_UserDefinedDefaultTypeInternal;
extern Expression_Literal_UserDefinedDefaultTypeInternal _Expression_Literal_UserDefined_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_Literal_UserDefined_class_data_;
class Expression_Literal_VarChar;
struct Expression_Literal_VarCharDefaultTypeInternal;
extern Expression_Literal_VarCharDefaultTypeInternal _Expression_Literal_VarChar_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_Literal_VarChar_class_data_;
class Expression_MaskExpression;
struct Expression_MaskExpressionDefaultTypeInternal;
extern Expression_MaskExpressionDefaultTypeInternal _Expression_MaskExpression_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_MaskExpression_class_data_;
class Expression_MaskExpression_ListSelect;
struct Expression_MaskExpression_ListSelectDefaultTypeInternal;
extern Expression_MaskExpression_ListSelectDefaultTypeInternal _Expression_MaskExpression_ListSelect_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_MaskExpression_ListSelect_class_data_;
class Expression_MaskExpression_ListSelect_ListSelectItem;
struct Expression_MaskExpression_ListSelect_ListSelectItemDefaultTypeInternal;
extern Expression_MaskExpression_ListSelect_ListSelectItemDefaultTypeInternal _Expression_MaskExpression_ListSelect_ListSelectItem_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_MaskExpression_ListSelect_ListSelectItem_class_data_;
class Expression_MaskExpression_ListSelect_ListSelectItem_ListElement;
struct Expression_MaskExpression_ListSelect_ListSelectItem_ListElementDefaultTypeInternal;
extern Expression_MaskExpression_ListSelect_ListSelectItem_ListElementDefaultTypeInternal _Expression_MaskExpression_ListSelect_ListSelectItem_ListElement_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_MaskExpression_ListSelect_ListSelectItem_ListElement_class_data_;
class Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice;
struct Expression_MaskExpression_ListSelect_ListSelectItem_ListSliceDefaultTypeInternal;
extern Expression_MaskExpression_ListSelect_ListSelectItem_ListSliceDefaultTypeInternal _Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice_class_data_;
class Expression_MaskExpression_MapSelect;
struct Expression_MaskExpression_MapSelectDefaultTypeInternal;
extern Expression_MaskExpression_MapSelectDefaultTypeInternal _Expression_MaskExpression_MapSelect_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_MaskExpression_MapSelect_class_data_;
class Expression_MaskExpression_MapSelect_MapKey;
struct Expression_MaskExpression_MapSelect_MapKeyDefaultTypeInternal;
extern Expression_MaskExpression_MapSelect_MapKeyDefaultTypeInternal _Expression_MaskExpression_MapSelect_MapKey_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_MaskExpression_MapSelect_MapKey_class_data_;
class Expression_MaskExpression_MapSelect_MapKeyExpression;
struct Expression_MaskExpression_MapSelect_MapKeyExpressionDefaultTypeInternal;
extern Expression_MaskExpression_MapSelect_MapKeyExpressionDefaultTypeInternal _Expression_MaskExpression_MapSelect_MapKeyExpression_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_MaskExpression_MapSelect_MapKeyExpression_class_data_;
class Expression_MaskExpression_Select;
struct Expression_MaskExpression_SelectDefaultTypeInternal;
extern Expression_MaskExpression_SelectDefaultTypeInternal _Expression_MaskExpression_Select_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_MaskExpression_Select_class_data_;
class Expression_MaskExpression_StructItem;
struct Expression_MaskExpression_StructItemDefaultTypeInternal;
extern Expression_MaskExpression_StructItemDefaultTypeInternal _Expression_MaskExpression_StructItem_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_MaskExpression_StructItem_class_data_;
class Expression_MaskExpression_StructSelect;
struct Expression_MaskExpression_StructSelectDefaultTypeInternal;
extern Expression_MaskExpression_StructSelectDefaultTypeInternal _Expression_MaskExpression_StructSelect_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_MaskExpression_StructSelect_class_data_;
class Expression_MultiOrList;
struct Expression_MultiOrListDefaultTypeInternal;
extern Expression_MultiOrListDefaultTypeInternal _Expression_MultiOrList_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_MultiOrList_class_data_;
class Expression_MultiOrList_Record;
struct Expression_MultiOrList_RecordDefaultTypeInternal;
extern Expression_MultiOrList_RecordDefaultTypeInternal _Expression_MultiOrList_Record_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_MultiOrList_Record_class_data_;
class Expression_Nested;
struct Expression_NestedDefaultTypeInternal;
extern Expression_NestedDefaultTypeInternal _Expression_Nested_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_Nested_class_data_;
class Expression_Nested_List;
struct Expression_Nested_ListDefaultTypeInternal;
extern Expression_Nested_ListDefaultTypeInternal _Expression_Nested_List_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_Nested_List_class_data_;
class Expression_Nested_Map;
struct Expression_Nested_MapDefaultTypeInternal;
extern Expression_Nested_MapDefaultTypeInternal _Expression_Nested_Map_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_Nested_Map_class_data_;
class Expression_Nested_Map_KeyValue;
struct Expression_Nested_Map_KeyValueDefaultTypeInternal;
extern Expression_Nested_Map_KeyValueDefaultTypeInternal _Expression_Nested_Map_KeyValue_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_Nested_Map_KeyValue_class_data_;
class Expression_Nested_Struct;
struct Expression_Nested_StructDefaultTypeInternal;
extern Expression_Nested_StructDefaultTypeInternal _Expression_Nested_Struct_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_Nested_Struct_class_data_;
class Expression_ReferenceSegment;
struct Expression_ReferenceSegmentDefaultTypeInternal;
extern Expression_ReferenceSegmentDefaultTypeInternal _Expression_ReferenceSegment_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_ReferenceSegment_class_data_;
class Expression_ReferenceSegment_ListElement;
struct Expression_ReferenceSegment_ListElementDefaultTypeInternal;
extern Expression_ReferenceSegment_ListElementDefaultTypeInternal _Expression_ReferenceSegment_ListElement_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_ReferenceSegment_ListElement_class_data_;
class Expression_ReferenceSegment_MapKey;
struct Expression_ReferenceSegment_MapKeyDefaultTypeInternal;
extern Expression_ReferenceSegment_MapKeyDefaultTypeInternal _Expression_ReferenceSegment_MapKey_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_ReferenceSegment_MapKey_class_data_;
class Expression_ReferenceSegment_StructField;
struct Expression_ReferenceSegment_StructFieldDefaultTypeInternal;
extern Expression_ReferenceSegment_StructFieldDefaultTypeInternal _Expression_ReferenceSegment_StructField_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_ReferenceSegment_StructField_class_data_;
class Expression_ScalarFunction;
struct Expression_ScalarFunctionDefaultTypeInternal;
extern Expression_ScalarFunctionDefaultTypeInternal _Expression_ScalarFunction_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_ScalarFunction_class_data_;
class Expression_SingularOrList;
struct Expression_SingularOrListDefaultTypeInternal;
extern Expression_SingularOrListDefaultTypeInternal _Expression_SingularOrList_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_SingularOrList_class_data_;
class Expression_Subquery;
struct Expression_SubqueryDefaultTypeInternal;
extern Expression_SubqueryDefaultTypeInternal _Expression_Subquery_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_Subquery_class_data_;
class Expression_Subquery_InPredicate;
struct Expression_Subquery_InPredicateDefaultTypeInternal;
extern Expression_Subquery_InPredicateDefaultTypeInternal _Expression_Subquery_InPredicate_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_Subquery_InPredicate_class_data_;
class Expression_Subquery_Scalar;
struct Expression_Subquery_ScalarDefaultTypeInternal;
extern Expression_Subquery_ScalarDefaultTypeInternal _Expression_Subquery_Scalar_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_Subquery_Scalar_class_data_;
class Expression_Subquery_SetComparison;
struct Expression_Subquery_SetComparisonDefaultTypeInternal;
extern Expression_Subquery_SetComparisonDefaultTypeInternal _Expression_Subquery_SetComparison_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_Subquery_SetComparison_class_data_;
class Expression_Subquery_SetPredicate;
struct Expression_Subquery_SetPredicateDefaultTypeInternal;
extern Expression_Subquery_SetPredicateDefaultTypeInternal _Expression_Subquery_SetPredicate_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_Subquery_SetPredicate_class_data_;
class Expression_SwitchExpression;
struct Expression_SwitchExpressionDefaultTypeInternal;
extern Expression_SwitchExpressionDefaultTypeInternal _Expression_SwitchExpression_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_SwitchExpression_class_data_;
class Expression_SwitchExpression_IfValue;
struct Expression_SwitchExpression_IfValueDefaultTypeInternal;
extern Expression_SwitchExpression_IfValueDefaultTypeInternal _Expression_SwitchExpression_IfValue_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_SwitchExpression_IfValue_class_data_;
class Expression_WindowFunction;
struct Expression_WindowFunctionDefaultTypeInternal;
extern Expression_WindowFunctionDefaultTypeInternal _Expression_WindowFunction_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_WindowFunction_class_data_;
class Expression_WindowFunction_Bound;
struct Expression_WindowFunction_BoundDefaultTypeInternal;
extern Expression_WindowFunction_BoundDefaultTypeInternal _Expression_WindowFunction_Bound_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_WindowFunction_Bound_class_data_;
class Expression_WindowFunction_Bound_CurrentRow;
struct Expression_WindowFunction_Bound_CurrentRowDefaultTypeInternal;
extern Expression_WindowFunction_Bound_CurrentRowDefaultTypeInternal _Expression_WindowFunction_Bound_CurrentRow_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_WindowFunction_Bound_CurrentRow_class_data_;
class Expression_WindowFunction_Bound_Following;
struct Expression_WindowFunction_Bound_FollowingDefaultTypeInternal;
extern Expression_WindowFunction_Bound_FollowingDefaultTypeInternal _Expression_WindowFunction_Bound_Following_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_WindowFunction_Bound_Following_class_data_;
class Expression_WindowFunction_Bound_Preceding;
struct Expression_WindowFunction_Bound_PrecedingDefaultTypeInternal;
extern Expression_WindowFunction_Bound_PrecedingDefaultTypeInternal _Expression_WindowFunction_Bound_Preceding_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_WindowFunction_Bound_Preceding_class_data_;
class Expression_WindowFunction_Bound_Unbounded;
struct Expression_WindowFunction_Bound_UnboundedDefaultTypeInternal;
extern Expression_WindowFunction_Bound_UnboundedDefaultTypeInternal _Expression_WindowFunction_Bound_Unbounded_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Expression_WindowFunction_Bound_Unbounded_class_data_;
class ExtensionLeafRel;
struct ExtensionLeafRelDefaultTypeInternal;
extern ExtensionLeafRelDefaultTypeInternal _ExtensionLeafRel_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ExtensionLeafRel_class_data_;
class ExtensionMultiRel;
struct ExtensionMultiRelDefaultTypeInternal;
extern ExtensionMultiRelDefaultTypeInternal _ExtensionMultiRel_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ExtensionMultiRel_class_data_;
class ExtensionObject;
struct ExtensionObjectDefaultTypeInternal;
extern ExtensionObjectDefaultTypeInternal _ExtensionObject_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ExtensionObject_class_data_;
class ExtensionSingleRel;
struct ExtensionSingleRelDefaultTypeInternal;
extern ExtensionSingleRelDefaultTypeInternal _ExtensionSingleRel_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ExtensionSingleRel_class_data_;
class FetchRel;
struct FetchRelDefaultTypeInternal;
extern FetchRelDefaultTypeInternal _FetchRel_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull FetchRel_class_data_;
class FilterRel;
struct FilterRelDefaultTypeInternal;
extern FilterRelDefaultTypeInternal _FilterRel_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull FilterRel_class_data_;
class FunctionArgument;
struct FunctionArgumentDefaultTypeInternal;
extern FunctionArgumentDefaultTypeInternal _FunctionArgument_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull FunctionArgument_class_data_;
class FunctionOption;
struct FunctionOptionDefaultTypeInternal;
extern FunctionOptionDefaultTypeInternal _FunctionOption_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull FunctionOption_class_data_;
class HashJoinRel;
struct HashJoinRelDefaultTypeInternal;
extern HashJoinRelDefaultTypeInternal _HashJoinRel_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull HashJoinRel_class_data_;
class JoinRel;
struct JoinRelDefaultTypeInternal;
extern JoinRelDefaultTypeInternal _JoinRel_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull JoinRel_class_data_;
class MergeJoinRel;
struct MergeJoinRelDefaultTypeInternal;
extern MergeJoinRelDefaultTypeInternal _MergeJoinRel_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull MergeJoinRel_class_data_;
class NamedObjectWrite;
struct NamedObjectWriteDefaultTypeInternal;
extern NamedObjectWriteDefaultTypeInternal _NamedObjectWrite_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull NamedObjectWrite_class_data_;
class NestedLoopJoinRel;
struct NestedLoopJoinRelDefaultTypeInternal;
extern NestedLoopJoinRelDefaultTypeInternal _NestedLoopJoinRel_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull NestedLoopJoinRel_class_data_;
class ProjectRel;
struct ProjectRelDefaultTypeInternal;
extern ProjectRelDefaultTypeInternal _ProjectRel_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ProjectRel_class_data_;
class ReadRel;
struct ReadRelDefaultTypeInternal;
extern ReadRelDefaultTypeInternal _ReadRel_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ReadRel_class_data_;
class ReadRel_ExtensionTable;
struct ReadRel_ExtensionTableDefaultTypeInternal;
extern ReadRel_ExtensionTableDefaultTypeInternal _ReadRel_ExtensionTable_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ReadRel_ExtensionTable_class_data_;
class ReadRel_LocalFiles;
struct ReadRel_LocalFilesDefaultTypeInternal;
extern ReadRel_LocalFilesDefaultTypeInternal _ReadRel_LocalFiles_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ReadRel_LocalFiles_class_data_;
class ReadRel_LocalFiles_FileOrFiles;
struct ReadRel_LocalFiles_FileOrFilesDefaultTypeInternal;
extern ReadRel_LocalFiles_FileOrFilesDefaultTypeInternal _ReadRel_LocalFiles_FileOrFiles_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ReadRel_LocalFiles_FileOrFiles_class_data_;
class ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions;
struct ReadRel_LocalFiles_FileOrFiles_ArrowReadOptionsDefaultTypeInternal;
extern ReadRel_LocalFiles_FileOrFiles_ArrowReadOptionsDefaultTypeInternal _ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions_class_data_;
class ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions;
struct ReadRel_LocalFiles_FileOrFiles_DwrfReadOptionsDefaultTypeInternal;
extern ReadRel_LocalFiles_FileOrFiles_DwrfReadOptionsDefaultTypeInternal _ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions_class_data_;
class ReadRel_LocalFiles_FileOrFiles_OrcReadOptions;
struct ReadRel_LocalFiles_FileOrFiles_OrcReadOptionsDefaultTypeInternal;
extern ReadRel_LocalFiles_FileOrFiles_OrcReadOptionsDefaultTypeInternal _ReadRel_LocalFiles_FileOrFiles_OrcReadOptions_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ReadRel_LocalFiles_FileOrFiles_OrcReadOptions_class_data_;
class ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions;
struct ReadRel_LocalFiles_FileOrFiles_ParquetReadOptionsDefaultTypeInternal;
extern ReadRel_LocalFiles_FileOrFiles_ParquetReadOptionsDefaultTypeInternal _ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions_class_data_;
class ReadRel_NamedTable;
struct ReadRel_NamedTableDefaultTypeInternal;
extern ReadRel_NamedTableDefaultTypeInternal _ReadRel_NamedTable_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ReadRel_NamedTable_class_data_;
class ReadRel_VirtualTable;
struct ReadRel_VirtualTableDefaultTypeInternal;
extern ReadRel_VirtualTableDefaultTypeInternal _ReadRel_VirtualTable_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ReadRel_VirtualTable_class_data_;
class ReferenceRel;
struct ReferenceRelDefaultTypeInternal;
extern ReferenceRelDefaultTypeInternal _ReferenceRel_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ReferenceRel_class_data_;
class Rel;
struct RelDefaultTypeInternal;
extern RelDefaultTypeInternal _Rel_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Rel_class_data_;
class RelCommon;
struct RelCommonDefaultTypeInternal;
extern RelCommonDefaultTypeInternal _RelCommon_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RelCommon_class_data_;
class RelCommon_Direct;
struct RelCommon_DirectDefaultTypeInternal;
extern RelCommon_DirectDefaultTypeInternal _RelCommon_Direct_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RelCommon_Direct_class_data_;
class RelCommon_Emit;
struct RelCommon_EmitDefaultTypeInternal;
extern RelCommon_EmitDefaultTypeInternal _RelCommon_Emit_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RelCommon_Emit_class_data_;
class RelCommon_Hint;
struct RelCommon_HintDefaultTypeInternal;
extern RelCommon_HintDefaultTypeInternal _RelCommon_Hint_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RelCommon_Hint_class_data_;
class RelCommon_Hint_RuntimeConstraint;
struct RelCommon_Hint_RuntimeConstraintDefaultTypeInternal;
extern RelCommon_Hint_RuntimeConstraintDefaultTypeInternal _RelCommon_Hint_RuntimeConstraint_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RelCommon_Hint_RuntimeConstraint_class_data_;
class RelCommon_Hint_Stats;
struct RelCommon_Hint_StatsDefaultTypeInternal;
extern RelCommon_Hint_StatsDefaultTypeInternal _RelCommon_Hint_Stats_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RelCommon_Hint_Stats_class_data_;
class RelRoot;
struct RelRootDefaultTypeInternal;
extern RelRootDefaultTypeInternal _RelRoot_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RelRoot_class_data_;
class SetRel;
struct SetRelDefaultTypeInternal;
extern SetRelDefaultTypeInternal _SetRel_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SetRel_class_data_;
class SortField;
struct SortFieldDefaultTypeInternal;
extern SortFieldDefaultTypeInternal _SortField_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SortField_class_data_;
class SortRel;
struct SortRelDefaultTypeInternal;
extern SortRelDefaultTypeInternal _SortRel_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SortRel_class_data_;
class WriteRel;
struct WriteRelDefaultTypeInternal;
extern WriteRelDefaultTypeInternal _WriteRel_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull WriteRel_class_data_;
}  // namespace substrait
namespace google {
namespace protobuf {
template <>
internal::EnumTraitsT<::substrait::AggregateFunction_AggregationInvocation_internal_data_>
    internal::EnumTraitsImpl::value<::substrait::AggregateFunction_AggregationInvocation>;
template <>
internal::EnumTraitsT<::substrait::AggregationPhase_internal_data_>
    internal::EnumTraitsImpl::value<::substrait::AggregationPhase>;
template <>
internal::EnumTraitsT<::substrait::ComparisonJoinKey_SimpleComparisonType_internal_data_>
    internal::EnumTraitsImpl::value<::substrait::ComparisonJoinKey_SimpleComparisonType>;
template <>
internal::EnumTraitsT<::substrait::DdlRel_DdlObject_internal_data_>
    internal::EnumTraitsImpl::value<::substrait::DdlRel_DdlObject>;
template <>
internal::EnumTraitsT<::substrait::DdlRel_DdlOp_internal_data_>
    internal::EnumTraitsImpl::value<::substrait::DdlRel_DdlOp>;
template <>
internal::EnumTraitsT<::substrait::Expression_Cast_FailureBehavior_internal_data_>
    internal::EnumTraitsImpl::value<::substrait::Expression_Cast_FailureBehavior>;
template <>
internal::EnumTraitsT<::substrait::Expression_Subquery_SetComparison_ComparisonOp_internal_data_>
    internal::EnumTraitsImpl::value<::substrait::Expression_Subquery_SetComparison_ComparisonOp>;
template <>
internal::EnumTraitsT<::substrait::Expression_Subquery_SetComparison_ReductionOp_internal_data_>
    internal::EnumTraitsImpl::value<::substrait::Expression_Subquery_SetComparison_ReductionOp>;
template <>
internal::EnumTraitsT<::substrait::Expression_Subquery_SetPredicate_PredicateOp_internal_data_>
    internal::EnumTraitsImpl::value<::substrait::Expression_Subquery_SetPredicate_PredicateOp>;
template <>
internal::EnumTraitsT<::substrait::Expression_WindowFunction_BoundsType_internal_data_>
    internal::EnumTraitsImpl::value<::substrait::Expression_WindowFunction_BoundsType>;
template <>
internal::EnumTraitsT<::substrait::HashJoinRel_JoinType_internal_data_>
    internal::EnumTraitsImpl::value<::substrait::HashJoinRel_JoinType>;
template <>
internal::EnumTraitsT<::substrait::JoinRel_JoinType_internal_data_>
    internal::EnumTraitsImpl::value<::substrait::JoinRel_JoinType>;
template <>
internal::EnumTraitsT<::substrait::MergeJoinRel_JoinType_internal_data_>
    internal::EnumTraitsImpl::value<::substrait::MergeJoinRel_JoinType>;
template <>
internal::EnumTraitsT<::substrait::NestedLoopJoinRel_JoinType_internal_data_>
    internal::EnumTraitsImpl::value<::substrait::NestedLoopJoinRel_JoinType>;
template <>
internal::EnumTraitsT<::substrait::SetRel_SetOp_internal_data_>
    internal::EnumTraitsImpl::value<::substrait::SetRel_SetOp>;
template <>
internal::EnumTraitsT<::substrait::SortField_SortDirection_internal_data_>
    internal::EnumTraitsImpl::value<::substrait::SortField_SortDirection>;
template <>
internal::EnumTraitsT<::substrait::WriteRel_OutputMode_internal_data_>
    internal::EnumTraitsImpl::value<::substrait::WriteRel_OutputMode>;
template <>
internal::EnumTraitsT<::substrait::WriteRel_WriteOp_internal_data_>
    internal::EnumTraitsImpl::value<::substrait::WriteRel_WriteOp>;
}  // namespace protobuf
}  // namespace google

namespace substrait {
enum JoinRel_JoinType : int {
  JoinRel_JoinType_JOIN_TYPE_UNSPECIFIED = 0,
  JoinRel_JoinType_JOIN_TYPE_INNER = 1,
  JoinRel_JoinType_JOIN_TYPE_OUTER = 2,
  JoinRel_JoinType_JOIN_TYPE_LEFT = 3,
  JoinRel_JoinType_JOIN_TYPE_RIGHT = 4,
  JoinRel_JoinType_JOIN_TYPE_SEMI = 5,
  JoinRel_JoinType_JOIN_TYPE_ANTI = 6,
  JoinRel_JoinType_JOIN_TYPE_SINGLE = 7,
  JoinRel_JoinType_JoinRel_JoinType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  JoinRel_JoinType_JoinRel_JoinType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool JoinRel_JoinType_IsValid(int value);
extern const uint32_t JoinRel_JoinType_internal_data_[];
inline constexpr JoinRel_JoinType JoinRel_JoinType_JoinType_MIN =
    static_cast<JoinRel_JoinType>(0);
inline constexpr JoinRel_JoinType JoinRel_JoinType_JoinType_MAX =
    static_cast<JoinRel_JoinType>(7);
inline constexpr int JoinRel_JoinType_JoinType_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor*
JoinRel_JoinType_descriptor();
template <typename T>
const std::string& JoinRel_JoinType_Name(T value) {
  static_assert(std::is_same<T, JoinRel_JoinType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to JoinType_Name().");
  return JoinRel_JoinType_Name(static_cast<JoinRel_JoinType>(value));
}
template <>
inline const std::string& JoinRel_JoinType_Name(JoinRel_JoinType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<JoinRel_JoinType_descriptor,
                                                 0, 7>(
      static_cast<int>(value));
}
inline bool JoinRel_JoinType_Parse(absl::string_view name, JoinRel_JoinType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<JoinRel_JoinType>(
      JoinRel_JoinType_descriptor(), name, value);
}
enum SetRel_SetOp : int {
  SetRel_SetOp_SET_OP_UNSPECIFIED = 0,
  SetRel_SetOp_SET_OP_MINUS_PRIMARY = 1,
  SetRel_SetOp_SET_OP_MINUS_MULTISET = 2,
  SetRel_SetOp_SET_OP_INTERSECTION_PRIMARY = 3,
  SetRel_SetOp_SET_OP_INTERSECTION_MULTISET = 4,
  SetRel_SetOp_SET_OP_UNION_DISTINCT = 5,
  SetRel_SetOp_SET_OP_UNION_ALL = 6,
  SetRel_SetOp_SetRel_SetOp_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SetRel_SetOp_SetRel_SetOp_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool SetRel_SetOp_IsValid(int value);
extern const uint32_t SetRel_SetOp_internal_data_[];
inline constexpr SetRel_SetOp SetRel_SetOp_SetOp_MIN =
    static_cast<SetRel_SetOp>(0);
inline constexpr SetRel_SetOp SetRel_SetOp_SetOp_MAX =
    static_cast<SetRel_SetOp>(6);
inline constexpr int SetRel_SetOp_SetOp_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor*
SetRel_SetOp_descriptor();
template <typename T>
const std::string& SetRel_SetOp_Name(T value) {
  static_assert(std::is_same<T, SetRel_SetOp>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SetOp_Name().");
  return SetRel_SetOp_Name(static_cast<SetRel_SetOp>(value));
}
template <>
inline const std::string& SetRel_SetOp_Name(SetRel_SetOp value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SetRel_SetOp_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool SetRel_SetOp_Parse(absl::string_view name, SetRel_SetOp* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SetRel_SetOp>(
      SetRel_SetOp_descriptor(), name, value);
}
enum DdlRel_DdlObject : int {
  DdlRel_DdlObject_DDL_OBJECT_UNSPECIFIED = 0,
  DdlRel_DdlObject_DDL_OBJECT_TABLE = 1,
  DdlRel_DdlObject_DDL_OBJECT_VIEW = 2,
  DdlRel_DdlObject_DdlRel_DdlObject_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DdlRel_DdlObject_DdlRel_DdlObject_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DdlRel_DdlObject_IsValid(int value);
extern const uint32_t DdlRel_DdlObject_internal_data_[];
inline constexpr DdlRel_DdlObject DdlRel_DdlObject_DdlObject_MIN =
    static_cast<DdlRel_DdlObject>(0);
inline constexpr DdlRel_DdlObject DdlRel_DdlObject_DdlObject_MAX =
    static_cast<DdlRel_DdlObject>(2);
inline constexpr int DdlRel_DdlObject_DdlObject_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
DdlRel_DdlObject_descriptor();
template <typename T>
const std::string& DdlRel_DdlObject_Name(T value) {
  static_assert(std::is_same<T, DdlRel_DdlObject>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DdlObject_Name().");
  return DdlRel_DdlObject_Name(static_cast<DdlRel_DdlObject>(value));
}
template <>
inline const std::string& DdlRel_DdlObject_Name(DdlRel_DdlObject value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DdlRel_DdlObject_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool DdlRel_DdlObject_Parse(absl::string_view name, DdlRel_DdlObject* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DdlRel_DdlObject>(
      DdlRel_DdlObject_descriptor(), name, value);
}
enum DdlRel_DdlOp : int {
  DdlRel_DdlOp_DDL_OP_UNSPECIFIED = 0,
  DdlRel_DdlOp_DDL_OP_CREATE = 1,
  DdlRel_DdlOp_DDL_OP_CREATE_OR_REPLACE = 2,
  DdlRel_DdlOp_DDL_OP_ALTER = 3,
  DdlRel_DdlOp_DDL_OP_DROP = 4,
  DdlRel_DdlOp_DDL_OP_DROP_IF_EXIST = 5,
  DdlRel_DdlOp_DdlRel_DdlOp_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DdlRel_DdlOp_DdlRel_DdlOp_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DdlRel_DdlOp_IsValid(int value);
extern const uint32_t DdlRel_DdlOp_internal_data_[];
inline constexpr DdlRel_DdlOp DdlRel_DdlOp_DdlOp_MIN =
    static_cast<DdlRel_DdlOp>(0);
inline constexpr DdlRel_DdlOp DdlRel_DdlOp_DdlOp_MAX =
    static_cast<DdlRel_DdlOp>(5);
inline constexpr int DdlRel_DdlOp_DdlOp_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
DdlRel_DdlOp_descriptor();
template <typename T>
const std::string& DdlRel_DdlOp_Name(T value) {
  static_assert(std::is_same<T, DdlRel_DdlOp>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DdlOp_Name().");
  return DdlRel_DdlOp_Name(static_cast<DdlRel_DdlOp>(value));
}
template <>
inline const std::string& DdlRel_DdlOp_Name(DdlRel_DdlOp value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DdlRel_DdlOp_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool DdlRel_DdlOp_Parse(absl::string_view name, DdlRel_DdlOp* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DdlRel_DdlOp>(
      DdlRel_DdlOp_descriptor(), name, value);
}
enum WriteRel_WriteOp : int {
  WriteRel_WriteOp_WRITE_OP_UNSPECIFIED = 0,
  WriteRel_WriteOp_WRITE_OP_INSERT = 1,
  WriteRel_WriteOp_WRITE_OP_DELETE = 2,
  WriteRel_WriteOp_WRITE_OP_UPDATE = 3,
  WriteRel_WriteOp_WRITE_OP_CTAS = 4,
  WriteRel_WriteOp_WriteRel_WriteOp_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  WriteRel_WriteOp_WriteRel_WriteOp_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool WriteRel_WriteOp_IsValid(int value);
extern const uint32_t WriteRel_WriteOp_internal_data_[];
inline constexpr WriteRel_WriteOp WriteRel_WriteOp_WriteOp_MIN =
    static_cast<WriteRel_WriteOp>(0);
inline constexpr WriteRel_WriteOp WriteRel_WriteOp_WriteOp_MAX =
    static_cast<WriteRel_WriteOp>(4);
inline constexpr int WriteRel_WriteOp_WriteOp_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
WriteRel_WriteOp_descriptor();
template <typename T>
const std::string& WriteRel_WriteOp_Name(T value) {
  static_assert(std::is_same<T, WriteRel_WriteOp>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to WriteOp_Name().");
  return WriteRel_WriteOp_Name(static_cast<WriteRel_WriteOp>(value));
}
template <>
inline const std::string& WriteRel_WriteOp_Name(WriteRel_WriteOp value) {
  return ::google::protobuf::internal::NameOfDenseEnum<WriteRel_WriteOp_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool WriteRel_WriteOp_Parse(absl::string_view name, WriteRel_WriteOp* value) {
  return ::google::protobuf::internal::ParseNamedEnum<WriteRel_WriteOp>(
      WriteRel_WriteOp_descriptor(), name, value);
}
enum WriteRel_OutputMode : int {
  WriteRel_OutputMode_OUTPUT_MODE_UNSPECIFIED = 0,
  WriteRel_OutputMode_OUTPUT_MODE_NO_OUTPUT = 1,
  WriteRel_OutputMode_OUTPUT_MODE_MODIFIED_RECORDS = 2,
  WriteRel_OutputMode_WriteRel_OutputMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  WriteRel_OutputMode_WriteRel_OutputMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool WriteRel_OutputMode_IsValid(int value);
extern const uint32_t WriteRel_OutputMode_internal_data_[];
inline constexpr WriteRel_OutputMode WriteRel_OutputMode_OutputMode_MIN =
    static_cast<WriteRel_OutputMode>(0);
inline constexpr WriteRel_OutputMode WriteRel_OutputMode_OutputMode_MAX =
    static_cast<WriteRel_OutputMode>(2);
inline constexpr int WriteRel_OutputMode_OutputMode_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
WriteRel_OutputMode_descriptor();
template <typename T>
const std::string& WriteRel_OutputMode_Name(T value) {
  static_assert(std::is_same<T, WriteRel_OutputMode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to OutputMode_Name().");
  return WriteRel_OutputMode_Name(static_cast<WriteRel_OutputMode>(value));
}
template <>
inline const std::string& WriteRel_OutputMode_Name(WriteRel_OutputMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<WriteRel_OutputMode_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool WriteRel_OutputMode_Parse(absl::string_view name, WriteRel_OutputMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<WriteRel_OutputMode>(
      WriteRel_OutputMode_descriptor(), name, value);
}
enum ComparisonJoinKey_SimpleComparisonType : int {
  ComparisonJoinKey_SimpleComparisonType_SIMPLE_COMPARISON_TYPE_UNSPECIFIED = 0,
  ComparisonJoinKey_SimpleComparisonType_SIMPLE_COMPARISON_TYPE_EQ = 1,
  ComparisonJoinKey_SimpleComparisonType_SIMPLE_COMPARISON_TYPE_IS_NOT_DISTINCT_FROM = 2,
  ComparisonJoinKey_SimpleComparisonType_SIMPLE_COMPARISON_TYPE_MIGHT_EQUAL = 3,
  ComparisonJoinKey_SimpleComparisonType_ComparisonJoinKey_SimpleComparisonType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ComparisonJoinKey_SimpleComparisonType_ComparisonJoinKey_SimpleComparisonType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ComparisonJoinKey_SimpleComparisonType_IsValid(int value);
extern const uint32_t ComparisonJoinKey_SimpleComparisonType_internal_data_[];
inline constexpr ComparisonJoinKey_SimpleComparisonType ComparisonJoinKey_SimpleComparisonType_SimpleComparisonType_MIN =
    static_cast<ComparisonJoinKey_SimpleComparisonType>(0);
inline constexpr ComparisonJoinKey_SimpleComparisonType ComparisonJoinKey_SimpleComparisonType_SimpleComparisonType_MAX =
    static_cast<ComparisonJoinKey_SimpleComparisonType>(3);
inline constexpr int ComparisonJoinKey_SimpleComparisonType_SimpleComparisonType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
ComparisonJoinKey_SimpleComparisonType_descriptor();
template <typename T>
const std::string& ComparisonJoinKey_SimpleComparisonType_Name(T value) {
  static_assert(std::is_same<T, ComparisonJoinKey_SimpleComparisonType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SimpleComparisonType_Name().");
  return ComparisonJoinKey_SimpleComparisonType_Name(static_cast<ComparisonJoinKey_SimpleComparisonType>(value));
}
template <>
inline const std::string& ComparisonJoinKey_SimpleComparisonType_Name(ComparisonJoinKey_SimpleComparisonType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ComparisonJoinKey_SimpleComparisonType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool ComparisonJoinKey_SimpleComparisonType_Parse(absl::string_view name, ComparisonJoinKey_SimpleComparisonType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ComparisonJoinKey_SimpleComparisonType>(
      ComparisonJoinKey_SimpleComparisonType_descriptor(), name, value);
}
enum HashJoinRel_JoinType : int {
  HashJoinRel_JoinType_JOIN_TYPE_UNSPECIFIED = 0,
  HashJoinRel_JoinType_JOIN_TYPE_INNER = 1,
  HashJoinRel_JoinType_JOIN_TYPE_OUTER = 2,
  HashJoinRel_JoinType_JOIN_TYPE_LEFT = 3,
  HashJoinRel_JoinType_JOIN_TYPE_RIGHT = 4,
  HashJoinRel_JoinType_JOIN_TYPE_LEFT_SEMI = 5,
  HashJoinRel_JoinType_JOIN_TYPE_RIGHT_SEMI = 6,
  HashJoinRel_JoinType_JOIN_TYPE_LEFT_ANTI = 7,
  HashJoinRel_JoinType_JOIN_TYPE_RIGHT_ANTI = 8,
  HashJoinRel_JoinType_HashJoinRel_JoinType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  HashJoinRel_JoinType_HashJoinRel_JoinType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool HashJoinRel_JoinType_IsValid(int value);
extern const uint32_t HashJoinRel_JoinType_internal_data_[];
inline constexpr HashJoinRel_JoinType HashJoinRel_JoinType_JoinType_MIN =
    static_cast<HashJoinRel_JoinType>(0);
inline constexpr HashJoinRel_JoinType HashJoinRel_JoinType_JoinType_MAX =
    static_cast<HashJoinRel_JoinType>(8);
inline constexpr int HashJoinRel_JoinType_JoinType_ARRAYSIZE = 8 + 1;
const ::google::protobuf::EnumDescriptor*
HashJoinRel_JoinType_descriptor();
template <typename T>
const std::string& HashJoinRel_JoinType_Name(T value) {
  static_assert(std::is_same<T, HashJoinRel_JoinType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to JoinType_Name().");
  return HashJoinRel_JoinType_Name(static_cast<HashJoinRel_JoinType>(value));
}
template <>
inline const std::string& HashJoinRel_JoinType_Name(HashJoinRel_JoinType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<HashJoinRel_JoinType_descriptor,
                                                 0, 8>(
      static_cast<int>(value));
}
inline bool HashJoinRel_JoinType_Parse(absl::string_view name, HashJoinRel_JoinType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HashJoinRel_JoinType>(
      HashJoinRel_JoinType_descriptor(), name, value);
}
enum MergeJoinRel_JoinType : int {
  MergeJoinRel_JoinType_JOIN_TYPE_UNSPECIFIED = 0,
  MergeJoinRel_JoinType_JOIN_TYPE_INNER = 1,
  MergeJoinRel_JoinType_JOIN_TYPE_OUTER = 2,
  MergeJoinRel_JoinType_JOIN_TYPE_LEFT = 3,
  MergeJoinRel_JoinType_JOIN_TYPE_RIGHT = 4,
  MergeJoinRel_JoinType_JOIN_TYPE_LEFT_SEMI = 5,
  MergeJoinRel_JoinType_JOIN_TYPE_RIGHT_SEMI = 6,
  MergeJoinRel_JoinType_JOIN_TYPE_LEFT_ANTI = 7,
  MergeJoinRel_JoinType_JOIN_TYPE_RIGHT_ANTI = 8,
  MergeJoinRel_JoinType_MergeJoinRel_JoinType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  MergeJoinRel_JoinType_MergeJoinRel_JoinType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool MergeJoinRel_JoinType_IsValid(int value);
extern const uint32_t MergeJoinRel_JoinType_internal_data_[];
inline constexpr MergeJoinRel_JoinType MergeJoinRel_JoinType_JoinType_MIN =
    static_cast<MergeJoinRel_JoinType>(0);
inline constexpr MergeJoinRel_JoinType MergeJoinRel_JoinType_JoinType_MAX =
    static_cast<MergeJoinRel_JoinType>(8);
inline constexpr int MergeJoinRel_JoinType_JoinType_ARRAYSIZE = 8 + 1;
const ::google::protobuf::EnumDescriptor*
MergeJoinRel_JoinType_descriptor();
template <typename T>
const std::string& MergeJoinRel_JoinType_Name(T value) {
  static_assert(std::is_same<T, MergeJoinRel_JoinType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to JoinType_Name().");
  return MergeJoinRel_JoinType_Name(static_cast<MergeJoinRel_JoinType>(value));
}
template <>
inline const std::string& MergeJoinRel_JoinType_Name(MergeJoinRel_JoinType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MergeJoinRel_JoinType_descriptor,
                                                 0, 8>(
      static_cast<int>(value));
}
inline bool MergeJoinRel_JoinType_Parse(absl::string_view name, MergeJoinRel_JoinType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MergeJoinRel_JoinType>(
      MergeJoinRel_JoinType_descriptor(), name, value);
}
enum NestedLoopJoinRel_JoinType : int {
  NestedLoopJoinRel_JoinType_JOIN_TYPE_UNSPECIFIED = 0,
  NestedLoopJoinRel_JoinType_JOIN_TYPE_INNER = 1,
  NestedLoopJoinRel_JoinType_JOIN_TYPE_OUTER = 2,
  NestedLoopJoinRel_JoinType_JOIN_TYPE_LEFT = 3,
  NestedLoopJoinRel_JoinType_JOIN_TYPE_RIGHT = 4,
  NestedLoopJoinRel_JoinType_JOIN_TYPE_LEFT_SEMI = 5,
  NestedLoopJoinRel_JoinType_JOIN_TYPE_RIGHT_SEMI = 6,
  NestedLoopJoinRel_JoinType_JOIN_TYPE_LEFT_ANTI = 7,
  NestedLoopJoinRel_JoinType_JOIN_TYPE_RIGHT_ANTI = 8,
  NestedLoopJoinRel_JoinType_NestedLoopJoinRel_JoinType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  NestedLoopJoinRel_JoinType_NestedLoopJoinRel_JoinType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool NestedLoopJoinRel_JoinType_IsValid(int value);
extern const uint32_t NestedLoopJoinRel_JoinType_internal_data_[];
inline constexpr NestedLoopJoinRel_JoinType NestedLoopJoinRel_JoinType_JoinType_MIN =
    static_cast<NestedLoopJoinRel_JoinType>(0);
inline constexpr NestedLoopJoinRel_JoinType NestedLoopJoinRel_JoinType_JoinType_MAX =
    static_cast<NestedLoopJoinRel_JoinType>(8);
inline constexpr int NestedLoopJoinRel_JoinType_JoinType_ARRAYSIZE = 8 + 1;
const ::google::protobuf::EnumDescriptor*
NestedLoopJoinRel_JoinType_descriptor();
template <typename T>
const std::string& NestedLoopJoinRel_JoinType_Name(T value) {
  static_assert(std::is_same<T, NestedLoopJoinRel_JoinType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to JoinType_Name().");
  return NestedLoopJoinRel_JoinType_Name(static_cast<NestedLoopJoinRel_JoinType>(value));
}
template <>
inline const std::string& NestedLoopJoinRel_JoinType_Name(NestedLoopJoinRel_JoinType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<NestedLoopJoinRel_JoinType_descriptor,
                                                 0, 8>(
      static_cast<int>(value));
}
inline bool NestedLoopJoinRel_JoinType_Parse(absl::string_view name, NestedLoopJoinRel_JoinType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NestedLoopJoinRel_JoinType>(
      NestedLoopJoinRel_JoinType_descriptor(), name, value);
}
enum Expression_WindowFunction_BoundsType : int {
  Expression_WindowFunction_BoundsType_BOUNDS_TYPE_UNSPECIFIED = 0,
  Expression_WindowFunction_BoundsType_BOUNDS_TYPE_ROWS = 1,
  Expression_WindowFunction_BoundsType_BOUNDS_TYPE_RANGE = 2,
  Expression_WindowFunction_BoundsType_Expression_WindowFunction_BoundsType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Expression_WindowFunction_BoundsType_Expression_WindowFunction_BoundsType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Expression_WindowFunction_BoundsType_IsValid(int value);
extern const uint32_t Expression_WindowFunction_BoundsType_internal_data_[];
inline constexpr Expression_WindowFunction_BoundsType Expression_WindowFunction_BoundsType_BoundsType_MIN =
    static_cast<Expression_WindowFunction_BoundsType>(0);
inline constexpr Expression_WindowFunction_BoundsType Expression_WindowFunction_BoundsType_BoundsType_MAX =
    static_cast<Expression_WindowFunction_BoundsType>(2);
inline constexpr int Expression_WindowFunction_BoundsType_BoundsType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
Expression_WindowFunction_BoundsType_descriptor();
template <typename T>
const std::string& Expression_WindowFunction_BoundsType_Name(T value) {
  static_assert(std::is_same<T, Expression_WindowFunction_BoundsType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to BoundsType_Name().");
  return Expression_WindowFunction_BoundsType_Name(static_cast<Expression_WindowFunction_BoundsType>(value));
}
template <>
inline const std::string& Expression_WindowFunction_BoundsType_Name(Expression_WindowFunction_BoundsType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Expression_WindowFunction_BoundsType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool Expression_WindowFunction_BoundsType_Parse(absl::string_view name, Expression_WindowFunction_BoundsType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Expression_WindowFunction_BoundsType>(
      Expression_WindowFunction_BoundsType_descriptor(), name, value);
}
enum Expression_Cast_FailureBehavior : int {
  Expression_Cast_FailureBehavior_FAILURE_BEHAVIOR_UNSPECIFIED = 0,
  Expression_Cast_FailureBehavior_FAILURE_BEHAVIOR_RETURN_NULL = 1,
  Expression_Cast_FailureBehavior_FAILURE_BEHAVIOR_THROW_EXCEPTION = 2,
  Expression_Cast_FailureBehavior_Expression_Cast_FailureBehavior_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Expression_Cast_FailureBehavior_Expression_Cast_FailureBehavior_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Expression_Cast_FailureBehavior_IsValid(int value);
extern const uint32_t Expression_Cast_FailureBehavior_internal_data_[];
inline constexpr Expression_Cast_FailureBehavior Expression_Cast_FailureBehavior_FailureBehavior_MIN =
    static_cast<Expression_Cast_FailureBehavior>(0);
inline constexpr Expression_Cast_FailureBehavior Expression_Cast_FailureBehavior_FailureBehavior_MAX =
    static_cast<Expression_Cast_FailureBehavior>(2);
inline constexpr int Expression_Cast_FailureBehavior_FailureBehavior_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
Expression_Cast_FailureBehavior_descriptor();
template <typename T>
const std::string& Expression_Cast_FailureBehavior_Name(T value) {
  static_assert(std::is_same<T, Expression_Cast_FailureBehavior>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to FailureBehavior_Name().");
  return Expression_Cast_FailureBehavior_Name(static_cast<Expression_Cast_FailureBehavior>(value));
}
template <>
inline const std::string& Expression_Cast_FailureBehavior_Name(Expression_Cast_FailureBehavior value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Expression_Cast_FailureBehavior_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool Expression_Cast_FailureBehavior_Parse(absl::string_view name, Expression_Cast_FailureBehavior* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Expression_Cast_FailureBehavior>(
      Expression_Cast_FailureBehavior_descriptor(), name, value);
}
enum Expression_Subquery_SetPredicate_PredicateOp : int {
  Expression_Subquery_SetPredicate_PredicateOp_PREDICATE_OP_UNSPECIFIED = 0,
  Expression_Subquery_SetPredicate_PredicateOp_PREDICATE_OP_EXISTS = 1,
  Expression_Subquery_SetPredicate_PredicateOp_PREDICATE_OP_UNIQUE = 2,
  Expression_Subquery_SetPredicate_PredicateOp_Expression_Subquery_SetPredicate_PredicateOp_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Expression_Subquery_SetPredicate_PredicateOp_Expression_Subquery_SetPredicate_PredicateOp_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Expression_Subquery_SetPredicate_PredicateOp_IsValid(int value);
extern const uint32_t Expression_Subquery_SetPredicate_PredicateOp_internal_data_[];
inline constexpr Expression_Subquery_SetPredicate_PredicateOp Expression_Subquery_SetPredicate_PredicateOp_PredicateOp_MIN =
    static_cast<Expression_Subquery_SetPredicate_PredicateOp>(0);
inline constexpr Expression_Subquery_SetPredicate_PredicateOp Expression_Subquery_SetPredicate_PredicateOp_PredicateOp_MAX =
    static_cast<Expression_Subquery_SetPredicate_PredicateOp>(2);
inline constexpr int Expression_Subquery_SetPredicate_PredicateOp_PredicateOp_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
Expression_Subquery_SetPredicate_PredicateOp_descriptor();
template <typename T>
const std::string& Expression_Subquery_SetPredicate_PredicateOp_Name(T value) {
  static_assert(std::is_same<T, Expression_Subquery_SetPredicate_PredicateOp>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PredicateOp_Name().");
  return Expression_Subquery_SetPredicate_PredicateOp_Name(static_cast<Expression_Subquery_SetPredicate_PredicateOp>(value));
}
template <>
inline const std::string& Expression_Subquery_SetPredicate_PredicateOp_Name(Expression_Subquery_SetPredicate_PredicateOp value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Expression_Subquery_SetPredicate_PredicateOp_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool Expression_Subquery_SetPredicate_PredicateOp_Parse(absl::string_view name, Expression_Subquery_SetPredicate_PredicateOp* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Expression_Subquery_SetPredicate_PredicateOp>(
      Expression_Subquery_SetPredicate_PredicateOp_descriptor(), name, value);
}
enum Expression_Subquery_SetComparison_ComparisonOp : int {
  Expression_Subquery_SetComparison_ComparisonOp_COMPARISON_OP_UNSPECIFIED = 0,
  Expression_Subquery_SetComparison_ComparisonOp_COMPARISON_OP_EQ = 1,
  Expression_Subquery_SetComparison_ComparisonOp_COMPARISON_OP_NE = 2,
  Expression_Subquery_SetComparison_ComparisonOp_COMPARISON_OP_LT = 3,
  Expression_Subquery_SetComparison_ComparisonOp_COMPARISON_OP_GT = 4,
  Expression_Subquery_SetComparison_ComparisonOp_COMPARISON_OP_LE = 5,
  Expression_Subquery_SetComparison_ComparisonOp_COMPARISON_OP_GE = 6,
  Expression_Subquery_SetComparison_ComparisonOp_Expression_Subquery_SetComparison_ComparisonOp_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Expression_Subquery_SetComparison_ComparisonOp_Expression_Subquery_SetComparison_ComparisonOp_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Expression_Subquery_SetComparison_ComparisonOp_IsValid(int value);
extern const uint32_t Expression_Subquery_SetComparison_ComparisonOp_internal_data_[];
inline constexpr Expression_Subquery_SetComparison_ComparisonOp Expression_Subquery_SetComparison_ComparisonOp_ComparisonOp_MIN =
    static_cast<Expression_Subquery_SetComparison_ComparisonOp>(0);
inline constexpr Expression_Subquery_SetComparison_ComparisonOp Expression_Subquery_SetComparison_ComparisonOp_ComparisonOp_MAX =
    static_cast<Expression_Subquery_SetComparison_ComparisonOp>(6);
inline constexpr int Expression_Subquery_SetComparison_ComparisonOp_ComparisonOp_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor*
Expression_Subquery_SetComparison_ComparisonOp_descriptor();
template <typename T>
const std::string& Expression_Subquery_SetComparison_ComparisonOp_Name(T value) {
  static_assert(std::is_same<T, Expression_Subquery_SetComparison_ComparisonOp>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ComparisonOp_Name().");
  return Expression_Subquery_SetComparison_ComparisonOp_Name(static_cast<Expression_Subquery_SetComparison_ComparisonOp>(value));
}
template <>
inline const std::string& Expression_Subquery_SetComparison_ComparisonOp_Name(Expression_Subquery_SetComparison_ComparisonOp value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Expression_Subquery_SetComparison_ComparisonOp_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool Expression_Subquery_SetComparison_ComparisonOp_Parse(absl::string_view name, Expression_Subquery_SetComparison_ComparisonOp* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Expression_Subquery_SetComparison_ComparisonOp>(
      Expression_Subquery_SetComparison_ComparisonOp_descriptor(), name, value);
}
enum Expression_Subquery_SetComparison_ReductionOp : int {
  Expression_Subquery_SetComparison_ReductionOp_REDUCTION_OP_UNSPECIFIED = 0,
  Expression_Subquery_SetComparison_ReductionOp_REDUCTION_OP_ANY = 1,
  Expression_Subquery_SetComparison_ReductionOp_REDUCTION_OP_ALL = 2,
  Expression_Subquery_SetComparison_ReductionOp_Expression_Subquery_SetComparison_ReductionOp_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Expression_Subquery_SetComparison_ReductionOp_Expression_Subquery_SetComparison_ReductionOp_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Expression_Subquery_SetComparison_ReductionOp_IsValid(int value);
extern const uint32_t Expression_Subquery_SetComparison_ReductionOp_internal_data_[];
inline constexpr Expression_Subquery_SetComparison_ReductionOp Expression_Subquery_SetComparison_ReductionOp_ReductionOp_MIN =
    static_cast<Expression_Subquery_SetComparison_ReductionOp>(0);
inline constexpr Expression_Subquery_SetComparison_ReductionOp Expression_Subquery_SetComparison_ReductionOp_ReductionOp_MAX =
    static_cast<Expression_Subquery_SetComparison_ReductionOp>(2);
inline constexpr int Expression_Subquery_SetComparison_ReductionOp_ReductionOp_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
Expression_Subquery_SetComparison_ReductionOp_descriptor();
template <typename T>
const std::string& Expression_Subquery_SetComparison_ReductionOp_Name(T value) {
  static_assert(std::is_same<T, Expression_Subquery_SetComparison_ReductionOp>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ReductionOp_Name().");
  return Expression_Subquery_SetComparison_ReductionOp_Name(static_cast<Expression_Subquery_SetComparison_ReductionOp>(value));
}
template <>
inline const std::string& Expression_Subquery_SetComparison_ReductionOp_Name(Expression_Subquery_SetComparison_ReductionOp value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Expression_Subquery_SetComparison_ReductionOp_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool Expression_Subquery_SetComparison_ReductionOp_Parse(absl::string_view name, Expression_Subquery_SetComparison_ReductionOp* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Expression_Subquery_SetComparison_ReductionOp>(
      Expression_Subquery_SetComparison_ReductionOp_descriptor(), name, value);
}
enum SortField_SortDirection : int {
  SortField_SortDirection_SORT_DIRECTION_UNSPECIFIED = 0,
  SortField_SortDirection_SORT_DIRECTION_ASC_NULLS_FIRST = 1,
  SortField_SortDirection_SORT_DIRECTION_ASC_NULLS_LAST = 2,
  SortField_SortDirection_SORT_DIRECTION_DESC_NULLS_FIRST = 3,
  SortField_SortDirection_SORT_DIRECTION_DESC_NULLS_LAST = 4,
  SortField_SortDirection_SORT_DIRECTION_CLUSTERED = 5,
  SortField_SortDirection_SortField_SortDirection_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SortField_SortDirection_SortField_SortDirection_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool SortField_SortDirection_IsValid(int value);
extern const uint32_t SortField_SortDirection_internal_data_[];
inline constexpr SortField_SortDirection SortField_SortDirection_SortDirection_MIN =
    static_cast<SortField_SortDirection>(0);
inline constexpr SortField_SortDirection SortField_SortDirection_SortDirection_MAX =
    static_cast<SortField_SortDirection>(5);
inline constexpr int SortField_SortDirection_SortDirection_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
SortField_SortDirection_descriptor();
template <typename T>
const std::string& SortField_SortDirection_Name(T value) {
  static_assert(std::is_same<T, SortField_SortDirection>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SortDirection_Name().");
  return SortField_SortDirection_Name(static_cast<SortField_SortDirection>(value));
}
template <>
inline const std::string& SortField_SortDirection_Name(SortField_SortDirection value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SortField_SortDirection_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool SortField_SortDirection_Parse(absl::string_view name, SortField_SortDirection* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SortField_SortDirection>(
      SortField_SortDirection_descriptor(), name, value);
}
enum AggregateFunction_AggregationInvocation : int {
  AggregateFunction_AggregationInvocation_AGGREGATION_INVOCATION_UNSPECIFIED = 0,
  AggregateFunction_AggregationInvocation_AGGREGATION_INVOCATION_ALL = 1,
  AggregateFunction_AggregationInvocation_AGGREGATION_INVOCATION_DISTINCT = 2,
  AggregateFunction_AggregationInvocation_AggregateFunction_AggregationInvocation_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AggregateFunction_AggregationInvocation_AggregateFunction_AggregationInvocation_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AggregateFunction_AggregationInvocation_IsValid(int value);
extern const uint32_t AggregateFunction_AggregationInvocation_internal_data_[];
inline constexpr AggregateFunction_AggregationInvocation AggregateFunction_AggregationInvocation_AggregationInvocation_MIN =
    static_cast<AggregateFunction_AggregationInvocation>(0);
inline constexpr AggregateFunction_AggregationInvocation AggregateFunction_AggregationInvocation_AggregationInvocation_MAX =
    static_cast<AggregateFunction_AggregationInvocation>(2);
inline constexpr int AggregateFunction_AggregationInvocation_AggregationInvocation_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
AggregateFunction_AggregationInvocation_descriptor();
template <typename T>
const std::string& AggregateFunction_AggregationInvocation_Name(T value) {
  static_assert(std::is_same<T, AggregateFunction_AggregationInvocation>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AggregationInvocation_Name().");
  return AggregateFunction_AggregationInvocation_Name(static_cast<AggregateFunction_AggregationInvocation>(value));
}
template <>
inline const std::string& AggregateFunction_AggregationInvocation_Name(AggregateFunction_AggregationInvocation value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AggregateFunction_AggregationInvocation_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool AggregateFunction_AggregationInvocation_Parse(absl::string_view name, AggregateFunction_AggregationInvocation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AggregateFunction_AggregationInvocation>(
      AggregateFunction_AggregationInvocation_descriptor(), name, value);
}
enum AggregationPhase : int {
  AGGREGATION_PHASE_UNSPECIFIED = 0,
  AGGREGATION_PHASE_INITIAL_TO_INTERMEDIATE = 1,
  AGGREGATION_PHASE_INTERMEDIATE_TO_INTERMEDIATE = 2,
  AGGREGATION_PHASE_INITIAL_TO_RESULT = 3,
  AGGREGATION_PHASE_INTERMEDIATE_TO_RESULT = 4,
  AggregationPhase_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AggregationPhase_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AggregationPhase_IsValid(int value);
extern const uint32_t AggregationPhase_internal_data_[];
inline constexpr AggregationPhase AggregationPhase_MIN =
    static_cast<AggregationPhase>(0);
inline constexpr AggregationPhase AggregationPhase_MAX =
    static_cast<AggregationPhase>(4);
inline constexpr int AggregationPhase_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
AggregationPhase_descriptor();
template <typename T>
const std::string& AggregationPhase_Name(T value) {
  static_assert(std::is_same<T, AggregationPhase>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AggregationPhase_Name().");
  return AggregationPhase_Name(static_cast<AggregationPhase>(value));
}
template <>
inline const std::string& AggregationPhase_Name(AggregationPhase value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AggregationPhase_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool AggregationPhase_Parse(absl::string_view name, AggregationPhase* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AggregationPhase>(
      AggregationPhase_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class RelCommon_Emit final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.RelCommon.Emit) */ {
 public:
  inline RelCommon_Emit() : RelCommon_Emit(nullptr) {}
  ~RelCommon_Emit() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RelCommon_Emit* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RelCommon_Emit));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RelCommon_Emit(
      ::google::protobuf::internal::ConstantInitialized);

  inline RelCommon_Emit(const RelCommon_Emit& from) : RelCommon_Emit(nullptr, from) {}
  inline RelCommon_Emit(RelCommon_Emit&& from) noexcept
      : RelCommon_Emit(nullptr, std::move(from)) {}
  inline RelCommon_Emit& operator=(const RelCommon_Emit& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelCommon_Emit& operator=(RelCommon_Emit&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RelCommon_Emit& default_instance() {
    return *reinterpret_cast<const RelCommon_Emit*>(
        &_RelCommon_Emit_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(RelCommon_Emit& a, RelCommon_Emit& b) { a.Swap(&b); }
  inline void Swap(RelCommon_Emit* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelCommon_Emit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RelCommon_Emit* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RelCommon_Emit>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RelCommon_Emit& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RelCommon_Emit& from) { RelCommon_Emit::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RelCommon_Emit* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.RelCommon.Emit"; }

 protected:
  explicit RelCommon_Emit(::google::protobuf::Arena* arena);
  RelCommon_Emit(::google::protobuf::Arena* arena, const RelCommon_Emit& from);
  RelCommon_Emit(::google::protobuf::Arena* arena, RelCommon_Emit&& from) noexcept
      : RelCommon_Emit(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOutputMappingFieldNumber = 1,
  };
  // repeated int32 output_mapping = 1;
  int output_mapping_size() const;
  private:
  int _internal_output_mapping_size() const;

  public:
  void clear_output_mapping() ;
  ::int32_t output_mapping(int index) const;
  void set_output_mapping(int index, ::int32_t value);
  void add_output_mapping(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& output_mapping() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_output_mapping();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_output_mapping() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_output_mapping();

  public:
  // @@protoc_insertion_point(class_scope:substrait.RelCommon.Emit)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RelCommon_Emit& from_msg);
    ::google::protobuf::RepeatedField<::int32_t> output_mapping_;
    ::google::protobuf::internal::CachedSize _output_mapping_cached_byte_size_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RelCommon_Emit_class_data_;
// -------------------------------------------------------------------

class RelCommon_Direct final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:substrait.RelCommon.Direct) */ {
 public:
  inline RelCommon_Direct() : RelCommon_Direct(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RelCommon_Direct* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RelCommon_Direct));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RelCommon_Direct(
      ::google::protobuf::internal::ConstantInitialized);

  inline RelCommon_Direct(const RelCommon_Direct& from) : RelCommon_Direct(nullptr, from) {}
  inline RelCommon_Direct(RelCommon_Direct&& from) noexcept
      : RelCommon_Direct(nullptr, std::move(from)) {}
  inline RelCommon_Direct& operator=(const RelCommon_Direct& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelCommon_Direct& operator=(RelCommon_Direct&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RelCommon_Direct& default_instance() {
    return *reinterpret_cast<const RelCommon_Direct*>(
        &_RelCommon_Direct_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(RelCommon_Direct& a, RelCommon_Direct& b) { a.Swap(&b); }
  inline void Swap(RelCommon_Direct* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelCommon_Direct* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RelCommon_Direct* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<RelCommon_Direct>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RelCommon_Direct& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RelCommon_Direct& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.RelCommon.Direct"; }

 protected:
  explicit RelCommon_Direct(::google::protobuf::Arena* arena);
  RelCommon_Direct(::google::protobuf::Arena* arena, const RelCommon_Direct& from);
  RelCommon_Direct(::google::protobuf::Arena* arena, RelCommon_Direct&& from) noexcept
      : RelCommon_Direct(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:substrait.RelCommon.Direct)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RelCommon_Direct& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RelCommon_Direct_class_data_;
// -------------------------------------------------------------------

class ReferenceRel final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.ReferenceRel) */ {
 public:
  inline ReferenceRel() : ReferenceRel(nullptr) {}
  ~ReferenceRel() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReferenceRel* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReferenceRel));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReferenceRel(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReferenceRel(const ReferenceRel& from) : ReferenceRel(nullptr, from) {}
  inline ReferenceRel(ReferenceRel&& from) noexcept
      : ReferenceRel(nullptr, std::move(from)) {}
  inline ReferenceRel& operator=(const ReferenceRel& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReferenceRel& operator=(ReferenceRel&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReferenceRel& default_instance() {
    return *reinterpret_cast<const ReferenceRel*>(
        &_ReferenceRel_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 115;
  friend void swap(ReferenceRel& a, ReferenceRel& b) { a.Swap(&b); }
  inline void Swap(ReferenceRel* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReferenceRel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReferenceRel* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReferenceRel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReferenceRel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReferenceRel& from) { ReferenceRel::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReferenceRel* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.ReferenceRel"; }

 protected:
  explicit ReferenceRel(::google::protobuf::Arena* arena);
  ReferenceRel(::google::protobuf::Arena* arena, const ReferenceRel& from);
  ReferenceRel(::google::protobuf::Arena* arena, ReferenceRel&& from) noexcept
      : ReferenceRel(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSubtreeOrdinalFieldNumber = 1,
  };
  // int32 subtree_ordinal = 1;
  void clear_subtree_ordinal() ;
  ::int32_t subtree_ordinal() const;
  void set_subtree_ordinal(::int32_t value);

  private:
  ::int32_t _internal_subtree_ordinal() const;
  void _internal_set_subtree_ordinal(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:substrait.ReferenceRel)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReferenceRel& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t subtree_ordinal_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ReferenceRel_class_data_;
// -------------------------------------------------------------------

class ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:substrait.ReadRel.LocalFiles.FileOrFiles.ParquetReadOptions) */ {
 public:
  inline ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions() : ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions(const ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions& from) : ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions(nullptr, from) {}
  inline ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions(ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions&& from) noexcept
      : ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions(nullptr, std::move(from)) {}
  inline ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions& operator=(const ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions& operator=(ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions& default_instance() {
    return *reinterpret_cast<const ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions*>(
        &_ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions& a, ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions& b) { a.Swap(&b); }
  inline void Swap(ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.ReadRel.LocalFiles.FileOrFiles.ParquetReadOptions"; }

 protected:
  explicit ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions(::google::protobuf::Arena* arena);
  ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions(::google::protobuf::Arena* arena, const ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions& from);
  ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions(::google::protobuf::Arena* arena, ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions&& from) noexcept
      : ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:substrait.ReadRel.LocalFiles.FileOrFiles.ParquetReadOptions)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions_class_data_;
// -------------------------------------------------------------------

class ReadRel_LocalFiles_FileOrFiles_OrcReadOptions final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:substrait.ReadRel.LocalFiles.FileOrFiles.OrcReadOptions) */ {
 public:
  inline ReadRel_LocalFiles_FileOrFiles_OrcReadOptions() : ReadRel_LocalFiles_FileOrFiles_OrcReadOptions(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReadRel_LocalFiles_FileOrFiles_OrcReadOptions* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReadRel_LocalFiles_FileOrFiles_OrcReadOptions));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReadRel_LocalFiles_FileOrFiles_OrcReadOptions(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReadRel_LocalFiles_FileOrFiles_OrcReadOptions(const ReadRel_LocalFiles_FileOrFiles_OrcReadOptions& from) : ReadRel_LocalFiles_FileOrFiles_OrcReadOptions(nullptr, from) {}
  inline ReadRel_LocalFiles_FileOrFiles_OrcReadOptions(ReadRel_LocalFiles_FileOrFiles_OrcReadOptions&& from) noexcept
      : ReadRel_LocalFiles_FileOrFiles_OrcReadOptions(nullptr, std::move(from)) {}
  inline ReadRel_LocalFiles_FileOrFiles_OrcReadOptions& operator=(const ReadRel_LocalFiles_FileOrFiles_OrcReadOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadRel_LocalFiles_FileOrFiles_OrcReadOptions& operator=(ReadRel_LocalFiles_FileOrFiles_OrcReadOptions&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadRel_LocalFiles_FileOrFiles_OrcReadOptions& default_instance() {
    return *reinterpret_cast<const ReadRel_LocalFiles_FileOrFiles_OrcReadOptions*>(
        &_ReadRel_LocalFiles_FileOrFiles_OrcReadOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(ReadRel_LocalFiles_FileOrFiles_OrcReadOptions& a, ReadRel_LocalFiles_FileOrFiles_OrcReadOptions& b) { a.Swap(&b); }
  inline void Swap(ReadRel_LocalFiles_FileOrFiles_OrcReadOptions* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadRel_LocalFiles_FileOrFiles_OrcReadOptions* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadRel_LocalFiles_FileOrFiles_OrcReadOptions* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ReadRel_LocalFiles_FileOrFiles_OrcReadOptions>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ReadRel_LocalFiles_FileOrFiles_OrcReadOptions& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ReadRel_LocalFiles_FileOrFiles_OrcReadOptions& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.ReadRel.LocalFiles.FileOrFiles.OrcReadOptions"; }

 protected:
  explicit ReadRel_LocalFiles_FileOrFiles_OrcReadOptions(::google::protobuf::Arena* arena);
  ReadRel_LocalFiles_FileOrFiles_OrcReadOptions(::google::protobuf::Arena* arena, const ReadRel_LocalFiles_FileOrFiles_OrcReadOptions& from);
  ReadRel_LocalFiles_FileOrFiles_OrcReadOptions(::google::protobuf::Arena* arena, ReadRel_LocalFiles_FileOrFiles_OrcReadOptions&& from) noexcept
      : ReadRel_LocalFiles_FileOrFiles_OrcReadOptions(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:substrait.ReadRel.LocalFiles.FileOrFiles.OrcReadOptions)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReadRel_LocalFiles_FileOrFiles_OrcReadOptions& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ReadRel_LocalFiles_FileOrFiles_OrcReadOptions_class_data_;
// -------------------------------------------------------------------

class ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:substrait.ReadRel.LocalFiles.FileOrFiles.DwrfReadOptions) */ {
 public:
  inline ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions() : ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions(const ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions& from) : ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions(nullptr, from) {}
  inline ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions(ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions&& from) noexcept
      : ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions(nullptr, std::move(from)) {}
  inline ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions& operator=(const ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions& operator=(ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions& default_instance() {
    return *reinterpret_cast<const ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions*>(
        &_ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions& a, ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions& b) { a.Swap(&b); }
  inline void Swap(ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.ReadRel.LocalFiles.FileOrFiles.DwrfReadOptions"; }

 protected:
  explicit ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions(::google::protobuf::Arena* arena);
  ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions(::google::protobuf::Arena* arena, const ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions& from);
  ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions(::google::protobuf::Arena* arena, ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions&& from) noexcept
      : ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:substrait.ReadRel.LocalFiles.FileOrFiles.DwrfReadOptions)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions_class_data_;
// -------------------------------------------------------------------

class ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:substrait.ReadRel.LocalFiles.FileOrFiles.ArrowReadOptions) */ {
 public:
  inline ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions() : ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions(const ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions& from) : ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions(nullptr, from) {}
  inline ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions(ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions&& from) noexcept
      : ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions(nullptr, std::move(from)) {}
  inline ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions& operator=(const ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions& operator=(ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions& default_instance() {
    return *reinterpret_cast<const ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions*>(
        &_ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions& a, ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions& b) { a.Swap(&b); }
  inline void Swap(ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.ReadRel.LocalFiles.FileOrFiles.ArrowReadOptions"; }

 protected:
  explicit ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions(::google::protobuf::Arena* arena);
  ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions(::google::protobuf::Arena* arena, const ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions& from);
  ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions(::google::protobuf::Arena* arena, ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions&& from) noexcept
      : ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:substrait.ReadRel.LocalFiles.FileOrFiles.ArrowReadOptions)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions_class_data_;
// -------------------------------------------------------------------

class FunctionOption final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.FunctionOption) */ {
 public:
  inline FunctionOption() : FunctionOption(nullptr) {}
  ~FunctionOption() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FunctionOption* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FunctionOption));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FunctionOption(
      ::google::protobuf::internal::ConstantInitialized);

  inline FunctionOption(const FunctionOption& from) : FunctionOption(nullptr, from) {}
  inline FunctionOption(FunctionOption&& from) noexcept
      : FunctionOption(nullptr, std::move(from)) {}
  inline FunctionOption& operator=(const FunctionOption& from) {
    CopyFrom(from);
    return *this;
  }
  inline FunctionOption& operator=(FunctionOption&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FunctionOption& default_instance() {
    return *reinterpret_cast<const FunctionOption*>(
        &_FunctionOption_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 53;
  friend void swap(FunctionOption& a, FunctionOption& b) { a.Swap(&b); }
  inline void Swap(FunctionOption* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FunctionOption* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FunctionOption* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FunctionOption>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FunctionOption& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FunctionOption& from) { FunctionOption::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FunctionOption* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.FunctionOption"; }

 protected:
  explicit FunctionOption(::google::protobuf::Arena* arena);
  FunctionOption(::google::protobuf::Arena* arena, const FunctionOption& from);
  FunctionOption(::google::protobuf::Arena* arena, FunctionOption&& from) noexcept
      : FunctionOption(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPreferenceFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // repeated string preference = 2;
  int preference_size() const;
  private:
  int _internal_preference_size() const;

  public:
  void clear_preference() ;
  const std::string& preference(int index) const;
  std::string* mutable_preference(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_preference(int index, Arg_&& value, Args_... args);
  std::string* add_preference();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_preference(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& preference() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_preference();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_preference() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_preference();

  public:
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  [[nodiscard]] std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:substrait.FunctionOption)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      47, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FunctionOption& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> preference_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull FunctionOption_class_data_;
// -------------------------------------------------------------------

class Expression_WindowFunction_Bound_Unbounded final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:substrait.Expression.WindowFunction.Bound.Unbounded) */ {
 public:
  inline Expression_WindowFunction_Bound_Unbounded() : Expression_WindowFunction_Bound_Unbounded(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_WindowFunction_Bound_Unbounded* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_WindowFunction_Bound_Unbounded));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_WindowFunction_Bound_Unbounded(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_WindowFunction_Bound_Unbounded(const Expression_WindowFunction_Bound_Unbounded& from) : Expression_WindowFunction_Bound_Unbounded(nullptr, from) {}
  inline Expression_WindowFunction_Bound_Unbounded(Expression_WindowFunction_Bound_Unbounded&& from) noexcept
      : Expression_WindowFunction_Bound_Unbounded(nullptr, std::move(from)) {}
  inline Expression_WindowFunction_Bound_Unbounded& operator=(const Expression_WindowFunction_Bound_Unbounded& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_WindowFunction_Bound_Unbounded& operator=(Expression_WindowFunction_Bound_Unbounded&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_WindowFunction_Bound_Unbounded& default_instance() {
    return *reinterpret_cast<const Expression_WindowFunction_Bound_Unbounded*>(
        &_Expression_WindowFunction_Bound_Unbounded_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 75;
  friend void swap(Expression_WindowFunction_Bound_Unbounded& a, Expression_WindowFunction_Bound_Unbounded& b) { a.Swap(&b); }
  inline void Swap(Expression_WindowFunction_Bound_Unbounded* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_WindowFunction_Bound_Unbounded* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_WindowFunction_Bound_Unbounded* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<Expression_WindowFunction_Bound_Unbounded>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Expression_WindowFunction_Bound_Unbounded& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Expression_WindowFunction_Bound_Unbounded& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.WindowFunction.Bound.Unbounded"; }

 protected:
  explicit Expression_WindowFunction_Bound_Unbounded(::google::protobuf::Arena* arena);
  Expression_WindowFunction_Bound_Unbounded(::google::protobuf::Arena* arena, const Expression_WindowFunction_Bound_Unbounded& from);
  Expression_WindowFunction_Bound_Unbounded(::google::protobuf::Arena* arena, Expression_WindowFunction_Bound_Unbounded&& from) noexcept
      : Expression_WindowFunction_Bound_Unbounded(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:substrait.Expression.WindowFunction.Bound.Unbounded)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_WindowFunction_Bound_Unbounded& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_WindowFunction_Bound_Unbounded_class_data_;
// -------------------------------------------------------------------

class Expression_WindowFunction_Bound_Preceding final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.WindowFunction.Bound.Preceding) */ {
 public:
  inline Expression_WindowFunction_Bound_Preceding() : Expression_WindowFunction_Bound_Preceding(nullptr) {}
  ~Expression_WindowFunction_Bound_Preceding() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_WindowFunction_Bound_Preceding* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_WindowFunction_Bound_Preceding));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_WindowFunction_Bound_Preceding(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_WindowFunction_Bound_Preceding(const Expression_WindowFunction_Bound_Preceding& from) : Expression_WindowFunction_Bound_Preceding(nullptr, from) {}
  inline Expression_WindowFunction_Bound_Preceding(Expression_WindowFunction_Bound_Preceding&& from) noexcept
      : Expression_WindowFunction_Bound_Preceding(nullptr, std::move(from)) {}
  inline Expression_WindowFunction_Bound_Preceding& operator=(const Expression_WindowFunction_Bound_Preceding& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_WindowFunction_Bound_Preceding& operator=(Expression_WindowFunction_Bound_Preceding&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_WindowFunction_Bound_Preceding& default_instance() {
    return *reinterpret_cast<const Expression_WindowFunction_Bound_Preceding*>(
        &_Expression_WindowFunction_Bound_Preceding_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 72;
  friend void swap(Expression_WindowFunction_Bound_Preceding& a, Expression_WindowFunction_Bound_Preceding& b) { a.Swap(&b); }
  inline void Swap(Expression_WindowFunction_Bound_Preceding* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_WindowFunction_Bound_Preceding* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_WindowFunction_Bound_Preceding* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_WindowFunction_Bound_Preceding>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_WindowFunction_Bound_Preceding& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_WindowFunction_Bound_Preceding& from) { Expression_WindowFunction_Bound_Preceding::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_WindowFunction_Bound_Preceding* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.WindowFunction.Bound.Preceding"; }

 protected:
  explicit Expression_WindowFunction_Bound_Preceding(::google::protobuf::Arena* arena);
  Expression_WindowFunction_Bound_Preceding(::google::protobuf::Arena* arena, const Expression_WindowFunction_Bound_Preceding& from);
  Expression_WindowFunction_Bound_Preceding(::google::protobuf::Arena* arena, Expression_WindowFunction_Bound_Preceding&& from) noexcept
      : Expression_WindowFunction_Bound_Preceding(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOffsetFieldNumber = 1,
  };
  // int64 offset = 1;
  void clear_offset() ;
  ::int64_t offset() const;
  void set_offset(::int64_t value);

  private:
  ::int64_t _internal_offset() const;
  void _internal_set_offset(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:substrait.Expression.WindowFunction.Bound.Preceding)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_WindowFunction_Bound_Preceding& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t offset_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_WindowFunction_Bound_Preceding_class_data_;
// -------------------------------------------------------------------

class Expression_WindowFunction_Bound_Following final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.WindowFunction.Bound.Following) */ {
 public:
  inline Expression_WindowFunction_Bound_Following() : Expression_WindowFunction_Bound_Following(nullptr) {}
  ~Expression_WindowFunction_Bound_Following() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_WindowFunction_Bound_Following* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_WindowFunction_Bound_Following));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_WindowFunction_Bound_Following(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_WindowFunction_Bound_Following(const Expression_WindowFunction_Bound_Following& from) : Expression_WindowFunction_Bound_Following(nullptr, from) {}
  inline Expression_WindowFunction_Bound_Following(Expression_WindowFunction_Bound_Following&& from) noexcept
      : Expression_WindowFunction_Bound_Following(nullptr, std::move(from)) {}
  inline Expression_WindowFunction_Bound_Following& operator=(const Expression_WindowFunction_Bound_Following& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_WindowFunction_Bound_Following& operator=(Expression_WindowFunction_Bound_Following&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_WindowFunction_Bound_Following& default_instance() {
    return *reinterpret_cast<const Expression_WindowFunction_Bound_Following*>(
        &_Expression_WindowFunction_Bound_Following_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 73;
  friend void swap(Expression_WindowFunction_Bound_Following& a, Expression_WindowFunction_Bound_Following& b) { a.Swap(&b); }
  inline void Swap(Expression_WindowFunction_Bound_Following* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_WindowFunction_Bound_Following* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_WindowFunction_Bound_Following* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_WindowFunction_Bound_Following>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_WindowFunction_Bound_Following& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_WindowFunction_Bound_Following& from) { Expression_WindowFunction_Bound_Following::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_WindowFunction_Bound_Following* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.WindowFunction.Bound.Following"; }

 protected:
  explicit Expression_WindowFunction_Bound_Following(::google::protobuf::Arena* arena);
  Expression_WindowFunction_Bound_Following(::google::protobuf::Arena* arena, const Expression_WindowFunction_Bound_Following& from);
  Expression_WindowFunction_Bound_Following(::google::protobuf::Arena* arena, Expression_WindowFunction_Bound_Following&& from) noexcept
      : Expression_WindowFunction_Bound_Following(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOffsetFieldNumber = 1,
  };
  // int64 offset = 1;
  void clear_offset() ;
  ::int64_t offset() const;
  void set_offset(::int64_t value);

  private:
  ::int64_t _internal_offset() const;
  void _internal_set_offset(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:substrait.Expression.WindowFunction.Bound.Following)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_WindowFunction_Bound_Following& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t offset_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_WindowFunction_Bound_Following_class_data_;
// -------------------------------------------------------------------

class Expression_WindowFunction_Bound_CurrentRow final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:substrait.Expression.WindowFunction.Bound.CurrentRow) */ {
 public:
  inline Expression_WindowFunction_Bound_CurrentRow() : Expression_WindowFunction_Bound_CurrentRow(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_WindowFunction_Bound_CurrentRow* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_WindowFunction_Bound_CurrentRow));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_WindowFunction_Bound_CurrentRow(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_WindowFunction_Bound_CurrentRow(const Expression_WindowFunction_Bound_CurrentRow& from) : Expression_WindowFunction_Bound_CurrentRow(nullptr, from) {}
  inline Expression_WindowFunction_Bound_CurrentRow(Expression_WindowFunction_Bound_CurrentRow&& from) noexcept
      : Expression_WindowFunction_Bound_CurrentRow(nullptr, std::move(from)) {}
  inline Expression_WindowFunction_Bound_CurrentRow& operator=(const Expression_WindowFunction_Bound_CurrentRow& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_WindowFunction_Bound_CurrentRow& operator=(Expression_WindowFunction_Bound_CurrentRow&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_WindowFunction_Bound_CurrentRow& default_instance() {
    return *reinterpret_cast<const Expression_WindowFunction_Bound_CurrentRow*>(
        &_Expression_WindowFunction_Bound_CurrentRow_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 74;
  friend void swap(Expression_WindowFunction_Bound_CurrentRow& a, Expression_WindowFunction_Bound_CurrentRow& b) { a.Swap(&b); }
  inline void Swap(Expression_WindowFunction_Bound_CurrentRow* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_WindowFunction_Bound_CurrentRow* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_WindowFunction_Bound_CurrentRow* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<Expression_WindowFunction_Bound_CurrentRow>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Expression_WindowFunction_Bound_CurrentRow& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Expression_WindowFunction_Bound_CurrentRow& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.WindowFunction.Bound.CurrentRow"; }

 protected:
  explicit Expression_WindowFunction_Bound_CurrentRow(::google::protobuf::Arena* arena);
  Expression_WindowFunction_Bound_CurrentRow(::google::protobuf::Arena* arena, const Expression_WindowFunction_Bound_CurrentRow& from);
  Expression_WindowFunction_Bound_CurrentRow(::google::protobuf::Arena* arena, Expression_WindowFunction_Bound_CurrentRow&& from) noexcept
      : Expression_WindowFunction_Bound_CurrentRow(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:substrait.Expression.WindowFunction.Bound.CurrentRow)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_WindowFunction_Bound_CurrentRow& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_WindowFunction_Bound_CurrentRow_class_data_;
// -------------------------------------------------------------------

class Expression_MaskExpression_MapSelect_MapKeyExpression final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.MaskExpression.MapSelect.MapKeyExpression) */ {
 public:
  inline Expression_MaskExpression_MapSelect_MapKeyExpression() : Expression_MaskExpression_MapSelect_MapKeyExpression(nullptr) {}
  ~Expression_MaskExpression_MapSelect_MapKeyExpression() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_MaskExpression_MapSelect_MapKeyExpression* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_MaskExpression_MapSelect_MapKeyExpression));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_MaskExpression_MapSelect_MapKeyExpression(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_MaskExpression_MapSelect_MapKeyExpression(const Expression_MaskExpression_MapSelect_MapKeyExpression& from) : Expression_MaskExpression_MapSelect_MapKeyExpression(nullptr, from) {}
  inline Expression_MaskExpression_MapSelect_MapKeyExpression(Expression_MaskExpression_MapSelect_MapKeyExpression&& from) noexcept
      : Expression_MaskExpression_MapSelect_MapKeyExpression(nullptr, std::move(from)) {}
  inline Expression_MaskExpression_MapSelect_MapKeyExpression& operator=(const Expression_MaskExpression_MapSelect_MapKeyExpression& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_MaskExpression_MapSelect_MapKeyExpression& operator=(Expression_MaskExpression_MapSelect_MapKeyExpression&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_MaskExpression_MapSelect_MapKeyExpression& default_instance() {
    return *reinterpret_cast<const Expression_MaskExpression_MapSelect_MapKeyExpression*>(
        &_Expression_MaskExpression_MapSelect_MapKeyExpression_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 101;
  friend void swap(Expression_MaskExpression_MapSelect_MapKeyExpression& a, Expression_MaskExpression_MapSelect_MapKeyExpression& b) { a.Swap(&b); }
  inline void Swap(Expression_MaskExpression_MapSelect_MapKeyExpression* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_MaskExpression_MapSelect_MapKeyExpression* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_MaskExpression_MapSelect_MapKeyExpression* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_MaskExpression_MapSelect_MapKeyExpression>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_MaskExpression_MapSelect_MapKeyExpression& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_MaskExpression_MapSelect_MapKeyExpression& from) { Expression_MaskExpression_MapSelect_MapKeyExpression::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_MaskExpression_MapSelect_MapKeyExpression* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.MaskExpression.MapSelect.MapKeyExpression"; }

 protected:
  explicit Expression_MaskExpression_MapSelect_MapKeyExpression(::google::protobuf::Arena* arena);
  Expression_MaskExpression_MapSelect_MapKeyExpression(::google::protobuf::Arena* arena, const Expression_MaskExpression_MapSelect_MapKeyExpression& from);
  Expression_MaskExpression_MapSelect_MapKeyExpression(::google::protobuf::Arena* arena, Expression_MaskExpression_MapSelect_MapKeyExpression&& from) noexcept
      : Expression_MaskExpression_MapSelect_MapKeyExpression(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMapKeyExpressionFieldNumber = 1,
  };
  // string map_key_expression = 1;
  void clear_map_key_expression() ;
  const std::string& map_key_expression() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_map_key_expression(Arg_&& arg, Args_... args);
  std::string* mutable_map_key_expression();
  [[nodiscard]] std::string* release_map_key_expression();
  void set_allocated_map_key_expression(std::string* value);

  private:
  const std::string& _internal_map_key_expression() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_map_key_expression(const std::string& value);
  std::string* _internal_mutable_map_key_expression();

  public:
  // @@protoc_insertion_point(class_scope:substrait.Expression.MaskExpression.MapSelect.MapKeyExpression)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      89, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_MaskExpression_MapSelect_MapKeyExpression& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr map_key_expression_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_MaskExpression_MapSelect_MapKeyExpression_class_data_;
// -------------------------------------------------------------------

class Expression_MaskExpression_MapSelect_MapKey final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.MaskExpression.MapSelect.MapKey) */ {
 public:
  inline Expression_MaskExpression_MapSelect_MapKey() : Expression_MaskExpression_MapSelect_MapKey(nullptr) {}
  ~Expression_MaskExpression_MapSelect_MapKey() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_MaskExpression_MapSelect_MapKey* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_MaskExpression_MapSelect_MapKey));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_MaskExpression_MapSelect_MapKey(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_MaskExpression_MapSelect_MapKey(const Expression_MaskExpression_MapSelect_MapKey& from) : Expression_MaskExpression_MapSelect_MapKey(nullptr, from) {}
  inline Expression_MaskExpression_MapSelect_MapKey(Expression_MaskExpression_MapSelect_MapKey&& from) noexcept
      : Expression_MaskExpression_MapSelect_MapKey(nullptr, std::move(from)) {}
  inline Expression_MaskExpression_MapSelect_MapKey& operator=(const Expression_MaskExpression_MapSelect_MapKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_MaskExpression_MapSelect_MapKey& operator=(Expression_MaskExpression_MapSelect_MapKey&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_MaskExpression_MapSelect_MapKey& default_instance() {
    return *reinterpret_cast<const Expression_MaskExpression_MapSelect_MapKey*>(
        &_Expression_MaskExpression_MapSelect_MapKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 100;
  friend void swap(Expression_MaskExpression_MapSelect_MapKey& a, Expression_MaskExpression_MapSelect_MapKey& b) { a.Swap(&b); }
  inline void Swap(Expression_MaskExpression_MapSelect_MapKey* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_MaskExpression_MapSelect_MapKey* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_MaskExpression_MapSelect_MapKey* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_MaskExpression_MapSelect_MapKey>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_MaskExpression_MapSelect_MapKey& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_MaskExpression_MapSelect_MapKey& from) { Expression_MaskExpression_MapSelect_MapKey::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_MaskExpression_MapSelect_MapKey* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.MaskExpression.MapSelect.MapKey"; }

 protected:
  explicit Expression_MaskExpression_MapSelect_MapKey(::google::protobuf::Arena* arena);
  Expression_MaskExpression_MapSelect_MapKey(::google::protobuf::Arena* arena, const Expression_MaskExpression_MapSelect_MapKey& from);
  Expression_MaskExpression_MapSelect_MapKey(::google::protobuf::Arena* arena, Expression_MaskExpression_MapSelect_MapKey&& from) noexcept
      : Expression_MaskExpression_MapSelect_MapKey(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMapKeyFieldNumber = 1,
  };
  // string map_key = 1;
  void clear_map_key() ;
  const std::string& map_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_map_key(Arg_&& arg, Args_... args);
  std::string* mutable_map_key();
  [[nodiscard]] std::string* release_map_key();
  void set_allocated_map_key(std::string* value);

  private:
  const std::string& _internal_map_key() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_map_key(const std::string& value);
  std::string* _internal_mutable_map_key();

  public:
  // @@protoc_insertion_point(class_scope:substrait.Expression.MaskExpression.MapSelect.MapKey)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      68, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_MaskExpression_MapSelect_MapKey& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr map_key_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_MaskExpression_MapSelect_MapKey_class_data_;
// -------------------------------------------------------------------

class Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListSlice) */ {
 public:
  inline Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice() : Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice(nullptr) {}
  ~Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice(const Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice& from) : Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice(nullptr, from) {}
  inline Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice(Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice&& from) noexcept
      : Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice(nullptr, std::move(from)) {}
  inline Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice& operator=(const Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice& operator=(Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice& default_instance() {
    return *reinterpret_cast<const Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice*>(
        &_Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 97;
  friend void swap(Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice& a, Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice& b) { a.Swap(&b); }
  inline void Swap(Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice& from) { Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListSlice"; }

 protected:
  explicit Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice(::google::protobuf::Arena* arena);
  Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice(::google::protobuf::Arena* arena, const Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice& from);
  Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice(::google::protobuf::Arena* arena, Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice&& from) noexcept
      : Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStartFieldNumber = 1,
    kEndFieldNumber = 2,
  };
  // int32 start = 1;
  void clear_start() ;
  ::int32_t start() const;
  void set_start(::int32_t value);

  private:
  ::int32_t _internal_start() const;
  void _internal_set_start(::int32_t value);

  public:
  // int32 end = 2;
  void clear_end() ;
  ::int32_t end() const;
  void set_end(::int32_t value);

  private:
  ::int32_t _internal_end() const;
  void _internal_set_end(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListSlice)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t start_;
    ::int32_t end_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice_class_data_;
// -------------------------------------------------------------------

class Expression_MaskExpression_ListSelect_ListSelectItem_ListElement final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListElement) */ {
 public:
  inline Expression_MaskExpression_ListSelect_ListSelectItem_ListElement() : Expression_MaskExpression_ListSelect_ListSelectItem_ListElement(nullptr) {}
  ~Expression_MaskExpression_ListSelect_ListSelectItem_ListElement() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_MaskExpression_ListSelect_ListSelectItem_ListElement));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_MaskExpression_ListSelect_ListSelectItem_ListElement(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_MaskExpression_ListSelect_ListSelectItem_ListElement(const Expression_MaskExpression_ListSelect_ListSelectItem_ListElement& from) : Expression_MaskExpression_ListSelect_ListSelectItem_ListElement(nullptr, from) {}
  inline Expression_MaskExpression_ListSelect_ListSelectItem_ListElement(Expression_MaskExpression_ListSelect_ListSelectItem_ListElement&& from) noexcept
      : Expression_MaskExpression_ListSelect_ListSelectItem_ListElement(nullptr, std::move(from)) {}
  inline Expression_MaskExpression_ListSelect_ListSelectItem_ListElement& operator=(const Expression_MaskExpression_ListSelect_ListSelectItem_ListElement& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_MaskExpression_ListSelect_ListSelectItem_ListElement& operator=(Expression_MaskExpression_ListSelect_ListSelectItem_ListElement&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_MaskExpression_ListSelect_ListSelectItem_ListElement& default_instance() {
    return *reinterpret_cast<const Expression_MaskExpression_ListSelect_ListSelectItem_ListElement*>(
        &_Expression_MaskExpression_ListSelect_ListSelectItem_ListElement_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 96;
  friend void swap(Expression_MaskExpression_ListSelect_ListSelectItem_ListElement& a, Expression_MaskExpression_ListSelect_ListSelectItem_ListElement& b) { a.Swap(&b); }
  inline void Swap(Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_MaskExpression_ListSelect_ListSelectItem_ListElement>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_MaskExpression_ListSelect_ListSelectItem_ListElement& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_MaskExpression_ListSelect_ListSelectItem_ListElement& from) { Expression_MaskExpression_ListSelect_ListSelectItem_ListElement::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListElement"; }

 protected:
  explicit Expression_MaskExpression_ListSelect_ListSelectItem_ListElement(::google::protobuf::Arena* arena);
  Expression_MaskExpression_ListSelect_ListSelectItem_ListElement(::google::protobuf::Arena* arena, const Expression_MaskExpression_ListSelect_ListSelectItem_ListElement& from);
  Expression_MaskExpression_ListSelect_ListSelectItem_ListElement(::google::protobuf::Arena* arena, Expression_MaskExpression_ListSelect_ListSelectItem_ListElement&& from) noexcept
      : Expression_MaskExpression_ListSelect_ListSelectItem_ListElement(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFieldFieldNumber = 1,
  };
  // int32 field = 1;
  void clear_field() ;
  ::int32_t field() const;
  void set_field(::int32_t value);

  private:
  ::int32_t _internal_field() const;
  void _internal_set_field(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListElement)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_MaskExpression_ListSelect_ListSelectItem_ListElement& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t field_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_MaskExpression_ListSelect_ListSelectItem_ListElement_class_data_;
// -------------------------------------------------------------------

class Expression_Literal_VarChar final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.Literal.VarChar) */ {
 public:
  inline Expression_Literal_VarChar() : Expression_Literal_VarChar(nullptr) {}
  ~Expression_Literal_VarChar() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_Literal_VarChar* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_Literal_VarChar));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_Literal_VarChar(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_Literal_VarChar(const Expression_Literal_VarChar& from) : Expression_Literal_VarChar(nullptr, from) {}
  inline Expression_Literal_VarChar(Expression_Literal_VarChar&& from) noexcept
      : Expression_Literal_VarChar(nullptr, std::move(from)) {}
  inline Expression_Literal_VarChar& operator=(const Expression_Literal_VarChar& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_Literal_VarChar& operator=(Expression_Literal_VarChar&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_Literal_VarChar& default_instance() {
    return *reinterpret_cast<const Expression_Literal_VarChar*>(
        &_Expression_Literal_VarChar_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 56;
  friend void swap(Expression_Literal_VarChar& a, Expression_Literal_VarChar& b) { a.Swap(&b); }
  inline void Swap(Expression_Literal_VarChar* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_Literal_VarChar* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_Literal_VarChar* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_Literal_VarChar>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_Literal_VarChar& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_Literal_VarChar& from) { Expression_Literal_VarChar::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_Literal_VarChar* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.Literal.VarChar"; }

 protected:
  explicit Expression_Literal_VarChar(::google::protobuf::Arena* arena);
  Expression_Literal_VarChar(::google::protobuf::Arena* arena, const Expression_Literal_VarChar& from);
  Expression_Literal_VarChar(::google::protobuf::Arena* arena, Expression_Literal_VarChar&& from) noexcept
      : Expression_Literal_VarChar(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValueFieldNumber = 1,
    kLengthFieldNumber = 2,
  };
  // string value = 1;
  void clear_value() ;
  const std::string& value() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  [[nodiscard]] std::string* release_value();
  void set_allocated_value(std::string* value);

  private:
  const std::string& _internal_value() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // uint32 length = 2;
  void clear_length() ;
  ::uint32_t length() const;
  void set_length(::uint32_t value);

  private:
  ::uint32_t _internal_length() const;
  void _internal_set_length(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:substrait.Expression.Literal.VarChar)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      50, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_Literal_VarChar& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr value_;
    ::uint32_t length_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_Literal_VarChar_class_data_;
// -------------------------------------------------------------------

class Expression_Literal_IntervalYearToMonth final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.Literal.IntervalYearToMonth) */ {
 public:
  inline Expression_Literal_IntervalYearToMonth() : Expression_Literal_IntervalYearToMonth(nullptr) {}
  ~Expression_Literal_IntervalYearToMonth() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_Literal_IntervalYearToMonth* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_Literal_IntervalYearToMonth));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_Literal_IntervalYearToMonth(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_Literal_IntervalYearToMonth(const Expression_Literal_IntervalYearToMonth& from) : Expression_Literal_IntervalYearToMonth(nullptr, from) {}
  inline Expression_Literal_IntervalYearToMonth(Expression_Literal_IntervalYearToMonth&& from) noexcept
      : Expression_Literal_IntervalYearToMonth(nullptr, std::move(from)) {}
  inline Expression_Literal_IntervalYearToMonth& operator=(const Expression_Literal_IntervalYearToMonth& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_Literal_IntervalYearToMonth& operator=(Expression_Literal_IntervalYearToMonth&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_Literal_IntervalYearToMonth& default_instance() {
    return *reinterpret_cast<const Expression_Literal_IntervalYearToMonth*>(
        &_Expression_Literal_IntervalYearToMonth_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 60;
  friend void swap(Expression_Literal_IntervalYearToMonth& a, Expression_Literal_IntervalYearToMonth& b) { a.Swap(&b); }
  inline void Swap(Expression_Literal_IntervalYearToMonth* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_Literal_IntervalYearToMonth* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_Literal_IntervalYearToMonth* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_Literal_IntervalYearToMonth>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_Literal_IntervalYearToMonth& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_Literal_IntervalYearToMonth& from) { Expression_Literal_IntervalYearToMonth::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_Literal_IntervalYearToMonth* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.Literal.IntervalYearToMonth"; }

 protected:
  explicit Expression_Literal_IntervalYearToMonth(::google::protobuf::Arena* arena);
  Expression_Literal_IntervalYearToMonth(::google::protobuf::Arena* arena, const Expression_Literal_IntervalYearToMonth& from);
  Expression_Literal_IntervalYearToMonth(::google::protobuf::Arena* arena, Expression_Literal_IntervalYearToMonth&& from) noexcept
      : Expression_Literal_IntervalYearToMonth(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kYearsFieldNumber = 1,
    kMonthsFieldNumber = 2,
  };
  // int32 years = 1;
  void clear_years() ;
  ::int32_t years() const;
  void set_years(::int32_t value);

  private:
  ::int32_t _internal_years() const;
  void _internal_set_years(::int32_t value);

  public:
  // int32 months = 2;
  void clear_months() ;
  ::int32_t months() const;
  void set_months(::int32_t value);

  private:
  ::int32_t _internal_months() const;
  void _internal_set_months(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:substrait.Expression.Literal.IntervalYearToMonth)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_Literal_IntervalYearToMonth& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t years_;
    ::int32_t months_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_Literal_IntervalYearToMonth_class_data_;
// -------------------------------------------------------------------

class Expression_Literal_IntervalDayToSecond final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.Literal.IntervalDayToSecond) */ {
 public:
  inline Expression_Literal_IntervalDayToSecond() : Expression_Literal_IntervalDayToSecond(nullptr) {}
  ~Expression_Literal_IntervalDayToSecond() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_Literal_IntervalDayToSecond* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_Literal_IntervalDayToSecond));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_Literal_IntervalDayToSecond(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_Literal_IntervalDayToSecond(const Expression_Literal_IntervalDayToSecond& from) : Expression_Literal_IntervalDayToSecond(nullptr, from) {}
  inline Expression_Literal_IntervalDayToSecond(Expression_Literal_IntervalDayToSecond&& from) noexcept
      : Expression_Literal_IntervalDayToSecond(nullptr, std::move(from)) {}
  inline Expression_Literal_IntervalDayToSecond& operator=(const Expression_Literal_IntervalDayToSecond& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_Literal_IntervalDayToSecond& operator=(Expression_Literal_IntervalDayToSecond&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_Literal_IntervalDayToSecond& default_instance() {
    return *reinterpret_cast<const Expression_Literal_IntervalDayToSecond*>(
        &_Expression_Literal_IntervalDayToSecond_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 61;
  friend void swap(Expression_Literal_IntervalDayToSecond& a, Expression_Literal_IntervalDayToSecond& b) { a.Swap(&b); }
  inline void Swap(Expression_Literal_IntervalDayToSecond* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_Literal_IntervalDayToSecond* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_Literal_IntervalDayToSecond* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_Literal_IntervalDayToSecond>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_Literal_IntervalDayToSecond& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_Literal_IntervalDayToSecond& from) { Expression_Literal_IntervalDayToSecond::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_Literal_IntervalDayToSecond* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.Literal.IntervalDayToSecond"; }

 protected:
  explicit Expression_Literal_IntervalDayToSecond(::google::protobuf::Arena* arena);
  Expression_Literal_IntervalDayToSecond(::google::protobuf::Arena* arena, const Expression_Literal_IntervalDayToSecond& from);
  Expression_Literal_IntervalDayToSecond(::google::protobuf::Arena* arena, Expression_Literal_IntervalDayToSecond&& from) noexcept
      : Expression_Literal_IntervalDayToSecond(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDaysFieldNumber = 1,
    kSecondsFieldNumber = 2,
    kMicrosecondsFieldNumber = 3,
  };
  // int32 days = 1;
  void clear_days() ;
  ::int32_t days() const;
  void set_days(::int32_t value);

  private:
  ::int32_t _internal_days() const;
  void _internal_set_days(::int32_t value);

  public:
  // int32 seconds = 2;
  void clear_seconds() ;
  ::int32_t seconds() const;
  void set_seconds(::int32_t value);

  private:
  ::int32_t _internal_seconds() const;
  void _internal_set_seconds(::int32_t value);

  public:
  // int32 microseconds = 3;
  void clear_microseconds() ;
  ::int32_t microseconds() const;
  void set_microseconds(::int32_t value);

  private:
  ::int32_t _internal_microseconds() const;
  void _internal_set_microseconds(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:substrait.Expression.Literal.IntervalDayToSecond)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_Literal_IntervalDayToSecond& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t days_;
    ::int32_t seconds_;
    ::int32_t microseconds_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_Literal_IntervalDayToSecond_class_data_;
// -------------------------------------------------------------------

class Expression_Literal_Decimal final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.Literal.Decimal) */ {
 public:
  inline Expression_Literal_Decimal() : Expression_Literal_Decimal(nullptr) {}
  ~Expression_Literal_Decimal() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_Literal_Decimal* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_Literal_Decimal));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_Literal_Decimal(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_Literal_Decimal(const Expression_Literal_Decimal& from) : Expression_Literal_Decimal(nullptr, from) {}
  inline Expression_Literal_Decimal(Expression_Literal_Decimal&& from) noexcept
      : Expression_Literal_Decimal(nullptr, std::move(from)) {}
  inline Expression_Literal_Decimal& operator=(const Expression_Literal_Decimal& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_Literal_Decimal& operator=(Expression_Literal_Decimal&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_Literal_Decimal& default_instance() {
    return *reinterpret_cast<const Expression_Literal_Decimal*>(
        &_Expression_Literal_Decimal_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 57;
  friend void swap(Expression_Literal_Decimal& a, Expression_Literal_Decimal& b) { a.Swap(&b); }
  inline void Swap(Expression_Literal_Decimal* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_Literal_Decimal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_Literal_Decimal* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_Literal_Decimal>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_Literal_Decimal& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_Literal_Decimal& from) { Expression_Literal_Decimal::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_Literal_Decimal* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.Literal.Decimal"; }

 protected:
  explicit Expression_Literal_Decimal(::google::protobuf::Arena* arena);
  Expression_Literal_Decimal(::google::protobuf::Arena* arena, const Expression_Literal_Decimal& from);
  Expression_Literal_Decimal(::google::protobuf::Arena* arena, Expression_Literal_Decimal&& from) noexcept
      : Expression_Literal_Decimal(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValueFieldNumber = 1,
    kPrecisionFieldNumber = 2,
    kScaleFieldNumber = 3,
  };
  // bytes value = 1;
  void clear_value() ;
  const std::string& value() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  [[nodiscard]] std::string* release_value();
  void set_allocated_value(std::string* value);

  private:
  const std::string& _internal_value() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // int32 precision = 2;
  void clear_precision() ;
  ::int32_t precision() const;
  void set_precision(::int32_t value);

  private:
  ::int32_t _internal_precision() const;
  void _internal_set_precision(::int32_t value);

  public:
  // int32 scale = 3;
  void clear_scale() ;
  ::int32_t scale() const;
  void set_scale(::int32_t value);

  private:
  ::int32_t _internal_scale() const;
  void _internal_set_scale(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:substrait.Expression.Literal.Decimal)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_Literal_Decimal& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr value_;
    ::int32_t precision_;
    ::int32_t scale_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_Literal_Decimal_class_data_;
// -------------------------------------------------------------------

class Expression_FieldReference_RootReference final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:substrait.Expression.FieldReference.RootReference) */ {
 public:
  inline Expression_FieldReference_RootReference() : Expression_FieldReference_RootReference(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_FieldReference_RootReference* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_FieldReference_RootReference));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_FieldReference_RootReference(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_FieldReference_RootReference(const Expression_FieldReference_RootReference& from) : Expression_FieldReference_RootReference(nullptr, from) {}
  inline Expression_FieldReference_RootReference(Expression_FieldReference_RootReference&& from) noexcept
      : Expression_FieldReference_RootReference(nullptr, std::move(from)) {}
  inline Expression_FieldReference_RootReference& operator=(const Expression_FieldReference_RootReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_FieldReference_RootReference& operator=(Expression_FieldReference_RootReference&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_FieldReference_RootReference& default_instance() {
    return *reinterpret_cast<const Expression_FieldReference_RootReference*>(
        &_Expression_FieldReference_RootReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 104;
  friend void swap(Expression_FieldReference_RootReference& a, Expression_FieldReference_RootReference& b) { a.Swap(&b); }
  inline void Swap(Expression_FieldReference_RootReference* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_FieldReference_RootReference* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_FieldReference_RootReference* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<Expression_FieldReference_RootReference>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Expression_FieldReference_RootReference& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Expression_FieldReference_RootReference& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.FieldReference.RootReference"; }

 protected:
  explicit Expression_FieldReference_RootReference(::google::protobuf::Arena* arena);
  Expression_FieldReference_RootReference(::google::protobuf::Arena* arena, const Expression_FieldReference_RootReference& from);
  Expression_FieldReference_RootReference(::google::protobuf::Arena* arena, Expression_FieldReference_RootReference&& from) noexcept
      : Expression_FieldReference_RootReference(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:substrait.Expression.FieldReference.RootReference)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_FieldReference_RootReference& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_FieldReference_RootReference_class_data_;
// -------------------------------------------------------------------

class Expression_FieldReference_OuterReference final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.FieldReference.OuterReference) */ {
 public:
  inline Expression_FieldReference_OuterReference() : Expression_FieldReference_OuterReference(nullptr) {}
  ~Expression_FieldReference_OuterReference() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_FieldReference_OuterReference* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_FieldReference_OuterReference));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_FieldReference_OuterReference(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_FieldReference_OuterReference(const Expression_FieldReference_OuterReference& from) : Expression_FieldReference_OuterReference(nullptr, from) {}
  inline Expression_FieldReference_OuterReference(Expression_FieldReference_OuterReference&& from) noexcept
      : Expression_FieldReference_OuterReference(nullptr, std::move(from)) {}
  inline Expression_FieldReference_OuterReference& operator=(const Expression_FieldReference_OuterReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_FieldReference_OuterReference& operator=(Expression_FieldReference_OuterReference&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_FieldReference_OuterReference& default_instance() {
    return *reinterpret_cast<const Expression_FieldReference_OuterReference*>(
        &_Expression_FieldReference_OuterReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 105;
  friend void swap(Expression_FieldReference_OuterReference& a, Expression_FieldReference_OuterReference& b) { a.Swap(&b); }
  inline void Swap(Expression_FieldReference_OuterReference* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_FieldReference_OuterReference* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_FieldReference_OuterReference* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_FieldReference_OuterReference>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_FieldReference_OuterReference& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_FieldReference_OuterReference& from) { Expression_FieldReference_OuterReference::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_FieldReference_OuterReference* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.FieldReference.OuterReference"; }

 protected:
  explicit Expression_FieldReference_OuterReference(::google::protobuf::Arena* arena);
  Expression_FieldReference_OuterReference(::google::protobuf::Arena* arena, const Expression_FieldReference_OuterReference& from);
  Expression_FieldReference_OuterReference(::google::protobuf::Arena* arena, Expression_FieldReference_OuterReference&& from) noexcept
      : Expression_FieldReference_OuterReference(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStepsOutFieldNumber = 1,
  };
  // uint32 steps_out = 1;
  void clear_steps_out() ;
  ::uint32_t steps_out() const;
  void set_steps_out(::uint32_t value);

  private:
  ::uint32_t _internal_steps_out() const;
  void _internal_set_steps_out(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:substrait.Expression.FieldReference.OuterReference)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_FieldReference_OuterReference& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t steps_out_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_FieldReference_OuterReference_class_data_;
// -------------------------------------------------------------------

class [[deprecated]] Expression_Enum_Empty final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:substrait.Expression.Enum.Empty) */ {
 public:
  inline Expression_Enum_Empty() : Expression_Enum_Empty(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_Enum_Empty* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_Enum_Empty));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_Enum_Empty(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_Enum_Empty(const Expression_Enum_Empty& from) : Expression_Enum_Empty(nullptr, from) {}
  inline Expression_Enum_Empty(Expression_Enum_Empty&& from) noexcept
      : Expression_Enum_Empty(nullptr, std::move(from)) {}
  inline Expression_Enum_Empty& operator=(const Expression_Enum_Empty& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_Enum_Empty& operator=(Expression_Enum_Empty&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_Enum_Empty& default_instance() {
    return *reinterpret_cast<const Expression_Enum_Empty*>(
        &_Expression_Enum_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 54;
  friend void swap(Expression_Enum_Empty& a, Expression_Enum_Empty& b) { a.Swap(&b); }
  inline void Swap(Expression_Enum_Empty* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_Enum_Empty* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_Enum_Empty* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<Expression_Enum_Empty>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Expression_Enum_Empty& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Expression_Enum_Empty& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.Enum.Empty"; }

 protected:
  explicit Expression_Enum_Empty(::google::protobuf::Arena* arena);
  Expression_Enum_Empty(::google::protobuf::Arena* arena, const Expression_Enum_Empty& from);
  Expression_Enum_Empty(::google::protobuf::Arena* arena, Expression_Enum_Empty&& from) noexcept
      : Expression_Enum_Empty(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:substrait.Expression.Enum.Empty)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_Enum_Empty& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_Enum_Empty_class_data_;
// -------------------------------------------------------------------

class Expression_EmbeddedFunction_WebAssemblyFunction final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.EmbeddedFunction.WebAssemblyFunction) */ {
 public:
  inline Expression_EmbeddedFunction_WebAssemblyFunction() : Expression_EmbeddedFunction_WebAssemblyFunction(nullptr) {}
  ~Expression_EmbeddedFunction_WebAssemblyFunction() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_EmbeddedFunction_WebAssemblyFunction* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_EmbeddedFunction_WebAssemblyFunction));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_EmbeddedFunction_WebAssemblyFunction(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_EmbeddedFunction_WebAssemblyFunction(const Expression_EmbeddedFunction_WebAssemblyFunction& from) : Expression_EmbeddedFunction_WebAssemblyFunction(nullptr, from) {}
  inline Expression_EmbeddedFunction_WebAssemblyFunction(Expression_EmbeddedFunction_WebAssemblyFunction&& from) noexcept
      : Expression_EmbeddedFunction_WebAssemblyFunction(nullptr, std::move(from)) {}
  inline Expression_EmbeddedFunction_WebAssemblyFunction& operator=(const Expression_EmbeddedFunction_WebAssemblyFunction& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_EmbeddedFunction_WebAssemblyFunction& operator=(Expression_EmbeddedFunction_WebAssemblyFunction&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_EmbeddedFunction_WebAssemblyFunction& default_instance() {
    return *reinterpret_cast<const Expression_EmbeddedFunction_WebAssemblyFunction*>(
        &_Expression_EmbeddedFunction_WebAssemblyFunction_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 87;
  friend void swap(Expression_EmbeddedFunction_WebAssemblyFunction& a, Expression_EmbeddedFunction_WebAssemblyFunction& b) { a.Swap(&b); }
  inline void Swap(Expression_EmbeddedFunction_WebAssemblyFunction* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_EmbeddedFunction_WebAssemblyFunction* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_EmbeddedFunction_WebAssemblyFunction* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_EmbeddedFunction_WebAssemblyFunction>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_EmbeddedFunction_WebAssemblyFunction& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_EmbeddedFunction_WebAssemblyFunction& from) { Expression_EmbeddedFunction_WebAssemblyFunction::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_EmbeddedFunction_WebAssemblyFunction* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.EmbeddedFunction.WebAssemblyFunction"; }

 protected:
  explicit Expression_EmbeddedFunction_WebAssemblyFunction(::google::protobuf::Arena* arena);
  Expression_EmbeddedFunction_WebAssemblyFunction(::google::protobuf::Arena* arena, const Expression_EmbeddedFunction_WebAssemblyFunction& from);
  Expression_EmbeddedFunction_WebAssemblyFunction(::google::protobuf::Arena* arena, Expression_EmbeddedFunction_WebAssemblyFunction&& from) noexcept
      : Expression_EmbeddedFunction_WebAssemblyFunction(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPrerequisiteFieldNumber = 2,
    kScriptFieldNumber = 1,
  };
  // repeated string prerequisite = 2;
  int prerequisite_size() const;
  private:
  int _internal_prerequisite_size() const;

  public:
  void clear_prerequisite() ;
  const std::string& prerequisite(int index) const;
  std::string* mutable_prerequisite(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_prerequisite(int index, Arg_&& value, Args_... args);
  std::string* add_prerequisite();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_prerequisite(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& prerequisite() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_prerequisite();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_prerequisite() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_prerequisite();

  public:
  // bytes script = 1;
  void clear_script() ;
  const std::string& script() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_script(Arg_&& arg, Args_... args);
  std::string* mutable_script();
  [[nodiscard]] std::string* release_script();
  void set_allocated_script(std::string* value);

  private:
  const std::string& _internal_script() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_script(const std::string& value);
  std::string* _internal_mutable_script();

  public:
  // @@protoc_insertion_point(class_scope:substrait.Expression.EmbeddedFunction.WebAssemblyFunction)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      78, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_EmbeddedFunction_WebAssemblyFunction& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> prerequisite_;
    ::google::protobuf::internal::ArenaStringPtr script_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_EmbeddedFunction_WebAssemblyFunction_class_data_;
// -------------------------------------------------------------------

class Expression_EmbeddedFunction_PythonPickleFunction final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.EmbeddedFunction.PythonPickleFunction) */ {
 public:
  inline Expression_EmbeddedFunction_PythonPickleFunction() : Expression_EmbeddedFunction_PythonPickleFunction(nullptr) {}
  ~Expression_EmbeddedFunction_PythonPickleFunction() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_EmbeddedFunction_PythonPickleFunction* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_EmbeddedFunction_PythonPickleFunction));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_EmbeddedFunction_PythonPickleFunction(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_EmbeddedFunction_PythonPickleFunction(const Expression_EmbeddedFunction_PythonPickleFunction& from) : Expression_EmbeddedFunction_PythonPickleFunction(nullptr, from) {}
  inline Expression_EmbeddedFunction_PythonPickleFunction(Expression_EmbeddedFunction_PythonPickleFunction&& from) noexcept
      : Expression_EmbeddedFunction_PythonPickleFunction(nullptr, std::move(from)) {}
  inline Expression_EmbeddedFunction_PythonPickleFunction& operator=(const Expression_EmbeddedFunction_PythonPickleFunction& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_EmbeddedFunction_PythonPickleFunction& operator=(Expression_EmbeddedFunction_PythonPickleFunction&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_EmbeddedFunction_PythonPickleFunction& default_instance() {
    return *reinterpret_cast<const Expression_EmbeddedFunction_PythonPickleFunction*>(
        &_Expression_EmbeddedFunction_PythonPickleFunction_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 86;
  friend void swap(Expression_EmbeddedFunction_PythonPickleFunction& a, Expression_EmbeddedFunction_PythonPickleFunction& b) { a.Swap(&b); }
  inline void Swap(Expression_EmbeddedFunction_PythonPickleFunction* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_EmbeddedFunction_PythonPickleFunction* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_EmbeddedFunction_PythonPickleFunction* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_EmbeddedFunction_PythonPickleFunction>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_EmbeddedFunction_PythonPickleFunction& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_EmbeddedFunction_PythonPickleFunction& from) { Expression_EmbeddedFunction_PythonPickleFunction::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_EmbeddedFunction_PythonPickleFunction* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.EmbeddedFunction.PythonPickleFunction"; }

 protected:
  explicit Expression_EmbeddedFunction_PythonPickleFunction(::google::protobuf::Arena* arena);
  Expression_EmbeddedFunction_PythonPickleFunction(::google::protobuf::Arena* arena, const Expression_EmbeddedFunction_PythonPickleFunction& from);
  Expression_EmbeddedFunction_PythonPickleFunction(::google::protobuf::Arena* arena, Expression_EmbeddedFunction_PythonPickleFunction&& from) noexcept
      : Expression_EmbeddedFunction_PythonPickleFunction(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPrerequisiteFieldNumber = 2,
    kFunctionFieldNumber = 1,
  };
  // repeated string prerequisite = 2;
  int prerequisite_size() const;
  private:
  int _internal_prerequisite_size() const;

  public:
  void clear_prerequisite() ;
  const std::string& prerequisite(int index) const;
  std::string* mutable_prerequisite(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_prerequisite(int index, Arg_&& value, Args_... args);
  std::string* add_prerequisite();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_prerequisite(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& prerequisite() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_prerequisite();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_prerequisite() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_prerequisite();

  public:
  // bytes function = 1;
  void clear_function() ;
  const std::string& function() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_function(Arg_&& arg, Args_... args);
  std::string* mutable_function();
  [[nodiscard]] std::string* release_function();
  void set_allocated_function(std::string* value);

  private:
  const std::string& _internal_function() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_function(const std::string& value);
  std::string* _internal_mutable_function();

  public:
  // @@protoc_insertion_point(class_scope:substrait.Expression.EmbeddedFunction.PythonPickleFunction)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      79, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_EmbeddedFunction_PythonPickleFunction& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> prerequisite_;
    ::google::protobuf::internal::ArenaStringPtr function_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_EmbeddedFunction_PythonPickleFunction_class_data_;
// -------------------------------------------------------------------

class ExchangeRel_RoundRobin final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.ExchangeRel.RoundRobin) */ {
 public:
  inline ExchangeRel_RoundRobin() : ExchangeRel_RoundRobin(nullptr) {}
  ~ExchangeRel_RoundRobin() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ExchangeRel_RoundRobin* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ExchangeRel_RoundRobin));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ExchangeRel_RoundRobin(
      ::google::protobuf::internal::ConstantInitialized);

  inline ExchangeRel_RoundRobin(const ExchangeRel_RoundRobin& from) : ExchangeRel_RoundRobin(nullptr, from) {}
  inline ExchangeRel_RoundRobin(ExchangeRel_RoundRobin&& from) noexcept
      : ExchangeRel_RoundRobin(nullptr, std::move(from)) {}
  inline ExchangeRel_RoundRobin& operator=(const ExchangeRel_RoundRobin& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExchangeRel_RoundRobin& operator=(ExchangeRel_RoundRobin&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExchangeRel_RoundRobin& default_instance() {
    return *reinterpret_cast<const ExchangeRel_RoundRobin*>(
        &_ExchangeRel_RoundRobin_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 35;
  friend void swap(ExchangeRel_RoundRobin& a, ExchangeRel_RoundRobin& b) { a.Swap(&b); }
  inline void Swap(ExchangeRel_RoundRobin* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExchangeRel_RoundRobin* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExchangeRel_RoundRobin* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ExchangeRel_RoundRobin>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ExchangeRel_RoundRobin& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ExchangeRel_RoundRobin& from) { ExchangeRel_RoundRobin::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ExchangeRel_RoundRobin* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.ExchangeRel.RoundRobin"; }

 protected:
  explicit ExchangeRel_RoundRobin(::google::protobuf::Arena* arena);
  ExchangeRel_RoundRobin(::google::protobuf::Arena* arena, const ExchangeRel_RoundRobin& from);
  ExchangeRel_RoundRobin(::google::protobuf::Arena* arena, ExchangeRel_RoundRobin&& from) noexcept
      : ExchangeRel_RoundRobin(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kExactFieldNumber = 1,
  };
  // bool exact = 1;
  void clear_exact() ;
  bool exact() const;
  void set_exact(bool value);

  private:
  bool _internal_exact() const;
  void _internal_set_exact(bool value);

  public:
  // @@protoc_insertion_point(class_scope:substrait.ExchangeRel.RoundRobin)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ExchangeRel_RoundRobin& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    bool exact_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ExchangeRel_RoundRobin_class_data_;
// -------------------------------------------------------------------

class ExchangeRel_Broadcast final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:substrait.ExchangeRel.Broadcast) */ {
 public:
  inline ExchangeRel_Broadcast() : ExchangeRel_Broadcast(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ExchangeRel_Broadcast* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ExchangeRel_Broadcast));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ExchangeRel_Broadcast(
      ::google::protobuf::internal::ConstantInitialized);

  inline ExchangeRel_Broadcast(const ExchangeRel_Broadcast& from) : ExchangeRel_Broadcast(nullptr, from) {}
  inline ExchangeRel_Broadcast(ExchangeRel_Broadcast&& from) noexcept
      : ExchangeRel_Broadcast(nullptr, std::move(from)) {}
  inline ExchangeRel_Broadcast& operator=(const ExchangeRel_Broadcast& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExchangeRel_Broadcast& operator=(ExchangeRel_Broadcast&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExchangeRel_Broadcast& default_instance() {
    return *reinterpret_cast<const ExchangeRel_Broadcast*>(
        &_ExchangeRel_Broadcast_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 34;
  friend void swap(ExchangeRel_Broadcast& a, ExchangeRel_Broadcast& b) { a.Swap(&b); }
  inline void Swap(ExchangeRel_Broadcast* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExchangeRel_Broadcast* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExchangeRel_Broadcast* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ExchangeRel_Broadcast>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ExchangeRel_Broadcast& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ExchangeRel_Broadcast& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.ExchangeRel.Broadcast"; }

 protected:
  explicit ExchangeRel_Broadcast(::google::protobuf::Arena* arena);
  ExchangeRel_Broadcast(::google::protobuf::Arena* arena, const ExchangeRel_Broadcast& from);
  ExchangeRel_Broadcast(::google::protobuf::Arena* arena, ExchangeRel_Broadcast&& from) noexcept
      : ExchangeRel_Broadcast(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:substrait.ExchangeRel.Broadcast)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ExchangeRel_Broadcast& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ExchangeRel_Broadcast_class_data_;
// -------------------------------------------------------------------

class ComparisonJoinKey_ComparisonType final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.ComparisonJoinKey.ComparisonType) */ {
 public:
  inline ComparisonJoinKey_ComparisonType() : ComparisonJoinKey_ComparisonType(nullptr) {}
  ~ComparisonJoinKey_ComparisonType() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ComparisonJoinKey_ComparisonType* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ComparisonJoinKey_ComparisonType));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ComparisonJoinKey_ComparisonType(
      ::google::protobuf::internal::ConstantInitialized);

  inline ComparisonJoinKey_ComparisonType(const ComparisonJoinKey_ComparisonType& from) : ComparisonJoinKey_ComparisonType(nullptr, from) {}
  inline ComparisonJoinKey_ComparisonType(ComparisonJoinKey_ComparisonType&& from) noexcept
      : ComparisonJoinKey_ComparisonType(nullptr, std::move(from)) {}
  inline ComparisonJoinKey_ComparisonType& operator=(const ComparisonJoinKey_ComparisonType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ComparisonJoinKey_ComparisonType& operator=(ComparisonJoinKey_ComparisonType&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ComparisonJoinKey_ComparisonType& default_instance() {
    return *reinterpret_cast<const ComparisonJoinKey_ComparisonType*>(
        &_ComparisonJoinKey_ComparisonType_default_instance_);
  }
  enum InnerTypeCase {
    kSimple = 1,
    kCustomFunctionReference = 2,
    INNER_TYPE_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 47;
  friend void swap(ComparisonJoinKey_ComparisonType& a, ComparisonJoinKey_ComparisonType& b) { a.Swap(&b); }
  inline void Swap(ComparisonJoinKey_ComparisonType* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ComparisonJoinKey_ComparisonType* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ComparisonJoinKey_ComparisonType* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ComparisonJoinKey_ComparisonType>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ComparisonJoinKey_ComparisonType& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ComparisonJoinKey_ComparisonType& from) { ComparisonJoinKey_ComparisonType::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ComparisonJoinKey_ComparisonType* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.ComparisonJoinKey.ComparisonType"; }

 protected:
  explicit ComparisonJoinKey_ComparisonType(::google::protobuf::Arena* arena);
  ComparisonJoinKey_ComparisonType(::google::protobuf::Arena* arena, const ComparisonJoinKey_ComparisonType& from);
  ComparisonJoinKey_ComparisonType(::google::protobuf::Arena* arena, ComparisonJoinKey_ComparisonType&& from) noexcept
      : ComparisonJoinKey_ComparisonType(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSimpleFieldNumber = 1,
    kCustomFunctionReferenceFieldNumber = 2,
  };
  // .substrait.ComparisonJoinKey.SimpleComparisonType simple = 1;
  bool has_simple() const;
  void clear_simple() ;
  ::substrait::ComparisonJoinKey_SimpleComparisonType simple() const;
  void set_simple(::substrait::ComparisonJoinKey_SimpleComparisonType value);

  private:
  ::substrait::ComparisonJoinKey_SimpleComparisonType _internal_simple() const;
  void _internal_set_simple(::substrait::ComparisonJoinKey_SimpleComparisonType value);

  public:
  // uint32 custom_function_reference = 2;
  bool has_custom_function_reference() const;
  void clear_custom_function_reference() ;
  ::uint32_t custom_function_reference() const;
  void set_custom_function_reference(::uint32_t value);

  private:
  ::uint32_t _internal_custom_function_reference() const;
  void _internal_set_custom_function_reference(::uint32_t value);

  public:
  void clear_inner_type();
  InnerTypeCase inner_type_case() const;
  // @@protoc_insertion_point(class_scope:substrait.ComparisonJoinKey.ComparisonType)
 private:
  class _Internal;
  void set_has_simple();
  void set_has_custom_function_reference();
  inline bool has_inner_type() const;
  inline void clear_has_inner_type();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ComparisonJoinKey_ComparisonType& from_msg);
    union InnerTypeUnion {
      constexpr InnerTypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      int simple_;
      ::uint32_t custom_function_reference_;
    } inner_type_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ComparisonJoinKey_ComparisonType_class_data_;
// -------------------------------------------------------------------

class ReadRel_LocalFiles_FileOrFiles final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.ReadRel.LocalFiles.FileOrFiles) */ {
 public:
  inline ReadRel_LocalFiles_FileOrFiles() : ReadRel_LocalFiles_FileOrFiles(nullptr) {}
  ~ReadRel_LocalFiles_FileOrFiles() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReadRel_LocalFiles_FileOrFiles* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReadRel_LocalFiles_FileOrFiles));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReadRel_LocalFiles_FileOrFiles(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReadRel_LocalFiles_FileOrFiles(const ReadRel_LocalFiles_FileOrFiles& from) : ReadRel_LocalFiles_FileOrFiles(nullptr, from) {}
  inline ReadRel_LocalFiles_FileOrFiles(ReadRel_LocalFiles_FileOrFiles&& from) noexcept
      : ReadRel_LocalFiles_FileOrFiles(nullptr, std::move(from)) {}
  inline ReadRel_LocalFiles_FileOrFiles& operator=(const ReadRel_LocalFiles_FileOrFiles& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadRel_LocalFiles_FileOrFiles& operator=(ReadRel_LocalFiles_FileOrFiles&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadRel_LocalFiles_FileOrFiles& default_instance() {
    return *reinterpret_cast<const ReadRel_LocalFiles_FileOrFiles*>(
        &_ReadRel_LocalFiles_FileOrFiles_default_instance_);
  }
  enum PathTypeCase {
    kUriPath = 1,
    kUriPathGlob = 2,
    kUriFile = 3,
    kUriFolder = 4,
    PATH_TYPE_NOT_SET = 0,
  };
  enum FileFormatCase {
    kParquet = 9,
    kArrow = 10,
    kOrc = 11,
    kExtension = 12,
    kDwrf = 13,
    FILE_FORMAT_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(ReadRel_LocalFiles_FileOrFiles& a, ReadRel_LocalFiles_FileOrFiles& b) { a.Swap(&b); }
  inline void Swap(ReadRel_LocalFiles_FileOrFiles* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadRel_LocalFiles_FileOrFiles* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadRel_LocalFiles_FileOrFiles* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReadRel_LocalFiles_FileOrFiles>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReadRel_LocalFiles_FileOrFiles& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReadRel_LocalFiles_FileOrFiles& from) { ReadRel_LocalFiles_FileOrFiles::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReadRel_LocalFiles_FileOrFiles* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.ReadRel.LocalFiles.FileOrFiles"; }

 protected:
  explicit ReadRel_LocalFiles_FileOrFiles(::google::protobuf::Arena* arena);
  ReadRel_LocalFiles_FileOrFiles(::google::protobuf::Arena* arena, const ReadRel_LocalFiles_FileOrFiles& from);
  ReadRel_LocalFiles_FileOrFiles(::google::protobuf::Arena* arena, ReadRel_LocalFiles_FileOrFiles&& from) noexcept
      : ReadRel_LocalFiles_FileOrFiles(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using ParquetReadOptions = ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions;
  using ArrowReadOptions = ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions;
  using OrcReadOptions = ReadRel_LocalFiles_FileOrFiles_OrcReadOptions;
  using DwrfReadOptions = ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions;

  // accessors -------------------------------------------------------
  enum : int {
    kPartitionIndexFieldNumber = 6,
    kStartFieldNumber = 7,
    kLengthFieldNumber = 8,
    kUriPathFieldNumber = 1,
    kUriPathGlobFieldNumber = 2,
    kUriFileFieldNumber = 3,
    kUriFolderFieldNumber = 4,
    kParquetFieldNumber = 9,
    kArrowFieldNumber = 10,
    kOrcFieldNumber = 11,
    kExtensionFieldNumber = 12,
    kDwrfFieldNumber = 13,
  };
  // uint64 partition_index = 6;
  void clear_partition_index() ;
  ::uint64_t partition_index() const;
  void set_partition_index(::uint64_t value);

  private:
  ::uint64_t _internal_partition_index() const;
  void _internal_set_partition_index(::uint64_t value);

  public:
  // uint64 start = 7;
  void clear_start() ;
  ::uint64_t start() const;
  void set_start(::uint64_t value);

  private:
  ::uint64_t _internal_start() const;
  void _internal_set_start(::uint64_t value);

  public:
  // uint64 length = 8;
  void clear_length() ;
  ::uint64_t length() const;
  void set_length(::uint64_t value);

  private:
  ::uint64_t _internal_length() const;
  void _internal_set_length(::uint64_t value);

  public:
  // string uri_path = 1;
  bool has_uri_path() const;
  void clear_uri_path() ;
  const std::string& uri_path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_uri_path(Arg_&& arg, Args_... args);
  std::string* mutable_uri_path();
  [[nodiscard]] std::string* release_uri_path();
  void set_allocated_uri_path(std::string* value);

  private:
  const std::string& _internal_uri_path() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_uri_path(const std::string& value);
  std::string* _internal_mutable_uri_path();

  public:
  // string uri_path_glob = 2;
  bool has_uri_path_glob() const;
  void clear_uri_path_glob() ;
  const std::string& uri_path_glob() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_uri_path_glob(Arg_&& arg, Args_... args);
  std::string* mutable_uri_path_glob();
  [[nodiscard]] std::string* release_uri_path_glob();
  void set_allocated_uri_path_glob(std::string* value);

  private:
  const std::string& _internal_uri_path_glob() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_uri_path_glob(const std::string& value);
  std::string* _internal_mutable_uri_path_glob();

  public:
  // string uri_file = 3;
  bool has_uri_file() const;
  void clear_uri_file() ;
  const std::string& uri_file() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_uri_file(Arg_&& arg, Args_... args);
  std::string* mutable_uri_file();
  [[nodiscard]] std::string* release_uri_file();
  void set_allocated_uri_file(std::string* value);

  private:
  const std::string& _internal_uri_file() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_uri_file(const std::string& value);
  std::string* _internal_mutable_uri_file();

  public:
  // string uri_folder = 4;
  bool has_uri_folder() const;
  void clear_uri_folder() ;
  const std::string& uri_folder() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_uri_folder(Arg_&& arg, Args_... args);
  std::string* mutable_uri_folder();
  [[nodiscard]] std::string* release_uri_folder();
  void set_allocated_uri_folder(std::string* value);

  private:
  const std::string& _internal_uri_folder() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_uri_folder(const std::string& value);
  std::string* _internal_mutable_uri_folder();

  public:
  // .substrait.ReadRel.LocalFiles.FileOrFiles.ParquetReadOptions parquet = 9;
  bool has_parquet() const;
  private:
  bool _internal_has_parquet() const;

  public:
  void clear_parquet() ;
  const ::substrait::ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions& parquet() const;
  [[nodiscard]] ::substrait::ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions* release_parquet();
  ::substrait::ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions* mutable_parquet();
  void set_allocated_parquet(::substrait::ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions* value);
  void unsafe_arena_set_allocated_parquet(::substrait::ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions* value);
  ::substrait::ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions* unsafe_arena_release_parquet();

  private:
  const ::substrait::ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions& _internal_parquet() const;
  ::substrait::ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions* _internal_mutable_parquet();

  public:
  // .substrait.ReadRel.LocalFiles.FileOrFiles.ArrowReadOptions arrow = 10;
  bool has_arrow() const;
  private:
  bool _internal_has_arrow() const;

  public:
  void clear_arrow() ;
  const ::substrait::ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions& arrow() const;
  [[nodiscard]] ::substrait::ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions* release_arrow();
  ::substrait::ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions* mutable_arrow();
  void set_allocated_arrow(::substrait::ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions* value);
  void unsafe_arena_set_allocated_arrow(::substrait::ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions* value);
  ::substrait::ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions* unsafe_arena_release_arrow();

  private:
  const ::substrait::ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions& _internal_arrow() const;
  ::substrait::ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions* _internal_mutable_arrow();

  public:
  // .substrait.ReadRel.LocalFiles.FileOrFiles.OrcReadOptions orc = 11;
  bool has_orc() const;
  private:
  bool _internal_has_orc() const;

  public:
  void clear_orc() ;
  const ::substrait::ReadRel_LocalFiles_FileOrFiles_OrcReadOptions& orc() const;
  [[nodiscard]] ::substrait::ReadRel_LocalFiles_FileOrFiles_OrcReadOptions* release_orc();
  ::substrait::ReadRel_LocalFiles_FileOrFiles_OrcReadOptions* mutable_orc();
  void set_allocated_orc(::substrait::ReadRel_LocalFiles_FileOrFiles_OrcReadOptions* value);
  void unsafe_arena_set_allocated_orc(::substrait::ReadRel_LocalFiles_FileOrFiles_OrcReadOptions* value);
  ::substrait::ReadRel_LocalFiles_FileOrFiles_OrcReadOptions* unsafe_arena_release_orc();

  private:
  const ::substrait::ReadRel_LocalFiles_FileOrFiles_OrcReadOptions& _internal_orc() const;
  ::substrait::ReadRel_LocalFiles_FileOrFiles_OrcReadOptions* _internal_mutable_orc();

  public:
  // .google.protobuf.Any extension = 12;
  bool has_extension() const;
  private:
  bool _internal_has_extension() const;

  public:
  void clear_extension() ;
  const ::google::protobuf::Any& extension() const;
  [[nodiscard]] ::google::protobuf::Any* release_extension();
  ::google::protobuf::Any* mutable_extension();
  void set_allocated_extension(::google::protobuf::Any* value);
  void unsafe_arena_set_allocated_extension(::google::protobuf::Any* value);
  ::google::protobuf::Any* unsafe_arena_release_extension();

  private:
  const ::google::protobuf::Any& _internal_extension() const;
  ::google::protobuf::Any* _internal_mutable_extension();

  public:
  // .substrait.ReadRel.LocalFiles.FileOrFiles.DwrfReadOptions dwrf = 13;
  bool has_dwrf() const;
  private:
  bool _internal_has_dwrf() const;

  public:
  void clear_dwrf() ;
  const ::substrait::ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions& dwrf() const;
  [[nodiscard]] ::substrait::ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions* release_dwrf();
  ::substrait::ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions* mutable_dwrf();
  void set_allocated_dwrf(::substrait::ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions* value);
  void unsafe_arena_set_allocated_dwrf(::substrait::ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions* value);
  ::substrait::ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions* unsafe_arena_release_dwrf();

  private:
  const ::substrait::ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions& _internal_dwrf() const;
  ::substrait::ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions* _internal_mutable_dwrf();

  public:
  void clear_path_type();
  PathTypeCase path_type_case() const;
  void clear_file_format();
  FileFormatCase file_format_case() const;
  // @@protoc_insertion_point(class_scope:substrait.ReadRel.LocalFiles.FileOrFiles)
 private:
  class _Internal;
  void set_has_uri_path();
  void set_has_uri_path_glob();
  void set_has_uri_file();
  void set_has_uri_folder();
  void set_has_parquet();
  void set_has_arrow();
  void set_has_orc();
  void set_has_extension();
  void set_has_dwrf();
  inline bool has_path_type() const;
  inline void clear_has_path_type();
  inline bool has_file_format() const;
  inline void clear_has_file_format();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 12, 5,
      96, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReadRel_LocalFiles_FileOrFiles& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t partition_index_;
    ::uint64_t start_;
    ::uint64_t length_;
    union PathTypeUnion {
      constexpr PathTypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::internal::ArenaStringPtr uri_path_;
      ::google::protobuf::internal::ArenaStringPtr uri_path_glob_;
      ::google::protobuf::internal::ArenaStringPtr uri_file_;
      ::google::protobuf::internal::ArenaStringPtr uri_folder_;
    } path_type_;
    union FileFormatUnion {
      constexpr FileFormatUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::substrait::ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions* parquet_;
      ::substrait::ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions* arrow_;
      ::substrait::ReadRel_LocalFiles_FileOrFiles_OrcReadOptions* orc_;
      ::google::protobuf::Any* extension_;
      ::substrait::ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions* dwrf_;
    } file_format_;
    ::uint32_t _oneof_case_[2];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ReadRel_LocalFiles_FileOrFiles_class_data_;
// -------------------------------------------------------------------

class ReadRel_ExtensionTable final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.ReadRel.ExtensionTable) */ {
 public:
  inline ReadRel_ExtensionTable() : ReadRel_ExtensionTable(nullptr) {}
  ~ReadRel_ExtensionTable() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReadRel_ExtensionTable* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReadRel_ExtensionTable));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReadRel_ExtensionTable(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReadRel_ExtensionTable(const ReadRel_ExtensionTable& from) : ReadRel_ExtensionTable(nullptr, from) {}
  inline ReadRel_ExtensionTable(ReadRel_ExtensionTable&& from) noexcept
      : ReadRel_ExtensionTable(nullptr, std::move(from)) {}
  inline ReadRel_ExtensionTable& operator=(const ReadRel_ExtensionTable& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadRel_ExtensionTable& operator=(ReadRel_ExtensionTable&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadRel_ExtensionTable& default_instance() {
    return *reinterpret_cast<const ReadRel_ExtensionTable*>(
        &_ReadRel_ExtensionTable_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(ReadRel_ExtensionTable& a, ReadRel_ExtensionTable& b) { a.Swap(&b); }
  inline void Swap(ReadRel_ExtensionTable* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadRel_ExtensionTable* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadRel_ExtensionTable* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReadRel_ExtensionTable>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReadRel_ExtensionTable& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReadRel_ExtensionTable& from) { ReadRel_ExtensionTable::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReadRel_ExtensionTable* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.ReadRel.ExtensionTable"; }

 protected:
  explicit ReadRel_ExtensionTable(::google::protobuf::Arena* arena);
  ReadRel_ExtensionTable(::google::protobuf::Arena* arena, const ReadRel_ExtensionTable& from);
  ReadRel_ExtensionTable(::google::protobuf::Arena* arena, ReadRel_ExtensionTable&& from) noexcept
      : ReadRel_ExtensionTable(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDetailFieldNumber = 1,
  };
  // .google.protobuf.Any detail = 1;
  bool has_detail() const;
  void clear_detail() ;
  const ::google::protobuf::Any& detail() const;
  [[nodiscard]] ::google::protobuf::Any* release_detail();
  ::google::protobuf::Any* mutable_detail();
  void set_allocated_detail(::google::protobuf::Any* value);
  void unsafe_arena_set_allocated_detail(::google::protobuf::Any* value);
  ::google::protobuf::Any* unsafe_arena_release_detail();

  private:
  const ::google::protobuf::Any& _internal_detail() const;
  ::google::protobuf::Any* _internal_mutable_detail();

  public:
  // @@protoc_insertion_point(class_scope:substrait.ReadRel.ExtensionTable)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReadRel_ExtensionTable& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::Any* detail_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ReadRel_ExtensionTable_class_data_;
// -------------------------------------------------------------------

class ExtensionObject final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.ExtensionObject) */ {
 public:
  inline ExtensionObject() : ExtensionObject(nullptr) {}
  ~ExtensionObject() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ExtensionObject* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ExtensionObject));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ExtensionObject(
      ::google::protobuf::internal::ConstantInitialized);

  inline ExtensionObject(const ExtensionObject& from) : ExtensionObject(nullptr, from) {}
  inline ExtensionObject(ExtensionObject&& from) noexcept
      : ExtensionObject(nullptr, std::move(from)) {}
  inline ExtensionObject& operator=(const ExtensionObject& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExtensionObject& operator=(ExtensionObject&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExtensionObject& default_instance() {
    return *reinterpret_cast<const ExtensionObject*>(
        &_ExtensionObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 44;
  friend void swap(ExtensionObject& a, ExtensionObject& b) { a.Swap(&b); }
  inline void Swap(ExtensionObject* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExtensionObject* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExtensionObject* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ExtensionObject>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ExtensionObject& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ExtensionObject& from) { ExtensionObject::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ExtensionObject* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.ExtensionObject"; }

 protected:
  explicit ExtensionObject(::google::protobuf::Arena* arena);
  ExtensionObject(::google::protobuf::Arena* arena, const ExtensionObject& from);
  ExtensionObject(::google::protobuf::Arena* arena, ExtensionObject&& from) noexcept
      : ExtensionObject(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDetailFieldNumber = 1,
  };
  // .google.protobuf.Any detail = 1;
  bool has_detail() const;
  void clear_detail() ;
  const ::google::protobuf::Any& detail() const;
  [[nodiscard]] ::google::protobuf::Any* release_detail();
  ::google::protobuf::Any* mutable_detail();
  void set_allocated_detail(::google::protobuf::Any* value);
  void unsafe_arena_set_allocated_detail(::google::protobuf::Any* value);
  ::google::protobuf::Any* unsafe_arena_release_detail();

  private:
  const ::google::protobuf::Any& _internal_detail() const;
  ::google::protobuf::Any* _internal_mutable_detail();

  public:
  // @@protoc_insertion_point(class_scope:substrait.ExtensionObject)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ExtensionObject& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::Any* detail_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ExtensionObject_class_data_;
// -------------------------------------------------------------------

class Expression_WindowFunction_Bound final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.WindowFunction.Bound) */ {
 public:
  inline Expression_WindowFunction_Bound() : Expression_WindowFunction_Bound(nullptr) {}
  ~Expression_WindowFunction_Bound() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_WindowFunction_Bound* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_WindowFunction_Bound));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_WindowFunction_Bound(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_WindowFunction_Bound(const Expression_WindowFunction_Bound& from) : Expression_WindowFunction_Bound(nullptr, from) {}
  inline Expression_WindowFunction_Bound(Expression_WindowFunction_Bound&& from) noexcept
      : Expression_WindowFunction_Bound(nullptr, std::move(from)) {}
  inline Expression_WindowFunction_Bound& operator=(const Expression_WindowFunction_Bound& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_WindowFunction_Bound& operator=(Expression_WindowFunction_Bound&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_WindowFunction_Bound& default_instance() {
    return *reinterpret_cast<const Expression_WindowFunction_Bound*>(
        &_Expression_WindowFunction_Bound_default_instance_);
  }
  enum KindCase {
    kPreceding = 1,
    kFollowing = 2,
    kCurrentRow = 3,
    kUnbounded = 4,
    KIND_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 76;
  friend void swap(Expression_WindowFunction_Bound& a, Expression_WindowFunction_Bound& b) { a.Swap(&b); }
  inline void Swap(Expression_WindowFunction_Bound* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_WindowFunction_Bound* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_WindowFunction_Bound* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_WindowFunction_Bound>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_WindowFunction_Bound& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_WindowFunction_Bound& from) { Expression_WindowFunction_Bound::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_WindowFunction_Bound* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.WindowFunction.Bound"; }

 protected:
  explicit Expression_WindowFunction_Bound(::google::protobuf::Arena* arena);
  Expression_WindowFunction_Bound(::google::protobuf::Arena* arena, const Expression_WindowFunction_Bound& from);
  Expression_WindowFunction_Bound(::google::protobuf::Arena* arena, Expression_WindowFunction_Bound&& from) noexcept
      : Expression_WindowFunction_Bound(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Preceding = Expression_WindowFunction_Bound_Preceding;
  using Following = Expression_WindowFunction_Bound_Following;
  using CurrentRow = Expression_WindowFunction_Bound_CurrentRow;
  using Unbounded = Expression_WindowFunction_Bound_Unbounded;

  // accessors -------------------------------------------------------
  enum : int {
    kPrecedingFieldNumber = 1,
    kFollowingFieldNumber = 2,
    kCurrentRowFieldNumber = 3,
    kUnboundedFieldNumber = 4,
  };
  // .substrait.Expression.WindowFunction.Bound.Preceding preceding = 1;
  bool has_preceding() const;
  private:
  bool _internal_has_preceding() const;

  public:
  void clear_preceding() ;
  const ::substrait::Expression_WindowFunction_Bound_Preceding& preceding() const;
  [[nodiscard]] ::substrait::Expression_WindowFunction_Bound_Preceding* release_preceding();
  ::substrait::Expression_WindowFunction_Bound_Preceding* mutable_preceding();
  void set_allocated_preceding(::substrait::Expression_WindowFunction_Bound_Preceding* value);
  void unsafe_arena_set_allocated_preceding(::substrait::Expression_WindowFunction_Bound_Preceding* value);
  ::substrait::Expression_WindowFunction_Bound_Preceding* unsafe_arena_release_preceding();

  private:
  const ::substrait::Expression_WindowFunction_Bound_Preceding& _internal_preceding() const;
  ::substrait::Expression_WindowFunction_Bound_Preceding* _internal_mutable_preceding();

  public:
  // .substrait.Expression.WindowFunction.Bound.Following following = 2;
  bool has_following() const;
  private:
  bool _internal_has_following() const;

  public:
  void clear_following() ;
  const ::substrait::Expression_WindowFunction_Bound_Following& following() const;
  [[nodiscard]] ::substrait::Expression_WindowFunction_Bound_Following* release_following();
  ::substrait::Expression_WindowFunction_Bound_Following* mutable_following();
  void set_allocated_following(::substrait::Expression_WindowFunction_Bound_Following* value);
  void unsafe_arena_set_allocated_following(::substrait::Expression_WindowFunction_Bound_Following* value);
  ::substrait::Expression_WindowFunction_Bound_Following* unsafe_arena_release_following();

  private:
  const ::substrait::Expression_WindowFunction_Bound_Following& _internal_following() const;
  ::substrait::Expression_WindowFunction_Bound_Following* _internal_mutable_following();

  public:
  // .substrait.Expression.WindowFunction.Bound.CurrentRow current_row = 3;
  bool has_current_row() const;
  private:
  bool _internal_has_current_row() const;

  public:
  void clear_current_row() ;
  const ::substrait::Expression_WindowFunction_Bound_CurrentRow& current_row() const;
  [[nodiscard]] ::substrait::Expression_WindowFunction_Bound_CurrentRow* release_current_row();
  ::substrait::Expression_WindowFunction_Bound_CurrentRow* mutable_current_row();
  void set_allocated_current_row(::substrait::Expression_WindowFunction_Bound_CurrentRow* value);
  void unsafe_arena_set_allocated_current_row(::substrait::Expression_WindowFunction_Bound_CurrentRow* value);
  ::substrait::Expression_WindowFunction_Bound_CurrentRow* unsafe_arena_release_current_row();

  private:
  const ::substrait::Expression_WindowFunction_Bound_CurrentRow& _internal_current_row() const;
  ::substrait::Expression_WindowFunction_Bound_CurrentRow* _internal_mutable_current_row();

  public:
  // .substrait.Expression.WindowFunction.Bound.Unbounded unbounded = 4;
  bool has_unbounded() const;
  private:
  bool _internal_has_unbounded() const;

  public:
  void clear_unbounded() ;
  const ::substrait::Expression_WindowFunction_Bound_Unbounded& unbounded() const;
  [[nodiscard]] ::substrait::Expression_WindowFunction_Bound_Unbounded* release_unbounded();
  ::substrait::Expression_WindowFunction_Bound_Unbounded* mutable_unbounded();
  void set_allocated_unbounded(::substrait::Expression_WindowFunction_Bound_Unbounded* value);
  void unsafe_arena_set_allocated_unbounded(::substrait::Expression_WindowFunction_Bound_Unbounded* value);
  ::substrait::Expression_WindowFunction_Bound_Unbounded* unsafe_arena_release_unbounded();

  private:
  const ::substrait::Expression_WindowFunction_Bound_Unbounded& _internal_unbounded() const;
  ::substrait::Expression_WindowFunction_Bound_Unbounded* _internal_mutable_unbounded();

  public:
  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:substrait.Expression.WindowFunction.Bound)
 private:
  class _Internal;
  void set_has_preceding();
  void set_has_following();
  void set_has_current_row();
  void set_has_unbounded();
  inline bool has_kind() const;
  inline void clear_has_kind();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 4, 4,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_WindowFunction_Bound& from_msg);
    union KindUnion {
      constexpr KindUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::substrait::Expression_WindowFunction_Bound_Preceding* preceding_;
      ::substrait::Expression_WindowFunction_Bound_Following* following_;
      ::substrait::Expression_WindowFunction_Bound_CurrentRow* current_row_;
      ::substrait::Expression_WindowFunction_Bound_Unbounded* unbounded_;
    } kind_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_WindowFunction_Bound_class_data_;
// -------------------------------------------------------------------

class Expression_MaskExpression_ListSelect_ListSelectItem final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.MaskExpression.ListSelect.ListSelectItem) */ {
 public:
  inline Expression_MaskExpression_ListSelect_ListSelectItem() : Expression_MaskExpression_ListSelect_ListSelectItem(nullptr) {}
  ~Expression_MaskExpression_ListSelect_ListSelectItem() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_MaskExpression_ListSelect_ListSelectItem* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_MaskExpression_ListSelect_ListSelectItem));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_MaskExpression_ListSelect_ListSelectItem(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_MaskExpression_ListSelect_ListSelectItem(const Expression_MaskExpression_ListSelect_ListSelectItem& from) : Expression_MaskExpression_ListSelect_ListSelectItem(nullptr, from) {}
  inline Expression_MaskExpression_ListSelect_ListSelectItem(Expression_MaskExpression_ListSelect_ListSelectItem&& from) noexcept
      : Expression_MaskExpression_ListSelect_ListSelectItem(nullptr, std::move(from)) {}
  inline Expression_MaskExpression_ListSelect_ListSelectItem& operator=(const Expression_MaskExpression_ListSelect_ListSelectItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_MaskExpression_ListSelect_ListSelectItem& operator=(Expression_MaskExpression_ListSelect_ListSelectItem&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_MaskExpression_ListSelect_ListSelectItem& default_instance() {
    return *reinterpret_cast<const Expression_MaskExpression_ListSelect_ListSelectItem*>(
        &_Expression_MaskExpression_ListSelect_ListSelectItem_default_instance_);
  }
  enum TypeCase {
    kItem = 1,
    kSlice = 2,
    TYPE_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 98;
  friend void swap(Expression_MaskExpression_ListSelect_ListSelectItem& a, Expression_MaskExpression_ListSelect_ListSelectItem& b) { a.Swap(&b); }
  inline void Swap(Expression_MaskExpression_ListSelect_ListSelectItem* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_MaskExpression_ListSelect_ListSelectItem* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_MaskExpression_ListSelect_ListSelectItem* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_MaskExpression_ListSelect_ListSelectItem>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_MaskExpression_ListSelect_ListSelectItem& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_MaskExpression_ListSelect_ListSelectItem& from) { Expression_MaskExpression_ListSelect_ListSelectItem::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_MaskExpression_ListSelect_ListSelectItem* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.MaskExpression.ListSelect.ListSelectItem"; }

 protected:
  explicit Expression_MaskExpression_ListSelect_ListSelectItem(::google::protobuf::Arena* arena);
  Expression_MaskExpression_ListSelect_ListSelectItem(::google::protobuf::Arena* arena, const Expression_MaskExpression_ListSelect_ListSelectItem& from);
  Expression_MaskExpression_ListSelect_ListSelectItem(::google::protobuf::Arena* arena, Expression_MaskExpression_ListSelect_ListSelectItem&& from) noexcept
      : Expression_MaskExpression_ListSelect_ListSelectItem(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using ListElement = Expression_MaskExpression_ListSelect_ListSelectItem_ListElement;
  using ListSlice = Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice;

  // accessors -------------------------------------------------------
  enum : int {
    kItemFieldNumber = 1,
    kSliceFieldNumber = 2,
  };
  // .substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListElement item = 1;
  bool has_item() const;
  private:
  bool _internal_has_item() const;

  public:
  void clear_item() ;
  const ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement& item() const;
  [[nodiscard]] ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* release_item();
  ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* mutable_item();
  void set_allocated_item(::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* value);
  void unsafe_arena_set_allocated_item(::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* value);
  ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* unsafe_arena_release_item();

  private:
  const ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement& _internal_item() const;
  ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* _internal_mutable_item();

  public:
  // .substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListSlice slice = 2;
  bool has_slice() const;
  private:
  bool _internal_has_slice() const;

  public:
  void clear_slice() ;
  const ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice& slice() const;
  [[nodiscard]] ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* release_slice();
  ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* mutable_slice();
  void set_allocated_slice(::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* value);
  void unsafe_arena_set_allocated_slice(::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* value);
  ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* unsafe_arena_release_slice();

  private:
  const ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice& _internal_slice() const;
  ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* _internal_mutable_slice();

  public:
  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:substrait.Expression.MaskExpression.ListSelect.ListSelectItem)
 private:
  class _Internal;
  void set_has_item();
  void set_has_slice();
  inline bool has_type() const;
  inline void clear_has_type();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_MaskExpression_ListSelect_ListSelectItem& from_msg);
    union TypeUnion {
      constexpr TypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* item_;
      ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* slice_;
    } type_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_MaskExpression_ListSelect_ListSelectItem_class_data_;
// -------------------------------------------------------------------

class [[deprecated]] Expression_Enum final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.Enum) */ {
 public:
  inline Expression_Enum() : Expression_Enum(nullptr) {}
  ~Expression_Enum() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_Enum* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_Enum));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_Enum(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_Enum(const Expression_Enum& from) : Expression_Enum(nullptr, from) {}
  inline Expression_Enum(Expression_Enum&& from) noexcept
      : Expression_Enum(nullptr, std::move(from)) {}
  inline Expression_Enum& operator=(const Expression_Enum& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_Enum& operator=(Expression_Enum&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_Enum& default_instance() {
    return *reinterpret_cast<const Expression_Enum*>(
        &_Expression_Enum_default_instance_);
  }
  enum EnumKindCase {
    kSpecified = 1,
    kUnspecified = 2,
    ENUM_KIND_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 55;
  friend void swap(Expression_Enum& a, Expression_Enum& b) { a.Swap(&b); }
  inline void Swap(Expression_Enum* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_Enum* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_Enum* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_Enum>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_Enum& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_Enum& from) { Expression_Enum::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_Enum* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.Enum"; }

 protected:
  explicit Expression_Enum(::google::protobuf::Arena* arena);
  Expression_Enum(::google::protobuf::Arena* arena, const Expression_Enum& from);
  Expression_Enum(::google::protobuf::Arena* arena, Expression_Enum&& from) noexcept
      : Expression_Enum(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Empty = Expression_Enum_Empty;

  // accessors -------------------------------------------------------
  enum : int {
    kSpecifiedFieldNumber = 1,
    kUnspecifiedFieldNumber = 2,
  };
  // string specified = 1;
  bool has_specified() const;
  void clear_specified() ;
  const std::string& specified() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_specified(Arg_&& arg, Args_... args);
  std::string* mutable_specified();
  [[nodiscard]] std::string* release_specified();
  void set_allocated_specified(std::string* value);

  private:
  const std::string& _internal_specified() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_specified(const std::string& value);
  std::string* _internal_mutable_specified();

  public:
  // .substrait.Expression.Enum.Empty unspecified = 2;
  bool has_unspecified() const;
  private:
  bool _internal_has_unspecified() const;

  public:
  void clear_unspecified() ;
  const ::substrait::Expression_Enum_Empty& unspecified() const;
  [[nodiscard]] ::substrait::Expression_Enum_Empty* release_unspecified();
  ::substrait::Expression_Enum_Empty* mutable_unspecified();
  void set_allocated_unspecified(::substrait::Expression_Enum_Empty* value);
  void unsafe_arena_set_allocated_unspecified(::substrait::Expression_Enum_Empty* value);
  ::substrait::Expression_Enum_Empty* unsafe_arena_release_unspecified();

  private:
  const ::substrait::Expression_Enum_Empty& _internal_unspecified() const;
  ::substrait::Expression_Enum_Empty* _internal_mutable_unspecified();

  public:
  void clear_enum_kind();
  EnumKindCase enum_kind_case() const;
  // @@protoc_insertion_point(class_scope:substrait.Expression.Enum)
 private:
  class _Internal;
  void set_has_specified();
  void set_has_unspecified();
  inline bool has_enum_kind() const;
  inline void clear_has_enum_kind();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 1,
      43, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_Enum& from_msg);
    union EnumKindUnion {
      constexpr EnumKindUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::internal::ArenaStringPtr specified_;
      ::substrait::Expression_Enum_Empty* unspecified_;
    } enum_kind_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_Enum_class_data_;
// -------------------------------------------------------------------

class ExchangeRel_ExchangeTarget final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.ExchangeRel.ExchangeTarget) */ {
 public:
  inline ExchangeRel_ExchangeTarget() : ExchangeRel_ExchangeTarget(nullptr) {}
  ~ExchangeRel_ExchangeTarget() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ExchangeRel_ExchangeTarget* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ExchangeRel_ExchangeTarget));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ExchangeRel_ExchangeTarget(
      ::google::protobuf::internal::ConstantInitialized);

  inline ExchangeRel_ExchangeTarget(const ExchangeRel_ExchangeTarget& from) : ExchangeRel_ExchangeTarget(nullptr, from) {}
  inline ExchangeRel_ExchangeTarget(ExchangeRel_ExchangeTarget&& from) noexcept
      : ExchangeRel_ExchangeTarget(nullptr, std::move(from)) {}
  inline ExchangeRel_ExchangeTarget& operator=(const ExchangeRel_ExchangeTarget& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExchangeRel_ExchangeTarget& operator=(ExchangeRel_ExchangeTarget&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExchangeRel_ExchangeTarget& default_instance() {
    return *reinterpret_cast<const ExchangeRel_ExchangeTarget*>(
        &_ExchangeRel_ExchangeTarget_default_instance_);
  }
  enum TargetTypeCase {
    kUri = 2,
    kExtended = 3,
    TARGET_TYPE_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 36;
  friend void swap(ExchangeRel_ExchangeTarget& a, ExchangeRel_ExchangeTarget& b) { a.Swap(&b); }
  inline void Swap(ExchangeRel_ExchangeTarget* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExchangeRel_ExchangeTarget* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExchangeRel_ExchangeTarget* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ExchangeRel_ExchangeTarget>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ExchangeRel_ExchangeTarget& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ExchangeRel_ExchangeTarget& from) { ExchangeRel_ExchangeTarget::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ExchangeRel_ExchangeTarget* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.ExchangeRel.ExchangeTarget"; }

 protected:
  explicit ExchangeRel_ExchangeTarget(::google::protobuf::Arena* arena);
  ExchangeRel_ExchangeTarget(::google::protobuf::Arena* arena, const ExchangeRel_ExchangeTarget& from);
  ExchangeRel_ExchangeTarget(::google::protobuf::Arena* arena, ExchangeRel_ExchangeTarget&& from) noexcept
      : ExchangeRel_ExchangeTarget(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPartitionIdFieldNumber = 1,
    kUriFieldNumber = 2,
    kExtendedFieldNumber = 3,
  };
  // repeated int32 partition_id = 1;
  int partition_id_size() const;
  private:
  int _internal_partition_id_size() const;

  public:
  void clear_partition_id() ;
  ::int32_t partition_id(int index) const;
  void set_partition_id(int index, ::int32_t value);
  void add_partition_id(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& partition_id() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_partition_id();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_partition_id() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_partition_id();

  public:
  // string uri = 2;
  bool has_uri() const;
  void clear_uri() ;
  const std::string& uri() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_uri(Arg_&& arg, Args_... args);
  std::string* mutable_uri();
  [[nodiscard]] std::string* release_uri();
  void set_allocated_uri(std::string* value);

  private:
  const std::string& _internal_uri() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();

  public:
  // .google.protobuf.Any extended = 3;
  bool has_extended() const;
  private:
  bool _internal_has_extended() const;

  public:
  void clear_extended() ;
  const ::google::protobuf::Any& extended() const;
  [[nodiscard]] ::google::protobuf::Any* release_extended();
  ::google::protobuf::Any* mutable_extended();
  void set_allocated_extended(::google::protobuf::Any* value);
  void unsafe_arena_set_allocated_extended(::google::protobuf::Any* value);
  ::google::protobuf::Any* unsafe_arena_release_extended();

  private:
  const ::google::protobuf::Any& _internal_extended() const;
  ::google::protobuf::Any* _internal_mutable_extended();

  public:
  void clear_target_type();
  TargetTypeCase target_type_case() const;
  // @@protoc_insertion_point(class_scope:substrait.ExchangeRel.ExchangeTarget)
 private:
  class _Internal;
  void set_has_uri();
  void set_has_extended();
  inline bool has_target_type() const;
  inline void clear_has_target_type();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 3, 1,
      48, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ExchangeRel_ExchangeTarget& from_msg);
    ::google::protobuf::RepeatedField<::int32_t> partition_id_;
    ::google::protobuf::internal::CachedSize _partition_id_cached_byte_size_;
    union TargetTypeUnion {
      constexpr TargetTypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::internal::ArenaStringPtr uri_;
      ::google::protobuf::Any* extended_;
    } target_type_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ExchangeRel_ExchangeTarget_class_data_;
// -------------------------------------------------------------------

class RelCommon_Hint_Stats final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.RelCommon.Hint.Stats) */ {
 public:
  inline RelCommon_Hint_Stats() : RelCommon_Hint_Stats(nullptr) {}
  ~RelCommon_Hint_Stats() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RelCommon_Hint_Stats* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RelCommon_Hint_Stats));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RelCommon_Hint_Stats(
      ::google::protobuf::internal::ConstantInitialized);

  inline RelCommon_Hint_Stats(const RelCommon_Hint_Stats& from) : RelCommon_Hint_Stats(nullptr, from) {}
  inline RelCommon_Hint_Stats(RelCommon_Hint_Stats&& from) noexcept
      : RelCommon_Hint_Stats(nullptr, std::move(from)) {}
  inline RelCommon_Hint_Stats& operator=(const RelCommon_Hint_Stats& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelCommon_Hint_Stats& operator=(RelCommon_Hint_Stats&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RelCommon_Hint_Stats& default_instance() {
    return *reinterpret_cast<const RelCommon_Hint_Stats*>(
        &_RelCommon_Hint_Stats_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(RelCommon_Hint_Stats& a, RelCommon_Hint_Stats& b) { a.Swap(&b); }
  inline void Swap(RelCommon_Hint_Stats* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelCommon_Hint_Stats* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RelCommon_Hint_Stats* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RelCommon_Hint_Stats>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RelCommon_Hint_Stats& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RelCommon_Hint_Stats& from) { RelCommon_Hint_Stats::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RelCommon_Hint_Stats* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.RelCommon.Hint.Stats"; }

 protected:
  explicit RelCommon_Hint_Stats(::google::protobuf::Arena* arena);
  RelCommon_Hint_Stats(::google::protobuf::Arena* arena, const RelCommon_Hint_Stats& from);
  RelCommon_Hint_Stats(::google::protobuf::Arena* arena, RelCommon_Hint_Stats&& from) noexcept
      : RelCommon_Hint_Stats(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAdvancedExtensionFieldNumber = 10,
    kRowCountFieldNumber = 1,
    kRecordSizeFieldNumber = 2,
  };
  // .substrait.extensions.AdvancedExtension advanced_extension = 10;
  bool has_advanced_extension() const;
  void clear_advanced_extension() ;
  const ::substrait::extensions::AdvancedExtension& advanced_extension() const;
  [[nodiscard]] ::substrait::extensions::AdvancedExtension* release_advanced_extension();
  ::substrait::extensions::AdvancedExtension* mutable_advanced_extension();
  void set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value);
  void unsafe_arena_set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value);
  ::substrait::extensions::AdvancedExtension* unsafe_arena_release_advanced_extension();

  private:
  const ::substrait::extensions::AdvancedExtension& _internal_advanced_extension() const;
  ::substrait::extensions::AdvancedExtension* _internal_mutable_advanced_extension();

  public:
  // double row_count = 1;
  void clear_row_count() ;
  double row_count() const;
  void set_row_count(double value);

  private:
  double _internal_row_count() const;
  void _internal_set_row_count(double value);

  public:
  // double record_size = 2;
  void clear_record_size() ;
  double record_size() const;
  void set_record_size(double value);

  private:
  double _internal_record_size() const;
  void _internal_set_record_size(double value);

  public:
  // @@protoc_insertion_point(class_scope:substrait.RelCommon.Hint.Stats)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 3, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RelCommon_Hint_Stats& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::substrait::extensions::AdvancedExtension* advanced_extension_;
    double row_count_;
    double record_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RelCommon_Hint_Stats_class_data_;
// -------------------------------------------------------------------

class RelCommon_Hint_RuntimeConstraint final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.RelCommon.Hint.RuntimeConstraint) */ {
 public:
  inline RelCommon_Hint_RuntimeConstraint() : RelCommon_Hint_RuntimeConstraint(nullptr) {}
  ~RelCommon_Hint_RuntimeConstraint() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RelCommon_Hint_RuntimeConstraint* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RelCommon_Hint_RuntimeConstraint));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RelCommon_Hint_RuntimeConstraint(
      ::google::protobuf::internal::ConstantInitialized);

  inline RelCommon_Hint_RuntimeConstraint(const RelCommon_Hint_RuntimeConstraint& from) : RelCommon_Hint_RuntimeConstraint(nullptr, from) {}
  inline RelCommon_Hint_RuntimeConstraint(RelCommon_Hint_RuntimeConstraint&& from) noexcept
      : RelCommon_Hint_RuntimeConstraint(nullptr, std::move(from)) {}
  inline RelCommon_Hint_RuntimeConstraint& operator=(const RelCommon_Hint_RuntimeConstraint& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelCommon_Hint_RuntimeConstraint& operator=(RelCommon_Hint_RuntimeConstraint&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RelCommon_Hint_RuntimeConstraint& default_instance() {
    return *reinterpret_cast<const RelCommon_Hint_RuntimeConstraint*>(
        &_RelCommon_Hint_RuntimeConstraint_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(RelCommon_Hint_RuntimeConstraint& a, RelCommon_Hint_RuntimeConstraint& b) { a.Swap(&b); }
  inline void Swap(RelCommon_Hint_RuntimeConstraint* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelCommon_Hint_RuntimeConstraint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RelCommon_Hint_RuntimeConstraint* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RelCommon_Hint_RuntimeConstraint>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RelCommon_Hint_RuntimeConstraint& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RelCommon_Hint_RuntimeConstraint& from) { RelCommon_Hint_RuntimeConstraint::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RelCommon_Hint_RuntimeConstraint* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.RelCommon.Hint.RuntimeConstraint"; }

 protected:
  explicit RelCommon_Hint_RuntimeConstraint(::google::protobuf::Arena* arena);
  RelCommon_Hint_RuntimeConstraint(::google::protobuf::Arena* arena, const RelCommon_Hint_RuntimeConstraint& from);
  RelCommon_Hint_RuntimeConstraint(::google::protobuf::Arena* arena, RelCommon_Hint_RuntimeConstraint&& from) noexcept
      : RelCommon_Hint_RuntimeConstraint(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAdvancedExtensionFieldNumber = 10,
  };
  // .substrait.extensions.AdvancedExtension advanced_extension = 10;
  bool has_advanced_extension() const;
  void clear_advanced_extension() ;
  const ::substrait::extensions::AdvancedExtension& advanced_extension() const;
  [[nodiscard]] ::substrait::extensions::AdvancedExtension* release_advanced_extension();
  ::substrait::extensions::AdvancedExtension* mutable_advanced_extension();
  void set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value);
  void unsafe_arena_set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value);
  ::substrait::extensions::AdvancedExtension* unsafe_arena_release_advanced_extension();

  private:
  const ::substrait::extensions::AdvancedExtension& _internal_advanced_extension() const;
  ::substrait::extensions::AdvancedExtension* _internal_mutable_advanced_extension();

  public:
  // @@protoc_insertion_point(class_scope:substrait.RelCommon.Hint.RuntimeConstraint)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RelCommon_Hint_RuntimeConstraint& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::substrait::extensions::AdvancedExtension* advanced_extension_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RelCommon_Hint_RuntimeConstraint_class_data_;
// -------------------------------------------------------------------

class ReadRel_NamedTable final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.ReadRel.NamedTable) */ {
 public:
  inline ReadRel_NamedTable() : ReadRel_NamedTable(nullptr) {}
  ~ReadRel_NamedTable() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReadRel_NamedTable* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReadRel_NamedTable));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReadRel_NamedTable(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReadRel_NamedTable(const ReadRel_NamedTable& from) : ReadRel_NamedTable(nullptr, from) {}
  inline ReadRel_NamedTable(ReadRel_NamedTable&& from) noexcept
      : ReadRel_NamedTable(nullptr, std::move(from)) {}
  inline ReadRel_NamedTable& operator=(const ReadRel_NamedTable& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadRel_NamedTable& operator=(ReadRel_NamedTable&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadRel_NamedTable& default_instance() {
    return *reinterpret_cast<const ReadRel_NamedTable*>(
        &_ReadRel_NamedTable_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(ReadRel_NamedTable& a, ReadRel_NamedTable& b) { a.Swap(&b); }
  inline void Swap(ReadRel_NamedTable* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadRel_NamedTable* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadRel_NamedTable* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReadRel_NamedTable>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReadRel_NamedTable& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReadRel_NamedTable& from) { ReadRel_NamedTable::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReadRel_NamedTable* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.ReadRel.NamedTable"; }

 protected:
  explicit ReadRel_NamedTable(::google::protobuf::Arena* arena);
  ReadRel_NamedTable(::google::protobuf::Arena* arena, const ReadRel_NamedTable& from);
  ReadRel_NamedTable(::google::protobuf::Arena* arena, ReadRel_NamedTable&& from) noexcept
      : ReadRel_NamedTable(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNamesFieldNumber = 1,
    kAdvancedExtensionFieldNumber = 10,
  };
  // repeated string names = 1;
  int names_size() const;
  private:
  int _internal_names_size() const;

  public:
  void clear_names() ;
  const std::string& names(int index) const;
  std::string* mutable_names(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_names(int index, Arg_&& value, Args_... args);
  std::string* add_names();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_names(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& names() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_names();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_names() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_names();

  public:
  // .substrait.extensions.AdvancedExtension advanced_extension = 10;
  bool has_advanced_extension() const;
  void clear_advanced_extension() ;
  const ::substrait::extensions::AdvancedExtension& advanced_extension() const;
  [[nodiscard]] ::substrait::extensions::AdvancedExtension* release_advanced_extension();
  ::substrait::extensions::AdvancedExtension* mutable_advanced_extension();
  void set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value);
  void unsafe_arena_set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value);
  ::substrait::extensions::AdvancedExtension* unsafe_arena_release_advanced_extension();

  private:
  const ::substrait::extensions::AdvancedExtension& _internal_advanced_extension() const;
  ::substrait::extensions::AdvancedExtension* _internal_mutable_advanced_extension();

  public:
  // @@protoc_insertion_point(class_scope:substrait.ReadRel.NamedTable)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      42, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReadRel_NamedTable& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> names_;
    ::substrait::extensions::AdvancedExtension* advanced_extension_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ReadRel_NamedTable_class_data_;
// -------------------------------------------------------------------

class ReadRel_LocalFiles final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.ReadRel.LocalFiles) */ {
 public:
  inline ReadRel_LocalFiles() : ReadRel_LocalFiles(nullptr) {}
  ~ReadRel_LocalFiles() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReadRel_LocalFiles* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReadRel_LocalFiles));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReadRel_LocalFiles(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReadRel_LocalFiles(const ReadRel_LocalFiles& from) : ReadRel_LocalFiles(nullptr, from) {}
  inline ReadRel_LocalFiles(ReadRel_LocalFiles&& from) noexcept
      : ReadRel_LocalFiles(nullptr, std::move(from)) {}
  inline ReadRel_LocalFiles& operator=(const ReadRel_LocalFiles& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadRel_LocalFiles& operator=(ReadRel_LocalFiles&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadRel_LocalFiles& default_instance() {
    return *reinterpret_cast<const ReadRel_LocalFiles*>(
        &_ReadRel_LocalFiles_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(ReadRel_LocalFiles& a, ReadRel_LocalFiles& b) { a.Swap(&b); }
  inline void Swap(ReadRel_LocalFiles* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadRel_LocalFiles* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadRel_LocalFiles* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReadRel_LocalFiles>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReadRel_LocalFiles& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReadRel_LocalFiles& from) { ReadRel_LocalFiles::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReadRel_LocalFiles* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.ReadRel.LocalFiles"; }

 protected:
  explicit ReadRel_LocalFiles(::google::protobuf::Arena* arena);
  ReadRel_LocalFiles(::google::protobuf::Arena* arena, const ReadRel_LocalFiles& from);
  ReadRel_LocalFiles(::google::protobuf::Arena* arena, ReadRel_LocalFiles&& from) noexcept
      : ReadRel_LocalFiles(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using FileOrFiles = ReadRel_LocalFiles_FileOrFiles;

  // accessors -------------------------------------------------------
  enum : int {
    kItemsFieldNumber = 1,
    kAdvancedExtensionFieldNumber = 10,
  };
  // repeated .substrait.ReadRel.LocalFiles.FileOrFiles items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  ::substrait::ReadRel_LocalFiles_FileOrFiles* mutable_items(int index);
  ::google::protobuf::RepeatedPtrField<::substrait::ReadRel_LocalFiles_FileOrFiles>* mutable_items();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::ReadRel_LocalFiles_FileOrFiles>& _internal_items() const;
  ::google::protobuf::RepeatedPtrField<::substrait::ReadRel_LocalFiles_FileOrFiles>* _internal_mutable_items();
  public:
  const ::substrait::ReadRel_LocalFiles_FileOrFiles& items(int index) const;
  ::substrait::ReadRel_LocalFiles_FileOrFiles* add_items();
  const ::google::protobuf::RepeatedPtrField<::substrait::ReadRel_LocalFiles_FileOrFiles>& items() const;
  // .substrait.extensions.AdvancedExtension advanced_extension = 10;
  bool has_advanced_extension() const;
  void clear_advanced_extension() ;
  const ::substrait::extensions::AdvancedExtension& advanced_extension() const;
  [[nodiscard]] ::substrait::extensions::AdvancedExtension* release_advanced_extension();
  ::substrait::extensions::AdvancedExtension* mutable_advanced_extension();
  void set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value);
  void unsafe_arena_set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value);
  ::substrait::extensions::AdvancedExtension* unsafe_arena_release_advanced_extension();

  private:
  const ::substrait::extensions::AdvancedExtension& _internal_advanced_extension() const;
  ::substrait::extensions::AdvancedExtension* _internal_mutable_advanced_extension();

  public:
  // @@protoc_insertion_point(class_scope:substrait.ReadRel.LocalFiles)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReadRel_LocalFiles& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::substrait::ReadRel_LocalFiles_FileOrFiles > items_;
    ::substrait::extensions::AdvancedExtension* advanced_extension_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ReadRel_LocalFiles_class_data_;
// -------------------------------------------------------------------

class NamedObjectWrite final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.NamedObjectWrite) */ {
 public:
  inline NamedObjectWrite() : NamedObjectWrite(nullptr) {}
  ~NamedObjectWrite() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(NamedObjectWrite* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(NamedObjectWrite));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NamedObjectWrite(
      ::google::protobuf::internal::ConstantInitialized);

  inline NamedObjectWrite(const NamedObjectWrite& from) : NamedObjectWrite(nullptr, from) {}
  inline NamedObjectWrite(NamedObjectWrite&& from) noexcept
      : NamedObjectWrite(nullptr, std::move(from)) {}
  inline NamedObjectWrite& operator=(const NamedObjectWrite& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamedObjectWrite& operator=(NamedObjectWrite&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NamedObjectWrite& default_instance() {
    return *reinterpret_cast<const NamedObjectWrite*>(
        &_NamedObjectWrite_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 43;
  friend void swap(NamedObjectWrite& a, NamedObjectWrite& b) { a.Swap(&b); }
  inline void Swap(NamedObjectWrite* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NamedObjectWrite* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NamedObjectWrite* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<NamedObjectWrite>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NamedObjectWrite& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NamedObjectWrite& from) { NamedObjectWrite::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(NamedObjectWrite* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.NamedObjectWrite"; }

 protected:
  explicit NamedObjectWrite(::google::protobuf::Arena* arena);
  NamedObjectWrite(::google::protobuf::Arena* arena, const NamedObjectWrite& from);
  NamedObjectWrite(::google::protobuf::Arena* arena, NamedObjectWrite&& from) noexcept
      : NamedObjectWrite(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNamesFieldNumber = 1,
    kAdvancedExtensionFieldNumber = 10,
  };
  // repeated string names = 1;
  int names_size() const;
  private:
  int _internal_names_size() const;

  public:
  void clear_names() ;
  const std::string& names(int index) const;
  std::string* mutable_names(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_names(int index, Arg_&& value, Args_... args);
  std::string* add_names();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_names(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& names() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_names();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_names() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_names();

  public:
  // .substrait.extensions.AdvancedExtension advanced_extension = 10;
  bool has_advanced_extension() const;
  void clear_advanced_extension() ;
  const ::substrait::extensions::AdvancedExtension& advanced_extension() const;
  [[nodiscard]] ::substrait::extensions::AdvancedExtension* release_advanced_extension();
  ::substrait::extensions::AdvancedExtension* mutable_advanced_extension();
  void set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value);
  void unsafe_arena_set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value);
  ::substrait::extensions::AdvancedExtension* unsafe_arena_release_advanced_extension();

  private:
  const ::substrait::extensions::AdvancedExtension& _internal_advanced_extension() const;
  ::substrait::extensions::AdvancedExtension* _internal_mutable_advanced_extension();

  public:
  // @@protoc_insertion_point(class_scope:substrait.NamedObjectWrite)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      40, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const NamedObjectWrite& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> names_;
    ::substrait::extensions::AdvancedExtension* advanced_extension_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull NamedObjectWrite_class_data_;
// -------------------------------------------------------------------

class Expression_MaskExpression_ListSelect final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.MaskExpression.ListSelect) */ {
 public:
  inline Expression_MaskExpression_ListSelect() : Expression_MaskExpression_ListSelect(nullptr) {}
  ~Expression_MaskExpression_ListSelect() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_MaskExpression_ListSelect* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_MaskExpression_ListSelect));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_MaskExpression_ListSelect(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_MaskExpression_ListSelect(const Expression_MaskExpression_ListSelect& from) : Expression_MaskExpression_ListSelect(nullptr, from) {}
  inline Expression_MaskExpression_ListSelect(Expression_MaskExpression_ListSelect&& from) noexcept
      : Expression_MaskExpression_ListSelect(nullptr, std::move(from)) {}
  inline Expression_MaskExpression_ListSelect& operator=(const Expression_MaskExpression_ListSelect& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_MaskExpression_ListSelect& operator=(Expression_MaskExpression_ListSelect&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_MaskExpression_ListSelect& default_instance() {
    return *reinterpret_cast<const Expression_MaskExpression_ListSelect*>(
        &_Expression_MaskExpression_ListSelect_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 99;
  friend void swap(Expression_MaskExpression_ListSelect& a, Expression_MaskExpression_ListSelect& b) { a.Swap(&b); }
  inline void Swap(Expression_MaskExpression_ListSelect* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_MaskExpression_ListSelect* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_MaskExpression_ListSelect* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_MaskExpression_ListSelect>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_MaskExpression_ListSelect& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_MaskExpression_ListSelect& from) { Expression_MaskExpression_ListSelect::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_MaskExpression_ListSelect* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.MaskExpression.ListSelect"; }

 protected:
  explicit Expression_MaskExpression_ListSelect(::google::protobuf::Arena* arena);
  Expression_MaskExpression_ListSelect(::google::protobuf::Arena* arena, const Expression_MaskExpression_ListSelect& from);
  Expression_MaskExpression_ListSelect(::google::protobuf::Arena* arena, Expression_MaskExpression_ListSelect&& from) noexcept
      : Expression_MaskExpression_ListSelect(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using ListSelectItem = Expression_MaskExpression_ListSelect_ListSelectItem;

  // accessors -------------------------------------------------------
  enum : int {
    kSelectionFieldNumber = 1,
    kChildFieldNumber = 2,
  };
  // repeated .substrait.Expression.MaskExpression.ListSelect.ListSelectItem selection = 1;
  int selection_size() const;
  private:
  int _internal_selection_size() const;

  public:
  void clear_selection() ;
  ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem* mutable_selection(int index);
  ::google::protobuf::RepeatedPtrField<::substrait::Expression_MaskExpression_ListSelect_ListSelectItem>* mutable_selection();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression_MaskExpression_ListSelect_ListSelectItem>& _internal_selection() const;
  ::google::protobuf::RepeatedPtrField<::substrait::Expression_MaskExpression_ListSelect_ListSelectItem>* _internal_mutable_selection();
  public:
  const ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem& selection(int index) const;
  ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem* add_selection();
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression_MaskExpression_ListSelect_ListSelectItem>& selection() const;
  // .substrait.Expression.MaskExpression.Select child = 2;
  bool has_child() const;
  void clear_child() ;
  const ::substrait::Expression_MaskExpression_Select& child() const;
  [[nodiscard]] ::substrait::Expression_MaskExpression_Select* release_child();
  ::substrait::Expression_MaskExpression_Select* mutable_child();
  void set_allocated_child(::substrait::Expression_MaskExpression_Select* value);
  void unsafe_arena_set_allocated_child(::substrait::Expression_MaskExpression_Select* value);
  ::substrait::Expression_MaskExpression_Select* unsafe_arena_release_child();

  private:
  const ::substrait::Expression_MaskExpression_Select& _internal_child() const;
  ::substrait::Expression_MaskExpression_Select* _internal_mutable_child();

  public:
  // @@protoc_insertion_point(class_scope:substrait.Expression.MaskExpression.ListSelect)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_MaskExpression_ListSelect& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem > selection_;
    ::substrait::Expression_MaskExpression_Select* child_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_MaskExpression_ListSelect_class_data_;
// -------------------------------------------------------------------

class Expression_MaskExpression_MapSelect final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.MaskExpression.MapSelect) */ {
 public:
  inline Expression_MaskExpression_MapSelect() : Expression_MaskExpression_MapSelect(nullptr) {}
  ~Expression_MaskExpression_MapSelect() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_MaskExpression_MapSelect* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_MaskExpression_MapSelect));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_MaskExpression_MapSelect(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_MaskExpression_MapSelect(const Expression_MaskExpression_MapSelect& from) : Expression_MaskExpression_MapSelect(nullptr, from) {}
  inline Expression_MaskExpression_MapSelect(Expression_MaskExpression_MapSelect&& from) noexcept
      : Expression_MaskExpression_MapSelect(nullptr, std::move(from)) {}
  inline Expression_MaskExpression_MapSelect& operator=(const Expression_MaskExpression_MapSelect& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_MaskExpression_MapSelect& operator=(Expression_MaskExpression_MapSelect&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_MaskExpression_MapSelect& default_instance() {
    return *reinterpret_cast<const Expression_MaskExpression_MapSelect*>(
        &_Expression_MaskExpression_MapSelect_default_instance_);
  }
  enum SelectCase {
    kKey = 1,
    kExpression = 2,
    SELECT_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 102;
  friend void swap(Expression_MaskExpression_MapSelect& a, Expression_MaskExpression_MapSelect& b) { a.Swap(&b); }
  inline void Swap(Expression_MaskExpression_MapSelect* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_MaskExpression_MapSelect* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_MaskExpression_MapSelect* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_MaskExpression_MapSelect>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_MaskExpression_MapSelect& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_MaskExpression_MapSelect& from) { Expression_MaskExpression_MapSelect::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_MaskExpression_MapSelect* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.MaskExpression.MapSelect"; }

 protected:
  explicit Expression_MaskExpression_MapSelect(::google::protobuf::Arena* arena);
  Expression_MaskExpression_MapSelect(::google::protobuf::Arena* arena, const Expression_MaskExpression_MapSelect& from);
  Expression_MaskExpression_MapSelect(::google::protobuf::Arena* arena, Expression_MaskExpression_MapSelect&& from) noexcept
      : Expression_MaskExpression_MapSelect(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using MapKey = Expression_MaskExpression_MapSelect_MapKey;
  using MapKeyExpression = Expression_MaskExpression_MapSelect_MapKeyExpression;

  // accessors -------------------------------------------------------
  enum : int {
    kChildFieldNumber = 3,
    kKeyFieldNumber = 1,
    kExpressionFieldNumber = 2,
  };
  // .substrait.Expression.MaskExpression.Select child = 3;
  bool has_child() const;
  void clear_child() ;
  const ::substrait::Expression_MaskExpression_Select& child() const;
  [[nodiscard]] ::substrait::Expression_MaskExpression_Select* release_child();
  ::substrait::Expression_MaskExpression_Select* mutable_child();
  void set_allocated_child(::substrait::Expression_MaskExpression_Select* value);
  void unsafe_arena_set_allocated_child(::substrait::Expression_MaskExpression_Select* value);
  ::substrait::Expression_MaskExpression_Select* unsafe_arena_release_child();

  private:
  const ::substrait::Expression_MaskExpression_Select& _internal_child() const;
  ::substrait::Expression_MaskExpression_Select* _internal_mutable_child();

  public:
  // .substrait.Expression.MaskExpression.MapSelect.MapKey key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;

  public:
  void clear_key() ;
  const ::substrait::Expression_MaskExpression_MapSelect_MapKey& key() const;
  [[nodiscard]] ::substrait::Expression_MaskExpression_MapSelect_MapKey* release_key();
  ::substrait::Expression_MaskExpression_MapSelect_MapKey* mutable_key();
  void set_allocated_key(::substrait::Expression_MaskExpression_MapSelect_MapKey* value);
  void unsafe_arena_set_allocated_key(::substrait::Expression_MaskExpression_MapSelect_MapKey* value);
  ::substrait::Expression_MaskExpression_MapSelect_MapKey* unsafe_arena_release_key();

  private:
  const ::substrait::Expression_MaskExpression_MapSelect_MapKey& _internal_key() const;
  ::substrait::Expression_MaskExpression_MapSelect_MapKey* _internal_mutable_key();

  public:
  // .substrait.Expression.MaskExpression.MapSelect.MapKeyExpression expression = 2;
  bool has_expression() const;
  private:
  bool _internal_has_expression() const;

  public:
  void clear_expression() ;
  const ::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression& expression() const;
  [[nodiscard]] ::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression* release_expression();
  ::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression* mutable_expression();
  void set_allocated_expression(::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression* value);
  void unsafe_arena_set_allocated_expression(::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression* value);
  ::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression* unsafe_arena_release_expression();

  private:
  const ::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression& _internal_expression() const;
  ::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression* _internal_mutable_expression();

  public:
  void clear_select();
  SelectCase select_case() const;
  // @@protoc_insertion_point(class_scope:substrait.Expression.MaskExpression.MapSelect)
 private:
  class _Internal;
  void set_has_key();
  void set_has_expression();
  inline bool has_select() const;
  inline void clear_has_select();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 3, 3,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_MaskExpression_MapSelect& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::substrait::Expression_MaskExpression_Select* child_;
    union SelectUnion {
      constexpr SelectUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::substrait::Expression_MaskExpression_MapSelect_MapKey* key_;
      ::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression* expression_;
    } select_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_MaskExpression_MapSelect_class_data_;
// -------------------------------------------------------------------

class Expression_MaskExpression_Select final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.MaskExpression.Select) */ {
 public:
  inline Expression_MaskExpression_Select() : Expression_MaskExpression_Select(nullptr) {}
  ~Expression_MaskExpression_Select() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_MaskExpression_Select* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_MaskExpression_Select));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_MaskExpression_Select(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_MaskExpression_Select(const Expression_MaskExpression_Select& from) : Expression_MaskExpression_Select(nullptr, from) {}
  inline Expression_MaskExpression_Select(Expression_MaskExpression_Select&& from) noexcept
      : Expression_MaskExpression_Select(nullptr, std::move(from)) {}
  inline Expression_MaskExpression_Select& operator=(const Expression_MaskExpression_Select& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_MaskExpression_Select& operator=(Expression_MaskExpression_Select&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_MaskExpression_Select& default_instance() {
    return *reinterpret_cast<const Expression_MaskExpression_Select*>(
        &_Expression_MaskExpression_Select_default_instance_);
  }
  enum TypeCase {
    kStruct = 1,
    kList = 2,
    kMap = 3,
    TYPE_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 93;
  friend void swap(Expression_MaskExpression_Select& a, Expression_MaskExpression_Select& b) { a.Swap(&b); }
  inline void Swap(Expression_MaskExpression_Select* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_MaskExpression_Select* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_MaskExpression_Select* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_MaskExpression_Select>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_MaskExpression_Select& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_MaskExpression_Select& from) { Expression_MaskExpression_Select::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_MaskExpression_Select* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.MaskExpression.Select"; }

 protected:
  explicit Expression_MaskExpression_Select(::google::protobuf::Arena* arena);
  Expression_MaskExpression_Select(::google::protobuf::Arena* arena, const Expression_MaskExpression_Select& from);
  Expression_MaskExpression_Select(::google::protobuf::Arena* arena, Expression_MaskExpression_Select&& from) noexcept
      : Expression_MaskExpression_Select(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStructFieldNumber = 1,
    kListFieldNumber = 2,
    kMapFieldNumber = 3,
  };
  // .substrait.Expression.MaskExpression.StructSelect struct = 1;
  bool has_struct_() const;
  private:
  bool _internal_has_struct_() const;

  public:
  void clear_struct_() ;
  const ::substrait::Expression_MaskExpression_StructSelect& struct_() const;
  [[nodiscard]] ::substrait::Expression_MaskExpression_StructSelect* release_struct_();
  ::substrait::Expression_MaskExpression_StructSelect* mutable_struct_();
  void set_allocated_struct_(::substrait::Expression_MaskExpression_StructSelect* value);
  void unsafe_arena_set_allocated_struct_(::substrait::Expression_MaskExpression_StructSelect* value);
  ::substrait::Expression_MaskExpression_StructSelect* unsafe_arena_release_struct_();

  private:
  const ::substrait::Expression_MaskExpression_StructSelect& _internal_struct_() const;
  ::substrait::Expression_MaskExpression_StructSelect* _internal_mutable_struct_();

  public:
  // .substrait.Expression.MaskExpression.ListSelect list = 2;
  bool has_list() const;
  private:
  bool _internal_has_list() const;

  public:
  void clear_list() ;
  const ::substrait::Expression_MaskExpression_ListSelect& list() const;
  [[nodiscard]] ::substrait::Expression_MaskExpression_ListSelect* release_list();
  ::substrait::Expression_MaskExpression_ListSelect* mutable_list();
  void set_allocated_list(::substrait::Expression_MaskExpression_ListSelect* value);
  void unsafe_arena_set_allocated_list(::substrait::Expression_MaskExpression_ListSelect* value);
  ::substrait::Expression_MaskExpression_ListSelect* unsafe_arena_release_list();

  private:
  const ::substrait::Expression_MaskExpression_ListSelect& _internal_list() const;
  ::substrait::Expression_MaskExpression_ListSelect* _internal_mutable_list();

  public:
  // .substrait.Expression.MaskExpression.MapSelect map = 3;
  bool has_map() const;
  private:
  bool _internal_has_map() const;

  public:
  void clear_map() ;
  const ::substrait::Expression_MaskExpression_MapSelect& map() const;
  [[nodiscard]] ::substrait::Expression_MaskExpression_MapSelect* release_map();
  ::substrait::Expression_MaskExpression_MapSelect* mutable_map();
  void set_allocated_map(::substrait::Expression_MaskExpression_MapSelect* value);
  void unsafe_arena_set_allocated_map(::substrait::Expression_MaskExpression_MapSelect* value);
  ::substrait::Expression_MaskExpression_MapSelect* unsafe_arena_release_map();

  private:
  const ::substrait::Expression_MaskExpression_MapSelect& _internal_map() const;
  ::substrait::Expression_MaskExpression_MapSelect* _internal_mutable_map();

  public:
  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:substrait.Expression.MaskExpression.Select)
 private:
  class _Internal;
  void set_has_struct_();
  void set_has_list();
  void set_has_map();
  inline bool has_type() const;
  inline void clear_has_type();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 3, 3,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_MaskExpression_Select& from_msg);
    union TypeUnion {
      constexpr TypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::substrait::Expression_MaskExpression_StructSelect* struct__;
      ::substrait::Expression_MaskExpression_ListSelect* list_;
      ::substrait::Expression_MaskExpression_MapSelect* map_;
    } type_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_MaskExpression_Select_class_data_;
// -------------------------------------------------------------------

class Expression_MaskExpression_StructItem final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.MaskExpression.StructItem) */ {
 public:
  inline Expression_MaskExpression_StructItem() : Expression_MaskExpression_StructItem(nullptr) {}
  ~Expression_MaskExpression_StructItem() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_MaskExpression_StructItem* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_MaskExpression_StructItem));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_MaskExpression_StructItem(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_MaskExpression_StructItem(const Expression_MaskExpression_StructItem& from) : Expression_MaskExpression_StructItem(nullptr, from) {}
  inline Expression_MaskExpression_StructItem(Expression_MaskExpression_StructItem&& from) noexcept
      : Expression_MaskExpression_StructItem(nullptr, std::move(from)) {}
  inline Expression_MaskExpression_StructItem& operator=(const Expression_MaskExpression_StructItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_MaskExpression_StructItem& operator=(Expression_MaskExpression_StructItem&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_MaskExpression_StructItem& default_instance() {
    return *reinterpret_cast<const Expression_MaskExpression_StructItem*>(
        &_Expression_MaskExpression_StructItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 95;
  friend void swap(Expression_MaskExpression_StructItem& a, Expression_MaskExpression_StructItem& b) { a.Swap(&b); }
  inline void Swap(Expression_MaskExpression_StructItem* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_MaskExpression_StructItem* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_MaskExpression_StructItem* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_MaskExpression_StructItem>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_MaskExpression_StructItem& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_MaskExpression_StructItem& from) { Expression_MaskExpression_StructItem::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_MaskExpression_StructItem* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.MaskExpression.StructItem"; }

 protected:
  explicit Expression_MaskExpression_StructItem(::google::protobuf::Arena* arena);
  Expression_MaskExpression_StructItem(::google::protobuf::Arena* arena, const Expression_MaskExpression_StructItem& from);
  Expression_MaskExpression_StructItem(::google::protobuf::Arena* arena, Expression_MaskExpression_StructItem&& from) noexcept
      : Expression_MaskExpression_StructItem(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kChildFieldNumber = 2,
    kFieldFieldNumber = 1,
  };
  // .substrait.Expression.MaskExpression.Select child = 2;
  bool has_child() const;
  void clear_child() ;
  const ::substrait::Expression_MaskExpression_Select& child() const;
  [[nodiscard]] ::substrait::Expression_MaskExpression_Select* release_child();
  ::substrait::Expression_MaskExpression_Select* mutable_child();
  void set_allocated_child(::substrait::Expression_MaskExpression_Select* value);
  void unsafe_arena_set_allocated_child(::substrait::Expression_MaskExpression_Select* value);
  ::substrait::Expression_MaskExpression_Select* unsafe_arena_release_child();

  private:
  const ::substrait::Expression_MaskExpression_Select& _internal_child() const;
  ::substrait::Expression_MaskExpression_Select* _internal_mutable_child();

  public:
  // int32 field = 1;
  void clear_field() ;
  ::int32_t field() const;
  void set_field(::int32_t value);

  private:
  ::int32_t _internal_field() const;
  void _internal_set_field(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:substrait.Expression.MaskExpression.StructItem)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_MaskExpression_StructItem& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::substrait::Expression_MaskExpression_Select* child_;
    ::int32_t field_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_MaskExpression_StructItem_class_data_;
// -------------------------------------------------------------------

class Expression_MaskExpression_StructSelect final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.MaskExpression.StructSelect) */ {
 public:
  inline Expression_MaskExpression_StructSelect() : Expression_MaskExpression_StructSelect(nullptr) {}
  ~Expression_MaskExpression_StructSelect() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_MaskExpression_StructSelect* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_MaskExpression_StructSelect));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_MaskExpression_StructSelect(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_MaskExpression_StructSelect(const Expression_MaskExpression_StructSelect& from) : Expression_MaskExpression_StructSelect(nullptr, from) {}
  inline Expression_MaskExpression_StructSelect(Expression_MaskExpression_StructSelect&& from) noexcept
      : Expression_MaskExpression_StructSelect(nullptr, std::move(from)) {}
  inline Expression_MaskExpression_StructSelect& operator=(const Expression_MaskExpression_StructSelect& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_MaskExpression_StructSelect& operator=(Expression_MaskExpression_StructSelect&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_MaskExpression_StructSelect& default_instance() {
    return *reinterpret_cast<const Expression_MaskExpression_StructSelect*>(
        &_Expression_MaskExpression_StructSelect_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 94;
  friend void swap(Expression_MaskExpression_StructSelect& a, Expression_MaskExpression_StructSelect& b) { a.Swap(&b); }
  inline void Swap(Expression_MaskExpression_StructSelect* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_MaskExpression_StructSelect* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_MaskExpression_StructSelect* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_MaskExpression_StructSelect>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_MaskExpression_StructSelect& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_MaskExpression_StructSelect& from) { Expression_MaskExpression_StructSelect::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_MaskExpression_StructSelect* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.MaskExpression.StructSelect"; }

 protected:
  explicit Expression_MaskExpression_StructSelect(::google::protobuf::Arena* arena);
  Expression_MaskExpression_StructSelect(::google::protobuf::Arena* arena, const Expression_MaskExpression_StructSelect& from);
  Expression_MaskExpression_StructSelect(::google::protobuf::Arena* arena, Expression_MaskExpression_StructSelect&& from) noexcept
      : Expression_MaskExpression_StructSelect(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStructItemsFieldNumber = 1,
  };
  // repeated .substrait.Expression.MaskExpression.StructItem struct_items = 1;
  int struct_items_size() const;
  private:
  int _internal_struct_items_size() const;

  public:
  void clear_struct_items() ;
  ::substrait::Expression_MaskExpression_StructItem* mutable_struct_items(int index);
  ::google::protobuf::RepeatedPtrField<::substrait::Expression_MaskExpression_StructItem>* mutable_struct_items();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression_MaskExpression_StructItem>& _internal_struct_items() const;
  ::google::protobuf::RepeatedPtrField<::substrait::Expression_MaskExpression_StructItem>* _internal_mutable_struct_items();
  public:
  const ::substrait::Expression_MaskExpression_StructItem& struct_items(int index) const;
  ::substrait::Expression_MaskExpression_StructItem* add_struct_items();
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression_MaskExpression_StructItem>& struct_items() const;
  // @@protoc_insertion_point(class_scope:substrait.Expression.MaskExpression.StructSelect)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_MaskExpression_StructSelect& from_msg);
    ::google::protobuf::RepeatedPtrField< ::substrait::Expression_MaskExpression_StructItem > struct_items_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_MaskExpression_StructSelect_class_data_;
// -------------------------------------------------------------------

class Expression_Literal_UserDefined final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.Literal.UserDefined) */ {
 public:
  inline Expression_Literal_UserDefined() : Expression_Literal_UserDefined(nullptr) {}
  ~Expression_Literal_UserDefined() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_Literal_UserDefined* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_Literal_UserDefined));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_Literal_UserDefined(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_Literal_UserDefined(const Expression_Literal_UserDefined& from) : Expression_Literal_UserDefined(nullptr, from) {}
  inline Expression_Literal_UserDefined(Expression_Literal_UserDefined&& from) noexcept
      : Expression_Literal_UserDefined(nullptr, std::move(from)) {}
  inline Expression_Literal_UserDefined& operator=(const Expression_Literal_UserDefined& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_Literal_UserDefined& operator=(Expression_Literal_UserDefined&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_Literal_UserDefined& default_instance() {
    return *reinterpret_cast<const Expression_Literal_UserDefined*>(
        &_Expression_Literal_UserDefined_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 64;
  friend void swap(Expression_Literal_UserDefined& a, Expression_Literal_UserDefined& b) { a.Swap(&b); }
  inline void Swap(Expression_Literal_UserDefined* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_Literal_UserDefined* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_Literal_UserDefined* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_Literal_UserDefined>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_Literal_UserDefined& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_Literal_UserDefined& from) { Expression_Literal_UserDefined::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_Literal_UserDefined* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.Literal.UserDefined"; }

 protected:
  explicit Expression_Literal_UserDefined(::google::protobuf::Arena* arena);
  Expression_Literal_UserDefined(::google::protobuf::Arena* arena, const Expression_Literal_UserDefined& from);
  Expression_Literal_UserDefined(::google::protobuf::Arena* arena, Expression_Literal_UserDefined&& from) noexcept
      : Expression_Literal_UserDefined(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTypeParametersFieldNumber = 3,
    kValueFieldNumber = 2,
    kTypeReferenceFieldNumber = 1,
  };
  // repeated .substrait.Type.Parameter type_parameters = 3;
  int type_parameters_size() const;
  private:
  int _internal_type_parameters_size() const;

  public:
  void clear_type_parameters() ;
  ::substrait::Type_Parameter* mutable_type_parameters(int index);
  ::google::protobuf::RepeatedPtrField<::substrait::Type_Parameter>* mutable_type_parameters();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::Type_Parameter>& _internal_type_parameters() const;
  ::google::protobuf::RepeatedPtrField<::substrait::Type_Parameter>* _internal_mutable_type_parameters();
  public:
  const ::substrait::Type_Parameter& type_parameters(int index) const;
  ::substrait::Type_Parameter* add_type_parameters();
  const ::google::protobuf::RepeatedPtrField<::substrait::Type_Parameter>& type_parameters() const;
  // .google.protobuf.Any value = 2;
  bool has_value() const;
  void clear_value() ;
  const ::google::protobuf::Any& value() const;
  [[nodiscard]] ::google::protobuf::Any* release_value();
  ::google::protobuf::Any* mutable_value();
  void set_allocated_value(::google::protobuf::Any* value);
  void unsafe_arena_set_allocated_value(::google::protobuf::Any* value);
  ::google::protobuf::Any* unsafe_arena_release_value();

  private:
  const ::google::protobuf::Any& _internal_value() const;
  ::google::protobuf::Any* _internal_mutable_value();

  public:
  // uint32 type_reference = 1;
  void clear_type_reference() ;
  ::uint32_t type_reference() const;
  void set_type_reference(::uint32_t value);

  private:
  ::uint32_t _internal_type_reference() const;
  void _internal_set_type_reference(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:substrait.Expression.Literal.UserDefined)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_Literal_UserDefined& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::substrait::Type_Parameter > type_parameters_;
    ::google::protobuf::Any* value_;
    ::uint32_t type_reference_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_Literal_UserDefined_class_data_;
// -------------------------------------------------------------------

class RelCommon_Hint final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.RelCommon.Hint) */ {
 public:
  inline RelCommon_Hint() : RelCommon_Hint(nullptr) {}
  ~RelCommon_Hint() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RelCommon_Hint* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RelCommon_Hint));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RelCommon_Hint(
      ::google::protobuf::internal::ConstantInitialized);

  inline RelCommon_Hint(const RelCommon_Hint& from) : RelCommon_Hint(nullptr, from) {}
  inline RelCommon_Hint(RelCommon_Hint&& from) noexcept
      : RelCommon_Hint(nullptr, std::move(from)) {}
  inline RelCommon_Hint& operator=(const RelCommon_Hint& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelCommon_Hint& operator=(RelCommon_Hint&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RelCommon_Hint& default_instance() {
    return *reinterpret_cast<const RelCommon_Hint*>(
        &_RelCommon_Hint_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(RelCommon_Hint& a, RelCommon_Hint& b) { a.Swap(&b); }
  inline void Swap(RelCommon_Hint* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelCommon_Hint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RelCommon_Hint* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RelCommon_Hint>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RelCommon_Hint& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RelCommon_Hint& from) { RelCommon_Hint::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RelCommon_Hint* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.RelCommon.Hint"; }

 protected:
  explicit RelCommon_Hint(::google::protobuf::Arena* arena);
  RelCommon_Hint(::google::protobuf::Arena* arena, const RelCommon_Hint& from);
  RelCommon_Hint(::google::protobuf::Arena* arena, RelCommon_Hint&& from) noexcept
      : RelCommon_Hint(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Stats = RelCommon_Hint_Stats;
  using RuntimeConstraint = RelCommon_Hint_RuntimeConstraint;

  // accessors -------------------------------------------------------
  enum : int {
    kStatsFieldNumber = 1,
    kConstraintFieldNumber = 2,
    kAdvancedExtensionFieldNumber = 10,
  };
  // .substrait.RelCommon.Hint.Stats stats = 1;
  bool has_stats() const;
  void clear_stats() ;
  const ::substrait::RelCommon_Hint_Stats& stats() const;
  [[nodiscard]] ::substrait::RelCommon_Hint_Stats* release_stats();
  ::substrait::RelCommon_Hint_Stats* mutable_stats();
  void set_allocated_stats(::substrait::RelCommon_Hint_Stats* value);
  void unsafe_arena_set_allocated_stats(::substrait::RelCommon_Hint_Stats* value);
  ::substrait::RelCommon_Hint_Stats* unsafe_arena_release_stats();

  private:
  const ::substrait::RelCommon_Hint_Stats& _internal_stats() const;
  ::substrait::RelCommon_Hint_Stats* _internal_mutable_stats();

  public:
  // .substrait.RelCommon.Hint.RuntimeConstraint constraint = 2;
  bool has_constraint() const;
  void clear_constraint() ;
  const ::substrait::RelCommon_Hint_RuntimeConstraint& constraint() const;
  [[nodiscard]] ::substrait::RelCommon_Hint_RuntimeConstraint* release_constraint();
  ::substrait::RelCommon_Hint_RuntimeConstraint* mutable_constraint();
  void set_allocated_constraint(::substrait::RelCommon_Hint_RuntimeConstraint* value);
  void unsafe_arena_set_allocated_constraint(::substrait::RelCommon_Hint_RuntimeConstraint* value);
  ::substrait::RelCommon_Hint_RuntimeConstraint* unsafe_arena_release_constraint();

  private:
  const ::substrait::RelCommon_Hint_RuntimeConstraint& _internal_constraint() const;
  ::substrait::RelCommon_Hint_RuntimeConstraint* _internal_mutable_constraint();

  public:
  // .substrait.extensions.AdvancedExtension advanced_extension = 10;
  bool has_advanced_extension() const;
  void clear_advanced_extension() ;
  const ::substrait::extensions::AdvancedExtension& advanced_extension() const;
  [[nodiscard]] ::substrait::extensions::AdvancedExtension* release_advanced_extension();
  ::substrait::extensions::AdvancedExtension* mutable_advanced_extension();
  void set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value);
  void unsafe_arena_set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value);
  ::substrait::extensions::AdvancedExtension* unsafe_arena_release_advanced_extension();

  private:
  const ::substrait::extensions::AdvancedExtension& _internal_advanced_extension() const;
  ::substrait::extensions::AdvancedExtension* _internal_mutable_advanced_extension();

  public:
  // @@protoc_insertion_point(class_scope:substrait.RelCommon.Hint)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 3, 3,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RelCommon_Hint& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::substrait::RelCommon_Hint_Stats* stats_;
    ::substrait::RelCommon_Hint_RuntimeConstraint* constraint_;
    ::substrait::extensions::AdvancedExtension* advanced_extension_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RelCommon_Hint_class_data_;
// -------------------------------------------------------------------

class Expression_MaskExpression final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.MaskExpression) */ {
 public:
  inline Expression_MaskExpression() : Expression_MaskExpression(nullptr) {}
  ~Expression_MaskExpression() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_MaskExpression* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_MaskExpression));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_MaskExpression(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_MaskExpression(const Expression_MaskExpression& from) : Expression_MaskExpression(nullptr, from) {}
  inline Expression_MaskExpression(Expression_MaskExpression&& from) noexcept
      : Expression_MaskExpression(nullptr, std::move(from)) {}
  inline Expression_MaskExpression& operator=(const Expression_MaskExpression& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_MaskExpression& operator=(Expression_MaskExpression&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_MaskExpression& default_instance() {
    return *reinterpret_cast<const Expression_MaskExpression*>(
        &_Expression_MaskExpression_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 103;
  friend void swap(Expression_MaskExpression& a, Expression_MaskExpression& b) { a.Swap(&b); }
  inline void Swap(Expression_MaskExpression* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_MaskExpression* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_MaskExpression* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_MaskExpression>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_MaskExpression& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_MaskExpression& from) { Expression_MaskExpression::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_MaskExpression* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.MaskExpression"; }

 protected:
  explicit Expression_MaskExpression(::google::protobuf::Arena* arena);
  Expression_MaskExpression(::google::protobuf::Arena* arena, const Expression_MaskExpression& from);
  Expression_MaskExpression(::google::protobuf::Arena* arena, Expression_MaskExpression&& from) noexcept
      : Expression_MaskExpression(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Select = Expression_MaskExpression_Select;
  using StructSelect = Expression_MaskExpression_StructSelect;
  using StructItem = Expression_MaskExpression_StructItem;
  using ListSelect = Expression_MaskExpression_ListSelect;
  using MapSelect = Expression_MaskExpression_MapSelect;

  // accessors -------------------------------------------------------
  enum : int {
    kSelectFieldNumber = 1,
    kMaintainSingularStructFieldNumber = 2,
  };
  // .substrait.Expression.MaskExpression.StructSelect select = 1;
  bool has_select() const;
  void clear_select() ;
  const ::substrait::Expression_MaskExpression_StructSelect& select() const;
  [[nodiscard]] ::substrait::Expression_MaskExpression_StructSelect* release_select();
  ::substrait::Expression_MaskExpression_StructSelect* mutable_select();
  void set_allocated_select(::substrait::Expression_MaskExpression_StructSelect* value);
  void unsafe_arena_set_allocated_select(::substrait::Expression_MaskExpression_StructSelect* value);
  ::substrait::Expression_MaskExpression_StructSelect* unsafe_arena_release_select();

  private:
  const ::substrait::Expression_MaskExpression_StructSelect& _internal_select() const;
  ::substrait::Expression_MaskExpression_StructSelect* _internal_mutable_select();

  public:
  // bool maintain_singular_struct = 2;
  void clear_maintain_singular_struct() ;
  bool maintain_singular_struct() const;
  void set_maintain_singular_struct(bool value);

  private:
  bool _internal_maintain_singular_struct() const;
  void _internal_set_maintain_singular_struct(bool value);

  public:
  // @@protoc_insertion_point(class_scope:substrait.Expression.MaskExpression)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_MaskExpression& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::substrait::Expression_MaskExpression_StructSelect* select_;
    bool maintain_singular_struct_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_MaskExpression_class_data_;
// -------------------------------------------------------------------

class Expression_Literal final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.Literal) */ {
 public:
  inline Expression_Literal() : Expression_Literal(nullptr) {}
  ~Expression_Literal() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_Literal* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_Literal));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_Literal(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_Literal(const Expression_Literal& from) : Expression_Literal(nullptr, from) {}
  inline Expression_Literal(Expression_Literal&& from) noexcept
      : Expression_Literal(nullptr, std::move(from)) {}
  inline Expression_Literal& operator=(const Expression_Literal& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_Literal& operator=(Expression_Literal&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_Literal& default_instance() {
    return *reinterpret_cast<const Expression_Literal*>(
        &_Expression_Literal_default_instance_);
  }
  enum LiteralTypeCase {
    kBoolean = 1,
    kI8 = 2,
    kI16 = 3,
    kI32 = 5,
    kI64 = 7,
    kFp32 = 10,
    kFp64 = 11,
    kString = 12,
    kBinary = 13,
    kTimestamp = 14,
    kDate = 16,
    kTime = 17,
    kIntervalYearToMonth = 19,
    kIntervalDayToSecond = 20,
    kFixedChar = 21,
    kVarChar = 22,
    kFixedBinary = 23,
    kDecimal = 24,
    kPrecisionTimestamp = 34,
    kPrecisionTimestampTz = 35,
    kStruct = 25,
    kMap = 26,
    kTimestampTz = 27,
    kUuid = 28,
    kNull = 29,
    kList = 30,
    kEmptyList = 31,
    kEmptyMap = 32,
    kUserDefined = 33,
    LITERAL_TYPE_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 65;
  friend void swap(Expression_Literal& a, Expression_Literal& b) { a.Swap(&b); }
  inline void Swap(Expression_Literal* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_Literal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_Literal* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_Literal>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_Literal& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_Literal& from) { Expression_Literal::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_Literal* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.Literal"; }

 protected:
  explicit Expression_Literal(::google::protobuf::Arena* arena);
  Expression_Literal(::google::protobuf::Arena* arena, const Expression_Literal& from);
  Expression_Literal(::google::protobuf::Arena* arena, Expression_Literal&& from) noexcept
      : Expression_Literal(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using VarChar = Expression_Literal_VarChar;
  using Decimal = Expression_Literal_Decimal;
  using Map = Expression_Literal_Map;
  using IntervalYearToMonth = Expression_Literal_IntervalYearToMonth;
  using IntervalDayToSecond = Expression_Literal_IntervalDayToSecond;
  using Struct = Expression_Literal_Struct;
  using List = Expression_Literal_List;
  using UserDefined = Expression_Literal_UserDefined;

  // accessors -------------------------------------------------------
  enum : int {
    kNullableFieldNumber = 50,
    kTypeVariationReferenceFieldNumber = 51,
    kBooleanFieldNumber = 1,
    kI8FieldNumber = 2,
    kI16FieldNumber = 3,
    kI32FieldNumber = 5,
    kI64FieldNumber = 7,
    kFp32FieldNumber = 10,
    kFp64FieldNumber = 11,
    kStringFieldNumber = 12,
    kBinaryFieldNumber = 13,
    kTimestampFieldNumber = 14,
    kDateFieldNumber = 16,
    kTimeFieldNumber = 17,
    kIntervalYearToMonthFieldNumber = 19,
    kIntervalDayToSecondFieldNumber = 20,
    kFixedCharFieldNumber = 21,
    kVarCharFieldNumber = 22,
    kFixedBinaryFieldNumber = 23,
    kDecimalFieldNumber = 24,
    kPrecisionTimestampFieldNumber = 34,
    kPrecisionTimestampTzFieldNumber = 35,
    kStructFieldNumber = 25,
    kMapFieldNumber = 26,
    kTimestampTzFieldNumber = 27,
    kUuidFieldNumber = 28,
    kNullFieldNumber = 29,
    kListFieldNumber = 30,
    kEmptyListFieldNumber = 31,
    kEmptyMapFieldNumber = 32,
    kUserDefinedFieldNumber = 33,
  };
  // bool nullable = 50;
  void clear_nullable() ;
  bool nullable() const;
  void set_nullable(bool value);

  private:
  bool _internal_nullable() const;
  void _internal_set_nullable(bool value);

  public:
  // uint32 type_variation_reference = 51;
  void clear_type_variation_reference() ;
  ::uint32_t type_variation_reference() const;
  void set_type_variation_reference(::uint32_t value);

  private:
  ::uint32_t _internal_type_variation_reference() const;
  void _internal_set_type_variation_reference(::uint32_t value);

  public:
  // bool boolean = 1;
  bool has_boolean() const;
  void clear_boolean() ;
  bool boolean() const;
  void set_boolean(bool value);

  private:
  bool _internal_boolean() const;
  void _internal_set_boolean(bool value);

  public:
  // int32 i8 = 2;
  bool has_i8() const;
  void clear_i8() ;
  ::int32_t i8() const;
  void set_i8(::int32_t value);

  private:
  ::int32_t _internal_i8() const;
  void _internal_set_i8(::int32_t value);

  public:
  // int32 i16 = 3;
  bool has_i16() const;
  void clear_i16() ;
  ::int32_t i16() const;
  void set_i16(::int32_t value);

  private:
  ::int32_t _internal_i16() const;
  void _internal_set_i16(::int32_t value);

  public:
  // int32 i32 = 5;
  bool has_i32() const;
  void clear_i32() ;
  ::int32_t i32() const;
  void set_i32(::int32_t value);

  private:
  ::int32_t _internal_i32() const;
  void _internal_set_i32(::int32_t value);

  public:
  // int64 i64 = 7;
  bool has_i64() const;
  void clear_i64() ;
  ::int64_t i64() const;
  void set_i64(::int64_t value);

  private:
  ::int64_t _internal_i64() const;
  void _internal_set_i64(::int64_t value);

  public:
  // float fp32 = 10;
  bool has_fp32() const;
  void clear_fp32() ;
  float fp32() const;
  void set_fp32(float value);

  private:
  float _internal_fp32() const;
  void _internal_set_fp32(float value);

  public:
  // double fp64 = 11;
  bool has_fp64() const;
  void clear_fp64() ;
  double fp64() const;
  void set_fp64(double value);

  private:
  double _internal_fp64() const;
  void _internal_set_fp64(double value);

  public:
  // string string = 12;
  bool has_string() const;
  void clear_string() ;
  const std::string& string() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_string(Arg_&& arg, Args_... args);
  std::string* mutable_string();
  [[nodiscard]] std::string* release_string();
  void set_allocated_string(std::string* value);

  private:
  const std::string& _internal_string() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_string(const std::string& value);
  std::string* _internal_mutable_string();

  public:
  // bytes binary = 13;
  bool has_binary() const;
  void clear_binary() ;
  const std::string& binary() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_binary(Arg_&& arg, Args_... args);
  std::string* mutable_binary();
  [[nodiscard]] std::string* release_binary();
  void set_allocated_binary(std::string* value);

  private:
  const std::string& _internal_binary() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_binary(const std::string& value);
  std::string* _internal_mutable_binary();

  public:
  // int64 timestamp = 14 [deprecated = true];
  [[deprecated]]  bool has_timestamp() const;
  [[deprecated]]  void clear_timestamp() ;
  [[deprecated]] ::int64_t timestamp() const;
  [[deprecated]] void set_timestamp(::int64_t value);

  private:
  ::int64_t _internal_timestamp() const;
  void _internal_set_timestamp(::int64_t value);

  public:
  // int32 date = 16;
  bool has_date() const;
  void clear_date() ;
  ::int32_t date() const;
  void set_date(::int32_t value);

  private:
  ::int32_t _internal_date() const;
  void _internal_set_date(::int32_t value);

  public:
  // int64 time = 17;
  bool has_time() const;
  void clear_time() ;
  ::int64_t time() const;
  void set_time(::int64_t value);

  private:
  ::int64_t _internal_time() const;
  void _internal_set_time(::int64_t value);

  public:
  // .substrait.Expression.Literal.IntervalYearToMonth interval_year_to_month = 19;
  bool has_interval_year_to_month() const;
  private:
  bool _internal_has_interval_year_to_month() const;

  public:
  void clear_interval_year_to_month() ;
  const ::substrait::Expression_Literal_IntervalYearToMonth& interval_year_to_month() const;
  [[nodiscard]] ::substrait::Expression_Literal_IntervalYearToMonth* release_interval_year_to_month();
  ::substrait::Expression_Literal_IntervalYearToMonth* mutable_interval_year_to_month();
  void set_allocated_interval_year_to_month(::substrait::Expression_Literal_IntervalYearToMonth* value);
  void unsafe_arena_set_allocated_interval_year_to_month(::substrait::Expression_Literal_IntervalYearToMonth* value);
  ::substrait::Expression_Literal_IntervalYearToMonth* unsafe_arena_release_interval_year_to_month();

  private:
  const ::substrait::Expression_Literal_IntervalYearToMonth& _internal_interval_year_to_month() const;
  ::substrait::Expression_Literal_IntervalYearToMonth* _internal_mutable_interval_year_to_month();

  public:
  // .substrait.Expression.Literal.IntervalDayToSecond interval_day_to_second = 20;
  bool has_interval_day_to_second() const;
  private:
  bool _internal_has_interval_day_to_second() const;

  public:
  void clear_interval_day_to_second() ;
  const ::substrait::Expression_Literal_IntervalDayToSecond& interval_day_to_second() const;
  [[nodiscard]] ::substrait::Expression_Literal_IntervalDayToSecond* release_interval_day_to_second();
  ::substrait::Expression_Literal_IntervalDayToSecond* mutable_interval_day_to_second();
  void set_allocated_interval_day_to_second(::substrait::Expression_Literal_IntervalDayToSecond* value);
  void unsafe_arena_set_allocated_interval_day_to_second(::substrait::Expression_Literal_IntervalDayToSecond* value);
  ::substrait::Expression_Literal_IntervalDayToSecond* unsafe_arena_release_interval_day_to_second();

  private:
  const ::substrait::Expression_Literal_IntervalDayToSecond& _internal_interval_day_to_second() const;
  ::substrait::Expression_Literal_IntervalDayToSecond* _internal_mutable_interval_day_to_second();

  public:
  // string fixed_char = 21;
  bool has_fixed_char() const;
  void clear_fixed_char() ;
  const std::string& fixed_char() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fixed_char(Arg_&& arg, Args_... args);
  std::string* mutable_fixed_char();
  [[nodiscard]] std::string* release_fixed_char();
  void set_allocated_fixed_char(std::string* value);

  private:
  const std::string& _internal_fixed_char() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_fixed_char(const std::string& value);
  std::string* _internal_mutable_fixed_char();

  public:
  // .substrait.Expression.Literal.VarChar var_char = 22;
  bool has_var_char() const;
  private:
  bool _internal_has_var_char() const;

  public:
  void clear_var_char() ;
  const ::substrait::Expression_Literal_VarChar& var_char() const;
  [[nodiscard]] ::substrait::Expression_Literal_VarChar* release_var_char();
  ::substrait::Expression_Literal_VarChar* mutable_var_char();
  void set_allocated_var_char(::substrait::Expression_Literal_VarChar* value);
  void unsafe_arena_set_allocated_var_char(::substrait::Expression_Literal_VarChar* value);
  ::substrait::Expression_Literal_VarChar* unsafe_arena_release_var_char();

  private:
  const ::substrait::Expression_Literal_VarChar& _internal_var_char() const;
  ::substrait::Expression_Literal_VarChar* _internal_mutable_var_char();

  public:
  // bytes fixed_binary = 23;
  bool has_fixed_binary() const;
  void clear_fixed_binary() ;
  const std::string& fixed_binary() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fixed_binary(Arg_&& arg, Args_... args);
  std::string* mutable_fixed_binary();
  [[nodiscard]] std::string* release_fixed_binary();
  void set_allocated_fixed_binary(std::string* value);

  private:
  const std::string& _internal_fixed_binary() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_fixed_binary(const std::string& value);
  std::string* _internal_mutable_fixed_binary();

  public:
  // .substrait.Expression.Literal.Decimal decimal = 24;
  bool has_decimal() const;
  private:
  bool _internal_has_decimal() const;

  public:
  void clear_decimal() ;
  const ::substrait::Expression_Literal_Decimal& decimal() const;
  [[nodiscard]] ::substrait::Expression_Literal_Decimal* release_decimal();
  ::substrait::Expression_Literal_Decimal* mutable_decimal();
  void set_allocated_decimal(::substrait::Expression_Literal_Decimal* value);
  void unsafe_arena_set_allocated_decimal(::substrait::Expression_Literal_Decimal* value);
  ::substrait::Expression_Literal_Decimal* unsafe_arena_release_decimal();

  private:
  const ::substrait::Expression_Literal_Decimal& _internal_decimal() const;
  ::substrait::Expression_Literal_Decimal* _internal_mutable_decimal();

  public:
  // uint64 precision_timestamp = 34;
  bool has_precision_timestamp() const;
  void clear_precision_timestamp() ;
  ::uint64_t precision_timestamp() const;
  void set_precision_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_precision_timestamp() const;
  void _internal_set_precision_timestamp(::uint64_t value);

  public:
  // uint64 precision_timestamp_tz = 35;
  bool has_precision_timestamp_tz() const;
  void clear_precision_timestamp_tz() ;
  ::uint64_t precision_timestamp_tz() const;
  void set_precision_timestamp_tz(::uint64_t value);

  private:
  ::uint64_t _internal_precision_timestamp_tz() const;
  void _internal_set_precision_timestamp_tz(::uint64_t value);

  public:
  // .substrait.Expression.Literal.Struct struct = 25;
  bool has_struct_() const;
  private:
  bool _internal_has_struct_() const;

  public:
  void clear_struct_() ;
  const ::substrait::Expression_Literal_Struct& struct_() const;
  [[nodiscard]] ::substrait::Expression_Literal_Struct* release_struct_();
  ::substrait::Expression_Literal_Struct* mutable_struct_();
  void set_allocated_struct_(::substrait::Expression_Literal_Struct* value);
  void unsafe_arena_set_allocated_struct_(::substrait::Expression_Literal_Struct* value);
  ::substrait::Expression_Literal_Struct* unsafe_arena_release_struct_();

  private:
  const ::substrait::Expression_Literal_Struct& _internal_struct_() const;
  ::substrait::Expression_Literal_Struct* _internal_mutable_struct_();

  public:
  // .substrait.Expression.Literal.Map map = 26;
  bool has_map() const;
  private:
  bool _internal_has_map() const;

  public:
  void clear_map() ;
  const ::substrait::Expression_Literal_Map& map() const;
  [[nodiscard]] ::substrait::Expression_Literal_Map* release_map();
  ::substrait::Expression_Literal_Map* mutable_map();
  void set_allocated_map(::substrait::Expression_Literal_Map* value);
  void unsafe_arena_set_allocated_map(::substrait::Expression_Literal_Map* value);
  ::substrait::Expression_Literal_Map* unsafe_arena_release_map();

  private:
  const ::substrait::Expression_Literal_Map& _internal_map() const;
  ::substrait::Expression_Literal_Map* _internal_mutable_map();

  public:
  // int64 timestamp_tz = 27 [deprecated = true];
  [[deprecated]]  bool has_timestamp_tz() const;
  [[deprecated]]  void clear_timestamp_tz() ;
  [[deprecated]] ::int64_t timestamp_tz() const;
  [[deprecated]] void set_timestamp_tz(::int64_t value);

  private:
  ::int64_t _internal_timestamp_tz() const;
  void _internal_set_timestamp_tz(::int64_t value);

  public:
  // bytes uuid = 28;
  bool has_uuid() const;
  void clear_uuid() ;
  const std::string& uuid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_uuid(Arg_&& arg, Args_... args);
  std::string* mutable_uuid();
  [[nodiscard]] std::string* release_uuid();
  void set_allocated_uuid(std::string* value);

  private:
  const std::string& _internal_uuid() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(const std::string& value);
  std::string* _internal_mutable_uuid();

  public:
  // .substrait.Type null = 29;
  bool has_null() const;
  private:
  bool _internal_has_null() const;

  public:
  void clear_null() ;
  const ::substrait::Type& null() const;
  [[nodiscard]] ::substrait::Type* release_null();
  ::substrait::Type* mutable_null();
  void set_allocated_null(::substrait::Type* value);
  void unsafe_arena_set_allocated_null(::substrait::Type* value);
  ::substrait::Type* unsafe_arena_release_null();

  private:
  const ::substrait::Type& _internal_null() const;
  ::substrait::Type* _internal_mutable_null();

  public:
  // .substrait.Expression.Literal.List list = 30;
  bool has_list() const;
  private:
  bool _internal_has_list() const;

  public:
  void clear_list() ;
  const ::substrait::Expression_Literal_List& list() const;
  [[nodiscard]] ::substrait::Expression_Literal_List* release_list();
  ::substrait::Expression_Literal_List* mutable_list();
  void set_allocated_list(::substrait::Expression_Literal_List* value);
  void unsafe_arena_set_allocated_list(::substrait::Expression_Literal_List* value);
  ::substrait::Expression_Literal_List* unsafe_arena_release_list();

  private:
  const ::substrait::Expression_Literal_List& _internal_list() const;
  ::substrait::Expression_Literal_List* _internal_mutable_list();

  public:
  // .substrait.Type.List empty_list = 31;
  bool has_empty_list() const;
  private:
  bool _internal_has_empty_list() const;

  public:
  void clear_empty_list() ;
  const ::substrait::Type_List& empty_list() const;
  [[nodiscard]] ::substrait::Type_List* release_empty_list();
  ::substrait::Type_List* mutable_empty_list();
  void set_allocated_empty_list(::substrait::Type_List* value);
  void unsafe_arena_set_allocated_empty_list(::substrait::Type_List* value);
  ::substrait::Type_List* unsafe_arena_release_empty_list();

  private:
  const ::substrait::Type_List& _internal_empty_list() const;
  ::substrait::Type_List* _internal_mutable_empty_list();

  public:
  // .substrait.Type.Map empty_map = 32;
  bool has_empty_map() const;
  private:
  bool _internal_has_empty_map() const;

  public:
  void clear_empty_map() ;
  const ::substrait::Type_Map& empty_map() const;
  [[nodiscard]] ::substrait::Type_Map* release_empty_map();
  ::substrait::Type_Map* mutable_empty_map();
  void set_allocated_empty_map(::substrait::Type_Map* value);
  void unsafe_arena_set_allocated_empty_map(::substrait::Type_Map* value);
  ::substrait::Type_Map* unsafe_arena_release_empty_map();

  private:
  const ::substrait::Type_Map& _internal_empty_map() const;
  ::substrait::Type_Map* _internal_mutable_empty_map();

  public:
  // .substrait.Expression.Literal.UserDefined user_defined = 33;
  bool has_user_defined() const;
  private:
  bool _internal_has_user_defined() const;

  public:
  void clear_user_defined() ;
  const ::substrait::Expression_Literal_UserDefined& user_defined() const;
  [[nodiscard]] ::substrait::Expression_Literal_UserDefined* release_user_defined();
  ::substrait::Expression_Literal_UserDefined* mutable_user_defined();
  void set_allocated_user_defined(::substrait::Expression_Literal_UserDefined* value);
  void unsafe_arena_set_allocated_user_defined(::substrait::Expression_Literal_UserDefined* value);
  ::substrait::Expression_Literal_UserDefined* unsafe_arena_release_user_defined();

  private:
  const ::substrait::Expression_Literal_UserDefined& _internal_user_defined() const;
  ::substrait::Expression_Literal_UserDefined* _internal_mutable_user_defined();

  public:
  void clear_literal_type();
  LiteralTypeCase literal_type_case() const;
  // @@protoc_insertion_point(class_scope:substrait.Expression.Literal)
 private:
  class _Internal;
  void set_has_boolean();
  void set_has_i8();
  void set_has_i16();
  void set_has_i32();
  void set_has_i64();
  void set_has_fp32();
  void set_has_fp64();
  void set_has_string();
  void set_has_binary();
  void set_has_timestamp();
  void set_has_date();
  void set_has_time();
  void set_has_interval_year_to_month();
  void set_has_interval_day_to_second();
  void set_has_fixed_char();
  void set_has_var_char();
  void set_has_fixed_binary();
  void set_has_decimal();
  void set_has_precision_timestamp();
  void set_has_precision_timestamp_tz();
  void set_has_struct_();
  void set_has_map();
  void set_has_timestamp_tz();
  void set_has_uuid();
  void set_has_null();
  void set_has_list();
  void set_has_empty_list();
  void set_has_empty_map();
  void set_has_user_defined();
  inline bool has_literal_type() const;
  inline void clear_has_literal_type();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 31, 11,
      77, 9>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_Literal& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    bool nullable_;
    ::uint32_t type_variation_reference_;
    union LiteralTypeUnion {
      constexpr LiteralTypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool boolean_;
      ::int32_t i8_;
      ::int32_t i16_;
      ::int32_t i32_;
      ::int64_t i64_;
      float fp32_;
      double fp64_;
      ::google::protobuf::internal::ArenaStringPtr string_;
      ::google::protobuf::internal::ArenaStringPtr binary_;
      ::int64_t timestamp_;
      ::int32_t date_;
      ::int64_t time_;
      ::substrait::Expression_Literal_IntervalYearToMonth* interval_year_to_month_;
      ::substrait::Expression_Literal_IntervalDayToSecond* interval_day_to_second_;
      ::google::protobuf::internal::ArenaStringPtr fixed_char_;
      ::substrait::Expression_Literal_VarChar* var_char_;
      ::google::protobuf::internal::ArenaStringPtr fixed_binary_;
      ::substrait::Expression_Literal_Decimal* decimal_;
      ::uint64_t precision_timestamp_;
      ::uint64_t precision_timestamp_tz_;
      ::substrait::Expression_Literal_Struct* struct__;
      ::substrait::Expression_Literal_Map* map_;
      ::int64_t timestamp_tz_;
      ::google::protobuf::internal::ArenaStringPtr uuid_;
      ::substrait::Type* null_;
      ::substrait::Expression_Literal_List* list_;
      ::substrait::Type_List* empty_list_;
      ::substrait::Type_Map* empty_map_;
      ::substrait::Expression_Literal_UserDefined* user_defined_;
    } literal_type_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_Literal_class_data_;
// -------------------------------------------------------------------

class Expression_Literal_List final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.Literal.List) */ {
 public:
  inline Expression_Literal_List() : Expression_Literal_List(nullptr) {}
  ~Expression_Literal_List() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_Literal_List* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_Literal_List));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_Literal_List(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_Literal_List(const Expression_Literal_List& from) : Expression_Literal_List(nullptr, from) {}
  inline Expression_Literal_List(Expression_Literal_List&& from) noexcept
      : Expression_Literal_List(nullptr, std::move(from)) {}
  inline Expression_Literal_List& operator=(const Expression_Literal_List& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_Literal_List& operator=(Expression_Literal_List&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_Literal_List& default_instance() {
    return *reinterpret_cast<const Expression_Literal_List*>(
        &_Expression_Literal_List_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 63;
  friend void swap(Expression_Literal_List& a, Expression_Literal_List& b) { a.Swap(&b); }
  inline void Swap(Expression_Literal_List* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_Literal_List* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_Literal_List* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_Literal_List>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_Literal_List& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_Literal_List& from) { Expression_Literal_List::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_Literal_List* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.Literal.List"; }

 protected:
  explicit Expression_Literal_List(::google::protobuf::Arena* arena);
  Expression_Literal_List(::google::protobuf::Arena* arena, const Expression_Literal_List& from);
  Expression_Literal_List(::google::protobuf::Arena* arena, Expression_Literal_List&& from) noexcept
      : Expression_Literal_List(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated .substrait.Expression.Literal values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  ::substrait::Expression_Literal* mutable_values(int index);
  ::google::protobuf::RepeatedPtrField<::substrait::Expression_Literal>* mutable_values();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression_Literal>& _internal_values() const;
  ::google::protobuf::RepeatedPtrField<::substrait::Expression_Literal>* _internal_mutable_values();
  public:
  const ::substrait::Expression_Literal& values(int index) const;
  ::substrait::Expression_Literal* add_values();
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression_Literal>& values() const;
  // @@protoc_insertion_point(class_scope:substrait.Expression.Literal.List)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_Literal_List& from_msg);
    ::google::protobuf::RepeatedPtrField< ::substrait::Expression_Literal > values_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_Literal_List_class_data_;
// -------------------------------------------------------------------

class Expression_Literal_Map final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.Literal.Map) */ {
 public:
  inline Expression_Literal_Map() : Expression_Literal_Map(nullptr) {}
  ~Expression_Literal_Map() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_Literal_Map* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_Literal_Map));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_Literal_Map(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_Literal_Map(const Expression_Literal_Map& from) : Expression_Literal_Map(nullptr, from) {}
  inline Expression_Literal_Map(Expression_Literal_Map&& from) noexcept
      : Expression_Literal_Map(nullptr, std::move(from)) {}
  inline Expression_Literal_Map& operator=(const Expression_Literal_Map& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_Literal_Map& operator=(Expression_Literal_Map&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_Literal_Map& default_instance() {
    return *reinterpret_cast<const Expression_Literal_Map*>(
        &_Expression_Literal_Map_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 59;
  friend void swap(Expression_Literal_Map& a, Expression_Literal_Map& b) { a.Swap(&b); }
  inline void Swap(Expression_Literal_Map* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_Literal_Map* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_Literal_Map* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_Literal_Map>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_Literal_Map& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_Literal_Map& from) { Expression_Literal_Map::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_Literal_Map* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.Literal.Map"; }

 protected:
  explicit Expression_Literal_Map(::google::protobuf::Arena* arena);
  Expression_Literal_Map(::google::protobuf::Arena* arena, const Expression_Literal_Map& from);
  Expression_Literal_Map(::google::protobuf::Arena* arena, Expression_Literal_Map&& from) noexcept
      : Expression_Literal_Map(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using KeyValue = Expression_Literal_Map_KeyValue;

  // accessors -------------------------------------------------------
  enum : int {
    kKeyValuesFieldNumber = 1,
  };
  // repeated .substrait.Expression.Literal.Map.KeyValue key_values = 1;
  int key_values_size() const;
  private:
  int _internal_key_values_size() const;

  public:
  void clear_key_values() ;
  ::substrait::Expression_Literal_Map_KeyValue* mutable_key_values(int index);
  ::google::protobuf::RepeatedPtrField<::substrait::Expression_Literal_Map_KeyValue>* mutable_key_values();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression_Literal_Map_KeyValue>& _internal_key_values() const;
  ::google::protobuf::RepeatedPtrField<::substrait::Expression_Literal_Map_KeyValue>* _internal_mutable_key_values();
  public:
  const ::substrait::Expression_Literal_Map_KeyValue& key_values(int index) const;
  ::substrait::Expression_Literal_Map_KeyValue* add_key_values();
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression_Literal_Map_KeyValue>& key_values() const;
  // @@protoc_insertion_point(class_scope:substrait.Expression.Literal.Map)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_Literal_Map& from_msg);
    ::google::protobuf::RepeatedPtrField< ::substrait::Expression_Literal_Map_KeyValue > key_values_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_Literal_Map_class_data_;
// -------------------------------------------------------------------

class Expression_Literal_Map_KeyValue final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.Literal.Map.KeyValue) */ {
 public:
  inline Expression_Literal_Map_KeyValue() : Expression_Literal_Map_KeyValue(nullptr) {}
  ~Expression_Literal_Map_KeyValue() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_Literal_Map_KeyValue* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_Literal_Map_KeyValue));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_Literal_Map_KeyValue(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_Literal_Map_KeyValue(const Expression_Literal_Map_KeyValue& from) : Expression_Literal_Map_KeyValue(nullptr, from) {}
  inline Expression_Literal_Map_KeyValue(Expression_Literal_Map_KeyValue&& from) noexcept
      : Expression_Literal_Map_KeyValue(nullptr, std::move(from)) {}
  inline Expression_Literal_Map_KeyValue& operator=(const Expression_Literal_Map_KeyValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_Literal_Map_KeyValue& operator=(Expression_Literal_Map_KeyValue&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_Literal_Map_KeyValue& default_instance() {
    return *reinterpret_cast<const Expression_Literal_Map_KeyValue*>(
        &_Expression_Literal_Map_KeyValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 58;
  friend void swap(Expression_Literal_Map_KeyValue& a, Expression_Literal_Map_KeyValue& b) { a.Swap(&b); }
  inline void Swap(Expression_Literal_Map_KeyValue* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_Literal_Map_KeyValue* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_Literal_Map_KeyValue* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_Literal_Map_KeyValue>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_Literal_Map_KeyValue& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_Literal_Map_KeyValue& from) { Expression_Literal_Map_KeyValue::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_Literal_Map_KeyValue* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.Literal.Map.KeyValue"; }

 protected:
  explicit Expression_Literal_Map_KeyValue(::google::protobuf::Arena* arena);
  Expression_Literal_Map_KeyValue(::google::protobuf::Arena* arena, const Expression_Literal_Map_KeyValue& from);
  Expression_Literal_Map_KeyValue(::google::protobuf::Arena* arena, Expression_Literal_Map_KeyValue&& from) noexcept
      : Expression_Literal_Map_KeyValue(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // .substrait.Expression.Literal key = 1;
  bool has_key() const;
  void clear_key() ;
  const ::substrait::Expression_Literal& key() const;
  [[nodiscard]] ::substrait::Expression_Literal* release_key();
  ::substrait::Expression_Literal* mutable_key();
  void set_allocated_key(::substrait::Expression_Literal* value);
  void unsafe_arena_set_allocated_key(::substrait::Expression_Literal* value);
  ::substrait::Expression_Literal* unsafe_arena_release_key();

  private:
  const ::substrait::Expression_Literal& _internal_key() const;
  ::substrait::Expression_Literal* _internal_mutable_key();

  public:
  // .substrait.Expression.Literal value = 2;
  bool has_value() const;
  void clear_value() ;
  const ::substrait::Expression_Literal& value() const;
  [[nodiscard]] ::substrait::Expression_Literal* release_value();
  ::substrait::Expression_Literal* mutable_value();
  void set_allocated_value(::substrait::Expression_Literal* value);
  void unsafe_arena_set_allocated_value(::substrait::Expression_Literal* value);
  ::substrait::Expression_Literal* unsafe_arena_release_value();

  private:
  const ::substrait::Expression_Literal& _internal_value() const;
  ::substrait::Expression_Literal* _internal_mutable_value();

  public:
  // @@protoc_insertion_point(class_scope:substrait.Expression.Literal.Map.KeyValue)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_Literal_Map_KeyValue& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::substrait::Expression_Literal* key_;
    ::substrait::Expression_Literal* value_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_Literal_Map_KeyValue_class_data_;
// -------------------------------------------------------------------

class Expression_Literal_Struct final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.Literal.Struct) */ {
 public:
  inline Expression_Literal_Struct() : Expression_Literal_Struct(nullptr) {}
  ~Expression_Literal_Struct() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_Literal_Struct* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_Literal_Struct));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_Literal_Struct(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_Literal_Struct(const Expression_Literal_Struct& from) : Expression_Literal_Struct(nullptr, from) {}
  inline Expression_Literal_Struct(Expression_Literal_Struct&& from) noexcept
      : Expression_Literal_Struct(nullptr, std::move(from)) {}
  inline Expression_Literal_Struct& operator=(const Expression_Literal_Struct& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_Literal_Struct& operator=(Expression_Literal_Struct&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_Literal_Struct& default_instance() {
    return *reinterpret_cast<const Expression_Literal_Struct*>(
        &_Expression_Literal_Struct_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 62;
  friend void swap(Expression_Literal_Struct& a, Expression_Literal_Struct& b) { a.Swap(&b); }
  inline void Swap(Expression_Literal_Struct* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_Literal_Struct* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_Literal_Struct* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_Literal_Struct>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_Literal_Struct& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_Literal_Struct& from) { Expression_Literal_Struct::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_Literal_Struct* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.Literal.Struct"; }

 protected:
  explicit Expression_Literal_Struct(::google::protobuf::Arena* arena);
  Expression_Literal_Struct(::google::protobuf::Arena* arena, const Expression_Literal_Struct& from);
  Expression_Literal_Struct(::google::protobuf::Arena* arena, Expression_Literal_Struct&& from) noexcept
      : Expression_Literal_Struct(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFieldsFieldNumber = 1,
  };
  // repeated .substrait.Expression.Literal fields = 1;
  int fields_size() const;
  private:
  int _internal_fields_size() const;

  public:
  void clear_fields() ;
  ::substrait::Expression_Literal* mutable_fields(int index);
  ::google::protobuf::RepeatedPtrField<::substrait::Expression_Literal>* mutable_fields();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression_Literal>& _internal_fields() const;
  ::google::protobuf::RepeatedPtrField<::substrait::Expression_Literal>* _internal_mutable_fields();
  public:
  const ::substrait::Expression_Literal& fields(int index) const;
  ::substrait::Expression_Literal* add_fields();
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression_Literal>& fields() const;
  // @@protoc_insertion_point(class_scope:substrait.Expression.Literal.Struct)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_Literal_Struct& from_msg);
    ::google::protobuf::RepeatedPtrField< ::substrait::Expression_Literal > fields_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_Literal_Struct_class_data_;
// -------------------------------------------------------------------

class RelCommon final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.RelCommon) */ {
 public:
  inline RelCommon() : RelCommon(nullptr) {}
  ~RelCommon() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RelCommon* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RelCommon));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RelCommon(
      ::google::protobuf::internal::ConstantInitialized);

  inline RelCommon(const RelCommon& from) : RelCommon(nullptr, from) {}
  inline RelCommon(RelCommon&& from) noexcept
      : RelCommon(nullptr, std::move(from)) {}
  inline RelCommon& operator=(const RelCommon& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelCommon& operator=(RelCommon&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RelCommon& default_instance() {
    return *reinterpret_cast<const RelCommon*>(
        &_RelCommon_default_instance_);
  }
  enum EmitKindCase {
    kDirect = 1,
    kEmit = 2,
    EMIT_KIND_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(RelCommon& a, RelCommon& b) { a.Swap(&b); }
  inline void Swap(RelCommon* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelCommon* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RelCommon* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RelCommon>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RelCommon& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RelCommon& from) { RelCommon::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RelCommon* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.RelCommon"; }

 protected:
  explicit RelCommon(::google::protobuf::Arena* arena);
  RelCommon(::google::protobuf::Arena* arena, const RelCommon& from);
  RelCommon(::google::protobuf::Arena* arena, RelCommon&& from) noexcept
      : RelCommon(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Direct = RelCommon_Direct;
  using Emit = RelCommon_Emit;
  using Hint = RelCommon_Hint;

  // accessors -------------------------------------------------------
  enum : int {
    kHintFieldNumber = 3,
    kAdvancedExtensionFieldNumber = 4,
    kDirectFieldNumber = 1,
    kEmitFieldNumber = 2,
  };
  // .substrait.RelCommon.Hint hint = 3;
  bool has_hint() const;
  void clear_hint() ;
  const ::substrait::RelCommon_Hint& hint() const;
  [[nodiscard]] ::substrait::RelCommon_Hint* release_hint();
  ::substrait::RelCommon_Hint* mutable_hint();
  void set_allocated_hint(::substrait::RelCommon_Hint* value);
  void unsafe_arena_set_allocated_hint(::substrait::RelCommon_Hint* value);
  ::substrait::RelCommon_Hint* unsafe_arena_release_hint();

  private:
  const ::substrait::RelCommon_Hint& _internal_hint() const;
  ::substrait::RelCommon_Hint* _internal_mutable_hint();

  public:
  // .substrait.extensions.AdvancedExtension advanced_extension = 4;
  bool has_advanced_extension() const;
  void clear_advanced_extension() ;
  const ::substrait::extensions::AdvancedExtension& advanced_extension() const;
  [[nodiscard]] ::substrait::extensions::AdvancedExtension* release_advanced_extension();
  ::substrait::extensions::AdvancedExtension* mutable_advanced_extension();
  void set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value);
  void unsafe_arena_set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value);
  ::substrait::extensions::AdvancedExtension* unsafe_arena_release_advanced_extension();

  private:
  const ::substrait::extensions::AdvancedExtension& _internal_advanced_extension() const;
  ::substrait::extensions::AdvancedExtension* _internal_mutable_advanced_extension();

  public:
  // .substrait.RelCommon.Direct direct = 1;
  bool has_direct() const;
  private:
  bool _internal_has_direct() const;

  public:
  void clear_direct() ;
  const ::substrait::RelCommon_Direct& direct() const;
  [[nodiscard]] ::substrait::RelCommon_Direct* release_direct();
  ::substrait::RelCommon_Direct* mutable_direct();
  void set_allocated_direct(::substrait::RelCommon_Direct* value);
  void unsafe_arena_set_allocated_direct(::substrait::RelCommon_Direct* value);
  ::substrait::RelCommon_Direct* unsafe_arena_release_direct();

  private:
  const ::substrait::RelCommon_Direct& _internal_direct() const;
  ::substrait::RelCommon_Direct* _internal_mutable_direct();

  public:
  // .substrait.RelCommon.Emit emit = 2;
  bool has_emit() const;
  private:
  bool _internal_has_emit() const;

  public:
  void clear_emit() ;
  const ::substrait::RelCommon_Emit& emit() const;
  [[nodiscard]] ::substrait::RelCommon_Emit* release_emit();
  ::substrait::RelCommon_Emit* mutable_emit();
  void set_allocated_emit(::substrait::RelCommon_Emit* value);
  void unsafe_arena_set_allocated_emit(::substrait::RelCommon_Emit* value);
  ::substrait::RelCommon_Emit* unsafe_arena_release_emit();

  private:
  const ::substrait::RelCommon_Emit& _internal_emit() const;
  ::substrait::RelCommon_Emit* _internal_mutable_emit();

  public:
  void clear_emit_kind();
  EmitKindCase emit_kind_case() const;
  // @@protoc_insertion_point(class_scope:substrait.RelCommon)
 private:
  class _Internal;
  void set_has_direct();
  void set_has_emit();
  inline bool has_emit_kind() const;
  inline void clear_has_emit_kind();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 4, 4,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RelCommon& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::substrait::RelCommon_Hint* hint_;
    ::substrait::extensions::AdvancedExtension* advanced_extension_;
    union EmitKindUnion {
      constexpr EmitKindUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::substrait::RelCommon_Direct* direct_;
      ::substrait::RelCommon_Emit* emit_;
    } emit_kind_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RelCommon_class_data_;
// -------------------------------------------------------------------

class ReadRel_VirtualTable final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.ReadRel.VirtualTable) */ {
 public:
  inline ReadRel_VirtualTable() : ReadRel_VirtualTable(nullptr) {}
  ~ReadRel_VirtualTable() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReadRel_VirtualTable* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReadRel_VirtualTable));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReadRel_VirtualTable(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReadRel_VirtualTable(const ReadRel_VirtualTable& from) : ReadRel_VirtualTable(nullptr, from) {}
  inline ReadRel_VirtualTable(ReadRel_VirtualTable&& from) noexcept
      : ReadRel_VirtualTable(nullptr, std::move(from)) {}
  inline ReadRel_VirtualTable& operator=(const ReadRel_VirtualTable& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadRel_VirtualTable& operator=(ReadRel_VirtualTable&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadRel_VirtualTable& default_instance() {
    return *reinterpret_cast<const ReadRel_VirtualTable*>(
        &_ReadRel_VirtualTable_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(ReadRel_VirtualTable& a, ReadRel_VirtualTable& b) { a.Swap(&b); }
  inline void Swap(ReadRel_VirtualTable* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadRel_VirtualTable* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadRel_VirtualTable* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReadRel_VirtualTable>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReadRel_VirtualTable& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReadRel_VirtualTable& from) { ReadRel_VirtualTable::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReadRel_VirtualTable* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.ReadRel.VirtualTable"; }

 protected:
  explicit ReadRel_VirtualTable(::google::protobuf::Arena* arena);
  ReadRel_VirtualTable(::google::protobuf::Arena* arena, const ReadRel_VirtualTable& from);
  ReadRel_VirtualTable(::google::protobuf::Arena* arena, ReadRel_VirtualTable&& from) noexcept
      : ReadRel_VirtualTable(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated .substrait.Expression.Literal.Struct values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  ::substrait::Expression_Literal_Struct* mutable_values(int index);
  ::google::protobuf::RepeatedPtrField<::substrait::Expression_Literal_Struct>* mutable_values();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression_Literal_Struct>& _internal_values() const;
  ::google::protobuf::RepeatedPtrField<::substrait::Expression_Literal_Struct>* _internal_mutable_values();
  public:
  const ::substrait::Expression_Literal_Struct& values(int index) const;
  ::substrait::Expression_Literal_Struct* add_values();
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression_Literal_Struct>& values() const;
  // @@protoc_insertion_point(class_scope:substrait.ReadRel.VirtualTable)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReadRel_VirtualTable& from_msg);
    ::google::protobuf::RepeatedPtrField< ::substrait::Expression_Literal_Struct > values_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ReadRel_VirtualTable_class_data_;
// -------------------------------------------------------------------

class Expression_ReferenceSegment final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.ReferenceSegment) */ {
 public:
  inline Expression_ReferenceSegment() : Expression_ReferenceSegment(nullptr) {}
  ~Expression_ReferenceSegment() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_ReferenceSegment* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_ReferenceSegment));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_ReferenceSegment(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_ReferenceSegment(const Expression_ReferenceSegment& from) : Expression_ReferenceSegment(nullptr, from) {}
  inline Expression_ReferenceSegment(Expression_ReferenceSegment&& from) noexcept
      : Expression_ReferenceSegment(nullptr, std::move(from)) {}
  inline Expression_ReferenceSegment& operator=(const Expression_ReferenceSegment& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_ReferenceSegment& operator=(Expression_ReferenceSegment&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_ReferenceSegment& default_instance() {
    return *reinterpret_cast<const Expression_ReferenceSegment*>(
        &_Expression_ReferenceSegment_default_instance_);
  }
  enum ReferenceTypeCase {
    kMapKey = 1,
    kStructField = 2,
    kListElement = 3,
    REFERENCE_TYPE_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 92;
  friend void swap(Expression_ReferenceSegment& a, Expression_ReferenceSegment& b) { a.Swap(&b); }
  inline void Swap(Expression_ReferenceSegment* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_ReferenceSegment* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_ReferenceSegment* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_ReferenceSegment>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_ReferenceSegment& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_ReferenceSegment& from) { Expression_ReferenceSegment::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_ReferenceSegment* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.ReferenceSegment"; }

 protected:
  explicit Expression_ReferenceSegment(::google::protobuf::Arena* arena);
  Expression_ReferenceSegment(::google::protobuf::Arena* arena, const Expression_ReferenceSegment& from);
  Expression_ReferenceSegment(::google::protobuf::Arena* arena, Expression_ReferenceSegment&& from) noexcept
      : Expression_ReferenceSegment(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using MapKey = Expression_ReferenceSegment_MapKey;
  using StructField = Expression_ReferenceSegment_StructField;
  using ListElement = Expression_ReferenceSegment_ListElement;

  // accessors -------------------------------------------------------
  enum : int {
    kMapKeyFieldNumber = 1,
    kStructFieldFieldNumber = 2,
    kListElementFieldNumber = 3,
  };
  // .substrait.Expression.ReferenceSegment.MapKey map_key = 1;
  bool has_map_key() const;
  private:
  bool _internal_has_map_key() const;

  public:
  void clear_map_key() ;
  const ::substrait::Expression_ReferenceSegment_MapKey& map_key() const;
  [[nodiscard]] ::substrait::Expression_ReferenceSegment_MapKey* release_map_key();
  ::substrait::Expression_ReferenceSegment_MapKey* mutable_map_key();
  void set_allocated_map_key(::substrait::Expression_ReferenceSegment_MapKey* value);
  void unsafe_arena_set_allocated_map_key(::substrait::Expression_ReferenceSegment_MapKey* value);
  ::substrait::Expression_ReferenceSegment_MapKey* unsafe_arena_release_map_key();

  private:
  const ::substrait::Expression_ReferenceSegment_MapKey& _internal_map_key() const;
  ::substrait::Expression_ReferenceSegment_MapKey* _internal_mutable_map_key();

  public:
  // .substrait.Expression.ReferenceSegment.StructField struct_field = 2;
  bool has_struct_field() const;
  private:
  bool _internal_has_struct_field() const;

  public:
  void clear_struct_field() ;
  const ::substrait::Expression_ReferenceSegment_StructField& struct_field() const;
  [[nodiscard]] ::substrait::Expression_ReferenceSegment_StructField* release_struct_field();
  ::substrait::Expression_ReferenceSegment_StructField* mutable_struct_field();
  void set_allocated_struct_field(::substrait::Expression_ReferenceSegment_StructField* value);
  void unsafe_arena_set_allocated_struct_field(::substrait::Expression_ReferenceSegment_StructField* value);
  ::substrait::Expression_ReferenceSegment_StructField* unsafe_arena_release_struct_field();

  private:
  const ::substrait::Expression_ReferenceSegment_StructField& _internal_struct_field() const;
  ::substrait::Expression_ReferenceSegment_StructField* _internal_mutable_struct_field();

  public:
  // .substrait.Expression.ReferenceSegment.ListElement list_element = 3;
  bool has_list_element() const;
  private:
  bool _internal_has_list_element() const;

  public:
  void clear_list_element() ;
  const ::substrait::Expression_ReferenceSegment_ListElement& list_element() const;
  [[nodiscard]] ::substrait::Expression_ReferenceSegment_ListElement* release_list_element();
  ::substrait::Expression_ReferenceSegment_ListElement* mutable_list_element();
  void set_allocated_list_element(::substrait::Expression_ReferenceSegment_ListElement* value);
  void unsafe_arena_set_allocated_list_element(::substrait::Expression_ReferenceSegment_ListElement* value);
  ::substrait::Expression_ReferenceSegment_ListElement* unsafe_arena_release_list_element();

  private:
  const ::substrait::Expression_ReferenceSegment_ListElement& _internal_list_element() const;
  ::substrait::Expression_ReferenceSegment_ListElement* _internal_mutable_list_element();

  public:
  void clear_reference_type();
  ReferenceTypeCase reference_type_case() const;
  // @@protoc_insertion_point(class_scope:substrait.Expression.ReferenceSegment)
 private:
  class _Internal;
  void set_has_map_key();
  void set_has_struct_field();
  void set_has_list_element();
  inline bool has_reference_type() const;
  inline void clear_has_reference_type();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 3, 3,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_ReferenceSegment& from_msg);
    union ReferenceTypeUnion {
      constexpr ReferenceTypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::substrait::Expression_ReferenceSegment_MapKey* map_key_;
      ::substrait::Expression_ReferenceSegment_StructField* struct_field_;
      ::substrait::Expression_ReferenceSegment_ListElement* list_element_;
    } reference_type_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_ReferenceSegment_class_data_;
// -------------------------------------------------------------------

class Expression_ReferenceSegment_ListElement final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.ReferenceSegment.ListElement) */ {
 public:
  inline Expression_ReferenceSegment_ListElement() : Expression_ReferenceSegment_ListElement(nullptr) {}
  ~Expression_ReferenceSegment_ListElement() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_ReferenceSegment_ListElement* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_ReferenceSegment_ListElement));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_ReferenceSegment_ListElement(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_ReferenceSegment_ListElement(const Expression_ReferenceSegment_ListElement& from) : Expression_ReferenceSegment_ListElement(nullptr, from) {}
  inline Expression_ReferenceSegment_ListElement(Expression_ReferenceSegment_ListElement&& from) noexcept
      : Expression_ReferenceSegment_ListElement(nullptr, std::move(from)) {}
  inline Expression_ReferenceSegment_ListElement& operator=(const Expression_ReferenceSegment_ListElement& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_ReferenceSegment_ListElement& operator=(Expression_ReferenceSegment_ListElement&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_ReferenceSegment_ListElement& default_instance() {
    return *reinterpret_cast<const Expression_ReferenceSegment_ListElement*>(
        &_Expression_ReferenceSegment_ListElement_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 91;
  friend void swap(Expression_ReferenceSegment_ListElement& a, Expression_ReferenceSegment_ListElement& b) { a.Swap(&b); }
  inline void Swap(Expression_ReferenceSegment_ListElement* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_ReferenceSegment_ListElement* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_ReferenceSegment_ListElement* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_ReferenceSegment_ListElement>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_ReferenceSegment_ListElement& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_ReferenceSegment_ListElement& from) { Expression_ReferenceSegment_ListElement::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_ReferenceSegment_ListElement* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.ReferenceSegment.ListElement"; }

 protected:
  explicit Expression_ReferenceSegment_ListElement(::google::protobuf::Arena* arena);
  Expression_ReferenceSegment_ListElement(::google::protobuf::Arena* arena, const Expression_ReferenceSegment_ListElement& from);
  Expression_ReferenceSegment_ListElement(::google::protobuf::Arena* arena, Expression_ReferenceSegment_ListElement&& from) noexcept
      : Expression_ReferenceSegment_ListElement(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kChildFieldNumber = 2,
    kOffsetFieldNumber = 1,
  };
  // .substrait.Expression.ReferenceSegment child = 2;
  bool has_child() const;
  void clear_child() ;
  const ::substrait::Expression_ReferenceSegment& child() const;
  [[nodiscard]] ::substrait::Expression_ReferenceSegment* release_child();
  ::substrait::Expression_ReferenceSegment* mutable_child();
  void set_allocated_child(::substrait::Expression_ReferenceSegment* value);
  void unsafe_arena_set_allocated_child(::substrait::Expression_ReferenceSegment* value);
  ::substrait::Expression_ReferenceSegment* unsafe_arena_release_child();

  private:
  const ::substrait::Expression_ReferenceSegment& _internal_child() const;
  ::substrait::Expression_ReferenceSegment* _internal_mutable_child();

  public:
  // int32 offset = 1;
  void clear_offset() ;
  ::int32_t offset() const;
  void set_offset(::int32_t value);

  private:
  ::int32_t _internal_offset() const;
  void _internal_set_offset(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:substrait.Expression.ReferenceSegment.ListElement)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_ReferenceSegment_ListElement& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::substrait::Expression_ReferenceSegment* child_;
    ::int32_t offset_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_ReferenceSegment_ListElement_class_data_;
// -------------------------------------------------------------------

class Expression_ReferenceSegment_MapKey final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.ReferenceSegment.MapKey) */ {
 public:
  inline Expression_ReferenceSegment_MapKey() : Expression_ReferenceSegment_MapKey(nullptr) {}
  ~Expression_ReferenceSegment_MapKey() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_ReferenceSegment_MapKey* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_ReferenceSegment_MapKey));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_ReferenceSegment_MapKey(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_ReferenceSegment_MapKey(const Expression_ReferenceSegment_MapKey& from) : Expression_ReferenceSegment_MapKey(nullptr, from) {}
  inline Expression_ReferenceSegment_MapKey(Expression_ReferenceSegment_MapKey&& from) noexcept
      : Expression_ReferenceSegment_MapKey(nullptr, std::move(from)) {}
  inline Expression_ReferenceSegment_MapKey& operator=(const Expression_ReferenceSegment_MapKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_ReferenceSegment_MapKey& operator=(Expression_ReferenceSegment_MapKey&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_ReferenceSegment_MapKey& default_instance() {
    return *reinterpret_cast<const Expression_ReferenceSegment_MapKey*>(
        &_Expression_ReferenceSegment_MapKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 89;
  friend void swap(Expression_ReferenceSegment_MapKey& a, Expression_ReferenceSegment_MapKey& b) { a.Swap(&b); }
  inline void Swap(Expression_ReferenceSegment_MapKey* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_ReferenceSegment_MapKey* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_ReferenceSegment_MapKey* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_ReferenceSegment_MapKey>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_ReferenceSegment_MapKey& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_ReferenceSegment_MapKey& from) { Expression_ReferenceSegment_MapKey::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_ReferenceSegment_MapKey* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.ReferenceSegment.MapKey"; }

 protected:
  explicit Expression_ReferenceSegment_MapKey(::google::protobuf::Arena* arena);
  Expression_ReferenceSegment_MapKey(::google::protobuf::Arena* arena, const Expression_ReferenceSegment_MapKey& from);
  Expression_ReferenceSegment_MapKey(::google::protobuf::Arena* arena, Expression_ReferenceSegment_MapKey&& from) noexcept
      : Expression_ReferenceSegment_MapKey(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMapKeyFieldNumber = 1,
    kChildFieldNumber = 2,
  };
  // .substrait.Expression.Literal map_key = 1;
  bool has_map_key() const;
  void clear_map_key() ;
  const ::substrait::Expression_Literal& map_key() const;
  [[nodiscard]] ::substrait::Expression_Literal* release_map_key();
  ::substrait::Expression_Literal* mutable_map_key();
  void set_allocated_map_key(::substrait::Expression_Literal* value);
  void unsafe_arena_set_allocated_map_key(::substrait::Expression_Literal* value);
  ::substrait::Expression_Literal* unsafe_arena_release_map_key();

  private:
  const ::substrait::Expression_Literal& _internal_map_key() const;
  ::substrait::Expression_Literal* _internal_mutable_map_key();

  public:
  // .substrait.Expression.ReferenceSegment child = 2;
  bool has_child() const;
  void clear_child() ;
  const ::substrait::Expression_ReferenceSegment& child() const;
  [[nodiscard]] ::substrait::Expression_ReferenceSegment* release_child();
  ::substrait::Expression_ReferenceSegment* mutable_child();
  void set_allocated_child(::substrait::Expression_ReferenceSegment* value);
  void unsafe_arena_set_allocated_child(::substrait::Expression_ReferenceSegment* value);
  ::substrait::Expression_ReferenceSegment* unsafe_arena_release_child();

  private:
  const ::substrait::Expression_ReferenceSegment& _internal_child() const;
  ::substrait::Expression_ReferenceSegment* _internal_mutable_child();

  public:
  // @@protoc_insertion_point(class_scope:substrait.Expression.ReferenceSegment.MapKey)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_ReferenceSegment_MapKey& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::substrait::Expression_Literal* map_key_;
    ::substrait::Expression_ReferenceSegment* child_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_ReferenceSegment_MapKey_class_data_;
// -------------------------------------------------------------------

class Expression_ReferenceSegment_StructField final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.ReferenceSegment.StructField) */ {
 public:
  inline Expression_ReferenceSegment_StructField() : Expression_ReferenceSegment_StructField(nullptr) {}
  ~Expression_ReferenceSegment_StructField() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_ReferenceSegment_StructField* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_ReferenceSegment_StructField));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_ReferenceSegment_StructField(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_ReferenceSegment_StructField(const Expression_ReferenceSegment_StructField& from) : Expression_ReferenceSegment_StructField(nullptr, from) {}
  inline Expression_ReferenceSegment_StructField(Expression_ReferenceSegment_StructField&& from) noexcept
      : Expression_ReferenceSegment_StructField(nullptr, std::move(from)) {}
  inline Expression_ReferenceSegment_StructField& operator=(const Expression_ReferenceSegment_StructField& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_ReferenceSegment_StructField& operator=(Expression_ReferenceSegment_StructField&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_ReferenceSegment_StructField& default_instance() {
    return *reinterpret_cast<const Expression_ReferenceSegment_StructField*>(
        &_Expression_ReferenceSegment_StructField_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 90;
  friend void swap(Expression_ReferenceSegment_StructField& a, Expression_ReferenceSegment_StructField& b) { a.Swap(&b); }
  inline void Swap(Expression_ReferenceSegment_StructField* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_ReferenceSegment_StructField* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_ReferenceSegment_StructField* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_ReferenceSegment_StructField>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_ReferenceSegment_StructField& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_ReferenceSegment_StructField& from) { Expression_ReferenceSegment_StructField::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_ReferenceSegment_StructField* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.ReferenceSegment.StructField"; }

 protected:
  explicit Expression_ReferenceSegment_StructField(::google::protobuf::Arena* arena);
  Expression_ReferenceSegment_StructField(::google::protobuf::Arena* arena, const Expression_ReferenceSegment_StructField& from);
  Expression_ReferenceSegment_StructField(::google::protobuf::Arena* arena, Expression_ReferenceSegment_StructField&& from) noexcept
      : Expression_ReferenceSegment_StructField(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kChildFieldNumber = 2,
    kFieldFieldNumber = 1,
  };
  // .substrait.Expression.ReferenceSegment child = 2;
  bool has_child() const;
  void clear_child() ;
  const ::substrait::Expression_ReferenceSegment& child() const;
  [[nodiscard]] ::substrait::Expression_ReferenceSegment* release_child();
  ::substrait::Expression_ReferenceSegment* mutable_child();
  void set_allocated_child(::substrait::Expression_ReferenceSegment* value);
  void unsafe_arena_set_allocated_child(::substrait::Expression_ReferenceSegment* value);
  ::substrait::Expression_ReferenceSegment* unsafe_arena_release_child();

  private:
  const ::substrait::Expression_ReferenceSegment& _internal_child() const;
  ::substrait::Expression_ReferenceSegment* _internal_mutable_child();

  public:
  // int32 field = 1;
  void clear_field() ;
  ::int32_t field() const;
  void set_field(::int32_t value);

  private:
  ::int32_t _internal_field() const;
  void _internal_set_field(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:substrait.Expression.ReferenceSegment.StructField)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_ReferenceSegment_StructField& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::substrait::Expression_ReferenceSegment* child_;
    ::int32_t field_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_ReferenceSegment_StructField_class_data_;
// -------------------------------------------------------------------

class ExtensionLeafRel final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.ExtensionLeafRel) */ {
 public:
  inline ExtensionLeafRel() : ExtensionLeafRel(nullptr) {}
  ~ExtensionLeafRel() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ExtensionLeafRel* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ExtensionLeafRel));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ExtensionLeafRel(
      ::google::protobuf::internal::ConstantInitialized);

  inline ExtensionLeafRel(const ExtensionLeafRel& from) : ExtensionLeafRel(nullptr, from) {}
  inline ExtensionLeafRel(ExtensionLeafRel&& from) noexcept
      : ExtensionLeafRel(nullptr, std::move(from)) {}
  inline ExtensionLeafRel& operator=(const ExtensionLeafRel& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExtensionLeafRel& operator=(ExtensionLeafRel&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExtensionLeafRel& default_instance() {
    return *reinterpret_cast<const ExtensionLeafRel*>(
        &_ExtensionLeafRel_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 29;
  friend void swap(ExtensionLeafRel& a, ExtensionLeafRel& b) { a.Swap(&b); }
  inline void Swap(ExtensionLeafRel* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExtensionLeafRel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExtensionLeafRel* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ExtensionLeafRel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ExtensionLeafRel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ExtensionLeafRel& from) { ExtensionLeafRel::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ExtensionLeafRel* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.ExtensionLeafRel"; }

 protected:
  explicit ExtensionLeafRel(::google::protobuf::Arena* arena);
  ExtensionLeafRel(::google::protobuf::Arena* arena, const ExtensionLeafRel& from);
  ExtensionLeafRel(::google::protobuf::Arena* arena, ExtensionLeafRel&& from) noexcept
      : ExtensionLeafRel(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCommonFieldNumber = 1,
    kDetailFieldNumber = 2,
  };
  // .substrait.RelCommon common = 1;
  bool has_common() const;
  void clear_common() ;
  const ::substrait::RelCommon& common() const;
  [[nodiscard]] ::substrait::RelCommon* release_common();
  ::substrait::RelCommon* mutable_common();
  void set_allocated_common(::substrait::RelCommon* value);
  void unsafe_arena_set_allocated_common(::substrait::RelCommon* value);
  ::substrait::RelCommon* unsafe_arena_release_common();

  private:
  const ::substrait::RelCommon& _internal_common() const;
  ::substrait::RelCommon* _internal_mutable_common();

  public:
  // .google.protobuf.Any detail = 2;
  bool has_detail() const;
  void clear_detail() ;
  const ::google::protobuf::Any& detail() const;
  [[nodiscard]] ::google::protobuf::Any* release_detail();
  ::google::protobuf::Any* mutable_detail();
  void set_allocated_detail(::google::protobuf::Any* value);
  void unsafe_arena_set_allocated_detail(::google::protobuf::Any* value);
  ::google::protobuf::Any* unsafe_arena_release_detail();

  private:
  const ::google::protobuf::Any& _internal_detail() const;
  ::google::protobuf::Any* _internal_mutable_detail();

  public:
  // @@protoc_insertion_point(class_scope:substrait.ExtensionLeafRel)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ExtensionLeafRel& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::substrait::RelCommon* common_;
    ::google::protobuf::Any* detail_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ExtensionLeafRel_class_data_;
// -------------------------------------------------------------------

class AggregateFunction final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.AggregateFunction) */ {
 public:
  inline AggregateFunction() : AggregateFunction(nullptr) {}
  ~AggregateFunction() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AggregateFunction* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AggregateFunction));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AggregateFunction(
      ::google::protobuf::internal::ConstantInitialized);

  inline AggregateFunction(const AggregateFunction& from) : AggregateFunction(nullptr, from) {}
  inline AggregateFunction(AggregateFunction&& from) noexcept
      : AggregateFunction(nullptr, std::move(from)) {}
  inline AggregateFunction& operator=(const AggregateFunction& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggregateFunction& operator=(AggregateFunction&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggregateFunction& default_instance() {
    return *reinterpret_cast<const AggregateFunction*>(
        &_AggregateFunction_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 114;
  friend void swap(AggregateFunction& a, AggregateFunction& b) { a.Swap(&b); }
  inline void Swap(AggregateFunction* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggregateFunction* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggregateFunction* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AggregateFunction>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AggregateFunction& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AggregateFunction& from) { AggregateFunction::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AggregateFunction* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.AggregateFunction"; }

 protected:
  explicit AggregateFunction(::google::protobuf::Arena* arena);
  AggregateFunction(::google::protobuf::Arena* arena, const AggregateFunction& from);
  AggregateFunction(::google::protobuf::Arena* arena, AggregateFunction&& from) noexcept
      : AggregateFunction(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using AggregationInvocation = AggregateFunction_AggregationInvocation;
  static constexpr AggregationInvocation AGGREGATION_INVOCATION_UNSPECIFIED = AggregateFunction_AggregationInvocation_AGGREGATION_INVOCATION_UNSPECIFIED;
  static constexpr AggregationInvocation AGGREGATION_INVOCATION_ALL = AggregateFunction_AggregationInvocation_AGGREGATION_INVOCATION_ALL;
  static constexpr AggregationInvocation AGGREGATION_INVOCATION_DISTINCT = AggregateFunction_AggregationInvocation_AGGREGATION_INVOCATION_DISTINCT;
  static inline bool AggregationInvocation_IsValid(int value) {
    return AggregateFunction_AggregationInvocation_IsValid(value);
  }
  static constexpr AggregationInvocation AggregationInvocation_MIN = AggregateFunction_AggregationInvocation_AggregationInvocation_MIN;
  static constexpr AggregationInvocation AggregationInvocation_MAX = AggregateFunction_AggregationInvocation_AggregationInvocation_MAX;
  static constexpr int AggregationInvocation_ARRAYSIZE = AggregateFunction_AggregationInvocation_AggregationInvocation_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* AggregationInvocation_descriptor() {
    return AggregateFunction_AggregationInvocation_descriptor();
  }
  template <typename T>
  static inline const std::string& AggregationInvocation_Name(T value) {
    return AggregateFunction_AggregationInvocation_Name(value);
  }
  static inline bool AggregationInvocation_Parse(absl::string_view name, AggregationInvocation* value) {
    return AggregateFunction_AggregationInvocation_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kArgsFieldNumber = 2,
    kSortsFieldNumber = 3,
    kArgumentsFieldNumber = 7,
    kOptionsFieldNumber = 8,
    kOutputTypeFieldNumber = 5,
    kFunctionReferenceFieldNumber = 1,
    kPhaseFieldNumber = 4,
    kInvocationFieldNumber = 6,
  };
  // repeated .substrait.Expression args = 2 [deprecated = true];
  [[deprecated]]  int args_size() const;
  private:
  int _internal_args_size() const;

  public:
  [[deprecated]]  void clear_args() ;
  [[deprecated]] ::substrait::Expression* mutable_args(int index);
  [[deprecated]] ::google::protobuf::RepeatedPtrField<::substrait::Expression>* mutable_args();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression>& _internal_args() const;
  ::google::protobuf::RepeatedPtrField<::substrait::Expression>* _internal_mutable_args();
  public:
  [[deprecated]] const ::substrait::Expression& args(int index) const;
  [[deprecated]] ::substrait::Expression* add_args();
  [[deprecated]] const ::google::protobuf::RepeatedPtrField<::substrait::Expression>& args() const;
  // repeated .substrait.SortField sorts = 3;
  int sorts_size() const;
  private:
  int _internal_sorts_size() const;

  public:
  void clear_sorts() ;
  ::substrait::SortField* mutable_sorts(int index);
  ::google::protobuf::RepeatedPtrField<::substrait::SortField>* mutable_sorts();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::SortField>& _internal_sorts() const;
  ::google::protobuf::RepeatedPtrField<::substrait::SortField>* _internal_mutable_sorts();
  public:
  const ::substrait::SortField& sorts(int index) const;
  ::substrait::SortField* add_sorts();
  const ::google::protobuf::RepeatedPtrField<::substrait::SortField>& sorts() const;
  // repeated .substrait.FunctionArgument arguments = 7;
  int arguments_size() const;
  private:
  int _internal_arguments_size() const;

  public:
  void clear_arguments() ;
  ::substrait::FunctionArgument* mutable_arguments(int index);
  ::google::protobuf::RepeatedPtrField<::substrait::FunctionArgument>* mutable_arguments();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::FunctionArgument>& _internal_arguments() const;
  ::google::protobuf::RepeatedPtrField<::substrait::FunctionArgument>* _internal_mutable_arguments();
  public:
  const ::substrait::FunctionArgument& arguments(int index) const;
  ::substrait::FunctionArgument* add_arguments();
  const ::google::protobuf::RepeatedPtrField<::substrait::FunctionArgument>& arguments() const;
  // repeated .substrait.FunctionOption options = 8;
  int options_size() const;
  private:
  int _internal_options_size() const;

  public:
  void clear_options() ;
  ::substrait::FunctionOption* mutable_options(int index);
  ::google::protobuf::RepeatedPtrField<::substrait::FunctionOption>* mutable_options();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::FunctionOption>& _internal_options() const;
  ::google::protobuf::RepeatedPtrField<::substrait::FunctionOption>* _internal_mutable_options();
  public:
  const ::substrait::FunctionOption& options(int index) const;
  ::substrait::FunctionOption* add_options();
  const ::google::protobuf::RepeatedPtrField<::substrait::FunctionOption>& options() const;
  // .substrait.Type output_type = 5;
  bool has_output_type() const;
  void clear_output_type() ;
  const ::substrait::Type& output_type() const;
  [[nodiscard]] ::substrait::Type* release_output_type();
  ::substrait::Type* mutable_output_type();
  void set_allocated_output_type(::substrait::Type* value);
  void unsafe_arena_set_allocated_output_type(::substrait::Type* value);
  ::substrait::Type* unsafe_arena_release_output_type();

  private:
  const ::substrait::Type& _internal_output_type() const;
  ::substrait::Type* _internal_mutable_output_type();

  public:
  // uint32 function_reference = 1;
  void clear_function_reference() ;
  ::uint32_t function_reference() const;
  void set_function_reference(::uint32_t value);

  private:
  ::uint32_t _internal_function_reference() const;
  void _internal_set_function_reference(::uint32_t value);

  public:
  // .substrait.AggregationPhase phase = 4;
  void clear_phase() ;
  ::substrait::AggregationPhase phase() const;
  void set_phase(::substrait::AggregationPhase value);

  private:
  ::substrait::AggregationPhase _internal_phase() const;
  void _internal_set_phase(::substrait::AggregationPhase value);

  public:
  // .substrait.AggregateFunction.AggregationInvocation invocation = 6;
  void clear_invocation() ;
  ::substrait::AggregateFunction_AggregationInvocation invocation() const;
  void set_invocation(::substrait::AggregateFunction_AggregationInvocation value);

  private:
  ::substrait::AggregateFunction_AggregationInvocation _internal_invocation() const;
  void _internal_set_invocation(::substrait::AggregateFunction_AggregationInvocation value);

  public:
  // @@protoc_insertion_point(class_scope:substrait.AggregateFunction)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 5,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AggregateFunction& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::substrait::Expression > args_;
    ::google::protobuf::RepeatedPtrField< ::substrait::SortField > sorts_;
    ::google::protobuf::RepeatedPtrField< ::substrait::FunctionArgument > arguments_;
    ::google::protobuf::RepeatedPtrField< ::substrait::FunctionOption > options_;
    ::substrait::Type* output_type_;
    ::uint32_t function_reference_;
    int phase_;
    int invocation_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull AggregateFunction_class_data_;
// -------------------------------------------------------------------

class AggregateRel final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.AggregateRel) */ {
 public:
  inline AggregateRel() : AggregateRel(nullptr) {}
  ~AggregateRel() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AggregateRel* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AggregateRel));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AggregateRel(
      ::google::protobuf::internal::ConstantInitialized);

  inline AggregateRel(const AggregateRel& from) : AggregateRel(nullptr, from) {}
  inline AggregateRel(AggregateRel&& from) noexcept
      : AggregateRel(nullptr, std::move(from)) {}
  inline AggregateRel& operator=(const AggregateRel& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggregateRel& operator=(AggregateRel&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggregateRel& default_instance() {
    return *reinterpret_cast<const AggregateRel*>(
        &_AggregateRel_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(AggregateRel& a, AggregateRel& b) { a.Swap(&b); }
  inline void Swap(AggregateRel* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggregateRel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggregateRel* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AggregateRel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AggregateRel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AggregateRel& from) { AggregateRel::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AggregateRel* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.AggregateRel"; }

 protected:
  explicit AggregateRel(::google::protobuf::Arena* arena);
  AggregateRel(::google::protobuf::Arena* arena, const AggregateRel& from);
  AggregateRel(::google::protobuf::Arena* arena, AggregateRel&& from) noexcept
      : AggregateRel(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Grouping = AggregateRel_Grouping;
  using Measure = AggregateRel_Measure;

  // accessors -------------------------------------------------------
  enum : int {
    kGroupingsFieldNumber = 3,
    kMeasuresFieldNumber = 4,
    kCommonFieldNumber = 1,
    kInputFieldNumber = 2,
    kAdvancedExtensionFieldNumber = 10,
  };
  // repeated .substrait.AggregateRel.Grouping groupings = 3;
  int groupings_size() const;
  private:
  int _internal_groupings_size() const;

  public:
  void clear_groupings() ;
  ::substrait::AggregateRel_Grouping* mutable_groupings(int index);
  ::google::protobuf::RepeatedPtrField<::substrait::AggregateRel_Grouping>* mutable_groupings();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::AggregateRel_Grouping>& _internal_groupings() const;
  ::google::protobuf::RepeatedPtrField<::substrait::AggregateRel_Grouping>* _internal_mutable_groupings();
  public:
  const ::substrait::AggregateRel_Grouping& groupings(int index) const;
  ::substrait::AggregateRel_Grouping* add_groupings();
  const ::google::protobuf::RepeatedPtrField<::substrait::AggregateRel_Grouping>& groupings() const;
  // repeated .substrait.AggregateRel.Measure measures = 4;
  int measures_size() const;
  private:
  int _internal_measures_size() const;

  public:
  void clear_measures() ;
  ::substrait::AggregateRel_Measure* mutable_measures(int index);
  ::google::protobuf::RepeatedPtrField<::substrait::AggregateRel_Measure>* mutable_measures();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::AggregateRel_Measure>& _internal_measures() const;
  ::google::protobuf::RepeatedPtrField<::substrait::AggregateRel_Measure>* _internal_mutable_measures();
  public:
  const ::substrait::AggregateRel_Measure& measures(int index) const;
  ::substrait::AggregateRel_Measure* add_measures();
  const ::google::protobuf::RepeatedPtrField<::substrait::AggregateRel_Measure>& measures() const;
  // .substrait.RelCommon common = 1;
  bool has_common() const;
  void clear_common() ;
  const ::substrait::RelCommon& common() const;
  [[nodiscard]] ::substrait::RelCommon* release_common();
  ::substrait::RelCommon* mutable_common();
  void set_allocated_common(::substrait::RelCommon* value);
  void unsafe_arena_set_allocated_common(::substrait::RelCommon* value);
  ::substrait::RelCommon* unsafe_arena_release_common();

  private:
  const ::substrait::RelCommon& _internal_common() const;
  ::substrait::RelCommon* _internal_mutable_common();

  public:
  // .substrait.Rel input = 2;
  bool has_input() const;
  void clear_input() ;
  const ::substrait::Rel& input() const;
  [[nodiscard]] ::substrait::Rel* release_input();
  ::substrait::Rel* mutable_input();
  void set_allocated_input(::substrait::Rel* value);
  void unsafe_arena_set_allocated_input(::substrait::Rel* value);
  ::substrait::Rel* unsafe_arena_release_input();

  private:
  const ::substrait::Rel& _internal_input() const;
  ::substrait::Rel* _internal_mutable_input();

  public:
  // .substrait.extensions.AdvancedExtension advanced_extension = 10;
  bool has_advanced_extension() const;
  void clear_advanced_extension() ;
  const ::substrait::extensions::AdvancedExtension& advanced_extension() const;
  [[nodiscard]] ::substrait::extensions::AdvancedExtension* release_advanced_extension();
  ::substrait::extensions::AdvancedExtension* mutable_advanced_extension();
  void set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value);
  void unsafe_arena_set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value);
  ::substrait::extensions::AdvancedExtension* unsafe_arena_release_advanced_extension();

  private:
  const ::substrait::extensions::AdvancedExtension& _internal_advanced_extension() const;
  ::substrait::extensions::AdvancedExtension* _internal_mutable_advanced_extension();

  public:
  // @@protoc_insertion_point(class_scope:substrait.AggregateRel)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 5, 5,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AggregateRel& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::substrait::AggregateRel_Grouping > groupings_;
    ::google::protobuf::RepeatedPtrField< ::substrait::AggregateRel_Measure > measures_;
    ::substrait::RelCommon* common_;
    ::substrait::Rel* input_;
    ::substrait::extensions::AdvancedExtension* advanced_extension_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull AggregateRel_class_data_;
// -------------------------------------------------------------------

class AggregateRel_Grouping final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.AggregateRel.Grouping) */ {
 public:
  inline AggregateRel_Grouping() : AggregateRel_Grouping(nullptr) {}
  ~AggregateRel_Grouping() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AggregateRel_Grouping* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AggregateRel_Grouping));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AggregateRel_Grouping(
      ::google::protobuf::internal::ConstantInitialized);

  inline AggregateRel_Grouping(const AggregateRel_Grouping& from) : AggregateRel_Grouping(nullptr, from) {}
  inline AggregateRel_Grouping(AggregateRel_Grouping&& from) noexcept
      : AggregateRel_Grouping(nullptr, std::move(from)) {}
  inline AggregateRel_Grouping& operator=(const AggregateRel_Grouping& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggregateRel_Grouping& operator=(AggregateRel_Grouping&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggregateRel_Grouping& default_instance() {
    return *reinterpret_cast<const AggregateRel_Grouping*>(
        &_AggregateRel_Grouping_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(AggregateRel_Grouping& a, AggregateRel_Grouping& b) { a.Swap(&b); }
  inline void Swap(AggregateRel_Grouping* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggregateRel_Grouping* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggregateRel_Grouping* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AggregateRel_Grouping>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AggregateRel_Grouping& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AggregateRel_Grouping& from) { AggregateRel_Grouping::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AggregateRel_Grouping* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.AggregateRel.Grouping"; }

 protected:
  explicit AggregateRel_Grouping(::google::protobuf::Arena* arena);
  AggregateRel_Grouping(::google::protobuf::Arena* arena, const AggregateRel_Grouping& from);
  AggregateRel_Grouping(::google::protobuf::Arena* arena, AggregateRel_Grouping&& from) noexcept
      : AggregateRel_Grouping(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGroupingExpressionsFieldNumber = 1,
  };
  // repeated .substrait.Expression grouping_expressions = 1;
  int grouping_expressions_size() const;
  private:
  int _internal_grouping_expressions_size() const;

  public:
  void clear_grouping_expressions() ;
  ::substrait::Expression* mutable_grouping_expressions(int index);
  ::google::protobuf::RepeatedPtrField<::substrait::Expression>* mutable_grouping_expressions();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression>& _internal_grouping_expressions() const;
  ::google::protobuf::RepeatedPtrField<::substrait::Expression>* _internal_mutable_grouping_expressions();
  public:
  const ::substrait::Expression& grouping_expressions(int index) const;
  ::substrait::Expression* add_grouping_expressions();
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression>& grouping_expressions() const;
  // @@protoc_insertion_point(class_scope:substrait.AggregateRel.Grouping)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AggregateRel_Grouping& from_msg);
    ::google::protobuf::RepeatedPtrField< ::substrait::Expression > grouping_expressions_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull AggregateRel_Grouping_class_data_;
// -------------------------------------------------------------------

class AggregateRel_Measure final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.AggregateRel.Measure) */ {
 public:
  inline AggregateRel_Measure() : AggregateRel_Measure(nullptr) {}
  ~AggregateRel_Measure() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AggregateRel_Measure* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AggregateRel_Measure));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AggregateRel_Measure(
      ::google::protobuf::internal::ConstantInitialized);

  inline AggregateRel_Measure(const AggregateRel_Measure& from) : AggregateRel_Measure(nullptr, from) {}
  inline AggregateRel_Measure(AggregateRel_Measure&& from) noexcept
      : AggregateRel_Measure(nullptr, std::move(from)) {}
  inline AggregateRel_Measure& operator=(const AggregateRel_Measure& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggregateRel_Measure& operator=(AggregateRel_Measure&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggregateRel_Measure& default_instance() {
    return *reinterpret_cast<const AggregateRel_Measure*>(
        &_AggregateRel_Measure_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(AggregateRel_Measure& a, AggregateRel_Measure& b) { a.Swap(&b); }
  inline void Swap(AggregateRel_Measure* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggregateRel_Measure* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggregateRel_Measure* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AggregateRel_Measure>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AggregateRel_Measure& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AggregateRel_Measure& from) { AggregateRel_Measure::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AggregateRel_Measure* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.AggregateRel.Measure"; }

 protected:
  explicit AggregateRel_Measure(::google::protobuf::Arena* arena);
  AggregateRel_Measure(::google::protobuf::Arena* arena, const AggregateRel_Measure& from);
  AggregateRel_Measure(::google::protobuf::Arena* arena, AggregateRel_Measure&& from) noexcept
      : AggregateRel_Measure(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMeasureFieldNumber = 1,
    kFilterFieldNumber = 2,
  };
  // .substrait.AggregateFunction measure = 1;
  bool has_measure() const;
  void clear_measure() ;
  const ::substrait::AggregateFunction& measure() const;
  [[nodiscard]] ::substrait::AggregateFunction* release_measure();
  ::substrait::AggregateFunction* mutable_measure();
  void set_allocated_measure(::substrait::AggregateFunction* value);
  void unsafe_arena_set_allocated_measure(::substrait::AggregateFunction* value);
  ::substrait::AggregateFunction* unsafe_arena_release_measure();

  private:
  const ::substrait::AggregateFunction& _internal_measure() const;
  ::substrait::AggregateFunction* _internal_mutable_measure();

  public:
  // .substrait.Expression filter = 2;
  bool has_filter() const;
  void clear_filter() ;
  const ::substrait::Expression& filter() const;
  [[nodiscard]] ::substrait::Expression* release_filter();
  ::substrait::Expression* mutable_filter();
  void set_allocated_filter(::substrait::Expression* value);
  void unsafe_arena_set_allocated_filter(::substrait::Expression* value);
  ::substrait::Expression* unsafe_arena_release_filter();

  private:
  const ::substrait::Expression& _internal_filter() const;
  ::substrait::Expression* _internal_mutable_filter();

  public:
  // @@protoc_insertion_point(class_scope:substrait.AggregateRel.Measure)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AggregateRel_Measure& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::substrait::AggregateFunction* measure_;
    ::substrait::Expression* filter_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull AggregateRel_Measure_class_data_;
// -------------------------------------------------------------------

class ComparisonJoinKey final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.ComparisonJoinKey) */ {
 public:
  inline ComparisonJoinKey() : ComparisonJoinKey(nullptr) {}
  ~ComparisonJoinKey() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ComparisonJoinKey* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ComparisonJoinKey));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ComparisonJoinKey(
      ::google::protobuf::internal::ConstantInitialized);

  inline ComparisonJoinKey(const ComparisonJoinKey& from) : ComparisonJoinKey(nullptr, from) {}
  inline ComparisonJoinKey(ComparisonJoinKey&& from) noexcept
      : ComparisonJoinKey(nullptr, std::move(from)) {}
  inline ComparisonJoinKey& operator=(const ComparisonJoinKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline ComparisonJoinKey& operator=(ComparisonJoinKey&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ComparisonJoinKey& default_instance() {
    return *reinterpret_cast<const ComparisonJoinKey*>(
        &_ComparisonJoinKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 48;
  friend void swap(ComparisonJoinKey& a, ComparisonJoinKey& b) { a.Swap(&b); }
  inline void Swap(ComparisonJoinKey* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ComparisonJoinKey* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ComparisonJoinKey* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ComparisonJoinKey>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ComparisonJoinKey& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ComparisonJoinKey& from) { ComparisonJoinKey::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ComparisonJoinKey* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.ComparisonJoinKey"; }

 protected:
  explicit ComparisonJoinKey(::google::protobuf::Arena* arena);
  ComparisonJoinKey(::google::protobuf::Arena* arena, const ComparisonJoinKey& from);
  ComparisonJoinKey(::google::protobuf::Arena* arena, ComparisonJoinKey&& from) noexcept
      : ComparisonJoinKey(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using ComparisonType = ComparisonJoinKey_ComparisonType;
  using SimpleComparisonType = ComparisonJoinKey_SimpleComparisonType;
  static constexpr SimpleComparisonType SIMPLE_COMPARISON_TYPE_UNSPECIFIED = ComparisonJoinKey_SimpleComparisonType_SIMPLE_COMPARISON_TYPE_UNSPECIFIED;
  static constexpr SimpleComparisonType SIMPLE_COMPARISON_TYPE_EQ = ComparisonJoinKey_SimpleComparisonType_SIMPLE_COMPARISON_TYPE_EQ;
  static constexpr SimpleComparisonType SIMPLE_COMPARISON_TYPE_IS_NOT_DISTINCT_FROM = ComparisonJoinKey_SimpleComparisonType_SIMPLE_COMPARISON_TYPE_IS_NOT_DISTINCT_FROM;
  static constexpr SimpleComparisonType SIMPLE_COMPARISON_TYPE_MIGHT_EQUAL = ComparisonJoinKey_SimpleComparisonType_SIMPLE_COMPARISON_TYPE_MIGHT_EQUAL;
  static inline bool SimpleComparisonType_IsValid(int value) {
    return ComparisonJoinKey_SimpleComparisonType_IsValid(value);
  }
  static constexpr SimpleComparisonType SimpleComparisonType_MIN = ComparisonJoinKey_SimpleComparisonType_SimpleComparisonType_MIN;
  static constexpr SimpleComparisonType SimpleComparisonType_MAX = ComparisonJoinKey_SimpleComparisonType_SimpleComparisonType_MAX;
  static constexpr int SimpleComparisonType_ARRAYSIZE = ComparisonJoinKey_SimpleComparisonType_SimpleComparisonType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* SimpleComparisonType_descriptor() {
    return ComparisonJoinKey_SimpleComparisonType_descriptor();
  }
  template <typename T>
  static inline const std::string& SimpleComparisonType_Name(T value) {
    return ComparisonJoinKey_SimpleComparisonType_Name(value);
  }
  static inline bool SimpleComparisonType_Parse(absl::string_view name, SimpleComparisonType* value) {
    return ComparisonJoinKey_SimpleComparisonType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kLeftFieldNumber = 1,
    kRightFieldNumber = 2,
    kComparisonFieldNumber = 3,
  };
  // .substrait.Expression.FieldReference left = 1;
  bool has_left() const;
  void clear_left() ;
  const ::substrait::Expression_FieldReference& left() const;
  [[nodiscard]] ::substrait::Expression_FieldReference* release_left();
  ::substrait::Expression_FieldReference* mutable_left();
  void set_allocated_left(::substrait::Expression_FieldReference* value);
  void unsafe_arena_set_allocated_left(::substrait::Expression_FieldReference* value);
  ::substrait::Expression_FieldReference* unsafe_arena_release_left();

  private:
  const ::substrait::Expression_FieldReference& _internal_left() const;
  ::substrait::Expression_FieldReference* _internal_mutable_left();

  public:
  // .substrait.Expression.FieldReference right = 2;
  bool has_right() const;
  void clear_right() ;
  const ::substrait::Expression_FieldReference& right() const;
  [[nodiscard]] ::substrait::Expression_FieldReference* release_right();
  ::substrait::Expression_FieldReference* mutable_right();
  void set_allocated_right(::substrait::Expression_FieldReference* value);
  void unsafe_arena_set_allocated_right(::substrait::Expression_FieldReference* value);
  ::substrait::Expression_FieldReference* unsafe_arena_release_right();

  private:
  const ::substrait::Expression_FieldReference& _internal_right() const;
  ::substrait::Expression_FieldReference* _internal_mutable_right();

  public:
  // .substrait.ComparisonJoinKey.ComparisonType comparison = 3;
  bool has_comparison() const;
  void clear_comparison() ;
  const ::substrait::ComparisonJoinKey_ComparisonType& comparison() const;
  [[nodiscard]] ::substrait::ComparisonJoinKey_ComparisonType* release_comparison();
  ::substrait::ComparisonJoinKey_ComparisonType* mutable_comparison();
  void set_allocated_comparison(::substrait::ComparisonJoinKey_ComparisonType* value);
  void unsafe_arena_set_allocated_comparison(::substrait::ComparisonJoinKey_ComparisonType* value);
  ::substrait::ComparisonJoinKey_ComparisonType* unsafe_arena_release_comparison();

  private:
  const ::substrait::ComparisonJoinKey_ComparisonType& _internal_comparison() const;
  ::substrait::ComparisonJoinKey_ComparisonType* _internal_mutable_comparison();

  public:
  // @@protoc_insertion_point(class_scope:substrait.ComparisonJoinKey)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ComparisonJoinKey& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::substrait::Expression_FieldReference* left_;
    ::substrait::Expression_FieldReference* right_;
    ::substrait::ComparisonJoinKey_ComparisonType* comparison_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ComparisonJoinKey_class_data_;
// -------------------------------------------------------------------

class ConsistentPartitionWindowRel final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.ConsistentPartitionWindowRel) */ {
 public:
  inline ConsistentPartitionWindowRel() : ConsistentPartitionWindowRel(nullptr) {}
  ~ConsistentPartitionWindowRel() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ConsistentPartitionWindowRel* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ConsistentPartitionWindowRel));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ConsistentPartitionWindowRel(
      ::google::protobuf::internal::ConstantInitialized);

  inline ConsistentPartitionWindowRel(const ConsistentPartitionWindowRel& from) : ConsistentPartitionWindowRel(nullptr, from) {}
  inline ConsistentPartitionWindowRel(ConsistentPartitionWindowRel&& from) noexcept
      : ConsistentPartitionWindowRel(nullptr, std::move(from)) {}
  inline ConsistentPartitionWindowRel& operator=(const ConsistentPartitionWindowRel& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConsistentPartitionWindowRel& operator=(ConsistentPartitionWindowRel&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConsistentPartitionWindowRel& default_instance() {
    return *reinterpret_cast<const ConsistentPartitionWindowRel*>(
        &_ConsistentPartitionWindowRel_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(ConsistentPartitionWindowRel& a, ConsistentPartitionWindowRel& b) { a.Swap(&b); }
  inline void Swap(ConsistentPartitionWindowRel* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConsistentPartitionWindowRel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConsistentPartitionWindowRel* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ConsistentPartitionWindowRel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ConsistentPartitionWindowRel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ConsistentPartitionWindowRel& from) { ConsistentPartitionWindowRel::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ConsistentPartitionWindowRel* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.ConsistentPartitionWindowRel"; }

 protected:
  explicit ConsistentPartitionWindowRel(::google::protobuf::Arena* arena);
  ConsistentPartitionWindowRel(::google::protobuf::Arena* arena, const ConsistentPartitionWindowRel& from);
  ConsistentPartitionWindowRel(::google::protobuf::Arena* arena, ConsistentPartitionWindowRel&& from) noexcept
      : ConsistentPartitionWindowRel(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using WindowRelFunction = ConsistentPartitionWindowRel_WindowRelFunction;

  // accessors -------------------------------------------------------
  enum : int {
    kWindowFunctionsFieldNumber = 3,
    kPartitionExpressionsFieldNumber = 4,
    kSortsFieldNumber = 5,
    kCommonFieldNumber = 1,
    kInputFieldNumber = 2,
    kAdvancedExtensionFieldNumber = 10,
  };
  // repeated .substrait.ConsistentPartitionWindowRel.WindowRelFunction window_functions = 3;
  int window_functions_size() const;
  private:
  int _internal_window_functions_size() const;

  public:
  void clear_window_functions() ;
  ::substrait::ConsistentPartitionWindowRel_WindowRelFunction* mutable_window_functions(int index);
  ::google::protobuf::RepeatedPtrField<::substrait::ConsistentPartitionWindowRel_WindowRelFunction>* mutable_window_functions();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::ConsistentPartitionWindowRel_WindowRelFunction>& _internal_window_functions() const;
  ::google::protobuf::RepeatedPtrField<::substrait::ConsistentPartitionWindowRel_WindowRelFunction>* _internal_mutable_window_functions();
  public:
  const ::substrait::ConsistentPartitionWindowRel_WindowRelFunction& window_functions(int index) const;
  ::substrait::ConsistentPartitionWindowRel_WindowRelFunction* add_window_functions();
  const ::google::protobuf::RepeatedPtrField<::substrait::ConsistentPartitionWindowRel_WindowRelFunction>& window_functions() const;
  // repeated .substrait.Expression partition_expressions = 4;
  int partition_expressions_size() const;
  private:
  int _internal_partition_expressions_size() const;

  public:
  void clear_partition_expressions() ;
  ::substrait::Expression* mutable_partition_expressions(int index);
  ::google::protobuf::RepeatedPtrField<::substrait::Expression>* mutable_partition_expressions();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression>& _internal_partition_expressions() const;
  ::google::protobuf::RepeatedPtrField<::substrait::Expression>* _internal_mutable_partition_expressions();
  public:
  const ::substrait::Expression& partition_expressions(int index) const;
  ::substrait::Expression* add_partition_expressions();
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression>& partition_expressions() const;
  // repeated .substrait.SortField sorts = 5;
  int sorts_size() const;
  private:
  int _internal_sorts_size() const;

  public:
  void clear_sorts() ;
  ::substrait::SortField* mutable_sorts(int index);
  ::google::protobuf::RepeatedPtrField<::substrait::SortField>* mutable_sorts();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::SortField>& _internal_sorts() const;
  ::google::protobuf::RepeatedPtrField<::substrait::SortField>* _internal_mutable_sorts();
  public:
  const ::substrait::SortField& sorts(int index) const;
  ::substrait::SortField* add_sorts();
  const ::google::protobuf::RepeatedPtrField<::substrait::SortField>& sorts() const;
  // .substrait.RelCommon common = 1;
  bool has_common() const;
  void clear_common() ;
  const ::substrait::RelCommon& common() const;
  [[nodiscard]] ::substrait::RelCommon* release_common();
  ::substrait::RelCommon* mutable_common();
  void set_allocated_common(::substrait::RelCommon* value);
  void unsafe_arena_set_allocated_common(::substrait::RelCommon* value);
  ::substrait::RelCommon* unsafe_arena_release_common();

  private:
  const ::substrait::RelCommon& _internal_common() const;
  ::substrait::RelCommon* _internal_mutable_common();

  public:
  // .substrait.Rel input = 2;
  bool has_input() const;
  void clear_input() ;
  const ::substrait::Rel& input() const;
  [[nodiscard]] ::substrait::Rel* release_input();
  ::substrait::Rel* mutable_input();
  void set_allocated_input(::substrait::Rel* value);
  void unsafe_arena_set_allocated_input(::substrait::Rel* value);
  ::substrait::Rel* unsafe_arena_release_input();

  private:
  const ::substrait::Rel& _internal_input() const;
  ::substrait::Rel* _internal_mutable_input();

  public:
  // .substrait.extensions.AdvancedExtension advanced_extension = 10;
  bool has_advanced_extension() const;
  void clear_advanced_extension() ;
  const ::substrait::extensions::AdvancedExtension& advanced_extension() const;
  [[nodiscard]] ::substrait::extensions::AdvancedExtension* release_advanced_extension();
  ::substrait::extensions::AdvancedExtension* mutable_advanced_extension();
  void set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value);
  void unsafe_arena_set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value);
  ::substrait::extensions::AdvancedExtension* unsafe_arena_release_advanced_extension();

  private:
  const ::substrait::extensions::AdvancedExtension& _internal_advanced_extension() const;
  ::substrait::extensions::AdvancedExtension* _internal_mutable_advanced_extension();

  public:
  // @@protoc_insertion_point(class_scope:substrait.ConsistentPartitionWindowRel)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 6,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ConsistentPartitionWindowRel& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::substrait::ConsistentPartitionWindowRel_WindowRelFunction > window_functions_;
    ::google::protobuf::RepeatedPtrField< ::substrait::Expression > partition_expressions_;
    ::google::protobuf::RepeatedPtrField< ::substrait::SortField > sorts_;
    ::substrait::RelCommon* common_;
    ::substrait::Rel* input_;
    ::substrait::extensions::AdvancedExtension* advanced_extension_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ConsistentPartitionWindowRel_class_data_;
// -------------------------------------------------------------------

class ConsistentPartitionWindowRel_WindowRelFunction final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.ConsistentPartitionWindowRel.WindowRelFunction) */ {
 public:
  inline ConsistentPartitionWindowRel_WindowRelFunction() : ConsistentPartitionWindowRel_WindowRelFunction(nullptr) {}
  ~ConsistentPartitionWindowRel_WindowRelFunction() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ConsistentPartitionWindowRel_WindowRelFunction* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ConsistentPartitionWindowRel_WindowRelFunction));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ConsistentPartitionWindowRel_WindowRelFunction(
      ::google::protobuf::internal::ConstantInitialized);

  inline ConsistentPartitionWindowRel_WindowRelFunction(const ConsistentPartitionWindowRel_WindowRelFunction& from) : ConsistentPartitionWindowRel_WindowRelFunction(nullptr, from) {}
  inline ConsistentPartitionWindowRel_WindowRelFunction(ConsistentPartitionWindowRel_WindowRelFunction&& from) noexcept
      : ConsistentPartitionWindowRel_WindowRelFunction(nullptr, std::move(from)) {}
  inline ConsistentPartitionWindowRel_WindowRelFunction& operator=(const ConsistentPartitionWindowRel_WindowRelFunction& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConsistentPartitionWindowRel_WindowRelFunction& operator=(ConsistentPartitionWindowRel_WindowRelFunction&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConsistentPartitionWindowRel_WindowRelFunction& default_instance() {
    return *reinterpret_cast<const ConsistentPartitionWindowRel_WindowRelFunction*>(
        &_ConsistentPartitionWindowRel_WindowRelFunction_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(ConsistentPartitionWindowRel_WindowRelFunction& a, ConsistentPartitionWindowRel_WindowRelFunction& b) { a.Swap(&b); }
  inline void Swap(ConsistentPartitionWindowRel_WindowRelFunction* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConsistentPartitionWindowRel_WindowRelFunction* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConsistentPartitionWindowRel_WindowRelFunction* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ConsistentPartitionWindowRel_WindowRelFunction>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ConsistentPartitionWindowRel_WindowRelFunction& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ConsistentPartitionWindowRel_WindowRelFunction& from) { ConsistentPartitionWindowRel_WindowRelFunction::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ConsistentPartitionWindowRel_WindowRelFunction* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.ConsistentPartitionWindowRel.WindowRelFunction"; }

 protected:
  explicit ConsistentPartitionWindowRel_WindowRelFunction(::google::protobuf::Arena* arena);
  ConsistentPartitionWindowRel_WindowRelFunction(::google::protobuf::Arena* arena, const ConsistentPartitionWindowRel_WindowRelFunction& from);
  ConsistentPartitionWindowRel_WindowRelFunction(::google::protobuf::Arena* arena, ConsistentPartitionWindowRel_WindowRelFunction&& from) noexcept
      : ConsistentPartitionWindowRel_WindowRelFunction(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kArgumentsFieldNumber = 9,
    kOptionsFieldNumber = 11,
    kUpperBoundFieldNumber = 4,
    kLowerBoundFieldNumber = 5,
    kOutputTypeFieldNumber = 7,
    kFunctionReferenceFieldNumber = 1,
    kPhaseFieldNumber = 6,
    kInvocationFieldNumber = 10,
    kBoundsTypeFieldNumber = 12,
  };
  // repeated .substrait.FunctionArgument arguments = 9;
  int arguments_size() const;
  private:
  int _internal_arguments_size() const;

  public:
  void clear_arguments() ;
  ::substrait::FunctionArgument* mutable_arguments(int index);
  ::google::protobuf::RepeatedPtrField<::substrait::FunctionArgument>* mutable_arguments();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::FunctionArgument>& _internal_arguments() const;
  ::google::protobuf::RepeatedPtrField<::substrait::FunctionArgument>* _internal_mutable_arguments();
  public:
  const ::substrait::FunctionArgument& arguments(int index) const;
  ::substrait::FunctionArgument* add_arguments();
  const ::google::protobuf::RepeatedPtrField<::substrait::FunctionArgument>& arguments() const;
  // repeated .substrait.FunctionOption options = 11;
  int options_size() const;
  private:
  int _internal_options_size() const;

  public:
  void clear_options() ;
  ::substrait::FunctionOption* mutable_options(int index);
  ::google::protobuf::RepeatedPtrField<::substrait::FunctionOption>* mutable_options();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::FunctionOption>& _internal_options() const;
  ::google::protobuf::RepeatedPtrField<::substrait::FunctionOption>* _internal_mutable_options();
  public:
  const ::substrait::FunctionOption& options(int index) const;
  ::substrait::FunctionOption* add_options();
  const ::google::protobuf::RepeatedPtrField<::substrait::FunctionOption>& options() const;
  // .substrait.Expression.WindowFunction.Bound upper_bound = 4;
  bool has_upper_bound() const;
  void clear_upper_bound() ;
  const ::substrait::Expression_WindowFunction_Bound& upper_bound() const;
  [[nodiscard]] ::substrait::Expression_WindowFunction_Bound* release_upper_bound();
  ::substrait::Expression_WindowFunction_Bound* mutable_upper_bound();
  void set_allocated_upper_bound(::substrait::Expression_WindowFunction_Bound* value);
  void unsafe_arena_set_allocated_upper_bound(::substrait::Expression_WindowFunction_Bound* value);
  ::substrait::Expression_WindowFunction_Bound* unsafe_arena_release_upper_bound();

  private:
  const ::substrait::Expression_WindowFunction_Bound& _internal_upper_bound() const;
  ::substrait::Expression_WindowFunction_Bound* _internal_mutable_upper_bound();

  public:
  // .substrait.Expression.WindowFunction.Bound lower_bound = 5;
  bool has_lower_bound() const;
  void clear_lower_bound() ;
  const ::substrait::Expression_WindowFunction_Bound& lower_bound() const;
  [[nodiscard]] ::substrait::Expression_WindowFunction_Bound* release_lower_bound();
  ::substrait::Expression_WindowFunction_Bound* mutable_lower_bound();
  void set_allocated_lower_bound(::substrait::Expression_WindowFunction_Bound* value);
  void unsafe_arena_set_allocated_lower_bound(::substrait::Expression_WindowFunction_Bound* value);
  ::substrait::Expression_WindowFunction_Bound* unsafe_arena_release_lower_bound();

  private:
  const ::substrait::Expression_WindowFunction_Bound& _internal_lower_bound() const;
  ::substrait::Expression_WindowFunction_Bound* _internal_mutable_lower_bound();

  public:
  // .substrait.Type output_type = 7;
  bool has_output_type() const;
  void clear_output_type() ;
  const ::substrait::Type& output_type() const;
  [[nodiscard]] ::substrait::Type* release_output_type();
  ::substrait::Type* mutable_output_type();
  void set_allocated_output_type(::substrait::Type* value);
  void unsafe_arena_set_allocated_output_type(::substrait::Type* value);
  ::substrait::Type* unsafe_arena_release_output_type();

  private:
  const ::substrait::Type& _internal_output_type() const;
  ::substrait::Type* _internal_mutable_output_type();

  public:
  // uint32 function_reference = 1;
  void clear_function_reference() ;
  ::uint32_t function_reference() const;
  void set_function_reference(::uint32_t value);

  private:
  ::uint32_t _internal_function_reference() const;
  void _internal_set_function_reference(::uint32_t value);

  public:
  // .substrait.AggregationPhase phase = 6;
  void clear_phase() ;
  ::substrait::AggregationPhase phase() const;
  void set_phase(::substrait::AggregationPhase value);

  private:
  ::substrait::AggregationPhase _internal_phase() const;
  void _internal_set_phase(::substrait::AggregationPhase value);

  public:
  // .substrait.AggregateFunction.AggregationInvocation invocation = 10;
  void clear_invocation() ;
  ::substrait::AggregateFunction_AggregationInvocation invocation() const;
  void set_invocation(::substrait::AggregateFunction_AggregationInvocation value);

  private:
  ::substrait::AggregateFunction_AggregationInvocation _internal_invocation() const;
  void _internal_set_invocation(::substrait::AggregateFunction_AggregationInvocation value);

  public:
  // .substrait.Expression.WindowFunction.BoundsType bounds_type = 12;
  void clear_bounds_type() ;
  ::substrait::Expression_WindowFunction_BoundsType bounds_type() const;
  void set_bounds_type(::substrait::Expression_WindowFunction_BoundsType value);

  private:
  ::substrait::Expression_WindowFunction_BoundsType _internal_bounds_type() const;
  void _internal_set_bounds_type(::substrait::Expression_WindowFunction_BoundsType value);

  public:
  // @@protoc_insertion_point(class_scope:substrait.ConsistentPartitionWindowRel.WindowRelFunction)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 5,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ConsistentPartitionWindowRel_WindowRelFunction& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::substrait::FunctionArgument > arguments_;
    ::google::protobuf::RepeatedPtrField< ::substrait::FunctionOption > options_;
    ::substrait::Expression_WindowFunction_Bound* upper_bound_;
    ::substrait::Expression_WindowFunction_Bound* lower_bound_;
    ::substrait::Type* output_type_;
    ::uint32_t function_reference_;
    int phase_;
    int invocation_;
    int bounds_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ConsistentPartitionWindowRel_WindowRelFunction_class_data_;
// -------------------------------------------------------------------

class CrossRel final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.CrossRel) */ {
 public:
  inline CrossRel() : CrossRel(nullptr) {}
  ~CrossRel() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CrossRel* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CrossRel));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CrossRel(
      ::google::protobuf::internal::ConstantInitialized);

  inline CrossRel(const CrossRel& from) : CrossRel(nullptr, from) {}
  inline CrossRel(CrossRel&& from) noexcept
      : CrossRel(nullptr, std::move(from)) {}
  inline CrossRel& operator=(const CrossRel& from) {
    CopyFrom(from);
    return *this;
  }
  inline CrossRel& operator=(CrossRel&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CrossRel& default_instance() {
    return *reinterpret_cast<const CrossRel*>(
        &_CrossRel_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(CrossRel& a, CrossRel& b) { a.Swap(&b); }
  inline void Swap(CrossRel* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CrossRel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CrossRel* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CrossRel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CrossRel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CrossRel& from) { CrossRel::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CrossRel* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.CrossRel"; }

 protected:
  explicit CrossRel(::google::protobuf::Arena* arena);
  CrossRel(::google::protobuf::Arena* arena, const CrossRel& from);
  CrossRel(::google::protobuf::Arena* arena, CrossRel&& from) noexcept
      : CrossRel(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCommonFieldNumber = 1,
    kLeftFieldNumber = 2,
    kRightFieldNumber = 3,
    kAdvancedExtensionFieldNumber = 10,
  };
  // .substrait.RelCommon common = 1;
  bool has_common() const;
  void clear_common() ;
  const ::substrait::RelCommon& common() const;
  [[nodiscard]] ::substrait::RelCommon* release_common();
  ::substrait::RelCommon* mutable_common();
  void set_allocated_common(::substrait::RelCommon* value);
  void unsafe_arena_set_allocated_common(::substrait::RelCommon* value);
  ::substrait::RelCommon* unsafe_arena_release_common();

  private:
  const ::substrait::RelCommon& _internal_common() const;
  ::substrait::RelCommon* _internal_mutable_common();

  public:
  // .substrait.Rel left = 2;
  bool has_left() const;
  void clear_left() ;
  const ::substrait::Rel& left() const;
  [[nodiscard]] ::substrait::Rel* release_left();
  ::substrait::Rel* mutable_left();
  void set_allocated_left(::substrait::Rel* value);
  void unsafe_arena_set_allocated_left(::substrait::Rel* value);
  ::substrait::Rel* unsafe_arena_release_left();

  private:
  const ::substrait::Rel& _internal_left() const;
  ::substrait::Rel* _internal_mutable_left();

  public:
  // .substrait.Rel right = 3;
  bool has_right() const;
  void clear_right() ;
  const ::substrait::Rel& right() const;
  [[nodiscard]] ::substrait::Rel* release_right();
  ::substrait::Rel* mutable_right();
  void set_allocated_right(::substrait::Rel* value);
  void unsafe_arena_set_allocated_right(::substrait::Rel* value);
  ::substrait::Rel* unsafe_arena_release_right();

  private:
  const ::substrait::Rel& _internal_right() const;
  ::substrait::Rel* _internal_mutable_right();

  public:
  // .substrait.extensions.AdvancedExtension advanced_extension = 10;
  bool has_advanced_extension() const;
  void clear_advanced_extension() ;
  const ::substrait::extensions::AdvancedExtension& advanced_extension() const;
  [[nodiscard]] ::substrait::extensions::AdvancedExtension* release_advanced_extension();
  ::substrait::extensions::AdvancedExtension* mutable_advanced_extension();
  void set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value);
  void unsafe_arena_set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value);
  ::substrait::extensions::AdvancedExtension* unsafe_arena_release_advanced_extension();

  private:
  const ::substrait::extensions::AdvancedExtension& _internal_advanced_extension() const;
  ::substrait::extensions::AdvancedExtension* _internal_mutable_advanced_extension();

  public:
  // @@protoc_insertion_point(class_scope:substrait.CrossRel)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 4,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CrossRel& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::substrait::RelCommon* common_;
    ::substrait::Rel* left_;
    ::substrait::Rel* right_;
    ::substrait::extensions::AdvancedExtension* advanced_extension_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CrossRel_class_data_;
// -------------------------------------------------------------------

class DdlRel final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.DdlRel) */ {
 public:
  inline DdlRel() : DdlRel(nullptr) {}
  ~DdlRel() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DdlRel* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DdlRel));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DdlRel(
      ::google::protobuf::internal::ConstantInitialized);

  inline DdlRel(const DdlRel& from) : DdlRel(nullptr, from) {}
  inline DdlRel(DdlRel&& from) noexcept
      : DdlRel(nullptr, std::move(from)) {}
  inline DdlRel& operator=(const DdlRel& from) {
    CopyFrom(from);
    return *this;
  }
  inline DdlRel& operator=(DdlRel&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DdlRel& default_instance() {
    return *reinterpret_cast<const DdlRel*>(
        &_DdlRel_default_instance_);
  }
  enum WriteTypeCase {
    kNamedObject = 1,
    kExtensionObject = 2,
    WRITE_TYPE_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 45;
  friend void swap(DdlRel& a, DdlRel& b) { a.Swap(&b); }
  inline void Swap(DdlRel* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DdlRel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DdlRel* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DdlRel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DdlRel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DdlRel& from) { DdlRel::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DdlRel* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.DdlRel"; }

 protected:
  explicit DdlRel(::google::protobuf::Arena* arena);
  DdlRel(::google::protobuf::Arena* arena, const DdlRel& from);
  DdlRel(::google::protobuf::Arena* arena, DdlRel&& from) noexcept
      : DdlRel(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using DdlObject = DdlRel_DdlObject;
  static constexpr DdlObject DDL_OBJECT_UNSPECIFIED = DdlRel_DdlObject_DDL_OBJECT_UNSPECIFIED;
  static constexpr DdlObject DDL_OBJECT_TABLE = DdlRel_DdlObject_DDL_OBJECT_TABLE;
  static constexpr DdlObject DDL_OBJECT_VIEW = DdlRel_DdlObject_DDL_OBJECT_VIEW;
  static inline bool DdlObject_IsValid(int value) {
    return DdlRel_DdlObject_IsValid(value);
  }
  static constexpr DdlObject DdlObject_MIN = DdlRel_DdlObject_DdlObject_MIN;
  static constexpr DdlObject DdlObject_MAX = DdlRel_DdlObject_DdlObject_MAX;
  static constexpr int DdlObject_ARRAYSIZE = DdlRel_DdlObject_DdlObject_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* DdlObject_descriptor() {
    return DdlRel_DdlObject_descriptor();
  }
  template <typename T>
  static inline const std::string& DdlObject_Name(T value) {
    return DdlRel_DdlObject_Name(value);
  }
  static inline bool DdlObject_Parse(absl::string_view name, DdlObject* value) {
    return DdlRel_DdlObject_Parse(name, value);
  }
  using DdlOp = DdlRel_DdlOp;
  static constexpr DdlOp DDL_OP_UNSPECIFIED = DdlRel_DdlOp_DDL_OP_UNSPECIFIED;
  static constexpr DdlOp DDL_OP_CREATE = DdlRel_DdlOp_DDL_OP_CREATE;
  static constexpr DdlOp DDL_OP_CREATE_OR_REPLACE = DdlRel_DdlOp_DDL_OP_CREATE_OR_REPLACE;
  static constexpr DdlOp DDL_OP_ALTER = DdlRel_DdlOp_DDL_OP_ALTER;
  static constexpr DdlOp DDL_OP_DROP = DdlRel_DdlOp_DDL_OP_DROP;
  static constexpr DdlOp DDL_OP_DROP_IF_EXIST = DdlRel_DdlOp_DDL_OP_DROP_IF_EXIST;
  static inline bool DdlOp_IsValid(int value) {
    return DdlRel_DdlOp_IsValid(value);
  }
  static constexpr DdlOp DdlOp_MIN = DdlRel_DdlOp_DdlOp_MIN;
  static constexpr DdlOp DdlOp_MAX = DdlRel_DdlOp_DdlOp_MAX;
  static constexpr int DdlOp_ARRAYSIZE = DdlRel_DdlOp_DdlOp_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* DdlOp_descriptor() {
    return DdlRel_DdlOp_descriptor();
  }
  template <typename T>
  static inline const std::string& DdlOp_Name(T value) {
    return DdlRel_DdlOp_Name(value);
  }
  static inline bool DdlOp_Parse(absl::string_view name, DdlOp* value) {
    return DdlRel_DdlOp_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kTableSchemaFieldNumber = 3,
    kTableDefaultsFieldNumber = 4,
    kViewDefinitionFieldNumber = 7,
    kCommonFieldNumber = 8,
    kObjectFieldNumber = 5,
    kOpFieldNumber = 6,
    kNamedObjectFieldNumber = 1,
    kExtensionObjectFieldNumber = 2,
  };
  // .substrait.NamedStruct table_schema = 3;
  bool has_table_schema() const;
  void clear_table_schema() ;
  const ::substrait::NamedStruct& table_schema() const;
  [[nodiscard]] ::substrait::NamedStruct* release_table_schema();
  ::substrait::NamedStruct* mutable_table_schema();
  void set_allocated_table_schema(::substrait::NamedStruct* value);
  void unsafe_arena_set_allocated_table_schema(::substrait::NamedStruct* value);
  ::substrait::NamedStruct* unsafe_arena_release_table_schema();

  private:
  const ::substrait::NamedStruct& _internal_table_schema() const;
  ::substrait::NamedStruct* _internal_mutable_table_schema();

  public:
  // .substrait.Expression.Literal.Struct table_defaults = 4;
  bool has_table_defaults() const;
  void clear_table_defaults() ;
  const ::substrait::Expression_Literal_Struct& table_defaults() const;
  [[nodiscard]] ::substrait::Expression_Literal_Struct* release_table_defaults();
  ::substrait::Expression_Literal_Struct* mutable_table_defaults();
  void set_allocated_table_defaults(::substrait::Expression_Literal_Struct* value);
  void unsafe_arena_set_allocated_table_defaults(::substrait::Expression_Literal_Struct* value);
  ::substrait::Expression_Literal_Struct* unsafe_arena_release_table_defaults();

  private:
  const ::substrait::Expression_Literal_Struct& _internal_table_defaults() const;
  ::substrait::Expression_Literal_Struct* _internal_mutable_table_defaults();

  public:
  // .substrait.Rel view_definition = 7;
  bool has_view_definition() const;
  void clear_view_definition() ;
  const ::substrait::Rel& view_definition() const;
  [[nodiscard]] ::substrait::Rel* release_view_definition();
  ::substrait::Rel* mutable_view_definition();
  void set_allocated_view_definition(::substrait::Rel* value);
  void unsafe_arena_set_allocated_view_definition(::substrait::Rel* value);
  ::substrait::Rel* unsafe_arena_release_view_definition();

  private:
  const ::substrait::Rel& _internal_view_definition() const;
  ::substrait::Rel* _internal_mutable_view_definition();

  public:
  // .substrait.RelCommon common = 8;
  bool has_common() const;
  void clear_common() ;
  const ::substrait::RelCommon& common() const;
  [[nodiscard]] ::substrait::RelCommon* release_common();
  ::substrait::RelCommon* mutable_common();
  void set_allocated_common(::substrait::RelCommon* value);
  void unsafe_arena_set_allocated_common(::substrait::RelCommon* value);
  ::substrait::RelCommon* unsafe_arena_release_common();

  private:
  const ::substrait::RelCommon& _internal_common() const;
  ::substrait::RelCommon* _internal_mutable_common();

  public:
  // .substrait.DdlRel.DdlObject object = 5;
  void clear_object() ;
  ::substrait::DdlRel_DdlObject object() const;
  void set_object(::substrait::DdlRel_DdlObject value);

  private:
  ::substrait::DdlRel_DdlObject _internal_object() const;
  void _internal_set_object(::substrait::DdlRel_DdlObject value);

  public:
  // .substrait.DdlRel.DdlOp op = 6;
  void clear_op() ;
  ::substrait::DdlRel_DdlOp op() const;
  void set_op(::substrait::DdlRel_DdlOp value);

  private:
  ::substrait::DdlRel_DdlOp _internal_op() const;
  void _internal_set_op(::substrait::DdlRel_DdlOp value);

  public:
  // .substrait.NamedObjectWrite named_object = 1;
  bool has_named_object() const;
  private:
  bool _internal_has_named_object() const;

  public:
  void clear_named_object() ;
  const ::substrait::NamedObjectWrite& named_object() const;
  [[nodiscard]] ::substrait::NamedObjectWrite* release_named_object();
  ::substrait::NamedObjectWrite* mutable_named_object();
  void set_allocated_named_object(::substrait::NamedObjectWrite* value);
  void unsafe_arena_set_allocated_named_object(::substrait::NamedObjectWrite* value);
  ::substrait::NamedObjectWrite* unsafe_arena_release_named_object();

  private:
  const ::substrait::NamedObjectWrite& _internal_named_object() const;
  ::substrait::NamedObjectWrite* _internal_mutable_named_object();

  public:
  // .substrait.ExtensionObject extension_object = 2;
  bool has_extension_object() const;
  private:
  bool _internal_has_extension_object() const;

  public:
  void clear_extension_object() ;
  const ::substrait::ExtensionObject& extension_object() const;
  [[nodiscard]] ::substrait::ExtensionObject* release_extension_object();
  ::substrait::ExtensionObject* mutable_extension_object();
  void set_allocated_extension_object(::substrait::ExtensionObject* value);
  void unsafe_arena_set_allocated_extension_object(::substrait::ExtensionObject* value);
  ::substrait::ExtensionObject* unsafe_arena_release_extension_object();

  private:
  const ::substrait::ExtensionObject& _internal_extension_object() const;
  ::substrait::ExtensionObject* _internal_mutable_extension_object();

  public:
  void clear_write_type();
  WriteTypeCase write_type_case() const;
  // @@protoc_insertion_point(class_scope:substrait.DdlRel)
 private:
  class _Internal;
  void set_has_named_object();
  void set_has_extension_object();
  inline bool has_write_type() const;
  inline void clear_has_write_type();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 6,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DdlRel& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::substrait::NamedStruct* table_schema_;
    ::substrait::Expression_Literal_Struct* table_defaults_;
    ::substrait::Rel* view_definition_;
    ::substrait::RelCommon* common_;
    int object_;
    int op_;
    union WriteTypeUnion {
      constexpr WriteTypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::substrait::NamedObjectWrite* named_object_;
      ::substrait::ExtensionObject* extension_object_;
    } write_type_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DdlRel_class_data_;
// -------------------------------------------------------------------

class ExchangeRel final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.ExchangeRel) */ {
 public:
  inline ExchangeRel() : ExchangeRel(nullptr) {}
  ~ExchangeRel() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ExchangeRel* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ExchangeRel));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ExchangeRel(
      ::google::protobuf::internal::ConstantInitialized);

  inline ExchangeRel(const ExchangeRel& from) : ExchangeRel(nullptr, from) {}
  inline ExchangeRel(ExchangeRel&& from) noexcept
      : ExchangeRel(nullptr, std::move(from)) {}
  inline ExchangeRel& operator=(const ExchangeRel& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExchangeRel& operator=(ExchangeRel&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExchangeRel& default_instance() {
    return *reinterpret_cast<const ExchangeRel*>(
        &_ExchangeRel_default_instance_);
  }
  enum ExchangeKindCase {
    kScatterByFields = 5,
    kSingleTarget = 6,
    kMultiTarget = 7,
    kRoundRobin = 8,
    kBroadcast = 9,
    EXCHANGE_KIND_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 37;
  friend void swap(ExchangeRel& a, ExchangeRel& b) { a.Swap(&b); }
  inline void Swap(ExchangeRel* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExchangeRel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExchangeRel* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ExchangeRel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ExchangeRel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ExchangeRel& from) { ExchangeRel::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ExchangeRel* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.ExchangeRel"; }

 protected:
  explicit ExchangeRel(::google::protobuf::Arena* arena);
  ExchangeRel(::google::protobuf::Arena* arena, const ExchangeRel& from);
  ExchangeRel(::google::protobuf::Arena* arena, ExchangeRel&& from) noexcept
      : ExchangeRel(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using ScatterFields = ExchangeRel_ScatterFields;
  using SingleBucketExpression = ExchangeRel_SingleBucketExpression;
  using MultiBucketExpression = ExchangeRel_MultiBucketExpression;
  using Broadcast = ExchangeRel_Broadcast;
  using RoundRobin = ExchangeRel_RoundRobin;
  using ExchangeTarget = ExchangeRel_ExchangeTarget;

  // accessors -------------------------------------------------------
  enum : int {
    kTargetsFieldNumber = 4,
    kCommonFieldNumber = 1,
    kInputFieldNumber = 2,
    kAdvancedExtensionFieldNumber = 10,
    kPartitionCountFieldNumber = 3,
    kScatterByFieldsFieldNumber = 5,
    kSingleTargetFieldNumber = 6,
    kMultiTargetFieldNumber = 7,
    kRoundRobinFieldNumber = 8,
    kBroadcastFieldNumber = 9,
  };
  // repeated .substrait.ExchangeRel.ExchangeTarget targets = 4;
  int targets_size() const;
  private:
  int _internal_targets_size() const;

  public:
  void clear_targets() ;
  ::substrait::ExchangeRel_ExchangeTarget* mutable_targets(int index);
  ::google::protobuf::RepeatedPtrField<::substrait::ExchangeRel_ExchangeTarget>* mutable_targets();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::ExchangeRel_ExchangeTarget>& _internal_targets() const;
  ::google::protobuf::RepeatedPtrField<::substrait::ExchangeRel_ExchangeTarget>* _internal_mutable_targets();
  public:
  const ::substrait::ExchangeRel_ExchangeTarget& targets(int index) const;
  ::substrait::ExchangeRel_ExchangeTarget* add_targets();
  const ::google::protobuf::RepeatedPtrField<::substrait::ExchangeRel_ExchangeTarget>& targets() const;
  // .substrait.RelCommon common = 1;
  bool has_common() const;
  void clear_common() ;
  const ::substrait::RelCommon& common() const;
  [[nodiscard]] ::substrait::RelCommon* release_common();
  ::substrait::RelCommon* mutable_common();
  void set_allocated_common(::substrait::RelCommon* value);
  void unsafe_arena_set_allocated_common(::substrait::RelCommon* value);
  ::substrait::RelCommon* unsafe_arena_release_common();

  private:
  const ::substrait::RelCommon& _internal_common() const;
  ::substrait::RelCommon* _internal_mutable_common();

  public:
  // .substrait.Rel input = 2;
  bool has_input() const;
  void clear_input() ;
  const ::substrait::Rel& input() const;
  [[nodiscard]] ::substrait::Rel* release_input();
  ::substrait::Rel* mutable_input();
  void set_allocated_input(::substrait::Rel* value);
  void unsafe_arena_set_allocated_input(::substrait::Rel* value);
  ::substrait::Rel* unsafe_arena_release_input();

  private:
  const ::substrait::Rel& _internal_input() const;
  ::substrait::Rel* _internal_mutable_input();

  public:
  // .substrait.extensions.AdvancedExtension advanced_extension = 10;
  bool has_advanced_extension() const;
  void clear_advanced_extension() ;
  const ::substrait::extensions::AdvancedExtension& advanced_extension() const;
  [[nodiscard]] ::substrait::extensions::AdvancedExtension* release_advanced_extension();
  ::substrait::extensions::AdvancedExtension* mutable_advanced_extension();
  void set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value);
  void unsafe_arena_set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value);
  ::substrait::extensions::AdvancedExtension* unsafe_arena_release_advanced_extension();

  private:
  const ::substrait::extensions::AdvancedExtension& _internal_advanced_extension() const;
  ::substrait::extensions::AdvancedExtension* _internal_mutable_advanced_extension();

  public:
  // int32 partition_count = 3;
  void clear_partition_count() ;
  ::int32_t partition_count() const;
  void set_partition_count(::int32_t value);

  private:
  ::int32_t _internal_partition_count() const;
  void _internal_set_partition_count(::int32_t value);

  public:
  // .substrait.ExchangeRel.ScatterFields scatter_by_fields = 5;
  bool has_scatter_by_fields() const;
  private:
  bool _internal_has_scatter_by_fields() const;

  public:
  void clear_scatter_by_fields() ;
  const ::substrait::ExchangeRel_ScatterFields& scatter_by_fields() const;
  [[nodiscard]] ::substrait::ExchangeRel_ScatterFields* release_scatter_by_fields();
  ::substrait::ExchangeRel_ScatterFields* mutable_scatter_by_fields();
  void set_allocated_scatter_by_fields(::substrait::ExchangeRel_ScatterFields* value);
  void unsafe_arena_set_allocated_scatter_by_fields(::substrait::ExchangeRel_ScatterFields* value);
  ::substrait::ExchangeRel_ScatterFields* unsafe_arena_release_scatter_by_fields();

  private:
  const ::substrait::ExchangeRel_ScatterFields& _internal_scatter_by_fields() const;
  ::substrait::ExchangeRel_ScatterFields* _internal_mutable_scatter_by_fields();

  public:
  // .substrait.ExchangeRel.SingleBucketExpression single_target = 6;
  bool has_single_target() const;
  private:
  bool _internal_has_single_target() const;

  public:
  void clear_single_target() ;
  const ::substrait::ExchangeRel_SingleBucketExpression& single_target() const;
  [[nodiscard]] ::substrait::ExchangeRel_SingleBucketExpression* release_single_target();
  ::substrait::ExchangeRel_SingleBucketExpression* mutable_single_target();
  void set_allocated_single_target(::substrait::ExchangeRel_SingleBucketExpression* value);
  void unsafe_arena_set_allocated_single_target(::substrait::ExchangeRel_SingleBucketExpression* value);
  ::substrait::ExchangeRel_SingleBucketExpression* unsafe_arena_release_single_target();

  private:
  const ::substrait::ExchangeRel_SingleBucketExpression& _internal_single_target() const;
  ::substrait::ExchangeRel_SingleBucketExpression* _internal_mutable_single_target();

  public:
  // .substrait.ExchangeRel.MultiBucketExpression multi_target = 7;
  bool has_multi_target() const;
  private:
  bool _internal_has_multi_target() const;

  public:
  void clear_multi_target() ;
  const ::substrait::ExchangeRel_MultiBucketExpression& multi_target() const;
  [[nodiscard]] ::substrait::ExchangeRel_MultiBucketExpression* release_multi_target();
  ::substrait::ExchangeRel_MultiBucketExpression* mutable_multi_target();
  void set_allocated_multi_target(::substrait::ExchangeRel_MultiBucketExpression* value);
  void unsafe_arena_set_allocated_multi_target(::substrait::ExchangeRel_MultiBucketExpression* value);
  ::substrait::ExchangeRel_MultiBucketExpression* unsafe_arena_release_multi_target();

  private:
  const ::substrait::ExchangeRel_MultiBucketExpression& _internal_multi_target() const;
  ::substrait::ExchangeRel_MultiBucketExpression* _internal_mutable_multi_target();

  public:
  // .substrait.ExchangeRel.RoundRobin round_robin = 8;
  bool has_round_robin() const;
  private:
  bool _internal_has_round_robin() const;

  public:
  void clear_round_robin() ;
  const ::substrait::ExchangeRel_RoundRobin& round_robin() const;
  [[nodiscard]] ::substrait::ExchangeRel_RoundRobin* release_round_robin();
  ::substrait::ExchangeRel_RoundRobin* mutable_round_robin();
  void set_allocated_round_robin(::substrait::ExchangeRel_RoundRobin* value);
  void unsafe_arena_set_allocated_round_robin(::substrait::ExchangeRel_RoundRobin* value);
  ::substrait::ExchangeRel_RoundRobin* unsafe_arena_release_round_robin();

  private:
  const ::substrait::ExchangeRel_RoundRobin& _internal_round_robin() const;
  ::substrait::ExchangeRel_RoundRobin* _internal_mutable_round_robin();

  public:
  // .substrait.ExchangeRel.Broadcast broadcast = 9;
  bool has_broadcast() const;
  private:
  bool _internal_has_broadcast() const;

  public:
  void clear_broadcast() ;
  const ::substrait::ExchangeRel_Broadcast& broadcast() const;
  [[nodiscard]] ::substrait::ExchangeRel_Broadcast* release_broadcast();
  ::substrait::ExchangeRel_Broadcast* mutable_broadcast();
  void set_allocated_broadcast(::substrait::ExchangeRel_Broadcast* value);
  void unsafe_arena_set_allocated_broadcast(::substrait::ExchangeRel_Broadcast* value);
  ::substrait::ExchangeRel_Broadcast* unsafe_arena_release_broadcast();

  private:
  const ::substrait::ExchangeRel_Broadcast& _internal_broadcast() const;
  ::substrait::ExchangeRel_Broadcast* _internal_mutable_broadcast();

  public:
  void clear_exchange_kind();
  ExchangeKindCase exchange_kind_case() const;
  // @@protoc_insertion_point(class_scope:substrait.ExchangeRel)
 private:
  class _Internal;
  void set_has_scatter_by_fields();
  void set_has_single_target();
  void set_has_multi_target();
  void set_has_round_robin();
  void set_has_broadcast();
  inline bool has_exchange_kind() const;
  inline void clear_has_exchange_kind();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 10, 9,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ExchangeRel& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::substrait::ExchangeRel_ExchangeTarget > targets_;
    ::substrait::RelCommon* common_;
    ::substrait::Rel* input_;
    ::substrait::extensions::AdvancedExtension* advanced_extension_;
    ::int32_t partition_count_;
    union ExchangeKindUnion {
      constexpr ExchangeKindUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::substrait::ExchangeRel_ScatterFields* scatter_by_fields_;
      ::substrait::ExchangeRel_SingleBucketExpression* single_target_;
      ::substrait::ExchangeRel_MultiBucketExpression* multi_target_;
      ::substrait::ExchangeRel_RoundRobin* round_robin_;
      ::substrait::ExchangeRel_Broadcast* broadcast_;
    } exchange_kind_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ExchangeRel_class_data_;
// -------------------------------------------------------------------

class ExchangeRel_MultiBucketExpression final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.ExchangeRel.MultiBucketExpression) */ {
 public:
  inline ExchangeRel_MultiBucketExpression() : ExchangeRel_MultiBucketExpression(nullptr) {}
  ~ExchangeRel_MultiBucketExpression() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ExchangeRel_MultiBucketExpression* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ExchangeRel_MultiBucketExpression));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ExchangeRel_MultiBucketExpression(
      ::google::protobuf::internal::ConstantInitialized);

  inline ExchangeRel_MultiBucketExpression(const ExchangeRel_MultiBucketExpression& from) : ExchangeRel_MultiBucketExpression(nullptr, from) {}
  inline ExchangeRel_MultiBucketExpression(ExchangeRel_MultiBucketExpression&& from) noexcept
      : ExchangeRel_MultiBucketExpression(nullptr, std::move(from)) {}
  inline ExchangeRel_MultiBucketExpression& operator=(const ExchangeRel_MultiBucketExpression& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExchangeRel_MultiBucketExpression& operator=(ExchangeRel_MultiBucketExpression&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExchangeRel_MultiBucketExpression& default_instance() {
    return *reinterpret_cast<const ExchangeRel_MultiBucketExpression*>(
        &_ExchangeRel_MultiBucketExpression_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 33;
  friend void swap(ExchangeRel_MultiBucketExpression& a, ExchangeRel_MultiBucketExpression& b) { a.Swap(&b); }
  inline void Swap(ExchangeRel_MultiBucketExpression* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExchangeRel_MultiBucketExpression* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExchangeRel_MultiBucketExpression* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ExchangeRel_MultiBucketExpression>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ExchangeRel_MultiBucketExpression& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ExchangeRel_MultiBucketExpression& from) { ExchangeRel_MultiBucketExpression::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ExchangeRel_MultiBucketExpression* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.ExchangeRel.MultiBucketExpression"; }

 protected:
  explicit ExchangeRel_MultiBucketExpression(::google::protobuf::Arena* arena);
  ExchangeRel_MultiBucketExpression(::google::protobuf::Arena* arena, const ExchangeRel_MultiBucketExpression& from);
  ExchangeRel_MultiBucketExpression(::google::protobuf::Arena* arena, ExchangeRel_MultiBucketExpression&& from) noexcept
      : ExchangeRel_MultiBucketExpression(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kExpressionFieldNumber = 1,
    kConstrainedToCountFieldNumber = 2,
  };
  // .substrait.Expression expression = 1;
  bool has_expression() const;
  void clear_expression() ;
  const ::substrait::Expression& expression() const;
  [[nodiscard]] ::substrait::Expression* release_expression();
  ::substrait::Expression* mutable_expression();
  void set_allocated_expression(::substrait::Expression* value);
  void unsafe_arena_set_allocated_expression(::substrait::Expression* value);
  ::substrait::Expression* unsafe_arena_release_expression();

  private:
  const ::substrait::Expression& _internal_expression() const;
  ::substrait::Expression* _internal_mutable_expression();

  public:
  // bool constrained_to_count = 2;
  void clear_constrained_to_count() ;
  bool constrained_to_count() const;
  void set_constrained_to_count(bool value);

  private:
  bool _internal_constrained_to_count() const;
  void _internal_set_constrained_to_count(bool value);

  public:
  // @@protoc_insertion_point(class_scope:substrait.ExchangeRel.MultiBucketExpression)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ExchangeRel_MultiBucketExpression& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::substrait::Expression* expression_;
    bool constrained_to_count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ExchangeRel_MultiBucketExpression_class_data_;
// -------------------------------------------------------------------

class ExchangeRel_ScatterFields final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.ExchangeRel.ScatterFields) */ {
 public:
  inline ExchangeRel_ScatterFields() : ExchangeRel_ScatterFields(nullptr) {}
  ~ExchangeRel_ScatterFields() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ExchangeRel_ScatterFields* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ExchangeRel_ScatterFields));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ExchangeRel_ScatterFields(
      ::google::protobuf::internal::ConstantInitialized);

  inline ExchangeRel_ScatterFields(const ExchangeRel_ScatterFields& from) : ExchangeRel_ScatterFields(nullptr, from) {}
  inline ExchangeRel_ScatterFields(ExchangeRel_ScatterFields&& from) noexcept
      : ExchangeRel_ScatterFields(nullptr, std::move(from)) {}
  inline ExchangeRel_ScatterFields& operator=(const ExchangeRel_ScatterFields& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExchangeRel_ScatterFields& operator=(ExchangeRel_ScatterFields&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExchangeRel_ScatterFields& default_instance() {
    return *reinterpret_cast<const ExchangeRel_ScatterFields*>(
        &_ExchangeRel_ScatterFields_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 31;
  friend void swap(ExchangeRel_ScatterFields& a, ExchangeRel_ScatterFields& b) { a.Swap(&b); }
  inline void Swap(ExchangeRel_ScatterFields* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExchangeRel_ScatterFields* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExchangeRel_ScatterFields* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ExchangeRel_ScatterFields>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ExchangeRel_ScatterFields& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ExchangeRel_ScatterFields& from) { ExchangeRel_ScatterFields::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ExchangeRel_ScatterFields* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.ExchangeRel.ScatterFields"; }

 protected:
  explicit ExchangeRel_ScatterFields(::google::protobuf::Arena* arena);
  ExchangeRel_ScatterFields(::google::protobuf::Arena* arena, const ExchangeRel_ScatterFields& from);
  ExchangeRel_ScatterFields(::google::protobuf::Arena* arena, ExchangeRel_ScatterFields&& from) noexcept
      : ExchangeRel_ScatterFields(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFieldsFieldNumber = 1,
  };
  // repeated .substrait.Expression.FieldReference fields = 1;
  int fields_size() const;
  private:
  int _internal_fields_size() const;

  public:
  void clear_fields() ;
  ::substrait::Expression_FieldReference* mutable_fields(int index);
  ::google::protobuf::RepeatedPtrField<::substrait::Expression_FieldReference>* mutable_fields();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression_FieldReference>& _internal_fields() const;
  ::google::protobuf::RepeatedPtrField<::substrait::Expression_FieldReference>* _internal_mutable_fields();
  public:
  const ::substrait::Expression_FieldReference& fields(int index) const;
  ::substrait::Expression_FieldReference* add_fields();
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression_FieldReference>& fields() const;
  // @@protoc_insertion_point(class_scope:substrait.ExchangeRel.ScatterFields)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ExchangeRel_ScatterFields& from_msg);
    ::google::protobuf::RepeatedPtrField< ::substrait::Expression_FieldReference > fields_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ExchangeRel_ScatterFields_class_data_;
// -------------------------------------------------------------------

class ExchangeRel_SingleBucketExpression final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.ExchangeRel.SingleBucketExpression) */ {
 public:
  inline ExchangeRel_SingleBucketExpression() : ExchangeRel_SingleBucketExpression(nullptr) {}
  ~ExchangeRel_SingleBucketExpression() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ExchangeRel_SingleBucketExpression* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ExchangeRel_SingleBucketExpression));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ExchangeRel_SingleBucketExpression(
      ::google::protobuf::internal::ConstantInitialized);

  inline ExchangeRel_SingleBucketExpression(const ExchangeRel_SingleBucketExpression& from) : ExchangeRel_SingleBucketExpression(nullptr, from) {}
  inline ExchangeRel_SingleBucketExpression(ExchangeRel_SingleBucketExpression&& from) noexcept
      : ExchangeRel_SingleBucketExpression(nullptr, std::move(from)) {}
  inline ExchangeRel_SingleBucketExpression& operator=(const ExchangeRel_SingleBucketExpression& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExchangeRel_SingleBucketExpression& operator=(ExchangeRel_SingleBucketExpression&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExchangeRel_SingleBucketExpression& default_instance() {
    return *reinterpret_cast<const ExchangeRel_SingleBucketExpression*>(
        &_ExchangeRel_SingleBucketExpression_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 32;
  friend void swap(ExchangeRel_SingleBucketExpression& a, ExchangeRel_SingleBucketExpression& b) { a.Swap(&b); }
  inline void Swap(ExchangeRel_SingleBucketExpression* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExchangeRel_SingleBucketExpression* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExchangeRel_SingleBucketExpression* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ExchangeRel_SingleBucketExpression>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ExchangeRel_SingleBucketExpression& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ExchangeRel_SingleBucketExpression& from) { ExchangeRel_SingleBucketExpression::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ExchangeRel_SingleBucketExpression* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.ExchangeRel.SingleBucketExpression"; }

 protected:
  explicit ExchangeRel_SingleBucketExpression(::google::protobuf::Arena* arena);
  ExchangeRel_SingleBucketExpression(::google::protobuf::Arena* arena, const ExchangeRel_SingleBucketExpression& from);
  ExchangeRel_SingleBucketExpression(::google::protobuf::Arena* arena, ExchangeRel_SingleBucketExpression&& from) noexcept
      : ExchangeRel_SingleBucketExpression(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kExpressionFieldNumber = 1,
  };
  // .substrait.Expression expression = 1;
  bool has_expression() const;
  void clear_expression() ;
  const ::substrait::Expression& expression() const;
  [[nodiscard]] ::substrait::Expression* release_expression();
  ::substrait::Expression* mutable_expression();
  void set_allocated_expression(::substrait::Expression* value);
  void unsafe_arena_set_allocated_expression(::substrait::Expression* value);
  ::substrait::Expression* unsafe_arena_release_expression();

  private:
  const ::substrait::Expression& _internal_expression() const;
  ::substrait::Expression* _internal_mutable_expression();

  public:
  // @@protoc_insertion_point(class_scope:substrait.ExchangeRel.SingleBucketExpression)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ExchangeRel_SingleBucketExpression& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::substrait::Expression* expression_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ExchangeRel_SingleBucketExpression_class_data_;
// -------------------------------------------------------------------

class ExpandRel final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.ExpandRel) */ {
 public:
  inline ExpandRel() : ExpandRel(nullptr) {}
  ~ExpandRel() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ExpandRel* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ExpandRel));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ExpandRel(
      ::google::protobuf::internal::ConstantInitialized);

  inline ExpandRel(const ExpandRel& from) : ExpandRel(nullptr, from) {}
  inline ExpandRel(ExpandRel&& from) noexcept
      : ExpandRel(nullptr, std::move(from)) {}
  inline ExpandRel& operator=(const ExpandRel& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExpandRel& operator=(ExpandRel&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExpandRel& default_instance() {
    return *reinterpret_cast<const ExpandRel*>(
        &_ExpandRel_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 40;
  friend void swap(ExpandRel& a, ExpandRel& b) { a.Swap(&b); }
  inline void Swap(ExpandRel* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExpandRel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExpandRel* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ExpandRel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ExpandRel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ExpandRel& from) { ExpandRel::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ExpandRel* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.ExpandRel"; }

 protected:
  explicit ExpandRel(::google::protobuf::Arena* arena);
  ExpandRel(::google::protobuf::Arena* arena, const ExpandRel& from);
  ExpandRel(::google::protobuf::Arena* arena, ExpandRel&& from) noexcept
      : ExpandRel(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using ExpandField = ExpandRel_ExpandField;
  using SwitchingField = ExpandRel_SwitchingField;

  // accessors -------------------------------------------------------
  enum : int {
    kFieldsFieldNumber = 4,
    kCommonFieldNumber = 1,
    kInputFieldNumber = 2,
  };
  // repeated .substrait.ExpandRel.ExpandField fields = 4;
  int fields_size() const;
  private:
  int _internal_fields_size() const;

  public:
  void clear_fields() ;
  ::substrait::ExpandRel_ExpandField* mutable_fields(int index);
  ::google::protobuf::RepeatedPtrField<::substrait::ExpandRel_ExpandField>* mutable_fields();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::ExpandRel_ExpandField>& _internal_fields() const;
  ::google::protobuf::RepeatedPtrField<::substrait::ExpandRel_ExpandField>* _internal_mutable_fields();
  public:
  const ::substrait::ExpandRel_ExpandField& fields(int index) const;
  ::substrait::ExpandRel_ExpandField* add_fields();
  const ::google::protobuf::RepeatedPtrField<::substrait::ExpandRel_ExpandField>& fields() const;
  // .substrait.RelCommon common = 1;
  bool has_common() const;
  void clear_common() ;
  const ::substrait::RelCommon& common() const;
  [[nodiscard]] ::substrait::RelCommon* release_common();
  ::substrait::RelCommon* mutable_common();
  void set_allocated_common(::substrait::RelCommon* value);
  void unsafe_arena_set_allocated_common(::substrait::RelCommon* value);
  ::substrait::RelCommon* unsafe_arena_release_common();

  private:
  const ::substrait::RelCommon& _internal_common() const;
  ::substrait::RelCommon* _internal_mutable_common();

  public:
  // .substrait.Rel input = 2;
  bool has_input() const;
  void clear_input() ;
  const ::substrait::Rel& input() const;
  [[nodiscard]] ::substrait::Rel* release_input();
  ::substrait::Rel* mutable_input();
  void set_allocated_input(::substrait::Rel* value);
  void unsafe_arena_set_allocated_input(::substrait::Rel* value);
  ::substrait::Rel* unsafe_arena_release_input();

  private:
  const ::substrait::Rel& _internal_input() const;
  ::substrait::Rel* _internal_mutable_input();

  public:
  // @@protoc_insertion_point(class_scope:substrait.ExpandRel)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ExpandRel& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::substrait::ExpandRel_ExpandField > fields_;
    ::substrait::RelCommon* common_;
    ::substrait::Rel* input_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ExpandRel_class_data_;
// -------------------------------------------------------------------

class ExpandRel_ExpandField final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.ExpandRel.ExpandField) */ {
 public:
  inline ExpandRel_ExpandField() : ExpandRel_ExpandField(nullptr) {}
  ~ExpandRel_ExpandField() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ExpandRel_ExpandField* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ExpandRel_ExpandField));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ExpandRel_ExpandField(
      ::google::protobuf::internal::ConstantInitialized);

  inline ExpandRel_ExpandField(const ExpandRel_ExpandField& from) : ExpandRel_ExpandField(nullptr, from) {}
  inline ExpandRel_ExpandField(ExpandRel_ExpandField&& from) noexcept
      : ExpandRel_ExpandField(nullptr, std::move(from)) {}
  inline ExpandRel_ExpandField& operator=(const ExpandRel_ExpandField& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExpandRel_ExpandField& operator=(ExpandRel_ExpandField&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExpandRel_ExpandField& default_instance() {
    return *reinterpret_cast<const ExpandRel_ExpandField*>(
        &_ExpandRel_ExpandField_default_instance_);
  }
  enum FieldTypeCase {
    kSwitchingField = 2,
    kConsistentField = 3,
    FIELD_TYPE_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 38;
  friend void swap(ExpandRel_ExpandField& a, ExpandRel_ExpandField& b) { a.Swap(&b); }
  inline void Swap(ExpandRel_ExpandField* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExpandRel_ExpandField* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExpandRel_ExpandField* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ExpandRel_ExpandField>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ExpandRel_ExpandField& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ExpandRel_ExpandField& from) { ExpandRel_ExpandField::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ExpandRel_ExpandField* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.ExpandRel.ExpandField"; }

 protected:
  explicit ExpandRel_ExpandField(::google::protobuf::Arena* arena);
  ExpandRel_ExpandField(::google::protobuf::Arena* arena, const ExpandRel_ExpandField& from);
  ExpandRel_ExpandField(::google::protobuf::Arena* arena, ExpandRel_ExpandField&& from) noexcept
      : ExpandRel_ExpandField(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSwitchingFieldFieldNumber = 2,
    kConsistentFieldFieldNumber = 3,
  };
  // .substrait.ExpandRel.SwitchingField switching_field = 2;
  bool has_switching_field() const;
  private:
  bool _internal_has_switching_field() const;

  public:
  void clear_switching_field() ;
  const ::substrait::ExpandRel_SwitchingField& switching_field() const;
  [[nodiscard]] ::substrait::ExpandRel_SwitchingField* release_switching_field();
  ::substrait::ExpandRel_SwitchingField* mutable_switching_field();
  void set_allocated_switching_field(::substrait::ExpandRel_SwitchingField* value);
  void unsafe_arena_set_allocated_switching_field(::substrait::ExpandRel_SwitchingField* value);
  ::substrait::ExpandRel_SwitchingField* unsafe_arena_release_switching_field();

  private:
  const ::substrait::ExpandRel_SwitchingField& _internal_switching_field() const;
  ::substrait::ExpandRel_SwitchingField* _internal_mutable_switching_field();

  public:
  // .substrait.Expression consistent_field = 3;
  bool has_consistent_field() const;
  private:
  bool _internal_has_consistent_field() const;

  public:
  void clear_consistent_field() ;
  const ::substrait::Expression& consistent_field() const;
  [[nodiscard]] ::substrait::Expression* release_consistent_field();
  ::substrait::Expression* mutable_consistent_field();
  void set_allocated_consistent_field(::substrait::Expression* value);
  void unsafe_arena_set_allocated_consistent_field(::substrait::Expression* value);
  ::substrait::Expression* unsafe_arena_release_consistent_field();

  private:
  const ::substrait::Expression& _internal_consistent_field() const;
  ::substrait::Expression* _internal_mutable_consistent_field();

  public:
  void clear_field_type();
  FieldTypeCase field_type_case() const;
  // @@protoc_insertion_point(class_scope:substrait.ExpandRel.ExpandField)
 private:
  class _Internal;
  void set_has_switching_field();
  void set_has_consistent_field();
  inline bool has_field_type() const;
  inline void clear_has_field_type();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ExpandRel_ExpandField& from_msg);
    union FieldTypeUnion {
      constexpr FieldTypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::substrait::ExpandRel_SwitchingField* switching_field_;
      ::substrait::Expression* consistent_field_;
    } field_type_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ExpandRel_ExpandField_class_data_;
// -------------------------------------------------------------------

class ExpandRel_SwitchingField final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.ExpandRel.SwitchingField) */ {
 public:
  inline ExpandRel_SwitchingField() : ExpandRel_SwitchingField(nullptr) {}
  ~ExpandRel_SwitchingField() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ExpandRel_SwitchingField* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ExpandRel_SwitchingField));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ExpandRel_SwitchingField(
      ::google::protobuf::internal::ConstantInitialized);

  inline ExpandRel_SwitchingField(const ExpandRel_SwitchingField& from) : ExpandRel_SwitchingField(nullptr, from) {}
  inline ExpandRel_SwitchingField(ExpandRel_SwitchingField&& from) noexcept
      : ExpandRel_SwitchingField(nullptr, std::move(from)) {}
  inline ExpandRel_SwitchingField& operator=(const ExpandRel_SwitchingField& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExpandRel_SwitchingField& operator=(ExpandRel_SwitchingField&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExpandRel_SwitchingField& default_instance() {
    return *reinterpret_cast<const ExpandRel_SwitchingField*>(
        &_ExpandRel_SwitchingField_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 39;
  friend void swap(ExpandRel_SwitchingField& a, ExpandRel_SwitchingField& b) { a.Swap(&b); }
  inline void Swap(ExpandRel_SwitchingField* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExpandRel_SwitchingField* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExpandRel_SwitchingField* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ExpandRel_SwitchingField>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ExpandRel_SwitchingField& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ExpandRel_SwitchingField& from) { ExpandRel_SwitchingField::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ExpandRel_SwitchingField* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.ExpandRel.SwitchingField"; }

 protected:
  explicit ExpandRel_SwitchingField(::google::protobuf::Arena* arena);
  ExpandRel_SwitchingField(::google::protobuf::Arena* arena, const ExpandRel_SwitchingField& from);
  ExpandRel_SwitchingField(::google::protobuf::Arena* arena, ExpandRel_SwitchingField&& from) noexcept
      : ExpandRel_SwitchingField(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDuplicatesFieldNumber = 1,
  };
  // repeated .substrait.Expression duplicates = 1;
  int duplicates_size() const;
  private:
  int _internal_duplicates_size() const;

  public:
  void clear_duplicates() ;
  ::substrait::Expression* mutable_duplicates(int index);
  ::google::protobuf::RepeatedPtrField<::substrait::Expression>* mutable_duplicates();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression>& _internal_duplicates() const;
  ::google::protobuf::RepeatedPtrField<::substrait::Expression>* _internal_mutable_duplicates();
  public:
  const ::substrait::Expression& duplicates(int index) const;
  ::substrait::Expression* add_duplicates();
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression>& duplicates() const;
  // @@protoc_insertion_point(class_scope:substrait.ExpandRel.SwitchingField)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ExpandRel_SwitchingField& from_msg);
    ::google::protobuf::RepeatedPtrField< ::substrait::Expression > duplicates_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ExpandRel_SwitchingField_class_data_;
// -------------------------------------------------------------------

class Expression final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression) */ {
 public:
  inline Expression() : Expression(nullptr) {}
  ~Expression() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression(const Expression& from) : Expression(nullptr, from) {}
  inline Expression(Expression&& from) noexcept
      : Expression(nullptr, std::move(from)) {}
  inline Expression& operator=(const Expression& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression& operator=(Expression&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression& default_instance() {
    return *reinterpret_cast<const Expression*>(
        &_Expression_default_instance_);
  }
  enum RexTypeCase {
    kLiteral = 1,
    kSelection = 2,
    kScalarFunction = 3,
    kWindowFunction = 5,
    kIfThen = 6,
    kSwitchExpression = 7,
    kSingularOrList = 8,
    kMultiOrList = 9,
    kCast = 11,
    kSubquery = 12,
    kNested = 13,
    kEnum = 10,
    REX_TYPE_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 112;
  friend void swap(Expression& a, Expression& b) { a.Swap(&b); }
  inline void Swap(Expression* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression& from) { Expression::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression"; }

 protected:
  explicit Expression(::google::protobuf::Arena* arena);
  Expression(::google::protobuf::Arena* arena, const Expression& from);
  Expression(::google::protobuf::Arena* arena, Expression&& from) noexcept
      : Expression(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Enum = Expression_Enum;
  using Literal = Expression_Literal;
  using Nested = Expression_Nested;
  using ScalarFunction = Expression_ScalarFunction;
  using WindowFunction = Expression_WindowFunction;
  using IfThen = Expression_IfThen;
  using Cast = Expression_Cast;
  using SwitchExpression = Expression_SwitchExpression;
  using SingularOrList = Expression_SingularOrList;
  using MultiOrList = Expression_MultiOrList;
  using EmbeddedFunction = Expression_EmbeddedFunction;
  using ReferenceSegment = Expression_ReferenceSegment;
  using MaskExpression = Expression_MaskExpression;
  using FieldReference = Expression_FieldReference;
  using Subquery = Expression_Subquery;

  // accessors -------------------------------------------------------
  enum : int {
    kLiteralFieldNumber = 1,
    kSelectionFieldNumber = 2,
    kScalarFunctionFieldNumber = 3,
    kWindowFunctionFieldNumber = 5,
    kIfThenFieldNumber = 6,
    kSwitchExpressionFieldNumber = 7,
    kSingularOrListFieldNumber = 8,
    kMultiOrListFieldNumber = 9,
    kCastFieldNumber = 11,
    kSubqueryFieldNumber = 12,
    kNestedFieldNumber = 13,
    kEnumFieldNumber = 10,
  };
  // .substrait.Expression.Literal literal = 1;
  bool has_literal() const;
  private:
  bool _internal_has_literal() const;

  public:
  void clear_literal() ;
  const ::substrait::Expression_Literal& literal() const;
  [[nodiscard]] ::substrait::Expression_Literal* release_literal();
  ::substrait::Expression_Literal* mutable_literal();
  void set_allocated_literal(::substrait::Expression_Literal* value);
  void unsafe_arena_set_allocated_literal(::substrait::Expression_Literal* value);
  ::substrait::Expression_Literal* unsafe_arena_release_literal();

  private:
  const ::substrait::Expression_Literal& _internal_literal() const;
  ::substrait::Expression_Literal* _internal_mutable_literal();

  public:
  // .substrait.Expression.FieldReference selection = 2;
  bool has_selection() const;
  private:
  bool _internal_has_selection() const;

  public:
  void clear_selection() ;
  const ::substrait::Expression_FieldReference& selection() const;
  [[nodiscard]] ::substrait::Expression_FieldReference* release_selection();
  ::substrait::Expression_FieldReference* mutable_selection();
  void set_allocated_selection(::substrait::Expression_FieldReference* value);
  void unsafe_arena_set_allocated_selection(::substrait::Expression_FieldReference* value);
  ::substrait::Expression_FieldReference* unsafe_arena_release_selection();

  private:
  const ::substrait::Expression_FieldReference& _internal_selection() const;
  ::substrait::Expression_FieldReference* _internal_mutable_selection();

  public:
  // .substrait.Expression.ScalarFunction scalar_function = 3;
  bool has_scalar_function() const;
  private:
  bool _internal_has_scalar_function() const;

  public:
  void clear_scalar_function() ;
  const ::substrait::Expression_ScalarFunction& scalar_function() const;
  [[nodiscard]] ::substrait::Expression_ScalarFunction* release_scalar_function();
  ::substrait::Expression_ScalarFunction* mutable_scalar_function();
  void set_allocated_scalar_function(::substrait::Expression_ScalarFunction* value);
  void unsafe_arena_set_allocated_scalar_function(::substrait::Expression_ScalarFunction* value);
  ::substrait::Expression_ScalarFunction* unsafe_arena_release_scalar_function();

  private:
  const ::substrait::Expression_ScalarFunction& _internal_scalar_function() const;
  ::substrait::Expression_ScalarFunction* _internal_mutable_scalar_function();

  public:
  // .substrait.Expression.WindowFunction window_function = 5;
  bool has_window_function() const;
  private:
  bool _internal_has_window_function() const;

  public:
  void clear_window_function() ;
  const ::substrait::Expression_WindowFunction& window_function() const;
  [[nodiscard]] ::substrait::Expression_WindowFunction* release_window_function();
  ::substrait::Expression_WindowFunction* mutable_window_function();
  void set_allocated_window_function(::substrait::Expression_WindowFunction* value);
  void unsafe_arena_set_allocated_window_function(::substrait::Expression_WindowFunction* value);
  ::substrait::Expression_WindowFunction* unsafe_arena_release_window_function();

  private:
  const ::substrait::Expression_WindowFunction& _internal_window_function() const;
  ::substrait::Expression_WindowFunction* _internal_mutable_window_function();

  public:
  // .substrait.Expression.IfThen if_then = 6;
  bool has_if_then() const;
  private:
  bool _internal_has_if_then() const;

  public:
  void clear_if_then() ;
  const ::substrait::Expression_IfThen& if_then() const;
  [[nodiscard]] ::substrait::Expression_IfThen* release_if_then();
  ::substrait::Expression_IfThen* mutable_if_then();
  void set_allocated_if_then(::substrait::Expression_IfThen* value);
  void unsafe_arena_set_allocated_if_then(::substrait::Expression_IfThen* value);
  ::substrait::Expression_IfThen* unsafe_arena_release_if_then();

  private:
  const ::substrait::Expression_IfThen& _internal_if_then() const;
  ::substrait::Expression_IfThen* _internal_mutable_if_then();

  public:
  // .substrait.Expression.SwitchExpression switch_expression = 7;
  bool has_switch_expression() const;
  private:
  bool _internal_has_switch_expression() const;

  public:
  void clear_switch_expression() ;
  const ::substrait::Expression_SwitchExpression& switch_expression() const;
  [[nodiscard]] ::substrait::Expression_SwitchExpression* release_switch_expression();
  ::substrait::Expression_SwitchExpression* mutable_switch_expression();
  void set_allocated_switch_expression(::substrait::Expression_SwitchExpression* value);
  void unsafe_arena_set_allocated_switch_expression(::substrait::Expression_SwitchExpression* value);
  ::substrait::Expression_SwitchExpression* unsafe_arena_release_switch_expression();

  private:
  const ::substrait::Expression_SwitchExpression& _internal_switch_expression() const;
  ::substrait::Expression_SwitchExpression* _internal_mutable_switch_expression();

  public:
  // .substrait.Expression.SingularOrList singular_or_list = 8;
  bool has_singular_or_list() const;
  private:
  bool _internal_has_singular_or_list() const;

  public:
  void clear_singular_or_list() ;
  const ::substrait::Expression_SingularOrList& singular_or_list() const;
  [[nodiscard]] ::substrait::Expression_SingularOrList* release_singular_or_list();
  ::substrait::Expression_SingularOrList* mutable_singular_or_list();
  void set_allocated_singular_or_list(::substrait::Expression_SingularOrList* value);
  void unsafe_arena_set_allocated_singular_or_list(::substrait::Expression_SingularOrList* value);
  ::substrait::Expression_SingularOrList* unsafe_arena_release_singular_or_list();

  private:
  const ::substrait::Expression_SingularOrList& _internal_singular_or_list() const;
  ::substrait::Expression_SingularOrList* _internal_mutable_singular_or_list();

  public:
  // .substrait.Expression.MultiOrList multi_or_list = 9;
  bool has_multi_or_list() const;
  private:
  bool _internal_has_multi_or_list() const;

  public:
  void clear_multi_or_list() ;
  const ::substrait::Expression_MultiOrList& multi_or_list() const;
  [[nodiscard]] ::substrait::Expression_MultiOrList* release_multi_or_list();
  ::substrait::Expression_MultiOrList* mutable_multi_or_list();
  void set_allocated_multi_or_list(::substrait::Expression_MultiOrList* value);
  void unsafe_arena_set_allocated_multi_or_list(::substrait::Expression_MultiOrList* value);
  ::substrait::Expression_MultiOrList* unsafe_arena_release_multi_or_list();

  private:
  const ::substrait::Expression_MultiOrList& _internal_multi_or_list() const;
  ::substrait::Expression_MultiOrList* _internal_mutable_multi_or_list();

  public:
  // .substrait.Expression.Cast cast = 11;
  bool has_cast() const;
  private:
  bool _internal_has_cast() const;

  public:
  void clear_cast() ;
  const ::substrait::Expression_Cast& cast() const;
  [[nodiscard]] ::substrait::Expression_Cast* release_cast();
  ::substrait::Expression_Cast* mutable_cast();
  void set_allocated_cast(::substrait::Expression_Cast* value);
  void unsafe_arena_set_allocated_cast(::substrait::Expression_Cast* value);
  ::substrait::Expression_Cast* unsafe_arena_release_cast();

  private:
  const ::substrait::Expression_Cast& _internal_cast() const;
  ::substrait::Expression_Cast* _internal_mutable_cast();

  public:
  // .substrait.Expression.Subquery subquery = 12;
  bool has_subquery() const;
  private:
  bool _internal_has_subquery() const;

  public:
  void clear_subquery() ;
  const ::substrait::Expression_Subquery& subquery() const;
  [[nodiscard]] ::substrait::Expression_Subquery* release_subquery();
  ::substrait::Expression_Subquery* mutable_subquery();
  void set_allocated_subquery(::substrait::Expression_Subquery* value);
  void unsafe_arena_set_allocated_subquery(::substrait::Expression_Subquery* value);
  ::substrait::Expression_Subquery* unsafe_arena_release_subquery();

  private:
  const ::substrait::Expression_Subquery& _internal_subquery() const;
  ::substrait::Expression_Subquery* _internal_mutable_subquery();

  public:
  // .substrait.Expression.Nested nested = 13;
  bool has_nested() const;
  private:
  bool _internal_has_nested() const;

  public:
  void clear_nested() ;
  const ::substrait::Expression_Nested& nested() const;
  [[nodiscard]] ::substrait::Expression_Nested* release_nested();
  ::substrait::Expression_Nested* mutable_nested();
  void set_allocated_nested(::substrait::Expression_Nested* value);
  void unsafe_arena_set_allocated_nested(::substrait::Expression_Nested* value);
  ::substrait::Expression_Nested* unsafe_arena_release_nested();

  private:
  const ::substrait::Expression_Nested& _internal_nested() const;
  ::substrait::Expression_Nested* _internal_mutable_nested();

  public:
  // .substrait.Expression.Enum enum = 10 [deprecated = true];
  [[deprecated]]  bool has_enum_() const;
  private:
  bool _internal_has_enum_() const;

  public:
  [[deprecated]]  void clear_enum_() ;
  [[deprecated]] const ::substrait::Expression_Enum& enum_() const;
  [[deprecated]] [[nodiscard]] ::substrait::Expression_Enum* release_enum_();
  [[deprecated]] ::substrait::Expression_Enum* mutable_enum_();
  [[deprecated]] void set_allocated_enum_(::substrait::Expression_Enum* value);
  [[deprecated]] void unsafe_arena_set_allocated_enum_(::substrait::Expression_Enum* value);
  [[deprecated]] ::substrait::Expression_Enum* unsafe_arena_release_enum_();

  private:
  const ::substrait::Expression_Enum& _internal_enum_() const;
  ::substrait::Expression_Enum* _internal_mutable_enum_();

  public:
  void clear_rex_type();
  RexTypeCase rex_type_case() const;
  // @@protoc_insertion_point(class_scope:substrait.Expression)
 private:
  class _Internal;
  void set_has_literal();
  void set_has_selection();
  void set_has_scalar_function();
  void set_has_window_function();
  void set_has_if_then();
  void set_has_switch_expression();
  void set_has_singular_or_list();
  void set_has_multi_or_list();
  void set_has_cast();
  void set_has_subquery();
  void set_has_nested();
  void set_has_enum_();
  inline bool has_rex_type() const;
  inline void clear_has_rex_type();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 12, 12,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression& from_msg);
    union RexTypeUnion {
      constexpr RexTypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::substrait::Expression_Literal* literal_;
      ::substrait::Expression_FieldReference* selection_;
      ::substrait::Expression_ScalarFunction* scalar_function_;
      ::substrait::Expression_WindowFunction* window_function_;
      ::substrait::Expression_IfThen* if_then_;
      ::substrait::Expression_SwitchExpression* switch_expression_;
      ::substrait::Expression_SingularOrList* singular_or_list_;
      ::substrait::Expression_MultiOrList* multi_or_list_;
      ::substrait::Expression_Cast* cast_;
      ::substrait::Expression_Subquery* subquery_;
      ::substrait::Expression_Nested* nested_;
      ::substrait::Expression_Enum* enum__;
    } rex_type_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_class_data_;
// -------------------------------------------------------------------

class Expression_Cast final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.Cast) */ {
 public:
  inline Expression_Cast() : Expression_Cast(nullptr) {}
  ~Expression_Cast() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_Cast* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_Cast));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_Cast(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_Cast(const Expression_Cast& from) : Expression_Cast(nullptr, from) {}
  inline Expression_Cast(Expression_Cast&& from) noexcept
      : Expression_Cast(nullptr, std::move(from)) {}
  inline Expression_Cast& operator=(const Expression_Cast& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_Cast& operator=(Expression_Cast&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_Cast& default_instance() {
    return *reinterpret_cast<const Expression_Cast*>(
        &_Expression_Cast_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 80;
  friend void swap(Expression_Cast& a, Expression_Cast& b) { a.Swap(&b); }
  inline void Swap(Expression_Cast* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_Cast* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_Cast* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_Cast>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_Cast& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_Cast& from) { Expression_Cast::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_Cast* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.Cast"; }

 protected:
  explicit Expression_Cast(::google::protobuf::Arena* arena);
  Expression_Cast(::google::protobuf::Arena* arena, const Expression_Cast& from);
  Expression_Cast(::google::protobuf::Arena* arena, Expression_Cast&& from) noexcept
      : Expression_Cast(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using FailureBehavior = Expression_Cast_FailureBehavior;
  static constexpr FailureBehavior FAILURE_BEHAVIOR_UNSPECIFIED = Expression_Cast_FailureBehavior_FAILURE_BEHAVIOR_UNSPECIFIED;
  static constexpr FailureBehavior FAILURE_BEHAVIOR_RETURN_NULL = Expression_Cast_FailureBehavior_FAILURE_BEHAVIOR_RETURN_NULL;
  static constexpr FailureBehavior FAILURE_BEHAVIOR_THROW_EXCEPTION = Expression_Cast_FailureBehavior_FAILURE_BEHAVIOR_THROW_EXCEPTION;
  static inline bool FailureBehavior_IsValid(int value) {
    return Expression_Cast_FailureBehavior_IsValid(value);
  }
  static constexpr FailureBehavior FailureBehavior_MIN = Expression_Cast_FailureBehavior_FailureBehavior_MIN;
  static constexpr FailureBehavior FailureBehavior_MAX = Expression_Cast_FailureBehavior_FailureBehavior_MAX;
  static constexpr int FailureBehavior_ARRAYSIZE = Expression_Cast_FailureBehavior_FailureBehavior_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* FailureBehavior_descriptor() {
    return Expression_Cast_FailureBehavior_descriptor();
  }
  template <typename T>
  static inline const std::string& FailureBehavior_Name(T value) {
    return Expression_Cast_FailureBehavior_Name(value);
  }
  static inline bool FailureBehavior_Parse(absl::string_view name, FailureBehavior* value) {
    return Expression_Cast_FailureBehavior_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kTypeFieldNumber = 1,
    kInputFieldNumber = 2,
    kFailureBehaviorFieldNumber = 3,
  };
  // .substrait.Type type = 1;
  bool has_type() const;
  void clear_type() ;
  const ::substrait::Type& type() const;
  [[nodiscard]] ::substrait::Type* release_type();
  ::substrait::Type* mutable_type();
  void set_allocated_type(::substrait::Type* value);
  void unsafe_arena_set_allocated_type(::substrait::Type* value);
  ::substrait::Type* unsafe_arena_release_type();

  private:
  const ::substrait::Type& _internal_type() const;
  ::substrait::Type* _internal_mutable_type();

  public:
  // .substrait.Expression input = 2;
  bool has_input() const;
  void clear_input() ;
  const ::substrait::Expression& input() const;
  [[nodiscard]] ::substrait::Expression* release_input();
  ::substrait::Expression* mutable_input();
  void set_allocated_input(::substrait::Expression* value);
  void unsafe_arena_set_allocated_input(::substrait::Expression* value);
  ::substrait::Expression* unsafe_arena_release_input();

  private:
  const ::substrait::Expression& _internal_input() const;
  ::substrait::Expression* _internal_mutable_input();

  public:
  // .substrait.Expression.Cast.FailureBehavior failure_behavior = 3;
  void clear_failure_behavior() ;
  ::substrait::Expression_Cast_FailureBehavior failure_behavior() const;
  void set_failure_behavior(::substrait::Expression_Cast_FailureBehavior value);

  private:
  ::substrait::Expression_Cast_FailureBehavior _internal_failure_behavior() const;
  void _internal_set_failure_behavior(::substrait::Expression_Cast_FailureBehavior value);

  public:
  // @@protoc_insertion_point(class_scope:substrait.Expression.Cast)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_Cast& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::substrait::Type* type_;
    ::substrait::Expression* input_;
    int failure_behavior_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_Cast_class_data_;
// -------------------------------------------------------------------

class Expression_FieldReference final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.FieldReference) */ {
 public:
  inline Expression_FieldReference() : Expression_FieldReference(nullptr) {}
  ~Expression_FieldReference() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_FieldReference* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_FieldReference));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_FieldReference(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_FieldReference(const Expression_FieldReference& from) : Expression_FieldReference(nullptr, from) {}
  inline Expression_FieldReference(Expression_FieldReference&& from) noexcept
      : Expression_FieldReference(nullptr, std::move(from)) {}
  inline Expression_FieldReference& operator=(const Expression_FieldReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_FieldReference& operator=(Expression_FieldReference&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_FieldReference& default_instance() {
    return *reinterpret_cast<const Expression_FieldReference*>(
        &_Expression_FieldReference_default_instance_);
  }
  enum ReferenceTypeCase {
    kDirectReference = 1,
    kMaskedReference = 2,
    REFERENCE_TYPE_NOT_SET = 0,
  };
  enum RootTypeCase {
    kExpression = 3,
    kRootReference = 4,
    kOuterReference = 5,
    ROOT_TYPE_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 106;
  friend void swap(Expression_FieldReference& a, Expression_FieldReference& b) { a.Swap(&b); }
  inline void Swap(Expression_FieldReference* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_FieldReference* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_FieldReference* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_FieldReference>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_FieldReference& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_FieldReference& from) { Expression_FieldReference::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_FieldReference* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.FieldReference"; }

 protected:
  explicit Expression_FieldReference(::google::protobuf::Arena* arena);
  Expression_FieldReference(::google::protobuf::Arena* arena, const Expression_FieldReference& from);
  Expression_FieldReference(::google::protobuf::Arena* arena, Expression_FieldReference&& from) noexcept
      : Expression_FieldReference(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using RootReference = Expression_FieldReference_RootReference;
  using OuterReference = Expression_FieldReference_OuterReference;

  // accessors -------------------------------------------------------
  enum : int {
    kDirectReferenceFieldNumber = 1,
    kMaskedReferenceFieldNumber = 2,
    kExpressionFieldNumber = 3,
    kRootReferenceFieldNumber = 4,
    kOuterReferenceFieldNumber = 5,
  };
  // .substrait.Expression.ReferenceSegment direct_reference = 1;
  bool has_direct_reference() const;
  private:
  bool _internal_has_direct_reference() const;

  public:
  void clear_direct_reference() ;
  const ::substrait::Expression_ReferenceSegment& direct_reference() const;
  [[nodiscard]] ::substrait::Expression_ReferenceSegment* release_direct_reference();
  ::substrait::Expression_ReferenceSegment* mutable_direct_reference();
  void set_allocated_direct_reference(::substrait::Expression_ReferenceSegment* value);
  void unsafe_arena_set_allocated_direct_reference(::substrait::Expression_ReferenceSegment* value);
  ::substrait::Expression_ReferenceSegment* unsafe_arena_release_direct_reference();

  private:
  const ::substrait::Expression_ReferenceSegment& _internal_direct_reference() const;
  ::substrait::Expression_ReferenceSegment* _internal_mutable_direct_reference();

  public:
  // .substrait.Expression.MaskExpression masked_reference = 2;
  bool has_masked_reference() const;
  private:
  bool _internal_has_masked_reference() const;

  public:
  void clear_masked_reference() ;
  const ::substrait::Expression_MaskExpression& masked_reference() const;
  [[nodiscard]] ::substrait::Expression_MaskExpression* release_masked_reference();
  ::substrait::Expression_MaskExpression* mutable_masked_reference();
  void set_allocated_masked_reference(::substrait::Expression_MaskExpression* value);
  void unsafe_arena_set_allocated_masked_reference(::substrait::Expression_MaskExpression* value);
  ::substrait::Expression_MaskExpression* unsafe_arena_release_masked_reference();

  private:
  const ::substrait::Expression_MaskExpression& _internal_masked_reference() const;
  ::substrait::Expression_MaskExpression* _internal_mutable_masked_reference();

  public:
  // .substrait.Expression expression = 3;
  bool has_expression() const;
  private:
  bool _internal_has_expression() const;

  public:
  void clear_expression() ;
  const ::substrait::Expression& expression() const;
  [[nodiscard]] ::substrait::Expression* release_expression();
  ::substrait::Expression* mutable_expression();
  void set_allocated_expression(::substrait::Expression* value);
  void unsafe_arena_set_allocated_expression(::substrait::Expression* value);
  ::substrait::Expression* unsafe_arena_release_expression();

  private:
  const ::substrait::Expression& _internal_expression() const;
  ::substrait::Expression* _internal_mutable_expression();

  public:
  // .substrait.Expression.FieldReference.RootReference root_reference = 4;
  bool has_root_reference() const;
  private:
  bool _internal_has_root_reference() const;

  public:
  void clear_root_reference() ;
  const ::substrait::Expression_FieldReference_RootReference& root_reference() const;
  [[nodiscard]] ::substrait::Expression_FieldReference_RootReference* release_root_reference();
  ::substrait::Expression_FieldReference_RootReference* mutable_root_reference();
  void set_allocated_root_reference(::substrait::Expression_FieldReference_RootReference* value);
  void unsafe_arena_set_allocated_root_reference(::substrait::Expression_FieldReference_RootReference* value);
  ::substrait::Expression_FieldReference_RootReference* unsafe_arena_release_root_reference();

  private:
  const ::substrait::Expression_FieldReference_RootReference& _internal_root_reference() const;
  ::substrait::Expression_FieldReference_RootReference* _internal_mutable_root_reference();

  public:
  // .substrait.Expression.FieldReference.OuterReference outer_reference = 5;
  bool has_outer_reference() const;
  private:
  bool _internal_has_outer_reference() const;

  public:
  void clear_outer_reference() ;
  const ::substrait::Expression_FieldReference_OuterReference& outer_reference() const;
  [[nodiscard]] ::substrait::Expression_FieldReference_OuterReference* release_outer_reference();
  ::substrait::Expression_FieldReference_OuterReference* mutable_outer_reference();
  void set_allocated_outer_reference(::substrait::Expression_FieldReference_OuterReference* value);
  void unsafe_arena_set_allocated_outer_reference(::substrait::Expression_FieldReference_OuterReference* value);
  ::substrait::Expression_FieldReference_OuterReference* unsafe_arena_release_outer_reference();

  private:
  const ::substrait::Expression_FieldReference_OuterReference& _internal_outer_reference() const;
  ::substrait::Expression_FieldReference_OuterReference* _internal_mutable_outer_reference();

  public:
  void clear_reference_type();
  ReferenceTypeCase reference_type_case() const;
  void clear_root_type();
  RootTypeCase root_type_case() const;
  // @@protoc_insertion_point(class_scope:substrait.Expression.FieldReference)
 private:
  class _Internal;
  void set_has_direct_reference();
  void set_has_masked_reference();
  void set_has_expression();
  void set_has_root_reference();
  void set_has_outer_reference();
  inline bool has_reference_type() const;
  inline void clear_has_reference_type();
  inline bool has_root_type() const;
  inline void clear_has_root_type();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 5, 5,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_FieldReference& from_msg);
    union ReferenceTypeUnion {
      constexpr ReferenceTypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::substrait::Expression_ReferenceSegment* direct_reference_;
      ::substrait::Expression_MaskExpression* masked_reference_;
    } reference_type_;
    union RootTypeUnion {
      constexpr RootTypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::substrait::Expression* expression_;
      ::substrait::Expression_FieldReference_RootReference* root_reference_;
      ::substrait::Expression_FieldReference_OuterReference* outer_reference_;
    } root_type_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[2];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_FieldReference_class_data_;
// -------------------------------------------------------------------

class Expression_IfThen final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.IfThen) */ {
 public:
  inline Expression_IfThen() : Expression_IfThen(nullptr) {}
  ~Expression_IfThen() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_IfThen* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_IfThen));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_IfThen(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_IfThen(const Expression_IfThen& from) : Expression_IfThen(nullptr, from) {}
  inline Expression_IfThen(Expression_IfThen&& from) noexcept
      : Expression_IfThen(nullptr, std::move(from)) {}
  inline Expression_IfThen& operator=(const Expression_IfThen& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_IfThen& operator=(Expression_IfThen&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_IfThen& default_instance() {
    return *reinterpret_cast<const Expression_IfThen*>(
        &_Expression_IfThen_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 79;
  friend void swap(Expression_IfThen& a, Expression_IfThen& b) { a.Swap(&b); }
  inline void Swap(Expression_IfThen* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_IfThen* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_IfThen* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_IfThen>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_IfThen& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_IfThen& from) { Expression_IfThen::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_IfThen* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.IfThen"; }

 protected:
  explicit Expression_IfThen(::google::protobuf::Arena* arena);
  Expression_IfThen(::google::protobuf::Arena* arena, const Expression_IfThen& from);
  Expression_IfThen(::google::protobuf::Arena* arena, Expression_IfThen&& from) noexcept
      : Expression_IfThen(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using IfClause = Expression_IfThen_IfClause;

  // accessors -------------------------------------------------------
  enum : int {
    kIfsFieldNumber = 1,
    kElseFieldNumber = 2,
  };
  // repeated .substrait.Expression.IfThen.IfClause ifs = 1;
  int ifs_size() const;
  private:
  int _internal_ifs_size() const;

  public:
  void clear_ifs() ;
  ::substrait::Expression_IfThen_IfClause* mutable_ifs(int index);
  ::google::protobuf::RepeatedPtrField<::substrait::Expression_IfThen_IfClause>* mutable_ifs();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression_IfThen_IfClause>& _internal_ifs() const;
  ::google::protobuf::RepeatedPtrField<::substrait::Expression_IfThen_IfClause>* _internal_mutable_ifs();
  public:
  const ::substrait::Expression_IfThen_IfClause& ifs(int index) const;
  ::substrait::Expression_IfThen_IfClause* add_ifs();
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression_IfThen_IfClause>& ifs() const;
  // .substrait.Expression else = 2;
  bool has_else_() const;
  void clear_else_() ;
  const ::substrait::Expression& else_() const;
  [[nodiscard]] ::substrait::Expression* release_else_();
  ::substrait::Expression* mutable_else_();
  void set_allocated_else_(::substrait::Expression* value);
  void unsafe_arena_set_allocated_else_(::substrait::Expression* value);
  ::substrait::Expression* unsafe_arena_release_else_();

  private:
  const ::substrait::Expression& _internal_else_() const;
  ::substrait::Expression* _internal_mutable_else_();

  public:
  // @@protoc_insertion_point(class_scope:substrait.Expression.IfThen)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_IfThen& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::substrait::Expression_IfThen_IfClause > ifs_;
    ::substrait::Expression* else__;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_IfThen_class_data_;
// -------------------------------------------------------------------

class Expression_IfThen_IfClause final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.IfThen.IfClause) */ {
 public:
  inline Expression_IfThen_IfClause() : Expression_IfThen_IfClause(nullptr) {}
  ~Expression_IfThen_IfClause() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_IfThen_IfClause* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_IfThen_IfClause));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_IfThen_IfClause(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_IfThen_IfClause(const Expression_IfThen_IfClause& from) : Expression_IfThen_IfClause(nullptr, from) {}
  inline Expression_IfThen_IfClause(Expression_IfThen_IfClause&& from) noexcept
      : Expression_IfThen_IfClause(nullptr, std::move(from)) {}
  inline Expression_IfThen_IfClause& operator=(const Expression_IfThen_IfClause& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_IfThen_IfClause& operator=(Expression_IfThen_IfClause&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_IfThen_IfClause& default_instance() {
    return *reinterpret_cast<const Expression_IfThen_IfClause*>(
        &_Expression_IfThen_IfClause_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 78;
  friend void swap(Expression_IfThen_IfClause& a, Expression_IfThen_IfClause& b) { a.Swap(&b); }
  inline void Swap(Expression_IfThen_IfClause* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_IfThen_IfClause* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_IfThen_IfClause* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_IfThen_IfClause>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_IfThen_IfClause& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_IfThen_IfClause& from) { Expression_IfThen_IfClause::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_IfThen_IfClause* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.IfThen.IfClause"; }

 protected:
  explicit Expression_IfThen_IfClause(::google::protobuf::Arena* arena);
  Expression_IfThen_IfClause(::google::protobuf::Arena* arena, const Expression_IfThen_IfClause& from);
  Expression_IfThen_IfClause(::google::protobuf::Arena* arena, Expression_IfThen_IfClause&& from) noexcept
      : Expression_IfThen_IfClause(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIfFieldNumber = 1,
    kThenFieldNumber = 2,
  };
  // .substrait.Expression if = 1;
  bool has_if_() const;
  void clear_if_() ;
  const ::substrait::Expression& if_() const;
  [[nodiscard]] ::substrait::Expression* release_if_();
  ::substrait::Expression* mutable_if_();
  void set_allocated_if_(::substrait::Expression* value);
  void unsafe_arena_set_allocated_if_(::substrait::Expression* value);
  ::substrait::Expression* unsafe_arena_release_if_();

  private:
  const ::substrait::Expression& _internal_if_() const;
  ::substrait::Expression* _internal_mutable_if_();

  public:
  // .substrait.Expression then = 2;
  bool has_then() const;
  void clear_then() ;
  const ::substrait::Expression& then() const;
  [[nodiscard]] ::substrait::Expression* release_then();
  ::substrait::Expression* mutable_then();
  void set_allocated_then(::substrait::Expression* value);
  void unsafe_arena_set_allocated_then(::substrait::Expression* value);
  ::substrait::Expression* unsafe_arena_release_then();

  private:
  const ::substrait::Expression& _internal_then() const;
  ::substrait::Expression* _internal_mutable_then();

  public:
  // @@protoc_insertion_point(class_scope:substrait.Expression.IfThen.IfClause)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_IfThen_IfClause& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::substrait::Expression* if__;
    ::substrait::Expression* then_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_IfThen_IfClause_class_data_;
// -------------------------------------------------------------------

class Expression_MultiOrList final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.MultiOrList) */ {
 public:
  inline Expression_MultiOrList() : Expression_MultiOrList(nullptr) {}
  ~Expression_MultiOrList() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_MultiOrList* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_MultiOrList));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_MultiOrList(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_MultiOrList(const Expression_MultiOrList& from) : Expression_MultiOrList(nullptr, from) {}
  inline Expression_MultiOrList(Expression_MultiOrList&& from) noexcept
      : Expression_MultiOrList(nullptr, std::move(from)) {}
  inline Expression_MultiOrList& operator=(const Expression_MultiOrList& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_MultiOrList& operator=(Expression_MultiOrList&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_MultiOrList& default_instance() {
    return *reinterpret_cast<const Expression_MultiOrList*>(
        &_Expression_MultiOrList_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 85;
  friend void swap(Expression_MultiOrList& a, Expression_MultiOrList& b) { a.Swap(&b); }
  inline void Swap(Expression_MultiOrList* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_MultiOrList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_MultiOrList* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_MultiOrList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_MultiOrList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_MultiOrList& from) { Expression_MultiOrList::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_MultiOrList* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.MultiOrList"; }

 protected:
  explicit Expression_MultiOrList(::google::protobuf::Arena* arena);
  Expression_MultiOrList(::google::protobuf::Arena* arena, const Expression_MultiOrList& from);
  Expression_MultiOrList(::google::protobuf::Arena* arena, Expression_MultiOrList&& from) noexcept
      : Expression_MultiOrList(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Record = Expression_MultiOrList_Record;

  // accessors -------------------------------------------------------
  enum : int {
    kValueFieldNumber = 1,
    kOptionsFieldNumber = 2,
  };
  // repeated .substrait.Expression value = 1;
  int value_size() const;
  private:
  int _internal_value_size() const;

  public:
  void clear_value() ;
  ::substrait::Expression* mutable_value(int index);
  ::google::protobuf::RepeatedPtrField<::substrait::Expression>* mutable_value();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression>& _internal_value() const;
  ::google::protobuf::RepeatedPtrField<::substrait::Expression>* _internal_mutable_value();
  public:
  const ::substrait::Expression& value(int index) const;
  ::substrait::Expression* add_value();
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression>& value() const;
  // repeated .substrait.Expression.MultiOrList.Record options = 2;
  int options_size() const;
  private:
  int _internal_options_size() const;

  public:
  void clear_options() ;
  ::substrait::Expression_MultiOrList_Record* mutable_options(int index);
  ::google::protobuf::RepeatedPtrField<::substrait::Expression_MultiOrList_Record>* mutable_options();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression_MultiOrList_Record>& _internal_options() const;
  ::google::protobuf::RepeatedPtrField<::substrait::Expression_MultiOrList_Record>* _internal_mutable_options();
  public:
  const ::substrait::Expression_MultiOrList_Record& options(int index) const;
  ::substrait::Expression_MultiOrList_Record* add_options();
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression_MultiOrList_Record>& options() const;
  // @@protoc_insertion_point(class_scope:substrait.Expression.MultiOrList)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_MultiOrList& from_msg);
    ::google::protobuf::RepeatedPtrField< ::substrait::Expression > value_;
    ::google::protobuf::RepeatedPtrField< ::substrait::Expression_MultiOrList_Record > options_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_MultiOrList_class_data_;
// -------------------------------------------------------------------

class Expression_MultiOrList_Record final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.MultiOrList.Record) */ {
 public:
  inline Expression_MultiOrList_Record() : Expression_MultiOrList_Record(nullptr) {}
  ~Expression_MultiOrList_Record() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_MultiOrList_Record* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_MultiOrList_Record));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_MultiOrList_Record(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_MultiOrList_Record(const Expression_MultiOrList_Record& from) : Expression_MultiOrList_Record(nullptr, from) {}
  inline Expression_MultiOrList_Record(Expression_MultiOrList_Record&& from) noexcept
      : Expression_MultiOrList_Record(nullptr, std::move(from)) {}
  inline Expression_MultiOrList_Record& operator=(const Expression_MultiOrList_Record& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_MultiOrList_Record& operator=(Expression_MultiOrList_Record&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_MultiOrList_Record& default_instance() {
    return *reinterpret_cast<const Expression_MultiOrList_Record*>(
        &_Expression_MultiOrList_Record_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 84;
  friend void swap(Expression_MultiOrList_Record& a, Expression_MultiOrList_Record& b) { a.Swap(&b); }
  inline void Swap(Expression_MultiOrList_Record* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_MultiOrList_Record* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_MultiOrList_Record* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_MultiOrList_Record>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_MultiOrList_Record& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_MultiOrList_Record& from) { Expression_MultiOrList_Record::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_MultiOrList_Record* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.MultiOrList.Record"; }

 protected:
  explicit Expression_MultiOrList_Record(::google::protobuf::Arena* arena);
  Expression_MultiOrList_Record(::google::protobuf::Arena* arena, const Expression_MultiOrList_Record& from);
  Expression_MultiOrList_Record(::google::protobuf::Arena* arena, Expression_MultiOrList_Record&& from) noexcept
      : Expression_MultiOrList_Record(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFieldsFieldNumber = 1,
  };
  // repeated .substrait.Expression fields = 1;
  int fields_size() const;
  private:
  int _internal_fields_size() const;

  public:
  void clear_fields() ;
  ::substrait::Expression* mutable_fields(int index);
  ::google::protobuf::RepeatedPtrField<::substrait::Expression>* mutable_fields();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression>& _internal_fields() const;
  ::google::protobuf::RepeatedPtrField<::substrait::Expression>* _internal_mutable_fields();
  public:
  const ::substrait::Expression& fields(int index) const;
  ::substrait::Expression* add_fields();
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression>& fields() const;
  // @@protoc_insertion_point(class_scope:substrait.Expression.MultiOrList.Record)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_MultiOrList_Record& from_msg);
    ::google::protobuf::RepeatedPtrField< ::substrait::Expression > fields_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_MultiOrList_Record_class_data_;
// -------------------------------------------------------------------

class Expression_Nested final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.Nested) */ {
 public:
  inline Expression_Nested() : Expression_Nested(nullptr) {}
  ~Expression_Nested() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_Nested* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_Nested));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_Nested(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_Nested(const Expression_Nested& from) : Expression_Nested(nullptr, from) {}
  inline Expression_Nested(Expression_Nested&& from) noexcept
      : Expression_Nested(nullptr, std::move(from)) {}
  inline Expression_Nested& operator=(const Expression_Nested& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_Nested& operator=(Expression_Nested&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_Nested& default_instance() {
    return *reinterpret_cast<const Expression_Nested*>(
        &_Expression_Nested_default_instance_);
  }
  enum NestedTypeCase {
    kStruct = 3,
    kList = 4,
    kMap = 5,
    NESTED_TYPE_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 70;
  friend void swap(Expression_Nested& a, Expression_Nested& b) { a.Swap(&b); }
  inline void Swap(Expression_Nested* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_Nested* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_Nested* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_Nested>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_Nested& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_Nested& from) { Expression_Nested::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_Nested* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.Nested"; }

 protected:
  explicit Expression_Nested(::google::protobuf::Arena* arena);
  Expression_Nested(::google::protobuf::Arena* arena, const Expression_Nested& from);
  Expression_Nested(::google::protobuf::Arena* arena, Expression_Nested&& from) noexcept
      : Expression_Nested(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Map = Expression_Nested_Map;
  using Struct = Expression_Nested_Struct;
  using List = Expression_Nested_List;

  // accessors -------------------------------------------------------
  enum : int {
    kNullableFieldNumber = 1,
    kTypeVariationReferenceFieldNumber = 2,
    kStructFieldNumber = 3,
    kListFieldNumber = 4,
    kMapFieldNumber = 5,
  };
  // bool nullable = 1;
  void clear_nullable() ;
  bool nullable() const;
  void set_nullable(bool value);

  private:
  bool _internal_nullable() const;
  void _internal_set_nullable(bool value);

  public:
  // uint32 type_variation_reference = 2;
  void clear_type_variation_reference() ;
  ::uint32_t type_variation_reference() const;
  void set_type_variation_reference(::uint32_t value);

  private:
  ::uint32_t _internal_type_variation_reference() const;
  void _internal_set_type_variation_reference(::uint32_t value);

  public:
  // .substrait.Expression.Nested.Struct struct = 3;
  bool has_struct_() const;
  private:
  bool _internal_has_struct_() const;

  public:
  void clear_struct_() ;
  const ::substrait::Expression_Nested_Struct& struct_() const;
  [[nodiscard]] ::substrait::Expression_Nested_Struct* release_struct_();
  ::substrait::Expression_Nested_Struct* mutable_struct_();
  void set_allocated_struct_(::substrait::Expression_Nested_Struct* value);
  void unsafe_arena_set_allocated_struct_(::substrait::Expression_Nested_Struct* value);
  ::substrait::Expression_Nested_Struct* unsafe_arena_release_struct_();

  private:
  const ::substrait::Expression_Nested_Struct& _internal_struct_() const;
  ::substrait::Expression_Nested_Struct* _internal_mutable_struct_();

  public:
  // .substrait.Expression.Nested.List list = 4;
  bool has_list() const;
  private:
  bool _internal_has_list() const;

  public:
  void clear_list() ;
  const ::substrait::Expression_Nested_List& list() const;
  [[nodiscard]] ::substrait::Expression_Nested_List* release_list();
  ::substrait::Expression_Nested_List* mutable_list();
  void set_allocated_list(::substrait::Expression_Nested_List* value);
  void unsafe_arena_set_allocated_list(::substrait::Expression_Nested_List* value);
  ::substrait::Expression_Nested_List* unsafe_arena_release_list();

  private:
  const ::substrait::Expression_Nested_List& _internal_list() const;
  ::substrait::Expression_Nested_List* _internal_mutable_list();

  public:
  // .substrait.Expression.Nested.Map map = 5;
  bool has_map() const;
  private:
  bool _internal_has_map() const;

  public:
  void clear_map() ;
  const ::substrait::Expression_Nested_Map& map() const;
  [[nodiscard]] ::substrait::Expression_Nested_Map* release_map();
  ::substrait::Expression_Nested_Map* mutable_map();
  void set_allocated_map(::substrait::Expression_Nested_Map* value);
  void unsafe_arena_set_allocated_map(::substrait::Expression_Nested_Map* value);
  ::substrait::Expression_Nested_Map* unsafe_arena_release_map();

  private:
  const ::substrait::Expression_Nested_Map& _internal_map() const;
  ::substrait::Expression_Nested_Map* _internal_mutable_map();

  public:
  void clear_nested_type();
  NestedTypeCase nested_type_case() const;
  // @@protoc_insertion_point(class_scope:substrait.Expression.Nested)
 private:
  class _Internal;
  void set_has_struct_();
  void set_has_list();
  void set_has_map();
  inline bool has_nested_type() const;
  inline void clear_has_nested_type();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 5, 3,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_Nested& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    bool nullable_;
    ::uint32_t type_variation_reference_;
    union NestedTypeUnion {
      constexpr NestedTypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::substrait::Expression_Nested_Struct* struct__;
      ::substrait::Expression_Nested_List* list_;
      ::substrait::Expression_Nested_Map* map_;
    } nested_type_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_Nested_class_data_;
// -------------------------------------------------------------------

class Expression_Nested_List final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.Nested.List) */ {
 public:
  inline Expression_Nested_List() : Expression_Nested_List(nullptr) {}
  ~Expression_Nested_List() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_Nested_List* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_Nested_List));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_Nested_List(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_Nested_List(const Expression_Nested_List& from) : Expression_Nested_List(nullptr, from) {}
  inline Expression_Nested_List(Expression_Nested_List&& from) noexcept
      : Expression_Nested_List(nullptr, std::move(from)) {}
  inline Expression_Nested_List& operator=(const Expression_Nested_List& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_Nested_List& operator=(Expression_Nested_List&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_Nested_List& default_instance() {
    return *reinterpret_cast<const Expression_Nested_List*>(
        &_Expression_Nested_List_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 69;
  friend void swap(Expression_Nested_List& a, Expression_Nested_List& b) { a.Swap(&b); }
  inline void Swap(Expression_Nested_List* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_Nested_List* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_Nested_List* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_Nested_List>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_Nested_List& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_Nested_List& from) { Expression_Nested_List::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_Nested_List* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.Nested.List"; }

 protected:
  explicit Expression_Nested_List(::google::protobuf::Arena* arena);
  Expression_Nested_List(::google::protobuf::Arena* arena, const Expression_Nested_List& from);
  Expression_Nested_List(::google::protobuf::Arena* arena, Expression_Nested_List&& from) noexcept
      : Expression_Nested_List(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated .substrait.Expression values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  ::substrait::Expression* mutable_values(int index);
  ::google::protobuf::RepeatedPtrField<::substrait::Expression>* mutable_values();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression>& _internal_values() const;
  ::google::protobuf::RepeatedPtrField<::substrait::Expression>* _internal_mutable_values();
  public:
  const ::substrait::Expression& values(int index) const;
  ::substrait::Expression* add_values();
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression>& values() const;
  // @@protoc_insertion_point(class_scope:substrait.Expression.Nested.List)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_Nested_List& from_msg);
    ::google::protobuf::RepeatedPtrField< ::substrait::Expression > values_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_Nested_List_class_data_;
// -------------------------------------------------------------------

class Expression_Nested_Map final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.Nested.Map) */ {
 public:
  inline Expression_Nested_Map() : Expression_Nested_Map(nullptr) {}
  ~Expression_Nested_Map() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_Nested_Map* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_Nested_Map));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_Nested_Map(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_Nested_Map(const Expression_Nested_Map& from) : Expression_Nested_Map(nullptr, from) {}
  inline Expression_Nested_Map(Expression_Nested_Map&& from) noexcept
      : Expression_Nested_Map(nullptr, std::move(from)) {}
  inline Expression_Nested_Map& operator=(const Expression_Nested_Map& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_Nested_Map& operator=(Expression_Nested_Map&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_Nested_Map& default_instance() {
    return *reinterpret_cast<const Expression_Nested_Map*>(
        &_Expression_Nested_Map_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 67;
  friend void swap(Expression_Nested_Map& a, Expression_Nested_Map& b) { a.Swap(&b); }
  inline void Swap(Expression_Nested_Map* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_Nested_Map* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_Nested_Map* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_Nested_Map>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_Nested_Map& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_Nested_Map& from) { Expression_Nested_Map::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_Nested_Map* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.Nested.Map"; }

 protected:
  explicit Expression_Nested_Map(::google::protobuf::Arena* arena);
  Expression_Nested_Map(::google::protobuf::Arena* arena, const Expression_Nested_Map& from);
  Expression_Nested_Map(::google::protobuf::Arena* arena, Expression_Nested_Map&& from) noexcept
      : Expression_Nested_Map(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using KeyValue = Expression_Nested_Map_KeyValue;

  // accessors -------------------------------------------------------
  enum : int {
    kKeyValuesFieldNumber = 1,
  };
  // repeated .substrait.Expression.Nested.Map.KeyValue key_values = 1;
  int key_values_size() const;
  private:
  int _internal_key_values_size() const;

  public:
  void clear_key_values() ;
  ::substrait::Expression_Nested_Map_KeyValue* mutable_key_values(int index);
  ::google::protobuf::RepeatedPtrField<::substrait::Expression_Nested_Map_KeyValue>* mutable_key_values();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression_Nested_Map_KeyValue>& _internal_key_values() const;
  ::google::protobuf::RepeatedPtrField<::substrait::Expression_Nested_Map_KeyValue>* _internal_mutable_key_values();
  public:
  const ::substrait::Expression_Nested_Map_KeyValue& key_values(int index) const;
  ::substrait::Expression_Nested_Map_KeyValue* add_key_values();
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression_Nested_Map_KeyValue>& key_values() const;
  // @@protoc_insertion_point(class_scope:substrait.Expression.Nested.Map)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_Nested_Map& from_msg);
    ::google::protobuf::RepeatedPtrField< ::substrait::Expression_Nested_Map_KeyValue > key_values_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_Nested_Map_class_data_;
// -------------------------------------------------------------------

class Expression_Nested_Map_KeyValue final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.Nested.Map.KeyValue) */ {
 public:
  inline Expression_Nested_Map_KeyValue() : Expression_Nested_Map_KeyValue(nullptr) {}
  ~Expression_Nested_Map_KeyValue() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_Nested_Map_KeyValue* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_Nested_Map_KeyValue));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_Nested_Map_KeyValue(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_Nested_Map_KeyValue(const Expression_Nested_Map_KeyValue& from) : Expression_Nested_Map_KeyValue(nullptr, from) {}
  inline Expression_Nested_Map_KeyValue(Expression_Nested_Map_KeyValue&& from) noexcept
      : Expression_Nested_Map_KeyValue(nullptr, std::move(from)) {}
  inline Expression_Nested_Map_KeyValue& operator=(const Expression_Nested_Map_KeyValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_Nested_Map_KeyValue& operator=(Expression_Nested_Map_KeyValue&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_Nested_Map_KeyValue& default_instance() {
    return *reinterpret_cast<const Expression_Nested_Map_KeyValue*>(
        &_Expression_Nested_Map_KeyValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 66;
  friend void swap(Expression_Nested_Map_KeyValue& a, Expression_Nested_Map_KeyValue& b) { a.Swap(&b); }
  inline void Swap(Expression_Nested_Map_KeyValue* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_Nested_Map_KeyValue* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_Nested_Map_KeyValue* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_Nested_Map_KeyValue>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_Nested_Map_KeyValue& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_Nested_Map_KeyValue& from) { Expression_Nested_Map_KeyValue::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_Nested_Map_KeyValue* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.Nested.Map.KeyValue"; }

 protected:
  explicit Expression_Nested_Map_KeyValue(::google::protobuf::Arena* arena);
  Expression_Nested_Map_KeyValue(::google::protobuf::Arena* arena, const Expression_Nested_Map_KeyValue& from);
  Expression_Nested_Map_KeyValue(::google::protobuf::Arena* arena, Expression_Nested_Map_KeyValue&& from) noexcept
      : Expression_Nested_Map_KeyValue(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // .substrait.Expression key = 1;
  bool has_key() const;
  void clear_key() ;
  const ::substrait::Expression& key() const;
  [[nodiscard]] ::substrait::Expression* release_key();
  ::substrait::Expression* mutable_key();
  void set_allocated_key(::substrait::Expression* value);
  void unsafe_arena_set_allocated_key(::substrait::Expression* value);
  ::substrait::Expression* unsafe_arena_release_key();

  private:
  const ::substrait::Expression& _internal_key() const;
  ::substrait::Expression* _internal_mutable_key();

  public:
  // .substrait.Expression value = 2;
  bool has_value() const;
  void clear_value() ;
  const ::substrait::Expression& value() const;
  [[nodiscard]] ::substrait::Expression* release_value();
  ::substrait::Expression* mutable_value();
  void set_allocated_value(::substrait::Expression* value);
  void unsafe_arena_set_allocated_value(::substrait::Expression* value);
  ::substrait::Expression* unsafe_arena_release_value();

  private:
  const ::substrait::Expression& _internal_value() const;
  ::substrait::Expression* _internal_mutable_value();

  public:
  // @@protoc_insertion_point(class_scope:substrait.Expression.Nested.Map.KeyValue)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_Nested_Map_KeyValue& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::substrait::Expression* key_;
    ::substrait::Expression* value_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_Nested_Map_KeyValue_class_data_;
// -------------------------------------------------------------------

class Expression_Nested_Struct final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.Nested.Struct) */ {
 public:
  inline Expression_Nested_Struct() : Expression_Nested_Struct(nullptr) {}
  ~Expression_Nested_Struct() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_Nested_Struct* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_Nested_Struct));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_Nested_Struct(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_Nested_Struct(const Expression_Nested_Struct& from) : Expression_Nested_Struct(nullptr, from) {}
  inline Expression_Nested_Struct(Expression_Nested_Struct&& from) noexcept
      : Expression_Nested_Struct(nullptr, std::move(from)) {}
  inline Expression_Nested_Struct& operator=(const Expression_Nested_Struct& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_Nested_Struct& operator=(Expression_Nested_Struct&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_Nested_Struct& default_instance() {
    return *reinterpret_cast<const Expression_Nested_Struct*>(
        &_Expression_Nested_Struct_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 68;
  friend void swap(Expression_Nested_Struct& a, Expression_Nested_Struct& b) { a.Swap(&b); }
  inline void Swap(Expression_Nested_Struct* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_Nested_Struct* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_Nested_Struct* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_Nested_Struct>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_Nested_Struct& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_Nested_Struct& from) { Expression_Nested_Struct::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_Nested_Struct* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.Nested.Struct"; }

 protected:
  explicit Expression_Nested_Struct(::google::protobuf::Arena* arena);
  Expression_Nested_Struct(::google::protobuf::Arena* arena, const Expression_Nested_Struct& from);
  Expression_Nested_Struct(::google::protobuf::Arena* arena, Expression_Nested_Struct&& from) noexcept
      : Expression_Nested_Struct(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFieldsFieldNumber = 1,
  };
  // repeated .substrait.Expression fields = 1;
  int fields_size() const;
  private:
  int _internal_fields_size() const;

  public:
  void clear_fields() ;
  ::substrait::Expression* mutable_fields(int index);
  ::google::protobuf::RepeatedPtrField<::substrait::Expression>* mutable_fields();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression>& _internal_fields() const;
  ::google::protobuf::RepeatedPtrField<::substrait::Expression>* _internal_mutable_fields();
  public:
  const ::substrait::Expression& fields(int index) const;
  ::substrait::Expression* add_fields();
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression>& fields() const;
  // @@protoc_insertion_point(class_scope:substrait.Expression.Nested.Struct)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_Nested_Struct& from_msg);
    ::google::protobuf::RepeatedPtrField< ::substrait::Expression > fields_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_Nested_Struct_class_data_;
// -------------------------------------------------------------------

class Expression_ScalarFunction final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.ScalarFunction) */ {
 public:
  inline Expression_ScalarFunction() : Expression_ScalarFunction(nullptr) {}
  ~Expression_ScalarFunction() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_ScalarFunction* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_ScalarFunction));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_ScalarFunction(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_ScalarFunction(const Expression_ScalarFunction& from) : Expression_ScalarFunction(nullptr, from) {}
  inline Expression_ScalarFunction(Expression_ScalarFunction&& from) noexcept
      : Expression_ScalarFunction(nullptr, std::move(from)) {}
  inline Expression_ScalarFunction& operator=(const Expression_ScalarFunction& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_ScalarFunction& operator=(Expression_ScalarFunction&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_ScalarFunction& default_instance() {
    return *reinterpret_cast<const Expression_ScalarFunction*>(
        &_Expression_ScalarFunction_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 71;
  friend void swap(Expression_ScalarFunction& a, Expression_ScalarFunction& b) { a.Swap(&b); }
  inline void Swap(Expression_ScalarFunction* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_ScalarFunction* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_ScalarFunction* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_ScalarFunction>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_ScalarFunction& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_ScalarFunction& from) { Expression_ScalarFunction::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_ScalarFunction* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.ScalarFunction"; }

 protected:
  explicit Expression_ScalarFunction(::google::protobuf::Arena* arena);
  Expression_ScalarFunction(::google::protobuf::Arena* arena, const Expression_ScalarFunction& from);
  Expression_ScalarFunction(::google::protobuf::Arena* arena, Expression_ScalarFunction&& from) noexcept
      : Expression_ScalarFunction(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kArgsFieldNumber = 2,
    kArgumentsFieldNumber = 4,
    kOptionsFieldNumber = 5,
    kOutputTypeFieldNumber = 3,
    kFunctionReferenceFieldNumber = 1,
  };
  // repeated .substrait.Expression args = 2 [deprecated = true];
  [[deprecated]]  int args_size() const;
  private:
  int _internal_args_size() const;

  public:
  [[deprecated]]  void clear_args() ;
  [[deprecated]] ::substrait::Expression* mutable_args(int index);
  [[deprecated]] ::google::protobuf::RepeatedPtrField<::substrait::Expression>* mutable_args();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression>& _internal_args() const;
  ::google::protobuf::RepeatedPtrField<::substrait::Expression>* _internal_mutable_args();
  public:
  [[deprecated]] const ::substrait::Expression& args(int index) const;
  [[deprecated]] ::substrait::Expression* add_args();
  [[deprecated]] const ::google::protobuf::RepeatedPtrField<::substrait::Expression>& args() const;
  // repeated .substrait.FunctionArgument arguments = 4;
  int arguments_size() const;
  private:
  int _internal_arguments_size() const;

  public:
  void clear_arguments() ;
  ::substrait::FunctionArgument* mutable_arguments(int index);
  ::google::protobuf::RepeatedPtrField<::substrait::FunctionArgument>* mutable_arguments();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::FunctionArgument>& _internal_arguments() const;
  ::google::protobuf::RepeatedPtrField<::substrait::FunctionArgument>* _internal_mutable_arguments();
  public:
  const ::substrait::FunctionArgument& arguments(int index) const;
  ::substrait::FunctionArgument* add_arguments();
  const ::google::protobuf::RepeatedPtrField<::substrait::FunctionArgument>& arguments() const;
  // repeated .substrait.FunctionOption options = 5;
  int options_size() const;
  private:
  int _internal_options_size() const;

  public:
  void clear_options() ;
  ::substrait::FunctionOption* mutable_options(int index);
  ::google::protobuf::RepeatedPtrField<::substrait::FunctionOption>* mutable_options();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::FunctionOption>& _internal_options() const;
  ::google::protobuf::RepeatedPtrField<::substrait::FunctionOption>* _internal_mutable_options();
  public:
  const ::substrait::FunctionOption& options(int index) const;
  ::substrait::FunctionOption* add_options();
  const ::google::protobuf::RepeatedPtrField<::substrait::FunctionOption>& options() const;
  // .substrait.Type output_type = 3;
  bool has_output_type() const;
  void clear_output_type() ;
  const ::substrait::Type& output_type() const;
  [[nodiscard]] ::substrait::Type* release_output_type();
  ::substrait::Type* mutable_output_type();
  void set_allocated_output_type(::substrait::Type* value);
  void unsafe_arena_set_allocated_output_type(::substrait::Type* value);
  ::substrait::Type* unsafe_arena_release_output_type();

  private:
  const ::substrait::Type& _internal_output_type() const;
  ::substrait::Type* _internal_mutable_output_type();

  public:
  // uint32 function_reference = 1;
  void clear_function_reference() ;
  ::uint32_t function_reference() const;
  void set_function_reference(::uint32_t value);

  private:
  ::uint32_t _internal_function_reference() const;
  void _internal_set_function_reference(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:substrait.Expression.ScalarFunction)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 4,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_ScalarFunction& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::substrait::Expression > args_;
    ::google::protobuf::RepeatedPtrField< ::substrait::FunctionArgument > arguments_;
    ::google::protobuf::RepeatedPtrField< ::substrait::FunctionOption > options_;
    ::substrait::Type* output_type_;
    ::uint32_t function_reference_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_ScalarFunction_class_data_;
// -------------------------------------------------------------------

class Expression_SingularOrList final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.SingularOrList) */ {
 public:
  inline Expression_SingularOrList() : Expression_SingularOrList(nullptr) {}
  ~Expression_SingularOrList() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_SingularOrList* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_SingularOrList));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_SingularOrList(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_SingularOrList(const Expression_SingularOrList& from) : Expression_SingularOrList(nullptr, from) {}
  inline Expression_SingularOrList(Expression_SingularOrList&& from) noexcept
      : Expression_SingularOrList(nullptr, std::move(from)) {}
  inline Expression_SingularOrList& operator=(const Expression_SingularOrList& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_SingularOrList& operator=(Expression_SingularOrList&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_SingularOrList& default_instance() {
    return *reinterpret_cast<const Expression_SingularOrList*>(
        &_Expression_SingularOrList_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 83;
  friend void swap(Expression_SingularOrList& a, Expression_SingularOrList& b) { a.Swap(&b); }
  inline void Swap(Expression_SingularOrList* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_SingularOrList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_SingularOrList* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_SingularOrList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_SingularOrList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_SingularOrList& from) { Expression_SingularOrList::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_SingularOrList* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.SingularOrList"; }

 protected:
  explicit Expression_SingularOrList(::google::protobuf::Arena* arena);
  Expression_SingularOrList(::google::protobuf::Arena* arena, const Expression_SingularOrList& from);
  Expression_SingularOrList(::google::protobuf::Arena* arena, Expression_SingularOrList&& from) noexcept
      : Expression_SingularOrList(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOptionsFieldNumber = 2,
    kValueFieldNumber = 1,
  };
  // repeated .substrait.Expression options = 2;
  int options_size() const;
  private:
  int _internal_options_size() const;

  public:
  void clear_options() ;
  ::substrait::Expression* mutable_options(int index);
  ::google::protobuf::RepeatedPtrField<::substrait::Expression>* mutable_options();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression>& _internal_options() const;
  ::google::protobuf::RepeatedPtrField<::substrait::Expression>* _internal_mutable_options();
  public:
  const ::substrait::Expression& options(int index) const;
  ::substrait::Expression* add_options();
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression>& options() const;
  // .substrait.Expression value = 1;
  bool has_value() const;
  void clear_value() ;
  const ::substrait::Expression& value() const;
  [[nodiscard]] ::substrait::Expression* release_value();
  ::substrait::Expression* mutable_value();
  void set_allocated_value(::substrait::Expression* value);
  void unsafe_arena_set_allocated_value(::substrait::Expression* value);
  ::substrait::Expression* unsafe_arena_release_value();

  private:
  const ::substrait::Expression& _internal_value() const;
  ::substrait::Expression* _internal_mutable_value();

  public:
  // @@protoc_insertion_point(class_scope:substrait.Expression.SingularOrList)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_SingularOrList& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::substrait::Expression > options_;
    ::substrait::Expression* value_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_SingularOrList_class_data_;
// -------------------------------------------------------------------

class Expression_Subquery final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.Subquery) */ {
 public:
  inline Expression_Subquery() : Expression_Subquery(nullptr) {}
  ~Expression_Subquery() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_Subquery* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_Subquery));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_Subquery(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_Subquery(const Expression_Subquery& from) : Expression_Subquery(nullptr, from) {}
  inline Expression_Subquery(Expression_Subquery&& from) noexcept
      : Expression_Subquery(nullptr, std::move(from)) {}
  inline Expression_Subquery& operator=(const Expression_Subquery& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_Subquery& operator=(Expression_Subquery&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_Subquery& default_instance() {
    return *reinterpret_cast<const Expression_Subquery*>(
        &_Expression_Subquery_default_instance_);
  }
  enum SubqueryTypeCase {
    kScalar = 1,
    kInPredicate = 2,
    kSetPredicate = 3,
    kSetComparison = 4,
    SUBQUERY_TYPE_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 111;
  friend void swap(Expression_Subquery& a, Expression_Subquery& b) { a.Swap(&b); }
  inline void Swap(Expression_Subquery* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_Subquery* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_Subquery* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_Subquery>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_Subquery& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_Subquery& from) { Expression_Subquery::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_Subquery* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.Subquery"; }

 protected:
  explicit Expression_Subquery(::google::protobuf::Arena* arena);
  Expression_Subquery(::google::protobuf::Arena* arena, const Expression_Subquery& from);
  Expression_Subquery(::google::protobuf::Arena* arena, Expression_Subquery&& from) noexcept
      : Expression_Subquery(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Scalar = Expression_Subquery_Scalar;
  using InPredicate = Expression_Subquery_InPredicate;
  using SetPredicate = Expression_Subquery_SetPredicate;
  using SetComparison = Expression_Subquery_SetComparison;

  // accessors -------------------------------------------------------
  enum : int {
    kScalarFieldNumber = 1,
    kInPredicateFieldNumber = 2,
    kSetPredicateFieldNumber = 3,
    kSetComparisonFieldNumber = 4,
  };
  // .substrait.Expression.Subquery.Scalar scalar = 1;
  bool has_scalar() const;
  private:
  bool _internal_has_scalar() const;

  public:
  void clear_scalar() ;
  const ::substrait::Expression_Subquery_Scalar& scalar() const;
  [[nodiscard]] ::substrait::Expression_Subquery_Scalar* release_scalar();
  ::substrait::Expression_Subquery_Scalar* mutable_scalar();
  void set_allocated_scalar(::substrait::Expression_Subquery_Scalar* value);
  void unsafe_arena_set_allocated_scalar(::substrait::Expression_Subquery_Scalar* value);
  ::substrait::Expression_Subquery_Scalar* unsafe_arena_release_scalar();

  private:
  const ::substrait::Expression_Subquery_Scalar& _internal_scalar() const;
  ::substrait::Expression_Subquery_Scalar* _internal_mutable_scalar();

  public:
  // .substrait.Expression.Subquery.InPredicate in_predicate = 2;
  bool has_in_predicate() const;
  private:
  bool _internal_has_in_predicate() const;

  public:
  void clear_in_predicate() ;
  const ::substrait::Expression_Subquery_InPredicate& in_predicate() const;
  [[nodiscard]] ::substrait::Expression_Subquery_InPredicate* release_in_predicate();
  ::substrait::Expression_Subquery_InPredicate* mutable_in_predicate();
  void set_allocated_in_predicate(::substrait::Expression_Subquery_InPredicate* value);
  void unsafe_arena_set_allocated_in_predicate(::substrait::Expression_Subquery_InPredicate* value);
  ::substrait::Expression_Subquery_InPredicate* unsafe_arena_release_in_predicate();

  private:
  const ::substrait::Expression_Subquery_InPredicate& _internal_in_predicate() const;
  ::substrait::Expression_Subquery_InPredicate* _internal_mutable_in_predicate();

  public:
  // .substrait.Expression.Subquery.SetPredicate set_predicate = 3;
  bool has_set_predicate() const;
  private:
  bool _internal_has_set_predicate() const;

  public:
  void clear_set_predicate() ;
  const ::substrait::Expression_Subquery_SetPredicate& set_predicate() const;
  [[nodiscard]] ::substrait::Expression_Subquery_SetPredicate* release_set_predicate();
  ::substrait::Expression_Subquery_SetPredicate* mutable_set_predicate();
  void set_allocated_set_predicate(::substrait::Expression_Subquery_SetPredicate* value);
  void unsafe_arena_set_allocated_set_predicate(::substrait::Expression_Subquery_SetPredicate* value);
  ::substrait::Expression_Subquery_SetPredicate* unsafe_arena_release_set_predicate();

  private:
  const ::substrait::Expression_Subquery_SetPredicate& _internal_set_predicate() const;
  ::substrait::Expression_Subquery_SetPredicate* _internal_mutable_set_predicate();

  public:
  // .substrait.Expression.Subquery.SetComparison set_comparison = 4;
  bool has_set_comparison() const;
  private:
  bool _internal_has_set_comparison() const;

  public:
  void clear_set_comparison() ;
  const ::substrait::Expression_Subquery_SetComparison& set_comparison() const;
  [[nodiscard]] ::substrait::Expression_Subquery_SetComparison* release_set_comparison();
  ::substrait::Expression_Subquery_SetComparison* mutable_set_comparison();
  void set_allocated_set_comparison(::substrait::Expression_Subquery_SetComparison* value);
  void unsafe_arena_set_allocated_set_comparison(::substrait::Expression_Subquery_SetComparison* value);
  ::substrait::Expression_Subquery_SetComparison* unsafe_arena_release_set_comparison();

  private:
  const ::substrait::Expression_Subquery_SetComparison& _internal_set_comparison() const;
  ::substrait::Expression_Subquery_SetComparison* _internal_mutable_set_comparison();

  public:
  void clear_subquery_type();
  SubqueryTypeCase subquery_type_case() const;
  // @@protoc_insertion_point(class_scope:substrait.Expression.Subquery)
 private:
  class _Internal;
  void set_has_scalar();
  void set_has_in_predicate();
  void set_has_set_predicate();
  void set_has_set_comparison();
  inline bool has_subquery_type() const;
  inline void clear_has_subquery_type();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 4, 4,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_Subquery& from_msg);
    union SubqueryTypeUnion {
      constexpr SubqueryTypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::substrait::Expression_Subquery_Scalar* scalar_;
      ::substrait::Expression_Subquery_InPredicate* in_predicate_;
      ::substrait::Expression_Subquery_SetPredicate* set_predicate_;
      ::substrait::Expression_Subquery_SetComparison* set_comparison_;
    } subquery_type_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_Subquery_class_data_;
// -------------------------------------------------------------------

class Expression_Subquery_InPredicate final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.Subquery.InPredicate) */ {
 public:
  inline Expression_Subquery_InPredicate() : Expression_Subquery_InPredicate(nullptr) {}
  ~Expression_Subquery_InPredicate() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_Subquery_InPredicate* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_Subquery_InPredicate));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_Subquery_InPredicate(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_Subquery_InPredicate(const Expression_Subquery_InPredicate& from) : Expression_Subquery_InPredicate(nullptr, from) {}
  inline Expression_Subquery_InPredicate(Expression_Subquery_InPredicate&& from) noexcept
      : Expression_Subquery_InPredicate(nullptr, std::move(from)) {}
  inline Expression_Subquery_InPredicate& operator=(const Expression_Subquery_InPredicate& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_Subquery_InPredicate& operator=(Expression_Subquery_InPredicate&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_Subquery_InPredicate& default_instance() {
    return *reinterpret_cast<const Expression_Subquery_InPredicate*>(
        &_Expression_Subquery_InPredicate_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 108;
  friend void swap(Expression_Subquery_InPredicate& a, Expression_Subquery_InPredicate& b) { a.Swap(&b); }
  inline void Swap(Expression_Subquery_InPredicate* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_Subquery_InPredicate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_Subquery_InPredicate* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_Subquery_InPredicate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_Subquery_InPredicate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_Subquery_InPredicate& from) { Expression_Subquery_InPredicate::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_Subquery_InPredicate* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.Subquery.InPredicate"; }

 protected:
  explicit Expression_Subquery_InPredicate(::google::protobuf::Arena* arena);
  Expression_Subquery_InPredicate(::google::protobuf::Arena* arena, const Expression_Subquery_InPredicate& from);
  Expression_Subquery_InPredicate(::google::protobuf::Arena* arena, Expression_Subquery_InPredicate&& from) noexcept
      : Expression_Subquery_InPredicate(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNeedlesFieldNumber = 1,
    kHaystackFieldNumber = 2,
  };
  // repeated .substrait.Expression needles = 1;
  int needles_size() const;
  private:
  int _internal_needles_size() const;

  public:
  void clear_needles() ;
  ::substrait::Expression* mutable_needles(int index);
  ::google::protobuf::RepeatedPtrField<::substrait::Expression>* mutable_needles();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression>& _internal_needles() const;
  ::google::protobuf::RepeatedPtrField<::substrait::Expression>* _internal_mutable_needles();
  public:
  const ::substrait::Expression& needles(int index) const;
  ::substrait::Expression* add_needles();
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression>& needles() const;
  // .substrait.Rel haystack = 2;
  bool has_haystack() const;
  void clear_haystack() ;
  const ::substrait::Rel& haystack() const;
  [[nodiscard]] ::substrait::Rel* release_haystack();
  ::substrait::Rel* mutable_haystack();
  void set_allocated_haystack(::substrait::Rel* value);
  void unsafe_arena_set_allocated_haystack(::substrait::Rel* value);
  ::substrait::Rel* unsafe_arena_release_haystack();

  private:
  const ::substrait::Rel& _internal_haystack() const;
  ::substrait::Rel* _internal_mutable_haystack();

  public:
  // @@protoc_insertion_point(class_scope:substrait.Expression.Subquery.InPredicate)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_Subquery_InPredicate& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::substrait::Expression > needles_;
    ::substrait::Rel* haystack_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_Subquery_InPredicate_class_data_;
// -------------------------------------------------------------------

class Expression_Subquery_Scalar final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.Subquery.Scalar) */ {
 public:
  inline Expression_Subquery_Scalar() : Expression_Subquery_Scalar(nullptr) {}
  ~Expression_Subquery_Scalar() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_Subquery_Scalar* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_Subquery_Scalar));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_Subquery_Scalar(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_Subquery_Scalar(const Expression_Subquery_Scalar& from) : Expression_Subquery_Scalar(nullptr, from) {}
  inline Expression_Subquery_Scalar(Expression_Subquery_Scalar&& from) noexcept
      : Expression_Subquery_Scalar(nullptr, std::move(from)) {}
  inline Expression_Subquery_Scalar& operator=(const Expression_Subquery_Scalar& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_Subquery_Scalar& operator=(Expression_Subquery_Scalar&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_Subquery_Scalar& default_instance() {
    return *reinterpret_cast<const Expression_Subquery_Scalar*>(
        &_Expression_Subquery_Scalar_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 107;
  friend void swap(Expression_Subquery_Scalar& a, Expression_Subquery_Scalar& b) { a.Swap(&b); }
  inline void Swap(Expression_Subquery_Scalar* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_Subquery_Scalar* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_Subquery_Scalar* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_Subquery_Scalar>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_Subquery_Scalar& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_Subquery_Scalar& from) { Expression_Subquery_Scalar::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_Subquery_Scalar* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.Subquery.Scalar"; }

 protected:
  explicit Expression_Subquery_Scalar(::google::protobuf::Arena* arena);
  Expression_Subquery_Scalar(::google::protobuf::Arena* arena, const Expression_Subquery_Scalar& from);
  Expression_Subquery_Scalar(::google::protobuf::Arena* arena, Expression_Subquery_Scalar&& from) noexcept
      : Expression_Subquery_Scalar(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInputFieldNumber = 1,
  };
  // .substrait.Rel input = 1;
  bool has_input() const;
  void clear_input() ;
  const ::substrait::Rel& input() const;
  [[nodiscard]] ::substrait::Rel* release_input();
  ::substrait::Rel* mutable_input();
  void set_allocated_input(::substrait::Rel* value);
  void unsafe_arena_set_allocated_input(::substrait::Rel* value);
  ::substrait::Rel* unsafe_arena_release_input();

  private:
  const ::substrait::Rel& _internal_input() const;
  ::substrait::Rel* _internal_mutable_input();

  public:
  // @@protoc_insertion_point(class_scope:substrait.Expression.Subquery.Scalar)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_Subquery_Scalar& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::substrait::Rel* input_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_Subquery_Scalar_class_data_;
// -------------------------------------------------------------------

class Expression_Subquery_SetComparison final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.Subquery.SetComparison) */ {
 public:
  inline Expression_Subquery_SetComparison() : Expression_Subquery_SetComparison(nullptr) {}
  ~Expression_Subquery_SetComparison() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_Subquery_SetComparison* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_Subquery_SetComparison));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_Subquery_SetComparison(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_Subquery_SetComparison(const Expression_Subquery_SetComparison& from) : Expression_Subquery_SetComparison(nullptr, from) {}
  inline Expression_Subquery_SetComparison(Expression_Subquery_SetComparison&& from) noexcept
      : Expression_Subquery_SetComparison(nullptr, std::move(from)) {}
  inline Expression_Subquery_SetComparison& operator=(const Expression_Subquery_SetComparison& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_Subquery_SetComparison& operator=(Expression_Subquery_SetComparison&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_Subquery_SetComparison& default_instance() {
    return *reinterpret_cast<const Expression_Subquery_SetComparison*>(
        &_Expression_Subquery_SetComparison_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 110;
  friend void swap(Expression_Subquery_SetComparison& a, Expression_Subquery_SetComparison& b) { a.Swap(&b); }
  inline void Swap(Expression_Subquery_SetComparison* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_Subquery_SetComparison* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_Subquery_SetComparison* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_Subquery_SetComparison>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_Subquery_SetComparison& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_Subquery_SetComparison& from) { Expression_Subquery_SetComparison::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_Subquery_SetComparison* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.Subquery.SetComparison"; }

 protected:
  explicit Expression_Subquery_SetComparison(::google::protobuf::Arena* arena);
  Expression_Subquery_SetComparison(::google::protobuf::Arena* arena, const Expression_Subquery_SetComparison& from);
  Expression_Subquery_SetComparison(::google::protobuf::Arena* arena, Expression_Subquery_SetComparison&& from) noexcept
      : Expression_Subquery_SetComparison(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using ComparisonOp = Expression_Subquery_SetComparison_ComparisonOp;
  static constexpr ComparisonOp COMPARISON_OP_UNSPECIFIED = Expression_Subquery_SetComparison_ComparisonOp_COMPARISON_OP_UNSPECIFIED;
  static constexpr ComparisonOp COMPARISON_OP_EQ = Expression_Subquery_SetComparison_ComparisonOp_COMPARISON_OP_EQ;
  static constexpr ComparisonOp COMPARISON_OP_NE = Expression_Subquery_SetComparison_ComparisonOp_COMPARISON_OP_NE;
  static constexpr ComparisonOp COMPARISON_OP_LT = Expression_Subquery_SetComparison_ComparisonOp_COMPARISON_OP_LT;
  static constexpr ComparisonOp COMPARISON_OP_GT = Expression_Subquery_SetComparison_ComparisonOp_COMPARISON_OP_GT;
  static constexpr ComparisonOp COMPARISON_OP_LE = Expression_Subquery_SetComparison_ComparisonOp_COMPARISON_OP_LE;
  static constexpr ComparisonOp COMPARISON_OP_GE = Expression_Subquery_SetComparison_ComparisonOp_COMPARISON_OP_GE;
  static inline bool ComparisonOp_IsValid(int value) {
    return Expression_Subquery_SetComparison_ComparisonOp_IsValid(value);
  }
  static constexpr ComparisonOp ComparisonOp_MIN = Expression_Subquery_SetComparison_ComparisonOp_ComparisonOp_MIN;
  static constexpr ComparisonOp ComparisonOp_MAX = Expression_Subquery_SetComparison_ComparisonOp_ComparisonOp_MAX;
  static constexpr int ComparisonOp_ARRAYSIZE = Expression_Subquery_SetComparison_ComparisonOp_ComparisonOp_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ComparisonOp_descriptor() {
    return Expression_Subquery_SetComparison_ComparisonOp_descriptor();
  }
  template <typename T>
  static inline const std::string& ComparisonOp_Name(T value) {
    return Expression_Subquery_SetComparison_ComparisonOp_Name(value);
  }
  static inline bool ComparisonOp_Parse(absl::string_view name, ComparisonOp* value) {
    return Expression_Subquery_SetComparison_ComparisonOp_Parse(name, value);
  }
  using ReductionOp = Expression_Subquery_SetComparison_ReductionOp;
  static constexpr ReductionOp REDUCTION_OP_UNSPECIFIED = Expression_Subquery_SetComparison_ReductionOp_REDUCTION_OP_UNSPECIFIED;
  static constexpr ReductionOp REDUCTION_OP_ANY = Expression_Subquery_SetComparison_ReductionOp_REDUCTION_OP_ANY;
  static constexpr ReductionOp REDUCTION_OP_ALL = Expression_Subquery_SetComparison_ReductionOp_REDUCTION_OP_ALL;
  static inline bool ReductionOp_IsValid(int value) {
    return Expression_Subquery_SetComparison_ReductionOp_IsValid(value);
  }
  static constexpr ReductionOp ReductionOp_MIN = Expression_Subquery_SetComparison_ReductionOp_ReductionOp_MIN;
  static constexpr ReductionOp ReductionOp_MAX = Expression_Subquery_SetComparison_ReductionOp_ReductionOp_MAX;
  static constexpr int ReductionOp_ARRAYSIZE = Expression_Subquery_SetComparison_ReductionOp_ReductionOp_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ReductionOp_descriptor() {
    return Expression_Subquery_SetComparison_ReductionOp_descriptor();
  }
  template <typename T>
  static inline const std::string& ReductionOp_Name(T value) {
    return Expression_Subquery_SetComparison_ReductionOp_Name(value);
  }
  static inline bool ReductionOp_Parse(absl::string_view name, ReductionOp* value) {
    return Expression_Subquery_SetComparison_ReductionOp_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kLeftFieldNumber = 3,
    kRightFieldNumber = 4,
    kReductionOpFieldNumber = 1,
    kComparisonOpFieldNumber = 2,
  };
  // .substrait.Expression left = 3;
  bool has_left() const;
  void clear_left() ;
  const ::substrait::Expression& left() const;
  [[nodiscard]] ::substrait::Expression* release_left();
  ::substrait::Expression* mutable_left();
  void set_allocated_left(::substrait::Expression* value);
  void unsafe_arena_set_allocated_left(::substrait::Expression* value);
  ::substrait::Expression* unsafe_arena_release_left();

  private:
  const ::substrait::Expression& _internal_left() const;
  ::substrait::Expression* _internal_mutable_left();

  public:
  // .substrait.Rel right = 4;
  bool has_right() const;
  void clear_right() ;
  const ::substrait::Rel& right() const;
  [[nodiscard]] ::substrait::Rel* release_right();
  ::substrait::Rel* mutable_right();
  void set_allocated_right(::substrait::Rel* value);
  void unsafe_arena_set_allocated_right(::substrait::Rel* value);
  ::substrait::Rel* unsafe_arena_release_right();

  private:
  const ::substrait::Rel& _internal_right() const;
  ::substrait::Rel* _internal_mutable_right();

  public:
  // .substrait.Expression.Subquery.SetComparison.ReductionOp reduction_op = 1;
  void clear_reduction_op() ;
  ::substrait::Expression_Subquery_SetComparison_ReductionOp reduction_op() const;
  void set_reduction_op(::substrait::Expression_Subquery_SetComparison_ReductionOp value);

  private:
  ::substrait::Expression_Subquery_SetComparison_ReductionOp _internal_reduction_op() const;
  void _internal_set_reduction_op(::substrait::Expression_Subquery_SetComparison_ReductionOp value);

  public:
  // .substrait.Expression.Subquery.SetComparison.ComparisonOp comparison_op = 2;
  void clear_comparison_op() ;
  ::substrait::Expression_Subquery_SetComparison_ComparisonOp comparison_op() const;
  void set_comparison_op(::substrait::Expression_Subquery_SetComparison_ComparisonOp value);

  private:
  ::substrait::Expression_Subquery_SetComparison_ComparisonOp _internal_comparison_op() const;
  void _internal_set_comparison_op(::substrait::Expression_Subquery_SetComparison_ComparisonOp value);

  public:
  // @@protoc_insertion_point(class_scope:substrait.Expression.Subquery.SetComparison)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_Subquery_SetComparison& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::substrait::Expression* left_;
    ::substrait::Rel* right_;
    int reduction_op_;
    int comparison_op_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_Subquery_SetComparison_class_data_;
// -------------------------------------------------------------------

class Expression_Subquery_SetPredicate final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.Subquery.SetPredicate) */ {
 public:
  inline Expression_Subquery_SetPredicate() : Expression_Subquery_SetPredicate(nullptr) {}
  ~Expression_Subquery_SetPredicate() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_Subquery_SetPredicate* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_Subquery_SetPredicate));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_Subquery_SetPredicate(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_Subquery_SetPredicate(const Expression_Subquery_SetPredicate& from) : Expression_Subquery_SetPredicate(nullptr, from) {}
  inline Expression_Subquery_SetPredicate(Expression_Subquery_SetPredicate&& from) noexcept
      : Expression_Subquery_SetPredicate(nullptr, std::move(from)) {}
  inline Expression_Subquery_SetPredicate& operator=(const Expression_Subquery_SetPredicate& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_Subquery_SetPredicate& operator=(Expression_Subquery_SetPredicate&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_Subquery_SetPredicate& default_instance() {
    return *reinterpret_cast<const Expression_Subquery_SetPredicate*>(
        &_Expression_Subquery_SetPredicate_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 109;
  friend void swap(Expression_Subquery_SetPredicate& a, Expression_Subquery_SetPredicate& b) { a.Swap(&b); }
  inline void Swap(Expression_Subquery_SetPredicate* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_Subquery_SetPredicate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_Subquery_SetPredicate* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_Subquery_SetPredicate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_Subquery_SetPredicate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_Subquery_SetPredicate& from) { Expression_Subquery_SetPredicate::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_Subquery_SetPredicate* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.Subquery.SetPredicate"; }

 protected:
  explicit Expression_Subquery_SetPredicate(::google::protobuf::Arena* arena);
  Expression_Subquery_SetPredicate(::google::protobuf::Arena* arena, const Expression_Subquery_SetPredicate& from);
  Expression_Subquery_SetPredicate(::google::protobuf::Arena* arena, Expression_Subquery_SetPredicate&& from) noexcept
      : Expression_Subquery_SetPredicate(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using PredicateOp = Expression_Subquery_SetPredicate_PredicateOp;
  static constexpr PredicateOp PREDICATE_OP_UNSPECIFIED = Expression_Subquery_SetPredicate_PredicateOp_PREDICATE_OP_UNSPECIFIED;
  static constexpr PredicateOp PREDICATE_OP_EXISTS = Expression_Subquery_SetPredicate_PredicateOp_PREDICATE_OP_EXISTS;
  static constexpr PredicateOp PREDICATE_OP_UNIQUE = Expression_Subquery_SetPredicate_PredicateOp_PREDICATE_OP_UNIQUE;
  static inline bool PredicateOp_IsValid(int value) {
    return Expression_Subquery_SetPredicate_PredicateOp_IsValid(value);
  }
  static constexpr PredicateOp PredicateOp_MIN = Expression_Subquery_SetPredicate_PredicateOp_PredicateOp_MIN;
  static constexpr PredicateOp PredicateOp_MAX = Expression_Subquery_SetPredicate_PredicateOp_PredicateOp_MAX;
  static constexpr int PredicateOp_ARRAYSIZE = Expression_Subquery_SetPredicate_PredicateOp_PredicateOp_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PredicateOp_descriptor() {
    return Expression_Subquery_SetPredicate_PredicateOp_descriptor();
  }
  template <typename T>
  static inline const std::string& PredicateOp_Name(T value) {
    return Expression_Subquery_SetPredicate_PredicateOp_Name(value);
  }
  static inline bool PredicateOp_Parse(absl::string_view name, PredicateOp* value) {
    return Expression_Subquery_SetPredicate_PredicateOp_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kTuplesFieldNumber = 2,
    kPredicateOpFieldNumber = 1,
  };
  // .substrait.Rel tuples = 2;
  bool has_tuples() const;
  void clear_tuples() ;
  const ::substrait::Rel& tuples() const;
  [[nodiscard]] ::substrait::Rel* release_tuples();
  ::substrait::Rel* mutable_tuples();
  void set_allocated_tuples(::substrait::Rel* value);
  void unsafe_arena_set_allocated_tuples(::substrait::Rel* value);
  ::substrait::Rel* unsafe_arena_release_tuples();

  private:
  const ::substrait::Rel& _internal_tuples() const;
  ::substrait::Rel* _internal_mutable_tuples();

  public:
  // .substrait.Expression.Subquery.SetPredicate.PredicateOp predicate_op = 1;
  void clear_predicate_op() ;
  ::substrait::Expression_Subquery_SetPredicate_PredicateOp predicate_op() const;
  void set_predicate_op(::substrait::Expression_Subquery_SetPredicate_PredicateOp value);

  private:
  ::substrait::Expression_Subquery_SetPredicate_PredicateOp _internal_predicate_op() const;
  void _internal_set_predicate_op(::substrait::Expression_Subquery_SetPredicate_PredicateOp value);

  public:
  // @@protoc_insertion_point(class_scope:substrait.Expression.Subquery.SetPredicate)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_Subquery_SetPredicate& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::substrait::Rel* tuples_;
    int predicate_op_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_Subquery_SetPredicate_class_data_;
// -------------------------------------------------------------------

class Expression_SwitchExpression final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.SwitchExpression) */ {
 public:
  inline Expression_SwitchExpression() : Expression_SwitchExpression(nullptr) {}
  ~Expression_SwitchExpression() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_SwitchExpression* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_SwitchExpression));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_SwitchExpression(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_SwitchExpression(const Expression_SwitchExpression& from) : Expression_SwitchExpression(nullptr, from) {}
  inline Expression_SwitchExpression(Expression_SwitchExpression&& from) noexcept
      : Expression_SwitchExpression(nullptr, std::move(from)) {}
  inline Expression_SwitchExpression& operator=(const Expression_SwitchExpression& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_SwitchExpression& operator=(Expression_SwitchExpression&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_SwitchExpression& default_instance() {
    return *reinterpret_cast<const Expression_SwitchExpression*>(
        &_Expression_SwitchExpression_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 82;
  friend void swap(Expression_SwitchExpression& a, Expression_SwitchExpression& b) { a.Swap(&b); }
  inline void Swap(Expression_SwitchExpression* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_SwitchExpression* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_SwitchExpression* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_SwitchExpression>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_SwitchExpression& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_SwitchExpression& from) { Expression_SwitchExpression::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_SwitchExpression* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.SwitchExpression"; }

 protected:
  explicit Expression_SwitchExpression(::google::protobuf::Arena* arena);
  Expression_SwitchExpression(::google::protobuf::Arena* arena, const Expression_SwitchExpression& from);
  Expression_SwitchExpression(::google::protobuf::Arena* arena, Expression_SwitchExpression&& from) noexcept
      : Expression_SwitchExpression(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using IfValue = Expression_SwitchExpression_IfValue;

  // accessors -------------------------------------------------------
  enum : int {
    kIfsFieldNumber = 1,
    kElseFieldNumber = 2,
    kMatchFieldNumber = 3,
  };
  // repeated .substrait.Expression.SwitchExpression.IfValue ifs = 1;
  int ifs_size() const;
  private:
  int _internal_ifs_size() const;

  public:
  void clear_ifs() ;
  ::substrait::Expression_SwitchExpression_IfValue* mutable_ifs(int index);
  ::google::protobuf::RepeatedPtrField<::substrait::Expression_SwitchExpression_IfValue>* mutable_ifs();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression_SwitchExpression_IfValue>& _internal_ifs() const;
  ::google::protobuf::RepeatedPtrField<::substrait::Expression_SwitchExpression_IfValue>* _internal_mutable_ifs();
  public:
  const ::substrait::Expression_SwitchExpression_IfValue& ifs(int index) const;
  ::substrait::Expression_SwitchExpression_IfValue* add_ifs();
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression_SwitchExpression_IfValue>& ifs() const;
  // .substrait.Expression else = 2;
  bool has_else_() const;
  void clear_else_() ;
  const ::substrait::Expression& else_() const;
  [[nodiscard]] ::substrait::Expression* release_else_();
  ::substrait::Expression* mutable_else_();
  void set_allocated_else_(::substrait::Expression* value);
  void unsafe_arena_set_allocated_else_(::substrait::Expression* value);
  ::substrait::Expression* unsafe_arena_release_else_();

  private:
  const ::substrait::Expression& _internal_else_() const;
  ::substrait::Expression* _internal_mutable_else_();

  public:
  // .substrait.Expression match = 3;
  bool has_match() const;
  void clear_match() ;
  const ::substrait::Expression& match() const;
  [[nodiscard]] ::substrait::Expression* release_match();
  ::substrait::Expression* mutable_match();
  void set_allocated_match(::substrait::Expression* value);
  void unsafe_arena_set_allocated_match(::substrait::Expression* value);
  ::substrait::Expression* unsafe_arena_release_match();

  private:
  const ::substrait::Expression& _internal_match() const;
  ::substrait::Expression* _internal_mutable_match();

  public:
  // @@protoc_insertion_point(class_scope:substrait.Expression.SwitchExpression)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_SwitchExpression& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::substrait::Expression_SwitchExpression_IfValue > ifs_;
    ::substrait::Expression* else__;
    ::substrait::Expression* match_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_SwitchExpression_class_data_;
// -------------------------------------------------------------------

class Expression_SwitchExpression_IfValue final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.SwitchExpression.IfValue) */ {
 public:
  inline Expression_SwitchExpression_IfValue() : Expression_SwitchExpression_IfValue(nullptr) {}
  ~Expression_SwitchExpression_IfValue() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_SwitchExpression_IfValue* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_SwitchExpression_IfValue));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_SwitchExpression_IfValue(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_SwitchExpression_IfValue(const Expression_SwitchExpression_IfValue& from) : Expression_SwitchExpression_IfValue(nullptr, from) {}
  inline Expression_SwitchExpression_IfValue(Expression_SwitchExpression_IfValue&& from) noexcept
      : Expression_SwitchExpression_IfValue(nullptr, std::move(from)) {}
  inline Expression_SwitchExpression_IfValue& operator=(const Expression_SwitchExpression_IfValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_SwitchExpression_IfValue& operator=(Expression_SwitchExpression_IfValue&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_SwitchExpression_IfValue& default_instance() {
    return *reinterpret_cast<const Expression_SwitchExpression_IfValue*>(
        &_Expression_SwitchExpression_IfValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 81;
  friend void swap(Expression_SwitchExpression_IfValue& a, Expression_SwitchExpression_IfValue& b) { a.Swap(&b); }
  inline void Swap(Expression_SwitchExpression_IfValue* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_SwitchExpression_IfValue* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_SwitchExpression_IfValue* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_SwitchExpression_IfValue>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_SwitchExpression_IfValue& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_SwitchExpression_IfValue& from) { Expression_SwitchExpression_IfValue::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_SwitchExpression_IfValue* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.SwitchExpression.IfValue"; }

 protected:
  explicit Expression_SwitchExpression_IfValue(::google::protobuf::Arena* arena);
  Expression_SwitchExpression_IfValue(::google::protobuf::Arena* arena, const Expression_SwitchExpression_IfValue& from);
  Expression_SwitchExpression_IfValue(::google::protobuf::Arena* arena, Expression_SwitchExpression_IfValue&& from) noexcept
      : Expression_SwitchExpression_IfValue(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIfFieldNumber = 1,
    kThenFieldNumber = 2,
  };
  // .substrait.Expression.Literal if = 1;
  bool has_if_() const;
  void clear_if_() ;
  const ::substrait::Expression_Literal& if_() const;
  [[nodiscard]] ::substrait::Expression_Literal* release_if_();
  ::substrait::Expression_Literal* mutable_if_();
  void set_allocated_if_(::substrait::Expression_Literal* value);
  void unsafe_arena_set_allocated_if_(::substrait::Expression_Literal* value);
  ::substrait::Expression_Literal* unsafe_arena_release_if_();

  private:
  const ::substrait::Expression_Literal& _internal_if_() const;
  ::substrait::Expression_Literal* _internal_mutable_if_();

  public:
  // .substrait.Expression then = 2;
  bool has_then() const;
  void clear_then() ;
  const ::substrait::Expression& then() const;
  [[nodiscard]] ::substrait::Expression* release_then();
  ::substrait::Expression* mutable_then();
  void set_allocated_then(::substrait::Expression* value);
  void unsafe_arena_set_allocated_then(::substrait::Expression* value);
  ::substrait::Expression* unsafe_arena_release_then();

  private:
  const ::substrait::Expression& _internal_then() const;
  ::substrait::Expression* _internal_mutable_then();

  public:
  // @@protoc_insertion_point(class_scope:substrait.Expression.SwitchExpression.IfValue)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_SwitchExpression_IfValue& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::substrait::Expression_Literal* if__;
    ::substrait::Expression* then_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_SwitchExpression_IfValue_class_data_;
// -------------------------------------------------------------------

class Expression_WindowFunction final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.WindowFunction) */ {
 public:
  inline Expression_WindowFunction() : Expression_WindowFunction(nullptr) {}
  ~Expression_WindowFunction() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_WindowFunction* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_WindowFunction));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_WindowFunction(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_WindowFunction(const Expression_WindowFunction& from) : Expression_WindowFunction(nullptr, from) {}
  inline Expression_WindowFunction(Expression_WindowFunction&& from) noexcept
      : Expression_WindowFunction(nullptr, std::move(from)) {}
  inline Expression_WindowFunction& operator=(const Expression_WindowFunction& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_WindowFunction& operator=(Expression_WindowFunction&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_WindowFunction& default_instance() {
    return *reinterpret_cast<const Expression_WindowFunction*>(
        &_Expression_WindowFunction_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 77;
  friend void swap(Expression_WindowFunction& a, Expression_WindowFunction& b) { a.Swap(&b); }
  inline void Swap(Expression_WindowFunction* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_WindowFunction* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_WindowFunction* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_WindowFunction>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_WindowFunction& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_WindowFunction& from) { Expression_WindowFunction::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_WindowFunction* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.WindowFunction"; }

 protected:
  explicit Expression_WindowFunction(::google::protobuf::Arena* arena);
  Expression_WindowFunction(::google::protobuf::Arena* arena, const Expression_WindowFunction& from);
  Expression_WindowFunction(::google::protobuf::Arena* arena, Expression_WindowFunction&& from) noexcept
      : Expression_WindowFunction(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Bound = Expression_WindowFunction_Bound;
  using BoundsType = Expression_WindowFunction_BoundsType;
  static constexpr BoundsType BOUNDS_TYPE_UNSPECIFIED = Expression_WindowFunction_BoundsType_BOUNDS_TYPE_UNSPECIFIED;
  static constexpr BoundsType BOUNDS_TYPE_ROWS = Expression_WindowFunction_BoundsType_BOUNDS_TYPE_ROWS;
  static constexpr BoundsType BOUNDS_TYPE_RANGE = Expression_WindowFunction_BoundsType_BOUNDS_TYPE_RANGE;
  static inline bool BoundsType_IsValid(int value) {
    return Expression_WindowFunction_BoundsType_IsValid(value);
  }
  static constexpr BoundsType BoundsType_MIN = Expression_WindowFunction_BoundsType_BoundsType_MIN;
  static constexpr BoundsType BoundsType_MAX = Expression_WindowFunction_BoundsType_BoundsType_MAX;
  static constexpr int BoundsType_ARRAYSIZE = Expression_WindowFunction_BoundsType_BoundsType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* BoundsType_descriptor() {
    return Expression_WindowFunction_BoundsType_descriptor();
  }
  template <typename T>
  static inline const std::string& BoundsType_Name(T value) {
    return Expression_WindowFunction_BoundsType_Name(value);
  }
  static inline bool BoundsType_Parse(absl::string_view name, BoundsType* value) {
    return Expression_WindowFunction_BoundsType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kPartitionsFieldNumber = 2,
    kSortsFieldNumber = 3,
    kArgsFieldNumber = 8,
    kArgumentsFieldNumber = 9,
    kOptionsFieldNumber = 11,
    kUpperBoundFieldNumber = 4,
    kLowerBoundFieldNumber = 5,
    kOutputTypeFieldNumber = 7,
    kFunctionReferenceFieldNumber = 1,
    kPhaseFieldNumber = 6,
    kInvocationFieldNumber = 10,
    kBoundsTypeFieldNumber = 12,
  };
  // repeated .substrait.Expression partitions = 2;
  int partitions_size() const;
  private:
  int _internal_partitions_size() const;

  public:
  void clear_partitions() ;
  ::substrait::Expression* mutable_partitions(int index);
  ::google::protobuf::RepeatedPtrField<::substrait::Expression>* mutable_partitions();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression>& _internal_partitions() const;
  ::google::protobuf::RepeatedPtrField<::substrait::Expression>* _internal_mutable_partitions();
  public:
  const ::substrait::Expression& partitions(int index) const;
  ::substrait::Expression* add_partitions();
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression>& partitions() const;
  // repeated .substrait.SortField sorts = 3;
  int sorts_size() const;
  private:
  int _internal_sorts_size() const;

  public:
  void clear_sorts() ;
  ::substrait::SortField* mutable_sorts(int index);
  ::google::protobuf::RepeatedPtrField<::substrait::SortField>* mutable_sorts();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::SortField>& _internal_sorts() const;
  ::google::protobuf::RepeatedPtrField<::substrait::SortField>* _internal_mutable_sorts();
  public:
  const ::substrait::SortField& sorts(int index) const;
  ::substrait::SortField* add_sorts();
  const ::google::protobuf::RepeatedPtrField<::substrait::SortField>& sorts() const;
  // repeated .substrait.Expression args = 8 [deprecated = true];
  [[deprecated]]  int args_size() const;
  private:
  int _internal_args_size() const;

  public:
  [[deprecated]]  void clear_args() ;
  [[deprecated]] ::substrait::Expression* mutable_args(int index);
  [[deprecated]] ::google::protobuf::RepeatedPtrField<::substrait::Expression>* mutable_args();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression>& _internal_args() const;
  ::google::protobuf::RepeatedPtrField<::substrait::Expression>* _internal_mutable_args();
  public:
  [[deprecated]] const ::substrait::Expression& args(int index) const;
  [[deprecated]] ::substrait::Expression* add_args();
  [[deprecated]] const ::google::protobuf::RepeatedPtrField<::substrait::Expression>& args() const;
  // repeated .substrait.FunctionArgument arguments = 9;
  int arguments_size() const;
  private:
  int _internal_arguments_size() const;

  public:
  void clear_arguments() ;
  ::substrait::FunctionArgument* mutable_arguments(int index);
  ::google::protobuf::RepeatedPtrField<::substrait::FunctionArgument>* mutable_arguments();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::FunctionArgument>& _internal_arguments() const;
  ::google::protobuf::RepeatedPtrField<::substrait::FunctionArgument>* _internal_mutable_arguments();
  public:
  const ::substrait::FunctionArgument& arguments(int index) const;
  ::substrait::FunctionArgument* add_arguments();
  const ::google::protobuf::RepeatedPtrField<::substrait::FunctionArgument>& arguments() const;
  // repeated .substrait.FunctionOption options = 11;
  int options_size() const;
  private:
  int _internal_options_size() const;

  public:
  void clear_options() ;
  ::substrait::FunctionOption* mutable_options(int index);
  ::google::protobuf::RepeatedPtrField<::substrait::FunctionOption>* mutable_options();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::FunctionOption>& _internal_options() const;
  ::google::protobuf::RepeatedPtrField<::substrait::FunctionOption>* _internal_mutable_options();
  public:
  const ::substrait::FunctionOption& options(int index) const;
  ::substrait::FunctionOption* add_options();
  const ::google::protobuf::RepeatedPtrField<::substrait::FunctionOption>& options() const;
  // .substrait.Expression.WindowFunction.Bound upper_bound = 4;
  bool has_upper_bound() const;
  void clear_upper_bound() ;
  const ::substrait::Expression_WindowFunction_Bound& upper_bound() const;
  [[nodiscard]] ::substrait::Expression_WindowFunction_Bound* release_upper_bound();
  ::substrait::Expression_WindowFunction_Bound* mutable_upper_bound();
  void set_allocated_upper_bound(::substrait::Expression_WindowFunction_Bound* value);
  void unsafe_arena_set_allocated_upper_bound(::substrait::Expression_WindowFunction_Bound* value);
  ::substrait::Expression_WindowFunction_Bound* unsafe_arena_release_upper_bound();

  private:
  const ::substrait::Expression_WindowFunction_Bound& _internal_upper_bound() const;
  ::substrait::Expression_WindowFunction_Bound* _internal_mutable_upper_bound();

  public:
  // .substrait.Expression.WindowFunction.Bound lower_bound = 5;
  bool has_lower_bound() const;
  void clear_lower_bound() ;
  const ::substrait::Expression_WindowFunction_Bound& lower_bound() const;
  [[nodiscard]] ::substrait::Expression_WindowFunction_Bound* release_lower_bound();
  ::substrait::Expression_WindowFunction_Bound* mutable_lower_bound();
  void set_allocated_lower_bound(::substrait::Expression_WindowFunction_Bound* value);
  void unsafe_arena_set_allocated_lower_bound(::substrait::Expression_WindowFunction_Bound* value);
  ::substrait::Expression_WindowFunction_Bound* unsafe_arena_release_lower_bound();

  private:
  const ::substrait::Expression_WindowFunction_Bound& _internal_lower_bound() const;
  ::substrait::Expression_WindowFunction_Bound* _internal_mutable_lower_bound();

  public:
  // .substrait.Type output_type = 7;
  bool has_output_type() const;
  void clear_output_type() ;
  const ::substrait::Type& output_type() const;
  [[nodiscard]] ::substrait::Type* release_output_type();
  ::substrait::Type* mutable_output_type();
  void set_allocated_output_type(::substrait::Type* value);
  void unsafe_arena_set_allocated_output_type(::substrait::Type* value);
  ::substrait::Type* unsafe_arena_release_output_type();

  private:
  const ::substrait::Type& _internal_output_type() const;
  ::substrait::Type* _internal_mutable_output_type();

  public:
  // uint32 function_reference = 1;
  void clear_function_reference() ;
  ::uint32_t function_reference() const;
  void set_function_reference(::uint32_t value);

  private:
  ::uint32_t _internal_function_reference() const;
  void _internal_set_function_reference(::uint32_t value);

  public:
  // .substrait.AggregationPhase phase = 6;
  void clear_phase() ;
  ::substrait::AggregationPhase phase() const;
  void set_phase(::substrait::AggregationPhase value);

  private:
  ::substrait::AggregationPhase _internal_phase() const;
  void _internal_set_phase(::substrait::AggregationPhase value);

  public:
  // .substrait.AggregateFunction.AggregationInvocation invocation = 10;
  void clear_invocation() ;
  ::substrait::AggregateFunction_AggregationInvocation invocation() const;
  void set_invocation(::substrait::AggregateFunction_AggregationInvocation value);

  private:
  ::substrait::AggregateFunction_AggregationInvocation _internal_invocation() const;
  void _internal_set_invocation(::substrait::AggregateFunction_AggregationInvocation value);

  public:
  // .substrait.Expression.WindowFunction.BoundsType bounds_type = 12;
  void clear_bounds_type() ;
  ::substrait::Expression_WindowFunction_BoundsType bounds_type() const;
  void set_bounds_type(::substrait::Expression_WindowFunction_BoundsType value);

  private:
  ::substrait::Expression_WindowFunction_BoundsType _internal_bounds_type() const;
  void _internal_set_bounds_type(::substrait::Expression_WindowFunction_BoundsType value);

  public:
  // @@protoc_insertion_point(class_scope:substrait.Expression.WindowFunction)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 12, 8,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_WindowFunction& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::substrait::Expression > partitions_;
    ::google::protobuf::RepeatedPtrField< ::substrait::SortField > sorts_;
    ::google::protobuf::RepeatedPtrField< ::substrait::Expression > args_;
    ::google::protobuf::RepeatedPtrField< ::substrait::FunctionArgument > arguments_;
    ::google::protobuf::RepeatedPtrField< ::substrait::FunctionOption > options_;
    ::substrait::Expression_WindowFunction_Bound* upper_bound_;
    ::substrait::Expression_WindowFunction_Bound* lower_bound_;
    ::substrait::Type* output_type_;
    ::uint32_t function_reference_;
    int phase_;
    int invocation_;
    int bounds_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_WindowFunction_class_data_;
// -------------------------------------------------------------------

class ExtensionMultiRel final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.ExtensionMultiRel) */ {
 public:
  inline ExtensionMultiRel() : ExtensionMultiRel(nullptr) {}
  ~ExtensionMultiRel() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ExtensionMultiRel* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ExtensionMultiRel));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ExtensionMultiRel(
      ::google::protobuf::internal::ConstantInitialized);

  inline ExtensionMultiRel(const ExtensionMultiRel& from) : ExtensionMultiRel(nullptr, from) {}
  inline ExtensionMultiRel(ExtensionMultiRel&& from) noexcept
      : ExtensionMultiRel(nullptr, std::move(from)) {}
  inline ExtensionMultiRel& operator=(const ExtensionMultiRel& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExtensionMultiRel& operator=(ExtensionMultiRel&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExtensionMultiRel& default_instance() {
    return *reinterpret_cast<const ExtensionMultiRel*>(
        &_ExtensionMultiRel_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 30;
  friend void swap(ExtensionMultiRel& a, ExtensionMultiRel& b) { a.Swap(&b); }
  inline void Swap(ExtensionMultiRel* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExtensionMultiRel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExtensionMultiRel* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ExtensionMultiRel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ExtensionMultiRel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ExtensionMultiRel& from) { ExtensionMultiRel::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ExtensionMultiRel* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.ExtensionMultiRel"; }

 protected:
  explicit ExtensionMultiRel(::google::protobuf::Arena* arena);
  ExtensionMultiRel(::google::protobuf::Arena* arena, const ExtensionMultiRel& from);
  ExtensionMultiRel(::google::protobuf::Arena* arena, ExtensionMultiRel&& from) noexcept
      : ExtensionMultiRel(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInputsFieldNumber = 2,
    kCommonFieldNumber = 1,
    kDetailFieldNumber = 3,
  };
  // repeated .substrait.Rel inputs = 2;
  int inputs_size() const;
  private:
  int _internal_inputs_size() const;

  public:
  void clear_inputs() ;
  ::substrait::Rel* mutable_inputs(int index);
  ::google::protobuf::RepeatedPtrField<::substrait::Rel>* mutable_inputs();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::Rel>& _internal_inputs() const;
  ::google::protobuf::RepeatedPtrField<::substrait::Rel>* _internal_mutable_inputs();
  public:
  const ::substrait::Rel& inputs(int index) const;
  ::substrait::Rel* add_inputs();
  const ::google::protobuf::RepeatedPtrField<::substrait::Rel>& inputs() const;
  // .substrait.RelCommon common = 1;
  bool has_common() const;
  void clear_common() ;
  const ::substrait::RelCommon& common() const;
  [[nodiscard]] ::substrait::RelCommon* release_common();
  ::substrait::RelCommon* mutable_common();
  void set_allocated_common(::substrait::RelCommon* value);
  void unsafe_arena_set_allocated_common(::substrait::RelCommon* value);
  ::substrait::RelCommon* unsafe_arena_release_common();

  private:
  const ::substrait::RelCommon& _internal_common() const;
  ::substrait::RelCommon* _internal_mutable_common();

  public:
  // .google.protobuf.Any detail = 3;
  bool has_detail() const;
  void clear_detail() ;
  const ::google::protobuf::Any& detail() const;
  [[nodiscard]] ::google::protobuf::Any* release_detail();
  ::google::protobuf::Any* mutable_detail();
  void set_allocated_detail(::google::protobuf::Any* value);
  void unsafe_arena_set_allocated_detail(::google::protobuf::Any* value);
  ::google::protobuf::Any* unsafe_arena_release_detail();

  private:
  const ::google::protobuf::Any& _internal_detail() const;
  ::google::protobuf::Any* _internal_mutable_detail();

  public:
  // @@protoc_insertion_point(class_scope:substrait.ExtensionMultiRel)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ExtensionMultiRel& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::substrait::Rel > inputs_;
    ::substrait::RelCommon* common_;
    ::google::protobuf::Any* detail_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ExtensionMultiRel_class_data_;
// -------------------------------------------------------------------

class ExtensionSingleRel final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.ExtensionSingleRel) */ {
 public:
  inline ExtensionSingleRel() : ExtensionSingleRel(nullptr) {}
  ~ExtensionSingleRel() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ExtensionSingleRel* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ExtensionSingleRel));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ExtensionSingleRel(
      ::google::protobuf::internal::ConstantInitialized);

  inline ExtensionSingleRel(const ExtensionSingleRel& from) : ExtensionSingleRel(nullptr, from) {}
  inline ExtensionSingleRel(ExtensionSingleRel&& from) noexcept
      : ExtensionSingleRel(nullptr, std::move(from)) {}
  inline ExtensionSingleRel& operator=(const ExtensionSingleRel& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExtensionSingleRel& operator=(ExtensionSingleRel&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExtensionSingleRel& default_instance() {
    return *reinterpret_cast<const ExtensionSingleRel*>(
        &_ExtensionSingleRel_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 28;
  friend void swap(ExtensionSingleRel& a, ExtensionSingleRel& b) { a.Swap(&b); }
  inline void Swap(ExtensionSingleRel* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExtensionSingleRel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExtensionSingleRel* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ExtensionSingleRel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ExtensionSingleRel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ExtensionSingleRel& from) { ExtensionSingleRel::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ExtensionSingleRel* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.ExtensionSingleRel"; }

 protected:
  explicit ExtensionSingleRel(::google::protobuf::Arena* arena);
  ExtensionSingleRel(::google::protobuf::Arena* arena, const ExtensionSingleRel& from);
  ExtensionSingleRel(::google::protobuf::Arena* arena, ExtensionSingleRel&& from) noexcept
      : ExtensionSingleRel(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCommonFieldNumber = 1,
    kInputFieldNumber = 2,
    kDetailFieldNumber = 3,
  };
  // .substrait.RelCommon common = 1;
  bool has_common() const;
  void clear_common() ;
  const ::substrait::RelCommon& common() const;
  [[nodiscard]] ::substrait::RelCommon* release_common();
  ::substrait::RelCommon* mutable_common();
  void set_allocated_common(::substrait::RelCommon* value);
  void unsafe_arena_set_allocated_common(::substrait::RelCommon* value);
  ::substrait::RelCommon* unsafe_arena_release_common();

  private:
  const ::substrait::RelCommon& _internal_common() const;
  ::substrait::RelCommon* _internal_mutable_common();

  public:
  // .substrait.Rel input = 2;
  bool has_input() const;
  void clear_input() ;
  const ::substrait::Rel& input() const;
  [[nodiscard]] ::substrait::Rel* release_input();
  ::substrait::Rel* mutable_input();
  void set_allocated_input(::substrait::Rel* value);
  void unsafe_arena_set_allocated_input(::substrait::Rel* value);
  ::substrait::Rel* unsafe_arena_release_input();

  private:
  const ::substrait::Rel& _internal_input() const;
  ::substrait::Rel* _internal_mutable_input();

  public:
  // .google.protobuf.Any detail = 3;
  bool has_detail() const;
  void clear_detail() ;
  const ::google::protobuf::Any& detail() const;
  [[nodiscard]] ::google::protobuf::Any* release_detail();
  ::google::protobuf::Any* mutable_detail();
  void set_allocated_detail(::google::protobuf::Any* value);
  void unsafe_arena_set_allocated_detail(::google::protobuf::Any* value);
  ::google::protobuf::Any* unsafe_arena_release_detail();

  private:
  const ::google::protobuf::Any& _internal_detail() const;
  ::google::protobuf::Any* _internal_mutable_detail();

  public:
  // @@protoc_insertion_point(class_scope:substrait.ExtensionSingleRel)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ExtensionSingleRel& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::substrait::RelCommon* common_;
    ::substrait::Rel* input_;
    ::google::protobuf::Any* detail_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ExtensionSingleRel_class_data_;
// -------------------------------------------------------------------

class FetchRel final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.FetchRel) */ {
 public:
  inline FetchRel() : FetchRel(nullptr) {}
  ~FetchRel() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FetchRel* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FetchRel));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FetchRel(
      ::google::protobuf::internal::ConstantInitialized);

  inline FetchRel(const FetchRel& from) : FetchRel(nullptr, from) {}
  inline FetchRel(FetchRel&& from) noexcept
      : FetchRel(nullptr, std::move(from)) {}
  inline FetchRel& operator=(const FetchRel& from) {
    CopyFrom(from);
    return *this;
  }
  inline FetchRel& operator=(FetchRel&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FetchRel& default_instance() {
    return *reinterpret_cast<const FetchRel*>(
        &_FetchRel_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(FetchRel& a, FetchRel& b) { a.Swap(&b); }
  inline void Swap(FetchRel* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FetchRel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FetchRel* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FetchRel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FetchRel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FetchRel& from) { FetchRel::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FetchRel* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.FetchRel"; }

 protected:
  explicit FetchRel(::google::protobuf::Arena* arena);
  FetchRel(::google::protobuf::Arena* arena, const FetchRel& from);
  FetchRel(::google::protobuf::Arena* arena, FetchRel&& from) noexcept
      : FetchRel(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCommonFieldNumber = 1,
    kInputFieldNumber = 2,
    kAdvancedExtensionFieldNumber = 10,
    kOffsetFieldNumber = 3,
    kCountFieldNumber = 4,
  };
  // .substrait.RelCommon common = 1;
  bool has_common() const;
  void clear_common() ;
  const ::substrait::RelCommon& common() const;
  [[nodiscard]] ::substrait::RelCommon* release_common();
  ::substrait::RelCommon* mutable_common();
  void set_allocated_common(::substrait::RelCommon* value);
  void unsafe_arena_set_allocated_common(::substrait::RelCommon* value);
  ::substrait::RelCommon* unsafe_arena_release_common();

  private:
  const ::substrait::RelCommon& _internal_common() const;
  ::substrait::RelCommon* _internal_mutable_common();

  public:
  // .substrait.Rel input = 2;
  bool has_input() const;
  void clear_input() ;
  const ::substrait::Rel& input() const;
  [[nodiscard]] ::substrait::Rel* release_input();
  ::substrait::Rel* mutable_input();
  void set_allocated_input(::substrait::Rel* value);
  void unsafe_arena_set_allocated_input(::substrait::Rel* value);
  ::substrait::Rel* unsafe_arena_release_input();

  private:
  const ::substrait::Rel& _internal_input() const;
  ::substrait::Rel* _internal_mutable_input();

  public:
  // .substrait.extensions.AdvancedExtension advanced_extension = 10;
  bool has_advanced_extension() const;
  void clear_advanced_extension() ;
  const ::substrait::extensions::AdvancedExtension& advanced_extension() const;
  [[nodiscard]] ::substrait::extensions::AdvancedExtension* release_advanced_extension();
  ::substrait::extensions::AdvancedExtension* mutable_advanced_extension();
  void set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value);
  void unsafe_arena_set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value);
  ::substrait::extensions::AdvancedExtension* unsafe_arena_release_advanced_extension();

  private:
  const ::substrait::extensions::AdvancedExtension& _internal_advanced_extension() const;
  ::substrait::extensions::AdvancedExtension* _internal_mutable_advanced_extension();

  public:
  // int64 offset = 3;
  void clear_offset() ;
  ::int64_t offset() const;
  void set_offset(::int64_t value);

  private:
  ::int64_t _internal_offset() const;
  void _internal_set_offset(::int64_t value);

  public:
  // int64 count = 4;
  void clear_count() ;
  ::int64_t count() const;
  void set_count(::int64_t value);

  private:
  ::int64_t _internal_count() const;
  void _internal_set_count(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:substrait.FetchRel)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 5, 3,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FetchRel& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::substrait::RelCommon* common_;
    ::substrait::Rel* input_;
    ::substrait::extensions::AdvancedExtension* advanced_extension_;
    ::int64_t offset_;
    ::int64_t count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull FetchRel_class_data_;
// -------------------------------------------------------------------

class FilterRel final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.FilterRel) */ {
 public:
  inline FilterRel() : FilterRel(nullptr) {}
  ~FilterRel() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FilterRel* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FilterRel));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FilterRel(
      ::google::protobuf::internal::ConstantInitialized);

  inline FilterRel(const FilterRel& from) : FilterRel(nullptr, from) {}
  inline FilterRel(FilterRel&& from) noexcept
      : FilterRel(nullptr, std::move(from)) {}
  inline FilterRel& operator=(const FilterRel& from) {
    CopyFrom(from);
    return *this;
  }
  inline FilterRel& operator=(FilterRel&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FilterRel& default_instance() {
    return *reinterpret_cast<const FilterRel*>(
        &_FilterRel_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 26;
  friend void swap(FilterRel& a, FilterRel& b) { a.Swap(&b); }
  inline void Swap(FilterRel* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FilterRel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FilterRel* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FilterRel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FilterRel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FilterRel& from) { FilterRel::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FilterRel* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.FilterRel"; }

 protected:
  explicit FilterRel(::google::protobuf::Arena* arena);
  FilterRel(::google::protobuf::Arena* arena, const FilterRel& from);
  FilterRel(::google::protobuf::Arena* arena, FilterRel&& from) noexcept
      : FilterRel(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCommonFieldNumber = 1,
    kInputFieldNumber = 2,
    kConditionFieldNumber = 3,
    kAdvancedExtensionFieldNumber = 10,
  };
  // .substrait.RelCommon common = 1;
  bool has_common() const;
  void clear_common() ;
  const ::substrait::RelCommon& common() const;
  [[nodiscard]] ::substrait::RelCommon* release_common();
  ::substrait::RelCommon* mutable_common();
  void set_allocated_common(::substrait::RelCommon* value);
  void unsafe_arena_set_allocated_common(::substrait::RelCommon* value);
  ::substrait::RelCommon* unsafe_arena_release_common();

  private:
  const ::substrait::RelCommon& _internal_common() const;
  ::substrait::RelCommon* _internal_mutable_common();

  public:
  // .substrait.Rel input = 2;
  bool has_input() const;
  void clear_input() ;
  const ::substrait::Rel& input() const;
  [[nodiscard]] ::substrait::Rel* release_input();
  ::substrait::Rel* mutable_input();
  void set_allocated_input(::substrait::Rel* value);
  void unsafe_arena_set_allocated_input(::substrait::Rel* value);
  ::substrait::Rel* unsafe_arena_release_input();

  private:
  const ::substrait::Rel& _internal_input() const;
  ::substrait::Rel* _internal_mutable_input();

  public:
  // .substrait.Expression condition = 3;
  bool has_condition() const;
  void clear_condition() ;
  const ::substrait::Expression& condition() const;
  [[nodiscard]] ::substrait::Expression* release_condition();
  ::substrait::Expression* mutable_condition();
  void set_allocated_condition(::substrait::Expression* value);
  void unsafe_arena_set_allocated_condition(::substrait::Expression* value);
  ::substrait::Expression* unsafe_arena_release_condition();

  private:
  const ::substrait::Expression& _internal_condition() const;
  ::substrait::Expression* _internal_mutable_condition();

  public:
  // .substrait.extensions.AdvancedExtension advanced_extension = 10;
  bool has_advanced_extension() const;
  void clear_advanced_extension() ;
  const ::substrait::extensions::AdvancedExtension& advanced_extension() const;
  [[nodiscard]] ::substrait::extensions::AdvancedExtension* release_advanced_extension();
  ::substrait::extensions::AdvancedExtension* mutable_advanced_extension();
  void set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value);
  void unsafe_arena_set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value);
  ::substrait::extensions::AdvancedExtension* unsafe_arena_release_advanced_extension();

  private:
  const ::substrait::extensions::AdvancedExtension& _internal_advanced_extension() const;
  ::substrait::extensions::AdvancedExtension* _internal_mutable_advanced_extension();

  public:
  // @@protoc_insertion_point(class_scope:substrait.FilterRel)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 4,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FilterRel& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::substrait::RelCommon* common_;
    ::substrait::Rel* input_;
    ::substrait::Expression* condition_;
    ::substrait::extensions::AdvancedExtension* advanced_extension_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull FilterRel_class_data_;
// -------------------------------------------------------------------

class FunctionArgument final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.FunctionArgument) */ {
 public:
  inline FunctionArgument() : FunctionArgument(nullptr) {}
  ~FunctionArgument() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FunctionArgument* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FunctionArgument));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FunctionArgument(
      ::google::protobuf::internal::ConstantInitialized);

  inline FunctionArgument(const FunctionArgument& from) : FunctionArgument(nullptr, from) {}
  inline FunctionArgument(FunctionArgument&& from) noexcept
      : FunctionArgument(nullptr, std::move(from)) {}
  inline FunctionArgument& operator=(const FunctionArgument& from) {
    CopyFrom(from);
    return *this;
  }
  inline FunctionArgument& operator=(FunctionArgument&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FunctionArgument& default_instance() {
    return *reinterpret_cast<const FunctionArgument*>(
        &_FunctionArgument_default_instance_);
  }
  enum ArgTypeCase {
    kEnum = 1,
    kType = 2,
    kValue = 3,
    ARG_TYPE_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 52;
  friend void swap(FunctionArgument& a, FunctionArgument& b) { a.Swap(&b); }
  inline void Swap(FunctionArgument* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FunctionArgument* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FunctionArgument* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FunctionArgument>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FunctionArgument& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FunctionArgument& from) { FunctionArgument::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FunctionArgument* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.FunctionArgument"; }

 protected:
  explicit FunctionArgument(::google::protobuf::Arena* arena);
  FunctionArgument(::google::protobuf::Arena* arena, const FunctionArgument& from);
  FunctionArgument(::google::protobuf::Arena* arena, FunctionArgument&& from) noexcept
      : FunctionArgument(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEnumFieldNumber = 1,
    kTypeFieldNumber = 2,
    kValueFieldNumber = 3,
  };
  // string enum = 1;
  bool has_enum_() const;
  void clear_enum_() ;
  const std::string& enum_() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_enum_(Arg_&& arg, Args_... args);
  std::string* mutable_enum_();
  [[nodiscard]] std::string* release_enum_();
  void set_allocated_enum_(std::string* value);

  private:
  const std::string& _internal_enum_() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_enum_(const std::string& value);
  std::string* _internal_mutable_enum_();

  public:
  // .substrait.Type type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;

  public:
  void clear_type() ;
  const ::substrait::Type& type() const;
  [[nodiscard]] ::substrait::Type* release_type();
  ::substrait::Type* mutable_type();
  void set_allocated_type(::substrait::Type* value);
  void unsafe_arena_set_allocated_type(::substrait::Type* value);
  ::substrait::Type* unsafe_arena_release_type();

  private:
  const ::substrait::Type& _internal_type() const;
  ::substrait::Type* _internal_mutable_type();

  public:
  // .substrait.Expression value = 3;
  bool has_value() const;
  private:
  bool _internal_has_value() const;

  public:
  void clear_value() ;
  const ::substrait::Expression& value() const;
  [[nodiscard]] ::substrait::Expression* release_value();
  ::substrait::Expression* mutable_value();
  void set_allocated_value(::substrait::Expression* value);
  void unsafe_arena_set_allocated_value(::substrait::Expression* value);
  ::substrait::Expression* unsafe_arena_release_value();

  private:
  const ::substrait::Expression& _internal_value() const;
  ::substrait::Expression* _internal_mutable_value();

  public:
  void clear_arg_type();
  ArgTypeCase arg_type_case() const;
  // @@protoc_insertion_point(class_scope:substrait.FunctionArgument)
 private:
  class _Internal;
  void set_has_enum_();
  void set_has_type();
  void set_has_value();
  inline bool has_arg_type() const;
  inline void clear_has_arg_type();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 3, 2,
      39, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FunctionArgument& from_msg);
    union ArgTypeUnion {
      constexpr ArgTypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::internal::ArenaStringPtr enum__;
      ::substrait::Type* type_;
      ::substrait::Expression* value_;
    } arg_type_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull FunctionArgument_class_data_;
// -------------------------------------------------------------------

class HashJoinRel final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.HashJoinRel) */ {
 public:
  inline HashJoinRel() : HashJoinRel(nullptr) {}
  ~HashJoinRel() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(HashJoinRel* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(HashJoinRel));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HashJoinRel(
      ::google::protobuf::internal::ConstantInitialized);

  inline HashJoinRel(const HashJoinRel& from) : HashJoinRel(nullptr, from) {}
  inline HashJoinRel(HashJoinRel&& from) noexcept
      : HashJoinRel(nullptr, std::move(from)) {}
  inline HashJoinRel& operator=(const HashJoinRel& from) {
    CopyFrom(from);
    return *this;
  }
  inline HashJoinRel& operator=(HashJoinRel&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HashJoinRel& default_instance() {
    return *reinterpret_cast<const HashJoinRel*>(
        &_HashJoinRel_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 49;
  friend void swap(HashJoinRel& a, HashJoinRel& b) { a.Swap(&b); }
  inline void Swap(HashJoinRel* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HashJoinRel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HashJoinRel* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<HashJoinRel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HashJoinRel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HashJoinRel& from) { HashJoinRel::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(HashJoinRel* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.HashJoinRel"; }

 protected:
  explicit HashJoinRel(::google::protobuf::Arena* arena);
  HashJoinRel(::google::protobuf::Arena* arena, const HashJoinRel& from);
  HashJoinRel(::google::protobuf::Arena* arena, HashJoinRel&& from) noexcept
      : HashJoinRel(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using JoinType = HashJoinRel_JoinType;
  static constexpr JoinType JOIN_TYPE_UNSPECIFIED = HashJoinRel_JoinType_JOIN_TYPE_UNSPECIFIED;
  static constexpr JoinType JOIN_TYPE_INNER = HashJoinRel_JoinType_JOIN_TYPE_INNER;
  static constexpr JoinType JOIN_TYPE_OUTER = HashJoinRel_JoinType_JOIN_TYPE_OUTER;
  static constexpr JoinType JOIN_TYPE_LEFT = HashJoinRel_JoinType_JOIN_TYPE_LEFT;
  static constexpr JoinType JOIN_TYPE_RIGHT = HashJoinRel_JoinType_JOIN_TYPE_RIGHT;
  static constexpr JoinType JOIN_TYPE_LEFT_SEMI = HashJoinRel_JoinType_JOIN_TYPE_LEFT_SEMI;
  static constexpr JoinType JOIN_TYPE_RIGHT_SEMI = HashJoinRel_JoinType_JOIN_TYPE_RIGHT_SEMI;
  static constexpr JoinType JOIN_TYPE_LEFT_ANTI = HashJoinRel_JoinType_JOIN_TYPE_LEFT_ANTI;
  static constexpr JoinType JOIN_TYPE_RIGHT_ANTI = HashJoinRel_JoinType_JOIN_TYPE_RIGHT_ANTI;
  static inline bool JoinType_IsValid(int value) {
    return HashJoinRel_JoinType_IsValid(value);
  }
  static constexpr JoinType JoinType_MIN = HashJoinRel_JoinType_JoinType_MIN;
  static constexpr JoinType JoinType_MAX = HashJoinRel_JoinType_JoinType_MAX;
  static constexpr int JoinType_ARRAYSIZE = HashJoinRel_JoinType_JoinType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* JoinType_descriptor() {
    return HashJoinRel_JoinType_descriptor();
  }
  template <typename T>
  static inline const std::string& JoinType_Name(T value) {
    return HashJoinRel_JoinType_Name(value);
  }
  static inline bool JoinType_Parse(absl::string_view name, JoinType* value) {
    return HashJoinRel_JoinType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kLeftKeysFieldNumber = 4,
    kRightKeysFieldNumber = 5,
    kKeysFieldNumber = 8,
    kCommonFieldNumber = 1,
    kLeftFieldNumber = 2,
    kRightFieldNumber = 3,
    kPostJoinFilterFieldNumber = 6,
    kAdvancedExtensionFieldNumber = 10,
    kTypeFieldNumber = 7,
  };
  // repeated .substrait.Expression.FieldReference left_keys = 4 [deprecated = true];
  [[deprecated]]  int left_keys_size() const;
  private:
  int _internal_left_keys_size() const;

  public:
  [[deprecated]]  void clear_left_keys() ;
  [[deprecated]] ::substrait::Expression_FieldReference* mutable_left_keys(int index);
  [[deprecated]] ::google::protobuf::RepeatedPtrField<::substrait::Expression_FieldReference>* mutable_left_keys();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression_FieldReference>& _internal_left_keys() const;
  ::google::protobuf::RepeatedPtrField<::substrait::Expression_FieldReference>* _internal_mutable_left_keys();
  public:
  [[deprecated]] const ::substrait::Expression_FieldReference& left_keys(int index) const;
  [[deprecated]] ::substrait::Expression_FieldReference* add_left_keys();
  [[deprecated]] const ::google::protobuf::RepeatedPtrField<::substrait::Expression_FieldReference>& left_keys() const;
  // repeated .substrait.Expression.FieldReference right_keys = 5 [deprecated = true];
  [[deprecated]]  int right_keys_size() const;
  private:
  int _internal_right_keys_size() const;

  public:
  [[deprecated]]  void clear_right_keys() ;
  [[deprecated]] ::substrait::Expression_FieldReference* mutable_right_keys(int index);
  [[deprecated]] ::google::protobuf::RepeatedPtrField<::substrait::Expression_FieldReference>* mutable_right_keys();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression_FieldReference>& _internal_right_keys() const;
  ::google::protobuf::RepeatedPtrField<::substrait::Expression_FieldReference>* _internal_mutable_right_keys();
  public:
  [[deprecated]] const ::substrait::Expression_FieldReference& right_keys(int index) const;
  [[deprecated]] ::substrait::Expression_FieldReference* add_right_keys();
  [[deprecated]] const ::google::protobuf::RepeatedPtrField<::substrait::Expression_FieldReference>& right_keys() const;
  // repeated .substrait.ComparisonJoinKey keys = 8;
  int keys_size() const;
  private:
  int _internal_keys_size() const;

  public:
  void clear_keys() ;
  ::substrait::ComparisonJoinKey* mutable_keys(int index);
  ::google::protobuf::RepeatedPtrField<::substrait::ComparisonJoinKey>* mutable_keys();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::ComparisonJoinKey>& _internal_keys() const;
  ::google::protobuf::RepeatedPtrField<::substrait::ComparisonJoinKey>* _internal_mutable_keys();
  public:
  const ::substrait::ComparisonJoinKey& keys(int index) const;
  ::substrait::ComparisonJoinKey* add_keys();
  const ::google::protobuf::RepeatedPtrField<::substrait::ComparisonJoinKey>& keys() const;
  // .substrait.RelCommon common = 1;
  bool has_common() const;
  void clear_common() ;
  const ::substrait::RelCommon& common() const;
  [[nodiscard]] ::substrait::RelCommon* release_common();
  ::substrait::RelCommon* mutable_common();
  void set_allocated_common(::substrait::RelCommon* value);
  void unsafe_arena_set_allocated_common(::substrait::RelCommon* value);
  ::substrait::RelCommon* unsafe_arena_release_common();

  private:
  const ::substrait::RelCommon& _internal_common() const;
  ::substrait::RelCommon* _internal_mutable_common();

  public:
  // .substrait.Rel left = 2;
  bool has_left() const;
  void clear_left() ;
  const ::substrait::Rel& left() const;
  [[nodiscard]] ::substrait::Rel* release_left();
  ::substrait::Rel* mutable_left();
  void set_allocated_left(::substrait::Rel* value);
  void unsafe_arena_set_allocated_left(::substrait::Rel* value);
  ::substrait::Rel* unsafe_arena_release_left();

  private:
  const ::substrait::Rel& _internal_left() const;
  ::substrait::Rel* _internal_mutable_left();

  public:
  // .substrait.Rel right = 3;
  bool has_right() const;
  void clear_right() ;
  const ::substrait::Rel& right() const;
  [[nodiscard]] ::substrait::Rel* release_right();
  ::substrait::Rel* mutable_right();
  void set_allocated_right(::substrait::Rel* value);
  void unsafe_arena_set_allocated_right(::substrait::Rel* value);
  ::substrait::Rel* unsafe_arena_release_right();

  private:
  const ::substrait::Rel& _internal_right() const;
  ::substrait::Rel* _internal_mutable_right();

  public:
  // .substrait.Expression post_join_filter = 6;
  bool has_post_join_filter() const;
  void clear_post_join_filter() ;
  const ::substrait::Expression& post_join_filter() const;
  [[nodiscard]] ::substrait::Expression* release_post_join_filter();
  ::substrait::Expression* mutable_post_join_filter();
  void set_allocated_post_join_filter(::substrait::Expression* value);
  void unsafe_arena_set_allocated_post_join_filter(::substrait::Expression* value);
  ::substrait::Expression* unsafe_arena_release_post_join_filter();

  private:
  const ::substrait::Expression& _internal_post_join_filter() const;
  ::substrait::Expression* _internal_mutable_post_join_filter();

  public:
  // .substrait.extensions.AdvancedExtension advanced_extension = 10;
  bool has_advanced_extension() const;
  void clear_advanced_extension() ;
  const ::substrait::extensions::AdvancedExtension& advanced_extension() const;
  [[nodiscard]] ::substrait::extensions::AdvancedExtension* release_advanced_extension();
  ::substrait::extensions::AdvancedExtension* mutable_advanced_extension();
  void set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value);
  void unsafe_arena_set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value);
  ::substrait::extensions::AdvancedExtension* unsafe_arena_release_advanced_extension();

  private:
  const ::substrait::extensions::AdvancedExtension& _internal_advanced_extension() const;
  ::substrait::extensions::AdvancedExtension* _internal_mutable_advanced_extension();

  public:
  // .substrait.HashJoinRel.JoinType type = 7;
  void clear_type() ;
  ::substrait::HashJoinRel_JoinType type() const;
  void set_type(::substrait::HashJoinRel_JoinType value);

  private:
  ::substrait::HashJoinRel_JoinType _internal_type() const;
  void _internal_set_type(::substrait::HashJoinRel_JoinType value);

  public:
  // @@protoc_insertion_point(class_scope:substrait.HashJoinRel)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 8,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const HashJoinRel& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::substrait::Expression_FieldReference > left_keys_;
    ::google::protobuf::RepeatedPtrField< ::substrait::Expression_FieldReference > right_keys_;
    ::google::protobuf::RepeatedPtrField< ::substrait::ComparisonJoinKey > keys_;
    ::substrait::RelCommon* common_;
    ::substrait::Rel* left_;
    ::substrait::Rel* right_;
    ::substrait::Expression* post_join_filter_;
    ::substrait::extensions::AdvancedExtension* advanced_extension_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull HashJoinRel_class_data_;
// -------------------------------------------------------------------

class JoinRel final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.JoinRel) */ {
 public:
  inline JoinRel() : JoinRel(nullptr) {}
  ~JoinRel() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(JoinRel* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(JoinRel));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR JoinRel(
      ::google::protobuf::internal::ConstantInitialized);

  inline JoinRel(const JoinRel& from) : JoinRel(nullptr, from) {}
  inline JoinRel(JoinRel&& from) noexcept
      : JoinRel(nullptr, std::move(from)) {}
  inline JoinRel& operator=(const JoinRel& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinRel& operator=(JoinRel&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JoinRel& default_instance() {
    return *reinterpret_cast<const JoinRel*>(
        &_JoinRel_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(JoinRel& a, JoinRel& b) { a.Swap(&b); }
  inline void Swap(JoinRel* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinRel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JoinRel* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<JoinRel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const JoinRel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const JoinRel& from) { JoinRel::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(JoinRel* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.JoinRel"; }

 protected:
  explicit JoinRel(::google::protobuf::Arena* arena);
  JoinRel(::google::protobuf::Arena* arena, const JoinRel& from);
  JoinRel(::google::protobuf::Arena* arena, JoinRel&& from) noexcept
      : JoinRel(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using JoinType = JoinRel_JoinType;
  static constexpr JoinType JOIN_TYPE_UNSPECIFIED = JoinRel_JoinType_JOIN_TYPE_UNSPECIFIED;
  static constexpr JoinType JOIN_TYPE_INNER = JoinRel_JoinType_JOIN_TYPE_INNER;
  static constexpr JoinType JOIN_TYPE_OUTER = JoinRel_JoinType_JOIN_TYPE_OUTER;
  static constexpr JoinType JOIN_TYPE_LEFT = JoinRel_JoinType_JOIN_TYPE_LEFT;
  static constexpr JoinType JOIN_TYPE_RIGHT = JoinRel_JoinType_JOIN_TYPE_RIGHT;
  static constexpr JoinType JOIN_TYPE_SEMI = JoinRel_JoinType_JOIN_TYPE_SEMI;
  static constexpr JoinType JOIN_TYPE_ANTI = JoinRel_JoinType_JOIN_TYPE_ANTI;
  static constexpr JoinType JOIN_TYPE_SINGLE = JoinRel_JoinType_JOIN_TYPE_SINGLE;
  static inline bool JoinType_IsValid(int value) {
    return JoinRel_JoinType_IsValid(value);
  }
  static constexpr JoinType JoinType_MIN = JoinRel_JoinType_JoinType_MIN;
  static constexpr JoinType JoinType_MAX = JoinRel_JoinType_JoinType_MAX;
  static constexpr int JoinType_ARRAYSIZE = JoinRel_JoinType_JoinType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* JoinType_descriptor() {
    return JoinRel_JoinType_descriptor();
  }
  template <typename T>
  static inline const std::string& JoinType_Name(T value) {
    return JoinRel_JoinType_Name(value);
  }
  static inline bool JoinType_Parse(absl::string_view name, JoinType* value) {
    return JoinRel_JoinType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kCommonFieldNumber = 1,
    kLeftFieldNumber = 2,
    kRightFieldNumber = 3,
    kExpressionFieldNumber = 4,
    kPostJoinFilterFieldNumber = 5,
    kAdvancedExtensionFieldNumber = 10,
    kTypeFieldNumber = 6,
  };
  // .substrait.RelCommon common = 1;
  bool has_common() const;
  void clear_common() ;
  const ::substrait::RelCommon& common() const;
  [[nodiscard]] ::substrait::RelCommon* release_common();
  ::substrait::RelCommon* mutable_common();
  void set_allocated_common(::substrait::RelCommon* value);
  void unsafe_arena_set_allocated_common(::substrait::RelCommon* value);
  ::substrait::RelCommon* unsafe_arena_release_common();

  private:
  const ::substrait::RelCommon& _internal_common() const;
  ::substrait::RelCommon* _internal_mutable_common();

  public:
  // .substrait.Rel left = 2;
  bool has_left() const;
  void clear_left() ;
  const ::substrait::Rel& left() const;
  [[nodiscard]] ::substrait::Rel* release_left();
  ::substrait::Rel* mutable_left();
  void set_allocated_left(::substrait::Rel* value);
  void unsafe_arena_set_allocated_left(::substrait::Rel* value);
  ::substrait::Rel* unsafe_arena_release_left();

  private:
  const ::substrait::Rel& _internal_left() const;
  ::substrait::Rel* _internal_mutable_left();

  public:
  // .substrait.Rel right = 3;
  bool has_right() const;
  void clear_right() ;
  const ::substrait::Rel& right() const;
  [[nodiscard]] ::substrait::Rel* release_right();
  ::substrait::Rel* mutable_right();
  void set_allocated_right(::substrait::Rel* value);
  void unsafe_arena_set_allocated_right(::substrait::Rel* value);
  ::substrait::Rel* unsafe_arena_release_right();

  private:
  const ::substrait::Rel& _internal_right() const;
  ::substrait::Rel* _internal_mutable_right();

  public:
  // .substrait.Expression expression = 4;
  bool has_expression() const;
  void clear_expression() ;
  const ::substrait::Expression& expression() const;
  [[nodiscard]] ::substrait::Expression* release_expression();
  ::substrait::Expression* mutable_expression();
  void set_allocated_expression(::substrait::Expression* value);
  void unsafe_arena_set_allocated_expression(::substrait::Expression* value);
  ::substrait::Expression* unsafe_arena_release_expression();

  private:
  const ::substrait::Expression& _internal_expression() const;
  ::substrait::Expression* _internal_mutable_expression();

  public:
  // .substrait.Expression post_join_filter = 5;
  bool has_post_join_filter() const;
  void clear_post_join_filter() ;
  const ::substrait::Expression& post_join_filter() const;
  [[nodiscard]] ::substrait::Expression* release_post_join_filter();
  ::substrait::Expression* mutable_post_join_filter();
  void set_allocated_post_join_filter(::substrait::Expression* value);
  void unsafe_arena_set_allocated_post_join_filter(::substrait::Expression* value);
  ::substrait::Expression* unsafe_arena_release_post_join_filter();

  private:
  const ::substrait::Expression& _internal_post_join_filter() const;
  ::substrait::Expression* _internal_mutable_post_join_filter();

  public:
  // .substrait.extensions.AdvancedExtension advanced_extension = 10;
  bool has_advanced_extension() const;
  void clear_advanced_extension() ;
  const ::substrait::extensions::AdvancedExtension& advanced_extension() const;
  [[nodiscard]] ::substrait::extensions::AdvancedExtension* release_advanced_extension();
  ::substrait::extensions::AdvancedExtension* mutable_advanced_extension();
  void set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value);
  void unsafe_arena_set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value);
  ::substrait::extensions::AdvancedExtension* unsafe_arena_release_advanced_extension();

  private:
  const ::substrait::extensions::AdvancedExtension& _internal_advanced_extension() const;
  ::substrait::extensions::AdvancedExtension* _internal_mutable_advanced_extension();

  public:
  // .substrait.JoinRel.JoinType type = 6;
  void clear_type() ;
  ::substrait::JoinRel_JoinType type() const;
  void set_type(::substrait::JoinRel_JoinType value);

  private:
  ::substrait::JoinRel_JoinType _internal_type() const;
  void _internal_set_type(::substrait::JoinRel_JoinType value);

  public:
  // @@protoc_insertion_point(class_scope:substrait.JoinRel)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 6,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const JoinRel& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::substrait::RelCommon* common_;
    ::substrait::Rel* left_;
    ::substrait::Rel* right_;
    ::substrait::Expression* expression_;
    ::substrait::Expression* post_join_filter_;
    ::substrait::extensions::AdvancedExtension* advanced_extension_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull JoinRel_class_data_;
// -------------------------------------------------------------------

class MergeJoinRel final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.MergeJoinRel) */ {
 public:
  inline MergeJoinRel() : MergeJoinRel(nullptr) {}
  ~MergeJoinRel() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MergeJoinRel* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MergeJoinRel));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MergeJoinRel(
      ::google::protobuf::internal::ConstantInitialized);

  inline MergeJoinRel(const MergeJoinRel& from) : MergeJoinRel(nullptr, from) {}
  inline MergeJoinRel(MergeJoinRel&& from) noexcept
      : MergeJoinRel(nullptr, std::move(from)) {}
  inline MergeJoinRel& operator=(const MergeJoinRel& from) {
    CopyFrom(from);
    return *this;
  }
  inline MergeJoinRel& operator=(MergeJoinRel&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MergeJoinRel& default_instance() {
    return *reinterpret_cast<const MergeJoinRel*>(
        &_MergeJoinRel_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 50;
  friend void swap(MergeJoinRel& a, MergeJoinRel& b) { a.Swap(&b); }
  inline void Swap(MergeJoinRel* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MergeJoinRel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MergeJoinRel* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MergeJoinRel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MergeJoinRel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MergeJoinRel& from) { MergeJoinRel::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MergeJoinRel* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.MergeJoinRel"; }

 protected:
  explicit MergeJoinRel(::google::protobuf::Arena* arena);
  MergeJoinRel(::google::protobuf::Arena* arena, const MergeJoinRel& from);
  MergeJoinRel(::google::protobuf::Arena* arena, MergeJoinRel&& from) noexcept
      : MergeJoinRel(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using JoinType = MergeJoinRel_JoinType;
  static constexpr JoinType JOIN_TYPE_UNSPECIFIED = MergeJoinRel_JoinType_JOIN_TYPE_UNSPECIFIED;
  static constexpr JoinType JOIN_TYPE_INNER = MergeJoinRel_JoinType_JOIN_TYPE_INNER;
  static constexpr JoinType JOIN_TYPE_OUTER = MergeJoinRel_JoinType_JOIN_TYPE_OUTER;
  static constexpr JoinType JOIN_TYPE_LEFT = MergeJoinRel_JoinType_JOIN_TYPE_LEFT;
  static constexpr JoinType JOIN_TYPE_RIGHT = MergeJoinRel_JoinType_JOIN_TYPE_RIGHT;
  static constexpr JoinType JOIN_TYPE_LEFT_SEMI = MergeJoinRel_JoinType_JOIN_TYPE_LEFT_SEMI;
  static constexpr JoinType JOIN_TYPE_RIGHT_SEMI = MergeJoinRel_JoinType_JOIN_TYPE_RIGHT_SEMI;
  static constexpr JoinType JOIN_TYPE_LEFT_ANTI = MergeJoinRel_JoinType_JOIN_TYPE_LEFT_ANTI;
  static constexpr JoinType JOIN_TYPE_RIGHT_ANTI = MergeJoinRel_JoinType_JOIN_TYPE_RIGHT_ANTI;
  static inline bool JoinType_IsValid(int value) {
    return MergeJoinRel_JoinType_IsValid(value);
  }
  static constexpr JoinType JoinType_MIN = MergeJoinRel_JoinType_JoinType_MIN;
  static constexpr JoinType JoinType_MAX = MergeJoinRel_JoinType_JoinType_MAX;
  static constexpr int JoinType_ARRAYSIZE = MergeJoinRel_JoinType_JoinType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* JoinType_descriptor() {
    return MergeJoinRel_JoinType_descriptor();
  }
  template <typename T>
  static inline const std::string& JoinType_Name(T value) {
    return MergeJoinRel_JoinType_Name(value);
  }
  static inline bool JoinType_Parse(absl::string_view name, JoinType* value) {
    return MergeJoinRel_JoinType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kLeftKeysFieldNumber = 4,
    kRightKeysFieldNumber = 5,
    kKeysFieldNumber = 8,
    kCommonFieldNumber = 1,
    kLeftFieldNumber = 2,
    kRightFieldNumber = 3,
    kPostJoinFilterFieldNumber = 6,
    kAdvancedExtensionFieldNumber = 10,
    kTypeFieldNumber = 7,
  };
  // repeated .substrait.Expression.FieldReference left_keys = 4 [deprecated = true];
  [[deprecated]]  int left_keys_size() const;
  private:
  int _internal_left_keys_size() const;

  public:
  [[deprecated]]  void clear_left_keys() ;
  [[deprecated]] ::substrait::Expression_FieldReference* mutable_left_keys(int index);
  [[deprecated]] ::google::protobuf::RepeatedPtrField<::substrait::Expression_FieldReference>* mutable_left_keys();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression_FieldReference>& _internal_left_keys() const;
  ::google::protobuf::RepeatedPtrField<::substrait::Expression_FieldReference>* _internal_mutable_left_keys();
  public:
  [[deprecated]] const ::substrait::Expression_FieldReference& left_keys(int index) const;
  [[deprecated]] ::substrait::Expression_FieldReference* add_left_keys();
  [[deprecated]] const ::google::protobuf::RepeatedPtrField<::substrait::Expression_FieldReference>& left_keys() const;
  // repeated .substrait.Expression.FieldReference right_keys = 5 [deprecated = true];
  [[deprecated]]  int right_keys_size() const;
  private:
  int _internal_right_keys_size() const;

  public:
  [[deprecated]]  void clear_right_keys() ;
  [[deprecated]] ::substrait::Expression_FieldReference* mutable_right_keys(int index);
  [[deprecated]] ::google::protobuf::RepeatedPtrField<::substrait::Expression_FieldReference>* mutable_right_keys();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression_FieldReference>& _internal_right_keys() const;
  ::google::protobuf::RepeatedPtrField<::substrait::Expression_FieldReference>* _internal_mutable_right_keys();
  public:
  [[deprecated]] const ::substrait::Expression_FieldReference& right_keys(int index) const;
  [[deprecated]] ::substrait::Expression_FieldReference* add_right_keys();
  [[deprecated]] const ::google::protobuf::RepeatedPtrField<::substrait::Expression_FieldReference>& right_keys() const;
  // repeated .substrait.ComparisonJoinKey keys = 8;
  int keys_size() const;
  private:
  int _internal_keys_size() const;

  public:
  void clear_keys() ;
  ::substrait::ComparisonJoinKey* mutable_keys(int index);
  ::google::protobuf::RepeatedPtrField<::substrait::ComparisonJoinKey>* mutable_keys();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::ComparisonJoinKey>& _internal_keys() const;
  ::google::protobuf::RepeatedPtrField<::substrait::ComparisonJoinKey>* _internal_mutable_keys();
  public:
  const ::substrait::ComparisonJoinKey& keys(int index) const;
  ::substrait::ComparisonJoinKey* add_keys();
  const ::google::protobuf::RepeatedPtrField<::substrait::ComparisonJoinKey>& keys() const;
  // .substrait.RelCommon common = 1;
  bool has_common() const;
  void clear_common() ;
  const ::substrait::RelCommon& common() const;
  [[nodiscard]] ::substrait::RelCommon* release_common();
  ::substrait::RelCommon* mutable_common();
  void set_allocated_common(::substrait::RelCommon* value);
  void unsafe_arena_set_allocated_common(::substrait::RelCommon* value);
  ::substrait::RelCommon* unsafe_arena_release_common();

  private:
  const ::substrait::RelCommon& _internal_common() const;
  ::substrait::RelCommon* _internal_mutable_common();

  public:
  // .substrait.Rel left = 2;
  bool has_left() const;
  void clear_left() ;
  const ::substrait::Rel& left() const;
  [[nodiscard]] ::substrait::Rel* release_left();
  ::substrait::Rel* mutable_left();
  void set_allocated_left(::substrait::Rel* value);
  void unsafe_arena_set_allocated_left(::substrait::Rel* value);
  ::substrait::Rel* unsafe_arena_release_left();

  private:
  const ::substrait::Rel& _internal_left() const;
  ::substrait::Rel* _internal_mutable_left();

  public:
  // .substrait.Rel right = 3;
  bool has_right() const;
  void clear_right() ;
  const ::substrait::Rel& right() const;
  [[nodiscard]] ::substrait::Rel* release_right();
  ::substrait::Rel* mutable_right();
  void set_allocated_right(::substrait::Rel* value);
  void unsafe_arena_set_allocated_right(::substrait::Rel* value);
  ::substrait::Rel* unsafe_arena_release_right();

  private:
  const ::substrait::Rel& _internal_right() const;
  ::substrait::Rel* _internal_mutable_right();

  public:
  // .substrait.Expression post_join_filter = 6;
  bool has_post_join_filter() const;
  void clear_post_join_filter() ;
  const ::substrait::Expression& post_join_filter() const;
  [[nodiscard]] ::substrait::Expression* release_post_join_filter();
  ::substrait::Expression* mutable_post_join_filter();
  void set_allocated_post_join_filter(::substrait::Expression* value);
  void unsafe_arena_set_allocated_post_join_filter(::substrait::Expression* value);
  ::substrait::Expression* unsafe_arena_release_post_join_filter();

  private:
  const ::substrait::Expression& _internal_post_join_filter() const;
  ::substrait::Expression* _internal_mutable_post_join_filter();

  public:
  // .substrait.extensions.AdvancedExtension advanced_extension = 10;
  bool has_advanced_extension() const;
  void clear_advanced_extension() ;
  const ::substrait::extensions::AdvancedExtension& advanced_extension() const;
  [[nodiscard]] ::substrait::extensions::AdvancedExtension* release_advanced_extension();
  ::substrait::extensions::AdvancedExtension* mutable_advanced_extension();
  void set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value);
  void unsafe_arena_set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value);
  ::substrait::extensions::AdvancedExtension* unsafe_arena_release_advanced_extension();

  private:
  const ::substrait::extensions::AdvancedExtension& _internal_advanced_extension() const;
  ::substrait::extensions::AdvancedExtension* _internal_mutable_advanced_extension();

  public:
  // .substrait.MergeJoinRel.JoinType type = 7;
  void clear_type() ;
  ::substrait::MergeJoinRel_JoinType type() const;
  void set_type(::substrait::MergeJoinRel_JoinType value);

  private:
  ::substrait::MergeJoinRel_JoinType _internal_type() const;
  void _internal_set_type(::substrait::MergeJoinRel_JoinType value);

  public:
  // @@protoc_insertion_point(class_scope:substrait.MergeJoinRel)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 8,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MergeJoinRel& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::substrait::Expression_FieldReference > left_keys_;
    ::google::protobuf::RepeatedPtrField< ::substrait::Expression_FieldReference > right_keys_;
    ::google::protobuf::RepeatedPtrField< ::substrait::ComparisonJoinKey > keys_;
    ::substrait::RelCommon* common_;
    ::substrait::Rel* left_;
    ::substrait::Rel* right_;
    ::substrait::Expression* post_join_filter_;
    ::substrait::extensions::AdvancedExtension* advanced_extension_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull MergeJoinRel_class_data_;
// -------------------------------------------------------------------

class NestedLoopJoinRel final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.NestedLoopJoinRel) */ {
 public:
  inline NestedLoopJoinRel() : NestedLoopJoinRel(nullptr) {}
  ~NestedLoopJoinRel() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(NestedLoopJoinRel* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(NestedLoopJoinRel));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NestedLoopJoinRel(
      ::google::protobuf::internal::ConstantInitialized);

  inline NestedLoopJoinRel(const NestedLoopJoinRel& from) : NestedLoopJoinRel(nullptr, from) {}
  inline NestedLoopJoinRel(NestedLoopJoinRel&& from) noexcept
      : NestedLoopJoinRel(nullptr, std::move(from)) {}
  inline NestedLoopJoinRel& operator=(const NestedLoopJoinRel& from) {
    CopyFrom(from);
    return *this;
  }
  inline NestedLoopJoinRel& operator=(NestedLoopJoinRel&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NestedLoopJoinRel& default_instance() {
    return *reinterpret_cast<const NestedLoopJoinRel*>(
        &_NestedLoopJoinRel_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 51;
  friend void swap(NestedLoopJoinRel& a, NestedLoopJoinRel& b) { a.Swap(&b); }
  inline void Swap(NestedLoopJoinRel* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NestedLoopJoinRel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NestedLoopJoinRel* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<NestedLoopJoinRel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NestedLoopJoinRel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NestedLoopJoinRel& from) { NestedLoopJoinRel::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(NestedLoopJoinRel* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.NestedLoopJoinRel"; }

 protected:
  explicit NestedLoopJoinRel(::google::protobuf::Arena* arena);
  NestedLoopJoinRel(::google::protobuf::Arena* arena, const NestedLoopJoinRel& from);
  NestedLoopJoinRel(::google::protobuf::Arena* arena, NestedLoopJoinRel&& from) noexcept
      : NestedLoopJoinRel(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using JoinType = NestedLoopJoinRel_JoinType;
  static constexpr JoinType JOIN_TYPE_UNSPECIFIED = NestedLoopJoinRel_JoinType_JOIN_TYPE_UNSPECIFIED;
  static constexpr JoinType JOIN_TYPE_INNER = NestedLoopJoinRel_JoinType_JOIN_TYPE_INNER;
  static constexpr JoinType JOIN_TYPE_OUTER = NestedLoopJoinRel_JoinType_JOIN_TYPE_OUTER;
  static constexpr JoinType JOIN_TYPE_LEFT = NestedLoopJoinRel_JoinType_JOIN_TYPE_LEFT;
  static constexpr JoinType JOIN_TYPE_RIGHT = NestedLoopJoinRel_JoinType_JOIN_TYPE_RIGHT;
  static constexpr JoinType JOIN_TYPE_LEFT_SEMI = NestedLoopJoinRel_JoinType_JOIN_TYPE_LEFT_SEMI;
  static constexpr JoinType JOIN_TYPE_RIGHT_SEMI = NestedLoopJoinRel_JoinType_JOIN_TYPE_RIGHT_SEMI;
  static constexpr JoinType JOIN_TYPE_LEFT_ANTI = NestedLoopJoinRel_JoinType_JOIN_TYPE_LEFT_ANTI;
  static constexpr JoinType JOIN_TYPE_RIGHT_ANTI = NestedLoopJoinRel_JoinType_JOIN_TYPE_RIGHT_ANTI;
  static inline bool JoinType_IsValid(int value) {
    return NestedLoopJoinRel_JoinType_IsValid(value);
  }
  static constexpr JoinType JoinType_MIN = NestedLoopJoinRel_JoinType_JoinType_MIN;
  static constexpr JoinType JoinType_MAX = NestedLoopJoinRel_JoinType_JoinType_MAX;
  static constexpr int JoinType_ARRAYSIZE = NestedLoopJoinRel_JoinType_JoinType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* JoinType_descriptor() {
    return NestedLoopJoinRel_JoinType_descriptor();
  }
  template <typename T>
  static inline const std::string& JoinType_Name(T value) {
    return NestedLoopJoinRel_JoinType_Name(value);
  }
  static inline bool JoinType_Parse(absl::string_view name, JoinType* value) {
    return NestedLoopJoinRel_JoinType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kCommonFieldNumber = 1,
    kLeftFieldNumber = 2,
    kRightFieldNumber = 3,
    kExpressionFieldNumber = 4,
    kAdvancedExtensionFieldNumber = 10,
    kTypeFieldNumber = 5,
  };
  // .substrait.RelCommon common = 1;
  bool has_common() const;
  void clear_common() ;
  const ::substrait::RelCommon& common() const;
  [[nodiscard]] ::substrait::RelCommon* release_common();
  ::substrait::RelCommon* mutable_common();
  void set_allocated_common(::substrait::RelCommon* value);
  void unsafe_arena_set_allocated_common(::substrait::RelCommon* value);
  ::substrait::RelCommon* unsafe_arena_release_common();

  private:
  const ::substrait::RelCommon& _internal_common() const;
  ::substrait::RelCommon* _internal_mutable_common();

  public:
  // .substrait.Rel left = 2;
  bool has_left() const;
  void clear_left() ;
  const ::substrait::Rel& left() const;
  [[nodiscard]] ::substrait::Rel* release_left();
  ::substrait::Rel* mutable_left();
  void set_allocated_left(::substrait::Rel* value);
  void unsafe_arena_set_allocated_left(::substrait::Rel* value);
  ::substrait::Rel* unsafe_arena_release_left();

  private:
  const ::substrait::Rel& _internal_left() const;
  ::substrait::Rel* _internal_mutable_left();

  public:
  // .substrait.Rel right = 3;
  bool has_right() const;
  void clear_right() ;
  const ::substrait::Rel& right() const;
  [[nodiscard]] ::substrait::Rel* release_right();
  ::substrait::Rel* mutable_right();
  void set_allocated_right(::substrait::Rel* value);
  void unsafe_arena_set_allocated_right(::substrait::Rel* value);
  ::substrait::Rel* unsafe_arena_release_right();

  private:
  const ::substrait::Rel& _internal_right() const;
  ::substrait::Rel* _internal_mutable_right();

  public:
  // .substrait.Expression expression = 4;
  bool has_expression() const;
  void clear_expression() ;
  const ::substrait::Expression& expression() const;
  [[nodiscard]] ::substrait::Expression* release_expression();
  ::substrait::Expression* mutable_expression();
  void set_allocated_expression(::substrait::Expression* value);
  void unsafe_arena_set_allocated_expression(::substrait::Expression* value);
  ::substrait::Expression* unsafe_arena_release_expression();

  private:
  const ::substrait::Expression& _internal_expression() const;
  ::substrait::Expression* _internal_mutable_expression();

  public:
  // .substrait.extensions.AdvancedExtension advanced_extension = 10;
  bool has_advanced_extension() const;
  void clear_advanced_extension() ;
  const ::substrait::extensions::AdvancedExtension& advanced_extension() const;
  [[nodiscard]] ::substrait::extensions::AdvancedExtension* release_advanced_extension();
  ::substrait::extensions::AdvancedExtension* mutable_advanced_extension();
  void set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value);
  void unsafe_arena_set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value);
  ::substrait::extensions::AdvancedExtension* unsafe_arena_release_advanced_extension();

  private:
  const ::substrait::extensions::AdvancedExtension& _internal_advanced_extension() const;
  ::substrait::extensions::AdvancedExtension* _internal_mutable_advanced_extension();

  public:
  // .substrait.NestedLoopJoinRel.JoinType type = 5;
  void clear_type() ;
  ::substrait::NestedLoopJoinRel_JoinType type() const;
  void set_type(::substrait::NestedLoopJoinRel_JoinType value);

  private:
  ::substrait::NestedLoopJoinRel_JoinType _internal_type() const;
  void _internal_set_type(::substrait::NestedLoopJoinRel_JoinType value);

  public:
  // @@protoc_insertion_point(class_scope:substrait.NestedLoopJoinRel)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 5,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const NestedLoopJoinRel& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::substrait::RelCommon* common_;
    ::substrait::Rel* left_;
    ::substrait::Rel* right_;
    ::substrait::Expression* expression_;
    ::substrait::extensions::AdvancedExtension* advanced_extension_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull NestedLoopJoinRel_class_data_;
// -------------------------------------------------------------------

class ProjectRel final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.ProjectRel) */ {
 public:
  inline ProjectRel() : ProjectRel(nullptr) {}
  ~ProjectRel() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ProjectRel* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ProjectRel));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ProjectRel(
      ::google::protobuf::internal::ConstantInitialized);

  inline ProjectRel(const ProjectRel& from) : ProjectRel(nullptr, from) {}
  inline ProjectRel(ProjectRel&& from) noexcept
      : ProjectRel(nullptr, std::move(from)) {}
  inline ProjectRel& operator=(const ProjectRel& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProjectRel& operator=(ProjectRel&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProjectRel& default_instance() {
    return *reinterpret_cast<const ProjectRel*>(
        &_ProjectRel_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(ProjectRel& a, ProjectRel& b) { a.Swap(&b); }
  inline void Swap(ProjectRel* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProjectRel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProjectRel* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ProjectRel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ProjectRel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ProjectRel& from) { ProjectRel::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ProjectRel* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.ProjectRel"; }

 protected:
  explicit ProjectRel(::google::protobuf::Arena* arena);
  ProjectRel(::google::protobuf::Arena* arena, const ProjectRel& from);
  ProjectRel(::google::protobuf::Arena* arena, ProjectRel&& from) noexcept
      : ProjectRel(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kExpressionsFieldNumber = 3,
    kCommonFieldNumber = 1,
    kInputFieldNumber = 2,
    kAdvancedExtensionFieldNumber = 10,
  };
  // repeated .substrait.Expression expressions = 3;
  int expressions_size() const;
  private:
  int _internal_expressions_size() const;

  public:
  void clear_expressions() ;
  ::substrait::Expression* mutable_expressions(int index);
  ::google::protobuf::RepeatedPtrField<::substrait::Expression>* mutable_expressions();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression>& _internal_expressions() const;
  ::google::protobuf::RepeatedPtrField<::substrait::Expression>* _internal_mutable_expressions();
  public:
  const ::substrait::Expression& expressions(int index) const;
  ::substrait::Expression* add_expressions();
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression>& expressions() const;
  // .substrait.RelCommon common = 1;
  bool has_common() const;
  void clear_common() ;
  const ::substrait::RelCommon& common() const;
  [[nodiscard]] ::substrait::RelCommon* release_common();
  ::substrait::RelCommon* mutable_common();
  void set_allocated_common(::substrait::RelCommon* value);
  void unsafe_arena_set_allocated_common(::substrait::RelCommon* value);
  ::substrait::RelCommon* unsafe_arena_release_common();

  private:
  const ::substrait::RelCommon& _internal_common() const;
  ::substrait::RelCommon* _internal_mutable_common();

  public:
  // .substrait.Rel input = 2;
  bool has_input() const;
  void clear_input() ;
  const ::substrait::Rel& input() const;
  [[nodiscard]] ::substrait::Rel* release_input();
  ::substrait::Rel* mutable_input();
  void set_allocated_input(::substrait::Rel* value);
  void unsafe_arena_set_allocated_input(::substrait::Rel* value);
  ::substrait::Rel* unsafe_arena_release_input();

  private:
  const ::substrait::Rel& _internal_input() const;
  ::substrait::Rel* _internal_mutable_input();

  public:
  // .substrait.extensions.AdvancedExtension advanced_extension = 10;
  bool has_advanced_extension() const;
  void clear_advanced_extension() ;
  const ::substrait::extensions::AdvancedExtension& advanced_extension() const;
  [[nodiscard]] ::substrait::extensions::AdvancedExtension* release_advanced_extension();
  ::substrait::extensions::AdvancedExtension* mutable_advanced_extension();
  void set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value);
  void unsafe_arena_set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value);
  ::substrait::extensions::AdvancedExtension* unsafe_arena_release_advanced_extension();

  private:
  const ::substrait::extensions::AdvancedExtension& _internal_advanced_extension() const;
  ::substrait::extensions::AdvancedExtension* _internal_mutable_advanced_extension();

  public:
  // @@protoc_insertion_point(class_scope:substrait.ProjectRel)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 4,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ProjectRel& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::substrait::Expression > expressions_;
    ::substrait::RelCommon* common_;
    ::substrait::Rel* input_;
    ::substrait::extensions::AdvancedExtension* advanced_extension_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ProjectRel_class_data_;
// -------------------------------------------------------------------

class ReadRel final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.ReadRel) */ {
 public:
  inline ReadRel() : ReadRel(nullptr) {}
  ~ReadRel() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReadRel* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReadRel));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReadRel(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReadRel(const ReadRel& from) : ReadRel(nullptr, from) {}
  inline ReadRel(ReadRel&& from) noexcept
      : ReadRel(nullptr, std::move(from)) {}
  inline ReadRel& operator=(const ReadRel& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadRel& operator=(ReadRel&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadRel& default_instance() {
    return *reinterpret_cast<const ReadRel*>(
        &_ReadRel_default_instance_);
  }
  enum ReadTypeCase {
    kVirtualTable = 5,
    kLocalFiles = 6,
    kNamedTable = 7,
    kExtensionTable = 8,
    READ_TYPE_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(ReadRel& a, ReadRel& b) { a.Swap(&b); }
  inline void Swap(ReadRel* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadRel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadRel* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReadRel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReadRel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReadRel& from) { ReadRel::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReadRel* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.ReadRel"; }

 protected:
  explicit ReadRel(::google::protobuf::Arena* arena);
  ReadRel(::google::protobuf::Arena* arena, const ReadRel& from);
  ReadRel(::google::protobuf::Arena* arena, ReadRel&& from) noexcept
      : ReadRel(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using NamedTable = ReadRel_NamedTable;
  using VirtualTable = ReadRel_VirtualTable;
  using ExtensionTable = ReadRel_ExtensionTable;
  using LocalFiles = ReadRel_LocalFiles;

  // accessors -------------------------------------------------------
  enum : int {
    kCommonFieldNumber = 1,
    kBaseSchemaFieldNumber = 2,
    kFilterFieldNumber = 3,
    kProjectionFieldNumber = 4,
    kAdvancedExtensionFieldNumber = 10,
    kBestEffortFilterFieldNumber = 11,
    kVirtualTableFieldNumber = 5,
    kLocalFilesFieldNumber = 6,
    kNamedTableFieldNumber = 7,
    kExtensionTableFieldNumber = 8,
  };
  // .substrait.RelCommon common = 1;
  bool has_common() const;
  void clear_common() ;
  const ::substrait::RelCommon& common() const;
  [[nodiscard]] ::substrait::RelCommon* release_common();
  ::substrait::RelCommon* mutable_common();
  void set_allocated_common(::substrait::RelCommon* value);
  void unsafe_arena_set_allocated_common(::substrait::RelCommon* value);
  ::substrait::RelCommon* unsafe_arena_release_common();

  private:
  const ::substrait::RelCommon& _internal_common() const;
  ::substrait::RelCommon* _internal_mutable_common();

  public:
  // .substrait.NamedStruct base_schema = 2;
  bool has_base_schema() const;
  void clear_base_schema() ;
  const ::substrait::NamedStruct& base_schema() const;
  [[nodiscard]] ::substrait::NamedStruct* release_base_schema();
  ::substrait::NamedStruct* mutable_base_schema();
  void set_allocated_base_schema(::substrait::NamedStruct* value);
  void unsafe_arena_set_allocated_base_schema(::substrait::NamedStruct* value);
  ::substrait::NamedStruct* unsafe_arena_release_base_schema();

  private:
  const ::substrait::NamedStruct& _internal_base_schema() const;
  ::substrait::NamedStruct* _internal_mutable_base_schema();

  public:
  // .substrait.Expression filter = 3;
  bool has_filter() const;
  void clear_filter() ;
  const ::substrait::Expression& filter() const;
  [[nodiscard]] ::substrait::Expression* release_filter();
  ::substrait::Expression* mutable_filter();
  void set_allocated_filter(::substrait::Expression* value);
  void unsafe_arena_set_allocated_filter(::substrait::Expression* value);
  ::substrait::Expression* unsafe_arena_release_filter();

  private:
  const ::substrait::Expression& _internal_filter() const;
  ::substrait::Expression* _internal_mutable_filter();

  public:
  // .substrait.Expression.MaskExpression projection = 4;
  bool has_projection() const;
  void clear_projection() ;
  const ::substrait::Expression_MaskExpression& projection() const;
  [[nodiscard]] ::substrait::Expression_MaskExpression* release_projection();
  ::substrait::Expression_MaskExpression* mutable_projection();
  void set_allocated_projection(::substrait::Expression_MaskExpression* value);
  void unsafe_arena_set_allocated_projection(::substrait::Expression_MaskExpression* value);
  ::substrait::Expression_MaskExpression* unsafe_arena_release_projection();

  private:
  const ::substrait::Expression_MaskExpression& _internal_projection() const;
  ::substrait::Expression_MaskExpression* _internal_mutable_projection();

  public:
  // .substrait.extensions.AdvancedExtension advanced_extension = 10;
  bool has_advanced_extension() const;
  void clear_advanced_extension() ;
  const ::substrait::extensions::AdvancedExtension& advanced_extension() const;
  [[nodiscard]] ::substrait::extensions::AdvancedExtension* release_advanced_extension();
  ::substrait::extensions::AdvancedExtension* mutable_advanced_extension();
  void set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value);
  void unsafe_arena_set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value);
  ::substrait::extensions::AdvancedExtension* unsafe_arena_release_advanced_extension();

  private:
  const ::substrait::extensions::AdvancedExtension& _internal_advanced_extension() const;
  ::substrait::extensions::AdvancedExtension* _internal_mutable_advanced_extension();

  public:
  // .substrait.Expression best_effort_filter = 11;
  bool has_best_effort_filter() const;
  void clear_best_effort_filter() ;
  const ::substrait::Expression& best_effort_filter() const;
  [[nodiscard]] ::substrait::Expression* release_best_effort_filter();
  ::substrait::Expression* mutable_best_effort_filter();
  void set_allocated_best_effort_filter(::substrait::Expression* value);
  void unsafe_arena_set_allocated_best_effort_filter(::substrait::Expression* value);
  ::substrait::Expression* unsafe_arena_release_best_effort_filter();

  private:
  const ::substrait::Expression& _internal_best_effort_filter() const;
  ::substrait::Expression* _internal_mutable_best_effort_filter();

  public:
  // .substrait.ReadRel.VirtualTable virtual_table = 5;
  bool has_virtual_table() const;
  private:
  bool _internal_has_virtual_table() const;

  public:
  void clear_virtual_table() ;
  const ::substrait::ReadRel_VirtualTable& virtual_table() const;
  [[nodiscard]] ::substrait::ReadRel_VirtualTable* release_virtual_table();
  ::substrait::ReadRel_VirtualTable* mutable_virtual_table();
  void set_allocated_virtual_table(::substrait::ReadRel_VirtualTable* value);
  void unsafe_arena_set_allocated_virtual_table(::substrait::ReadRel_VirtualTable* value);
  ::substrait::ReadRel_VirtualTable* unsafe_arena_release_virtual_table();

  private:
  const ::substrait::ReadRel_VirtualTable& _internal_virtual_table() const;
  ::substrait::ReadRel_VirtualTable* _internal_mutable_virtual_table();

  public:
  // .substrait.ReadRel.LocalFiles local_files = 6;
  bool has_local_files() const;
  private:
  bool _internal_has_local_files() const;

  public:
  void clear_local_files() ;
  const ::substrait::ReadRel_LocalFiles& local_files() const;
  [[nodiscard]] ::substrait::ReadRel_LocalFiles* release_local_files();
  ::substrait::ReadRel_LocalFiles* mutable_local_files();
  void set_allocated_local_files(::substrait::ReadRel_LocalFiles* value);
  void unsafe_arena_set_allocated_local_files(::substrait::ReadRel_LocalFiles* value);
  ::substrait::ReadRel_LocalFiles* unsafe_arena_release_local_files();

  private:
  const ::substrait::ReadRel_LocalFiles& _internal_local_files() const;
  ::substrait::ReadRel_LocalFiles* _internal_mutable_local_files();

  public:
  // .substrait.ReadRel.NamedTable named_table = 7;
  bool has_named_table() const;
  private:
  bool _internal_has_named_table() const;

  public:
  void clear_named_table() ;
  const ::substrait::ReadRel_NamedTable& named_table() const;
  [[nodiscard]] ::substrait::ReadRel_NamedTable* release_named_table();
  ::substrait::ReadRel_NamedTable* mutable_named_table();
  void set_allocated_named_table(::substrait::ReadRel_NamedTable* value);
  void unsafe_arena_set_allocated_named_table(::substrait::ReadRel_NamedTable* value);
  ::substrait::ReadRel_NamedTable* unsafe_arena_release_named_table();

  private:
  const ::substrait::ReadRel_NamedTable& _internal_named_table() const;
  ::substrait::ReadRel_NamedTable* _internal_mutable_named_table();

  public:
  // .substrait.ReadRel.ExtensionTable extension_table = 8;
  bool has_extension_table() const;
  private:
  bool _internal_has_extension_table() const;

  public:
  void clear_extension_table() ;
  const ::substrait::ReadRel_ExtensionTable& extension_table() const;
  [[nodiscard]] ::substrait::ReadRel_ExtensionTable* release_extension_table();
  ::substrait::ReadRel_ExtensionTable* mutable_extension_table();
  void set_allocated_extension_table(::substrait::ReadRel_ExtensionTable* value);
  void unsafe_arena_set_allocated_extension_table(::substrait::ReadRel_ExtensionTable* value);
  ::substrait::ReadRel_ExtensionTable* unsafe_arena_release_extension_table();

  private:
  const ::substrait::ReadRel_ExtensionTable& _internal_extension_table() const;
  ::substrait::ReadRel_ExtensionTable* _internal_mutable_extension_table();

  public:
  void clear_read_type();
  ReadTypeCase read_type_case() const;
  // @@protoc_insertion_point(class_scope:substrait.ReadRel)
 private:
  class _Internal;
  void set_has_virtual_table();
  void set_has_local_files();
  void set_has_named_table();
  void set_has_extension_table();
  inline bool has_read_type() const;
  inline void clear_has_read_type();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 10, 10,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReadRel& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::substrait::RelCommon* common_;
    ::substrait::NamedStruct* base_schema_;
    ::substrait::Expression* filter_;
    ::substrait::Expression_MaskExpression* projection_;
    ::substrait::extensions::AdvancedExtension* advanced_extension_;
    ::substrait::Expression* best_effort_filter_;
    union ReadTypeUnion {
      constexpr ReadTypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::substrait::ReadRel_VirtualTable* virtual_table_;
      ::substrait::ReadRel_LocalFiles* local_files_;
      ::substrait::ReadRel_NamedTable* named_table_;
      ::substrait::ReadRel_ExtensionTable* extension_table_;
    } read_type_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ReadRel_class_data_;
// -------------------------------------------------------------------

class Rel final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Rel) */ {
 public:
  inline Rel() : Rel(nullptr) {}
  ~Rel() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Rel* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Rel));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Rel(
      ::google::protobuf::internal::ConstantInitialized);

  inline Rel(const Rel& from) : Rel(nullptr, from) {}
  inline Rel(Rel&& from) noexcept
      : Rel(nullptr, std::move(from)) {}
  inline Rel& operator=(const Rel& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rel& operator=(Rel&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rel& default_instance() {
    return *reinterpret_cast<const Rel*>(
        &_Rel_default_instance_);
  }
  enum RelTypeCase {
    kRead = 1,
    kFilter = 2,
    kFetch = 3,
    kAggregate = 4,
    kSort = 5,
    kJoin = 6,
    kProject = 7,
    kSet = 8,
    kExtensionSingle = 9,
    kExtensionMulti = 10,
    kExtensionLeaf = 11,
    kCross = 12,
    kReference = 21,
    kWrite = 19,
    kDdl = 20,
    kHashJoin = 13,
    kMergeJoin = 14,
    kNestedLoopJoin = 18,
    kWindow = 17,
    kExchange = 15,
    kExpand = 16,
    REL_TYPE_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 42;
  friend void swap(Rel& a, Rel& b) { a.Swap(&b); }
  inline void Swap(Rel* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rel* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Rel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Rel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Rel& from) { Rel::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Rel* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Rel"; }

 protected:
  explicit Rel(::google::protobuf::Arena* arena);
  Rel(::google::protobuf::Arena* arena, const Rel& from);
  Rel(::google::protobuf::Arena* arena, Rel&& from) noexcept
      : Rel(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kReadFieldNumber = 1,
    kFilterFieldNumber = 2,
    kFetchFieldNumber = 3,
    kAggregateFieldNumber = 4,
    kSortFieldNumber = 5,
    kJoinFieldNumber = 6,
    kProjectFieldNumber = 7,
    kSetFieldNumber = 8,
    kExtensionSingleFieldNumber = 9,
    kExtensionMultiFieldNumber = 10,
    kExtensionLeafFieldNumber = 11,
    kCrossFieldNumber = 12,
    kReferenceFieldNumber = 21,
    kWriteFieldNumber = 19,
    kDdlFieldNumber = 20,
    kHashJoinFieldNumber = 13,
    kMergeJoinFieldNumber = 14,
    kNestedLoopJoinFieldNumber = 18,
    kWindowFieldNumber = 17,
    kExchangeFieldNumber = 15,
    kExpandFieldNumber = 16,
  };
  // .substrait.ReadRel read = 1;
  bool has_read() const;
  private:
  bool _internal_has_read() const;

  public:
  void clear_read() ;
  const ::substrait::ReadRel& read() const;
  [[nodiscard]] ::substrait::ReadRel* release_read();
  ::substrait::ReadRel* mutable_read();
  void set_allocated_read(::substrait::ReadRel* value);
  void unsafe_arena_set_allocated_read(::substrait::ReadRel* value);
  ::substrait::ReadRel* unsafe_arena_release_read();

  private:
  const ::substrait::ReadRel& _internal_read() const;
  ::substrait::ReadRel* _internal_mutable_read();

  public:
  // .substrait.FilterRel filter = 2;
  bool has_filter() const;
  private:
  bool _internal_has_filter() const;

  public:
  void clear_filter() ;
  const ::substrait::FilterRel& filter() const;
  [[nodiscard]] ::substrait::FilterRel* release_filter();
  ::substrait::FilterRel* mutable_filter();
  void set_allocated_filter(::substrait::FilterRel* value);
  void unsafe_arena_set_allocated_filter(::substrait::FilterRel* value);
  ::substrait::FilterRel* unsafe_arena_release_filter();

  private:
  const ::substrait::FilterRel& _internal_filter() const;
  ::substrait::FilterRel* _internal_mutable_filter();

  public:
  // .substrait.FetchRel fetch = 3;
  bool has_fetch() const;
  private:
  bool _internal_has_fetch() const;

  public:
  void clear_fetch() ;
  const ::substrait::FetchRel& fetch() const;
  [[nodiscard]] ::substrait::FetchRel* release_fetch();
  ::substrait::FetchRel* mutable_fetch();
  void set_allocated_fetch(::substrait::FetchRel* value);
  void unsafe_arena_set_allocated_fetch(::substrait::FetchRel* value);
  ::substrait::FetchRel* unsafe_arena_release_fetch();

  private:
  const ::substrait::FetchRel& _internal_fetch() const;
  ::substrait::FetchRel* _internal_mutable_fetch();

  public:
  // .substrait.AggregateRel aggregate = 4;
  bool has_aggregate() const;
  private:
  bool _internal_has_aggregate() const;

  public:
  void clear_aggregate() ;
  const ::substrait::AggregateRel& aggregate() const;
  [[nodiscard]] ::substrait::AggregateRel* release_aggregate();
  ::substrait::AggregateRel* mutable_aggregate();
  void set_allocated_aggregate(::substrait::AggregateRel* value);
  void unsafe_arena_set_allocated_aggregate(::substrait::AggregateRel* value);
  ::substrait::AggregateRel* unsafe_arena_release_aggregate();

  private:
  const ::substrait::AggregateRel& _internal_aggregate() const;
  ::substrait::AggregateRel* _internal_mutable_aggregate();

  public:
  // .substrait.SortRel sort = 5;
  bool has_sort() const;
  private:
  bool _internal_has_sort() const;

  public:
  void clear_sort() ;
  const ::substrait::SortRel& sort() const;
  [[nodiscard]] ::substrait::SortRel* release_sort();
  ::substrait::SortRel* mutable_sort();
  void set_allocated_sort(::substrait::SortRel* value);
  void unsafe_arena_set_allocated_sort(::substrait::SortRel* value);
  ::substrait::SortRel* unsafe_arena_release_sort();

  private:
  const ::substrait::SortRel& _internal_sort() const;
  ::substrait::SortRel* _internal_mutable_sort();

  public:
  // .substrait.JoinRel join = 6;
  bool has_join() const;
  private:
  bool _internal_has_join() const;

  public:
  void clear_join() ;
  const ::substrait::JoinRel& join() const;
  [[nodiscard]] ::substrait::JoinRel* release_join();
  ::substrait::JoinRel* mutable_join();
  void set_allocated_join(::substrait::JoinRel* value);
  void unsafe_arena_set_allocated_join(::substrait::JoinRel* value);
  ::substrait::JoinRel* unsafe_arena_release_join();

  private:
  const ::substrait::JoinRel& _internal_join() const;
  ::substrait::JoinRel* _internal_mutable_join();

  public:
  // .substrait.ProjectRel project = 7;
  bool has_project() const;
  private:
  bool _internal_has_project() const;

  public:
  void clear_project() ;
  const ::substrait::ProjectRel& project() const;
  [[nodiscard]] ::substrait::ProjectRel* release_project();
  ::substrait::ProjectRel* mutable_project();
  void set_allocated_project(::substrait::ProjectRel* value);
  void unsafe_arena_set_allocated_project(::substrait::ProjectRel* value);
  ::substrait::ProjectRel* unsafe_arena_release_project();

  private:
  const ::substrait::ProjectRel& _internal_project() const;
  ::substrait::ProjectRel* _internal_mutable_project();

  public:
  // .substrait.SetRel set = 8;
  bool has_set() const;
  private:
  bool _internal_has_set() const;

  public:
  void clear_set() ;
  const ::substrait::SetRel& set() const;
  [[nodiscard]] ::substrait::SetRel* release_set();
  ::substrait::SetRel* mutable_set();
  void set_allocated_set(::substrait::SetRel* value);
  void unsafe_arena_set_allocated_set(::substrait::SetRel* value);
  ::substrait::SetRel* unsafe_arena_release_set();

  private:
  const ::substrait::SetRel& _internal_set() const;
  ::substrait::SetRel* _internal_mutable_set();

  public:
  // .substrait.ExtensionSingleRel extension_single = 9;
  bool has_extension_single() const;
  private:
  bool _internal_has_extension_single() const;

  public:
  void clear_extension_single() ;
  const ::substrait::ExtensionSingleRel& extension_single() const;
  [[nodiscard]] ::substrait::ExtensionSingleRel* release_extension_single();
  ::substrait::ExtensionSingleRel* mutable_extension_single();
  void set_allocated_extension_single(::substrait::ExtensionSingleRel* value);
  void unsafe_arena_set_allocated_extension_single(::substrait::ExtensionSingleRel* value);
  ::substrait::ExtensionSingleRel* unsafe_arena_release_extension_single();

  private:
  const ::substrait::ExtensionSingleRel& _internal_extension_single() const;
  ::substrait::ExtensionSingleRel* _internal_mutable_extension_single();

  public:
  // .substrait.ExtensionMultiRel extension_multi = 10;
  bool has_extension_multi() const;
  private:
  bool _internal_has_extension_multi() const;

  public:
  void clear_extension_multi() ;
  const ::substrait::ExtensionMultiRel& extension_multi() const;
  [[nodiscard]] ::substrait::ExtensionMultiRel* release_extension_multi();
  ::substrait::ExtensionMultiRel* mutable_extension_multi();
  void set_allocated_extension_multi(::substrait::ExtensionMultiRel* value);
  void unsafe_arena_set_allocated_extension_multi(::substrait::ExtensionMultiRel* value);
  ::substrait::ExtensionMultiRel* unsafe_arena_release_extension_multi();

  private:
  const ::substrait::ExtensionMultiRel& _internal_extension_multi() const;
  ::substrait::ExtensionMultiRel* _internal_mutable_extension_multi();

  public:
  // .substrait.ExtensionLeafRel extension_leaf = 11;
  bool has_extension_leaf() const;
  private:
  bool _internal_has_extension_leaf() const;

  public:
  void clear_extension_leaf() ;
  const ::substrait::ExtensionLeafRel& extension_leaf() const;
  [[nodiscard]] ::substrait::ExtensionLeafRel* release_extension_leaf();
  ::substrait::ExtensionLeafRel* mutable_extension_leaf();
  void set_allocated_extension_leaf(::substrait::ExtensionLeafRel* value);
  void unsafe_arena_set_allocated_extension_leaf(::substrait::ExtensionLeafRel* value);
  ::substrait::ExtensionLeafRel* unsafe_arena_release_extension_leaf();

  private:
  const ::substrait::ExtensionLeafRel& _internal_extension_leaf() const;
  ::substrait::ExtensionLeafRel* _internal_mutable_extension_leaf();

  public:
  // .substrait.CrossRel cross = 12;
  bool has_cross() const;
  private:
  bool _internal_has_cross() const;

  public:
  void clear_cross() ;
  const ::substrait::CrossRel& cross() const;
  [[nodiscard]] ::substrait::CrossRel* release_cross();
  ::substrait::CrossRel* mutable_cross();
  void set_allocated_cross(::substrait::CrossRel* value);
  void unsafe_arena_set_allocated_cross(::substrait::CrossRel* value);
  ::substrait::CrossRel* unsafe_arena_release_cross();

  private:
  const ::substrait::CrossRel& _internal_cross() const;
  ::substrait::CrossRel* _internal_mutable_cross();

  public:
  // .substrait.ReferenceRel reference = 21;
  bool has_reference() const;
  private:
  bool _internal_has_reference() const;

  public:
  void clear_reference() ;
  const ::substrait::ReferenceRel& reference() const;
  [[nodiscard]] ::substrait::ReferenceRel* release_reference();
  ::substrait::ReferenceRel* mutable_reference();
  void set_allocated_reference(::substrait::ReferenceRel* value);
  void unsafe_arena_set_allocated_reference(::substrait::ReferenceRel* value);
  ::substrait::ReferenceRel* unsafe_arena_release_reference();

  private:
  const ::substrait::ReferenceRel& _internal_reference() const;
  ::substrait::ReferenceRel* _internal_mutable_reference();

  public:
  // .substrait.WriteRel write = 19;
  bool has_write() const;
  private:
  bool _internal_has_write() const;

  public:
  void clear_write() ;
  const ::substrait::WriteRel& write() const;
  [[nodiscard]] ::substrait::WriteRel* release_write();
  ::substrait::WriteRel* mutable_write();
  void set_allocated_write(::substrait::WriteRel* value);
  void unsafe_arena_set_allocated_write(::substrait::WriteRel* value);
  ::substrait::WriteRel* unsafe_arena_release_write();

  private:
  const ::substrait::WriteRel& _internal_write() const;
  ::substrait::WriteRel* _internal_mutable_write();

  public:
  // .substrait.DdlRel ddl = 20;
  bool has_ddl() const;
  private:
  bool _internal_has_ddl() const;

  public:
  void clear_ddl() ;
  const ::substrait::DdlRel& ddl() const;
  [[nodiscard]] ::substrait::DdlRel* release_ddl();
  ::substrait::DdlRel* mutable_ddl();
  void set_allocated_ddl(::substrait::DdlRel* value);
  void unsafe_arena_set_allocated_ddl(::substrait::DdlRel* value);
  ::substrait::DdlRel* unsafe_arena_release_ddl();

  private:
  const ::substrait::DdlRel& _internal_ddl() const;
  ::substrait::DdlRel* _internal_mutable_ddl();

  public:
  // .substrait.HashJoinRel hash_join = 13;
  bool has_hash_join() const;
  private:
  bool _internal_has_hash_join() const;

  public:
  void clear_hash_join() ;
  const ::substrait::HashJoinRel& hash_join() const;
  [[nodiscard]] ::substrait::HashJoinRel* release_hash_join();
  ::substrait::HashJoinRel* mutable_hash_join();
  void set_allocated_hash_join(::substrait::HashJoinRel* value);
  void unsafe_arena_set_allocated_hash_join(::substrait::HashJoinRel* value);
  ::substrait::HashJoinRel* unsafe_arena_release_hash_join();

  private:
  const ::substrait::HashJoinRel& _internal_hash_join() const;
  ::substrait::HashJoinRel* _internal_mutable_hash_join();

  public:
  // .substrait.MergeJoinRel merge_join = 14;
  bool has_merge_join() const;
  private:
  bool _internal_has_merge_join() const;

  public:
  void clear_merge_join() ;
  const ::substrait::MergeJoinRel& merge_join() const;
  [[nodiscard]] ::substrait::MergeJoinRel* release_merge_join();
  ::substrait::MergeJoinRel* mutable_merge_join();
  void set_allocated_merge_join(::substrait::MergeJoinRel* value);
  void unsafe_arena_set_allocated_merge_join(::substrait::MergeJoinRel* value);
  ::substrait::MergeJoinRel* unsafe_arena_release_merge_join();

  private:
  const ::substrait::MergeJoinRel& _internal_merge_join() const;
  ::substrait::MergeJoinRel* _internal_mutable_merge_join();

  public:
  // .substrait.NestedLoopJoinRel nested_loop_join = 18;
  bool has_nested_loop_join() const;
  private:
  bool _internal_has_nested_loop_join() const;

  public:
  void clear_nested_loop_join() ;
  const ::substrait::NestedLoopJoinRel& nested_loop_join() const;
  [[nodiscard]] ::substrait::NestedLoopJoinRel* release_nested_loop_join();
  ::substrait::NestedLoopJoinRel* mutable_nested_loop_join();
  void set_allocated_nested_loop_join(::substrait::NestedLoopJoinRel* value);
  void unsafe_arena_set_allocated_nested_loop_join(::substrait::NestedLoopJoinRel* value);
  ::substrait::NestedLoopJoinRel* unsafe_arena_release_nested_loop_join();

  private:
  const ::substrait::NestedLoopJoinRel& _internal_nested_loop_join() const;
  ::substrait::NestedLoopJoinRel* _internal_mutable_nested_loop_join();

  public:
  // .substrait.ConsistentPartitionWindowRel window = 17;
  bool has_window() const;
  private:
  bool _internal_has_window() const;

  public:
  void clear_window() ;
  const ::substrait::ConsistentPartitionWindowRel& window() const;
  [[nodiscard]] ::substrait::ConsistentPartitionWindowRel* release_window();
  ::substrait::ConsistentPartitionWindowRel* mutable_window();
  void set_allocated_window(::substrait::ConsistentPartitionWindowRel* value);
  void unsafe_arena_set_allocated_window(::substrait::ConsistentPartitionWindowRel* value);
  ::substrait::ConsistentPartitionWindowRel* unsafe_arena_release_window();

  private:
  const ::substrait::ConsistentPartitionWindowRel& _internal_window() const;
  ::substrait::ConsistentPartitionWindowRel* _internal_mutable_window();

  public:
  // .substrait.ExchangeRel exchange = 15;
  bool has_exchange() const;
  private:
  bool _internal_has_exchange() const;

  public:
  void clear_exchange() ;
  const ::substrait::ExchangeRel& exchange() const;
  [[nodiscard]] ::substrait::ExchangeRel* release_exchange();
  ::substrait::ExchangeRel* mutable_exchange();
  void set_allocated_exchange(::substrait::ExchangeRel* value);
  void unsafe_arena_set_allocated_exchange(::substrait::ExchangeRel* value);
  ::substrait::ExchangeRel* unsafe_arena_release_exchange();

  private:
  const ::substrait::ExchangeRel& _internal_exchange() const;
  ::substrait::ExchangeRel* _internal_mutable_exchange();

  public:
  // .substrait.ExpandRel expand = 16;
  bool has_expand() const;
  private:
  bool _internal_has_expand() const;

  public:
  void clear_expand() ;
  const ::substrait::ExpandRel& expand() const;
  [[nodiscard]] ::substrait::ExpandRel* release_expand();
  ::substrait::ExpandRel* mutable_expand();
  void set_allocated_expand(::substrait::ExpandRel* value);
  void unsafe_arena_set_allocated_expand(::substrait::ExpandRel* value);
  ::substrait::ExpandRel* unsafe_arena_release_expand();

  private:
  const ::substrait::ExpandRel& _internal_expand() const;
  ::substrait::ExpandRel* _internal_mutable_expand();

  public:
  void clear_rel_type();
  RelTypeCase rel_type_case() const;
  // @@protoc_insertion_point(class_scope:substrait.Rel)
 private:
  class _Internal;
  void set_has_read();
  void set_has_filter();
  void set_has_fetch();
  void set_has_aggregate();
  void set_has_sort();
  void set_has_join();
  void set_has_project();
  void set_has_set();
  void set_has_extension_single();
  void set_has_extension_multi();
  void set_has_extension_leaf();
  void set_has_cross();
  void set_has_reference();
  void set_has_write();
  void set_has_ddl();
  void set_has_hash_join();
  void set_has_merge_join();
  void set_has_nested_loop_join();
  void set_has_window();
  void set_has_exchange();
  void set_has_expand();
  inline bool has_rel_type() const;
  inline void clear_has_rel_type();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 21, 21,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Rel& from_msg);
    union RelTypeUnion {
      constexpr RelTypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::substrait::ReadRel* read_;
      ::substrait::FilterRel* filter_;
      ::substrait::FetchRel* fetch_;
      ::substrait::AggregateRel* aggregate_;
      ::substrait::SortRel* sort_;
      ::substrait::JoinRel* join_;
      ::substrait::ProjectRel* project_;
      ::substrait::SetRel* set_;
      ::substrait::ExtensionSingleRel* extension_single_;
      ::substrait::ExtensionMultiRel* extension_multi_;
      ::substrait::ExtensionLeafRel* extension_leaf_;
      ::substrait::CrossRel* cross_;
      ::substrait::ReferenceRel* reference_;
      ::substrait::WriteRel* write_;
      ::substrait::DdlRel* ddl_;
      ::substrait::HashJoinRel* hash_join_;
      ::substrait::MergeJoinRel* merge_join_;
      ::substrait::NestedLoopJoinRel* nested_loop_join_;
      ::substrait::ConsistentPartitionWindowRel* window_;
      ::substrait::ExchangeRel* exchange_;
      ::substrait::ExpandRel* expand_;
    } rel_type_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Rel_class_data_;
// -------------------------------------------------------------------

class SetRel final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.SetRel) */ {
 public:
  inline SetRel() : SetRel(nullptr) {}
  ~SetRel() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SetRel* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SetRel));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SetRel(
      ::google::protobuf::internal::ConstantInitialized);

  inline SetRel(const SetRel& from) : SetRel(nullptr, from) {}
  inline SetRel(SetRel&& from) noexcept
      : SetRel(nullptr, std::move(from)) {}
  inline SetRel& operator=(const SetRel& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetRel& operator=(SetRel&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetRel& default_instance() {
    return *reinterpret_cast<const SetRel*>(
        &_SetRel_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 27;
  friend void swap(SetRel& a, SetRel& b) { a.Swap(&b); }
  inline void Swap(SetRel* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetRel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetRel* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SetRel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SetRel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SetRel& from) { SetRel::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SetRel* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.SetRel"; }

 protected:
  explicit SetRel(::google::protobuf::Arena* arena);
  SetRel(::google::protobuf::Arena* arena, const SetRel& from);
  SetRel(::google::protobuf::Arena* arena, SetRel&& from) noexcept
      : SetRel(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using SetOp = SetRel_SetOp;
  static constexpr SetOp SET_OP_UNSPECIFIED = SetRel_SetOp_SET_OP_UNSPECIFIED;
  static constexpr SetOp SET_OP_MINUS_PRIMARY = SetRel_SetOp_SET_OP_MINUS_PRIMARY;
  static constexpr SetOp SET_OP_MINUS_MULTISET = SetRel_SetOp_SET_OP_MINUS_MULTISET;
  static constexpr SetOp SET_OP_INTERSECTION_PRIMARY = SetRel_SetOp_SET_OP_INTERSECTION_PRIMARY;
  static constexpr SetOp SET_OP_INTERSECTION_MULTISET = SetRel_SetOp_SET_OP_INTERSECTION_MULTISET;
  static constexpr SetOp SET_OP_UNION_DISTINCT = SetRel_SetOp_SET_OP_UNION_DISTINCT;
  static constexpr SetOp SET_OP_UNION_ALL = SetRel_SetOp_SET_OP_UNION_ALL;
  static inline bool SetOp_IsValid(int value) {
    return SetRel_SetOp_IsValid(value);
  }
  static constexpr SetOp SetOp_MIN = SetRel_SetOp_SetOp_MIN;
  static constexpr SetOp SetOp_MAX = SetRel_SetOp_SetOp_MAX;
  static constexpr int SetOp_ARRAYSIZE = SetRel_SetOp_SetOp_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* SetOp_descriptor() {
    return SetRel_SetOp_descriptor();
  }
  template <typename T>
  static inline const std::string& SetOp_Name(T value) {
    return SetRel_SetOp_Name(value);
  }
  static inline bool SetOp_Parse(absl::string_view name, SetOp* value) {
    return SetRel_SetOp_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kInputsFieldNumber = 2,
    kCommonFieldNumber = 1,
    kAdvancedExtensionFieldNumber = 10,
    kOpFieldNumber = 3,
  };
  // repeated .substrait.Rel inputs = 2;
  int inputs_size() const;
  private:
  int _internal_inputs_size() const;

  public:
  void clear_inputs() ;
  ::substrait::Rel* mutable_inputs(int index);
  ::google::protobuf::RepeatedPtrField<::substrait::Rel>* mutable_inputs();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::Rel>& _internal_inputs() const;
  ::google::protobuf::RepeatedPtrField<::substrait::Rel>* _internal_mutable_inputs();
  public:
  const ::substrait::Rel& inputs(int index) const;
  ::substrait::Rel* add_inputs();
  const ::google::protobuf::RepeatedPtrField<::substrait::Rel>& inputs() const;
  // .substrait.RelCommon common = 1;
  bool has_common() const;
  void clear_common() ;
  const ::substrait::RelCommon& common() const;
  [[nodiscard]] ::substrait::RelCommon* release_common();
  ::substrait::RelCommon* mutable_common();
  void set_allocated_common(::substrait::RelCommon* value);
  void unsafe_arena_set_allocated_common(::substrait::RelCommon* value);
  ::substrait::RelCommon* unsafe_arena_release_common();

  private:
  const ::substrait::RelCommon& _internal_common() const;
  ::substrait::RelCommon* _internal_mutable_common();

  public:
  // .substrait.extensions.AdvancedExtension advanced_extension = 10;
  bool has_advanced_extension() const;
  void clear_advanced_extension() ;
  const ::substrait::extensions::AdvancedExtension& advanced_extension() const;
  [[nodiscard]] ::substrait::extensions::AdvancedExtension* release_advanced_extension();
  ::substrait::extensions::AdvancedExtension* mutable_advanced_extension();
  void set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value);
  void unsafe_arena_set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value);
  ::substrait::extensions::AdvancedExtension* unsafe_arena_release_advanced_extension();

  private:
  const ::substrait::extensions::AdvancedExtension& _internal_advanced_extension() const;
  ::substrait::extensions::AdvancedExtension* _internal_mutable_advanced_extension();

  public:
  // .substrait.SetRel.SetOp op = 3;
  void clear_op() ;
  ::substrait::SetRel_SetOp op() const;
  void set_op(::substrait::SetRel_SetOp value);

  private:
  ::substrait::SetRel_SetOp _internal_op() const;
  void _internal_set_op(::substrait::SetRel_SetOp value);

  public:
  // @@protoc_insertion_point(class_scope:substrait.SetRel)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 3,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SetRel& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::substrait::Rel > inputs_;
    ::substrait::RelCommon* common_;
    ::substrait::extensions::AdvancedExtension* advanced_extension_;
    int op_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SetRel_class_data_;
// -------------------------------------------------------------------

class SortField final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.SortField) */ {
 public:
  inline SortField() : SortField(nullptr) {}
  ~SortField() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SortField* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SortField));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SortField(
      ::google::protobuf::internal::ConstantInitialized);

  inline SortField(const SortField& from) : SortField(nullptr, from) {}
  inline SortField(SortField&& from) noexcept
      : SortField(nullptr, std::move(from)) {}
  inline SortField& operator=(const SortField& from) {
    CopyFrom(from);
    return *this;
  }
  inline SortField& operator=(SortField&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SortField& default_instance() {
    return *reinterpret_cast<const SortField*>(
        &_SortField_default_instance_);
  }
  enum SortKindCase {
    kDirection = 2,
    kComparisonFunctionReference = 3,
    SORT_KIND_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 113;
  friend void swap(SortField& a, SortField& b) { a.Swap(&b); }
  inline void Swap(SortField* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SortField* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SortField* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SortField>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SortField& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SortField& from) { SortField::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SortField* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.SortField"; }

 protected:
  explicit SortField(::google::protobuf::Arena* arena);
  SortField(::google::protobuf::Arena* arena, const SortField& from);
  SortField(::google::protobuf::Arena* arena, SortField&& from) noexcept
      : SortField(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using SortDirection = SortField_SortDirection;
  static constexpr SortDirection SORT_DIRECTION_UNSPECIFIED = SortField_SortDirection_SORT_DIRECTION_UNSPECIFIED;
  static constexpr SortDirection SORT_DIRECTION_ASC_NULLS_FIRST = SortField_SortDirection_SORT_DIRECTION_ASC_NULLS_FIRST;
  static constexpr SortDirection SORT_DIRECTION_ASC_NULLS_LAST = SortField_SortDirection_SORT_DIRECTION_ASC_NULLS_LAST;
  static constexpr SortDirection SORT_DIRECTION_DESC_NULLS_FIRST = SortField_SortDirection_SORT_DIRECTION_DESC_NULLS_FIRST;
  static constexpr SortDirection SORT_DIRECTION_DESC_NULLS_LAST = SortField_SortDirection_SORT_DIRECTION_DESC_NULLS_LAST;
  static constexpr SortDirection SORT_DIRECTION_CLUSTERED = SortField_SortDirection_SORT_DIRECTION_CLUSTERED;
  static inline bool SortDirection_IsValid(int value) {
    return SortField_SortDirection_IsValid(value);
  }
  static constexpr SortDirection SortDirection_MIN = SortField_SortDirection_SortDirection_MIN;
  static constexpr SortDirection SortDirection_MAX = SortField_SortDirection_SortDirection_MAX;
  static constexpr int SortDirection_ARRAYSIZE = SortField_SortDirection_SortDirection_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* SortDirection_descriptor() {
    return SortField_SortDirection_descriptor();
  }
  template <typename T>
  static inline const std::string& SortDirection_Name(T value) {
    return SortField_SortDirection_Name(value);
  }
  static inline bool SortDirection_Parse(absl::string_view name, SortDirection* value) {
    return SortField_SortDirection_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kExprFieldNumber = 1,
    kDirectionFieldNumber = 2,
    kComparisonFunctionReferenceFieldNumber = 3,
  };
  // .substrait.Expression expr = 1;
  bool has_expr() const;
  void clear_expr() ;
  const ::substrait::Expression& expr() const;
  [[nodiscard]] ::substrait::Expression* release_expr();
  ::substrait::Expression* mutable_expr();
  void set_allocated_expr(::substrait::Expression* value);
  void unsafe_arena_set_allocated_expr(::substrait::Expression* value);
  ::substrait::Expression* unsafe_arena_release_expr();

  private:
  const ::substrait::Expression& _internal_expr() const;
  ::substrait::Expression* _internal_mutable_expr();

  public:
  // .substrait.SortField.SortDirection direction = 2;
  bool has_direction() const;
  void clear_direction() ;
  ::substrait::SortField_SortDirection direction() const;
  void set_direction(::substrait::SortField_SortDirection value);

  private:
  ::substrait::SortField_SortDirection _internal_direction() const;
  void _internal_set_direction(::substrait::SortField_SortDirection value);

  public:
  // uint32 comparison_function_reference = 3;
  bool has_comparison_function_reference() const;
  void clear_comparison_function_reference() ;
  ::uint32_t comparison_function_reference() const;
  void set_comparison_function_reference(::uint32_t value);

  private:
  ::uint32_t _internal_comparison_function_reference() const;
  void _internal_set_comparison_function_reference(::uint32_t value);

  public:
  void clear_sort_kind();
  SortKindCase sort_kind_case() const;
  // @@protoc_insertion_point(class_scope:substrait.SortField)
 private:
  class _Internal;
  void set_has_direction();
  void set_has_comparison_function_reference();
  inline bool has_sort_kind() const;
  inline void clear_has_sort_kind();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 3, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SortField& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::substrait::Expression* expr_;
    union SortKindUnion {
      constexpr SortKindUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      int direction_;
      ::uint32_t comparison_function_reference_;
    } sort_kind_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SortField_class_data_;
// -------------------------------------------------------------------

class SortRel final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.SortRel) */ {
 public:
  inline SortRel() : SortRel(nullptr) {}
  ~SortRel() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SortRel* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SortRel));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SortRel(
      ::google::protobuf::internal::ConstantInitialized);

  inline SortRel(const SortRel& from) : SortRel(nullptr, from) {}
  inline SortRel(SortRel&& from) noexcept
      : SortRel(nullptr, std::move(from)) {}
  inline SortRel& operator=(const SortRel& from) {
    CopyFrom(from);
    return *this;
  }
  inline SortRel& operator=(SortRel&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SortRel& default_instance() {
    return *reinterpret_cast<const SortRel*>(
        &_SortRel_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 25;
  friend void swap(SortRel& a, SortRel& b) { a.Swap(&b); }
  inline void Swap(SortRel* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SortRel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SortRel* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SortRel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SortRel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SortRel& from) { SortRel::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SortRel* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.SortRel"; }

 protected:
  explicit SortRel(::google::protobuf::Arena* arena);
  SortRel(::google::protobuf::Arena* arena, const SortRel& from);
  SortRel(::google::protobuf::Arena* arena, SortRel&& from) noexcept
      : SortRel(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSortsFieldNumber = 3,
    kCommonFieldNumber = 1,
    kInputFieldNumber = 2,
    kAdvancedExtensionFieldNumber = 10,
  };
  // repeated .substrait.SortField sorts = 3;
  int sorts_size() const;
  private:
  int _internal_sorts_size() const;

  public:
  void clear_sorts() ;
  ::substrait::SortField* mutable_sorts(int index);
  ::google::protobuf::RepeatedPtrField<::substrait::SortField>* mutable_sorts();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::SortField>& _internal_sorts() const;
  ::google::protobuf::RepeatedPtrField<::substrait::SortField>* _internal_mutable_sorts();
  public:
  const ::substrait::SortField& sorts(int index) const;
  ::substrait::SortField* add_sorts();
  const ::google::protobuf::RepeatedPtrField<::substrait::SortField>& sorts() const;
  // .substrait.RelCommon common = 1;
  bool has_common() const;
  void clear_common() ;
  const ::substrait::RelCommon& common() const;
  [[nodiscard]] ::substrait::RelCommon* release_common();
  ::substrait::RelCommon* mutable_common();
  void set_allocated_common(::substrait::RelCommon* value);
  void unsafe_arena_set_allocated_common(::substrait::RelCommon* value);
  ::substrait::RelCommon* unsafe_arena_release_common();

  private:
  const ::substrait::RelCommon& _internal_common() const;
  ::substrait::RelCommon* _internal_mutable_common();

  public:
  // .substrait.Rel input = 2;
  bool has_input() const;
  void clear_input() ;
  const ::substrait::Rel& input() const;
  [[nodiscard]] ::substrait::Rel* release_input();
  ::substrait::Rel* mutable_input();
  void set_allocated_input(::substrait::Rel* value);
  void unsafe_arena_set_allocated_input(::substrait::Rel* value);
  ::substrait::Rel* unsafe_arena_release_input();

  private:
  const ::substrait::Rel& _internal_input() const;
  ::substrait::Rel* _internal_mutable_input();

  public:
  // .substrait.extensions.AdvancedExtension advanced_extension = 10;
  bool has_advanced_extension() const;
  void clear_advanced_extension() ;
  const ::substrait::extensions::AdvancedExtension& advanced_extension() const;
  [[nodiscard]] ::substrait::extensions::AdvancedExtension* release_advanced_extension();
  ::substrait::extensions::AdvancedExtension* mutable_advanced_extension();
  void set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value);
  void unsafe_arena_set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value);
  ::substrait::extensions::AdvancedExtension* unsafe_arena_release_advanced_extension();

  private:
  const ::substrait::extensions::AdvancedExtension& _internal_advanced_extension() const;
  ::substrait::extensions::AdvancedExtension* _internal_mutable_advanced_extension();

  public:
  // @@protoc_insertion_point(class_scope:substrait.SortRel)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 4,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SortRel& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::substrait::SortField > sorts_;
    ::substrait::RelCommon* common_;
    ::substrait::Rel* input_;
    ::substrait::extensions::AdvancedExtension* advanced_extension_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SortRel_class_data_;
// -------------------------------------------------------------------

class WriteRel final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.WriteRel) */ {
 public:
  inline WriteRel() : WriteRel(nullptr) {}
  ~WriteRel() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(WriteRel* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(WriteRel));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WriteRel(
      ::google::protobuf::internal::ConstantInitialized);

  inline WriteRel(const WriteRel& from) : WriteRel(nullptr, from) {}
  inline WriteRel(WriteRel&& from) noexcept
      : WriteRel(nullptr, std::move(from)) {}
  inline WriteRel& operator=(const WriteRel& from) {
    CopyFrom(from);
    return *this;
  }
  inline WriteRel& operator=(WriteRel&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WriteRel& default_instance() {
    return *reinterpret_cast<const WriteRel*>(
        &_WriteRel_default_instance_);
  }
  enum WriteTypeCase {
    kNamedTable = 1,
    kExtensionTable = 2,
    WRITE_TYPE_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 46;
  friend void swap(WriteRel& a, WriteRel& b) { a.Swap(&b); }
  inline void Swap(WriteRel* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WriteRel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WriteRel* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<WriteRel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WriteRel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const WriteRel& from) { WriteRel::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(WriteRel* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.WriteRel"; }

 protected:
  explicit WriteRel(::google::protobuf::Arena* arena);
  WriteRel(::google::protobuf::Arena* arena, const WriteRel& from);
  WriteRel(::google::protobuf::Arena* arena, WriteRel&& from) noexcept
      : WriteRel(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using WriteOp = WriteRel_WriteOp;
  static constexpr WriteOp WRITE_OP_UNSPECIFIED = WriteRel_WriteOp_WRITE_OP_UNSPECIFIED;
  static constexpr WriteOp WRITE_OP_INSERT = WriteRel_WriteOp_WRITE_OP_INSERT;
  static constexpr WriteOp WRITE_OP_DELETE = WriteRel_WriteOp_WRITE_OP_DELETE;
  static constexpr WriteOp WRITE_OP_UPDATE = WriteRel_WriteOp_WRITE_OP_UPDATE;
  static constexpr WriteOp WRITE_OP_CTAS = WriteRel_WriteOp_WRITE_OP_CTAS;
  static inline bool WriteOp_IsValid(int value) {
    return WriteRel_WriteOp_IsValid(value);
  }
  static constexpr WriteOp WriteOp_MIN = WriteRel_WriteOp_WriteOp_MIN;
  static constexpr WriteOp WriteOp_MAX = WriteRel_WriteOp_WriteOp_MAX;
  static constexpr int WriteOp_ARRAYSIZE = WriteRel_WriteOp_WriteOp_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* WriteOp_descriptor() {
    return WriteRel_WriteOp_descriptor();
  }
  template <typename T>
  static inline const std::string& WriteOp_Name(T value) {
    return WriteRel_WriteOp_Name(value);
  }
  static inline bool WriteOp_Parse(absl::string_view name, WriteOp* value) {
    return WriteRel_WriteOp_Parse(name, value);
  }
  using OutputMode = WriteRel_OutputMode;
  static constexpr OutputMode OUTPUT_MODE_UNSPECIFIED = WriteRel_OutputMode_OUTPUT_MODE_UNSPECIFIED;
  static constexpr OutputMode OUTPUT_MODE_NO_OUTPUT = WriteRel_OutputMode_OUTPUT_MODE_NO_OUTPUT;
  static constexpr OutputMode OUTPUT_MODE_MODIFIED_RECORDS = WriteRel_OutputMode_OUTPUT_MODE_MODIFIED_RECORDS;
  static inline bool OutputMode_IsValid(int value) {
    return WriteRel_OutputMode_IsValid(value);
  }
  static constexpr OutputMode OutputMode_MIN = WriteRel_OutputMode_OutputMode_MIN;
  static constexpr OutputMode OutputMode_MAX = WriteRel_OutputMode_OutputMode_MAX;
  static constexpr int OutputMode_ARRAYSIZE = WriteRel_OutputMode_OutputMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* OutputMode_descriptor() {
    return WriteRel_OutputMode_descriptor();
  }
  template <typename T>
  static inline const std::string& OutputMode_Name(T value) {
    return WriteRel_OutputMode_Name(value);
  }
  static inline bool OutputMode_Parse(absl::string_view name, OutputMode* value) {
    return WriteRel_OutputMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kTableSchemaFieldNumber = 3,
    kInputFieldNumber = 5,
    kCommonFieldNumber = 7,
    kOpFieldNumber = 4,
    kOutputFieldNumber = 6,
    kNamedTableFieldNumber = 1,
    kExtensionTableFieldNumber = 2,
  };
  // .substrait.NamedStruct table_schema = 3;
  bool has_table_schema() const;
  void clear_table_schema() ;
  const ::substrait::NamedStruct& table_schema() const;
  [[nodiscard]] ::substrait::NamedStruct* release_table_schema();
  ::substrait::NamedStruct* mutable_table_schema();
  void set_allocated_table_schema(::substrait::NamedStruct* value);
  void unsafe_arena_set_allocated_table_schema(::substrait::NamedStruct* value);
  ::substrait::NamedStruct* unsafe_arena_release_table_schema();

  private:
  const ::substrait::NamedStruct& _internal_table_schema() const;
  ::substrait::NamedStruct* _internal_mutable_table_schema();

  public:
  // .substrait.Rel input = 5;
  bool has_input() const;
  void clear_input() ;
  const ::substrait::Rel& input() const;
  [[nodiscard]] ::substrait::Rel* release_input();
  ::substrait::Rel* mutable_input();
  void set_allocated_input(::substrait::Rel* value);
  void unsafe_arena_set_allocated_input(::substrait::Rel* value);
  ::substrait::Rel* unsafe_arena_release_input();

  private:
  const ::substrait::Rel& _internal_input() const;
  ::substrait::Rel* _internal_mutable_input();

  public:
  // .substrait.RelCommon common = 7;
  bool has_common() const;
  void clear_common() ;
  const ::substrait::RelCommon& common() const;
  [[nodiscard]] ::substrait::RelCommon* release_common();
  ::substrait::RelCommon* mutable_common();
  void set_allocated_common(::substrait::RelCommon* value);
  void unsafe_arena_set_allocated_common(::substrait::RelCommon* value);
  ::substrait::RelCommon* unsafe_arena_release_common();

  private:
  const ::substrait::RelCommon& _internal_common() const;
  ::substrait::RelCommon* _internal_mutable_common();

  public:
  // .substrait.WriteRel.WriteOp op = 4;
  void clear_op() ;
  ::substrait::WriteRel_WriteOp op() const;
  void set_op(::substrait::WriteRel_WriteOp value);

  private:
  ::substrait::WriteRel_WriteOp _internal_op() const;
  void _internal_set_op(::substrait::WriteRel_WriteOp value);

  public:
  // .substrait.WriteRel.OutputMode output = 6;
  void clear_output() ;
  ::substrait::WriteRel_OutputMode output() const;
  void set_output(::substrait::WriteRel_OutputMode value);

  private:
  ::substrait::WriteRel_OutputMode _internal_output() const;
  void _internal_set_output(::substrait::WriteRel_OutputMode value);

  public:
  // .substrait.NamedObjectWrite named_table = 1;
  bool has_named_table() const;
  private:
  bool _internal_has_named_table() const;

  public:
  void clear_named_table() ;
  const ::substrait::NamedObjectWrite& named_table() const;
  [[nodiscard]] ::substrait::NamedObjectWrite* release_named_table();
  ::substrait::NamedObjectWrite* mutable_named_table();
  void set_allocated_named_table(::substrait::NamedObjectWrite* value);
  void unsafe_arena_set_allocated_named_table(::substrait::NamedObjectWrite* value);
  ::substrait::NamedObjectWrite* unsafe_arena_release_named_table();

  private:
  const ::substrait::NamedObjectWrite& _internal_named_table() const;
  ::substrait::NamedObjectWrite* _internal_mutable_named_table();

  public:
  // .substrait.ExtensionObject extension_table = 2;
  bool has_extension_table() const;
  private:
  bool _internal_has_extension_table() const;

  public:
  void clear_extension_table() ;
  const ::substrait::ExtensionObject& extension_table() const;
  [[nodiscard]] ::substrait::ExtensionObject* release_extension_table();
  ::substrait::ExtensionObject* mutable_extension_table();
  void set_allocated_extension_table(::substrait::ExtensionObject* value);
  void unsafe_arena_set_allocated_extension_table(::substrait::ExtensionObject* value);
  ::substrait::ExtensionObject* unsafe_arena_release_extension_table();

  private:
  const ::substrait::ExtensionObject& _internal_extension_table() const;
  ::substrait::ExtensionObject* _internal_mutable_extension_table();

  public:
  void clear_write_type();
  WriteTypeCase write_type_case() const;
  // @@protoc_insertion_point(class_scope:substrait.WriteRel)
 private:
  class _Internal;
  void set_has_named_table();
  void set_has_extension_table();
  inline bool has_write_type() const;
  inline void clear_has_write_type();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 5,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const WriteRel& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::substrait::NamedStruct* table_schema_;
    ::substrait::Rel* input_;
    ::substrait::RelCommon* common_;
    int op_;
    int output_;
    union WriteTypeUnion {
      constexpr WriteTypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::substrait::NamedObjectWrite* named_table_;
      ::substrait::ExtensionObject* extension_table_;
    } write_type_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull WriteRel_class_data_;
// -------------------------------------------------------------------

class RelRoot final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.RelRoot) */ {
 public:
  inline RelRoot() : RelRoot(nullptr) {}
  ~RelRoot() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RelRoot* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RelRoot));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RelRoot(
      ::google::protobuf::internal::ConstantInitialized);

  inline RelRoot(const RelRoot& from) : RelRoot(nullptr, from) {}
  inline RelRoot(RelRoot&& from) noexcept
      : RelRoot(nullptr, std::move(from)) {}
  inline RelRoot& operator=(const RelRoot& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelRoot& operator=(RelRoot&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RelRoot& default_instance() {
    return *reinterpret_cast<const RelRoot*>(
        &_RelRoot_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 41;
  friend void swap(RelRoot& a, RelRoot& b) { a.Swap(&b); }
  inline void Swap(RelRoot* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelRoot* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RelRoot* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RelRoot>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RelRoot& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RelRoot& from) { RelRoot::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RelRoot* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.RelRoot"; }

 protected:
  explicit RelRoot(::google::protobuf::Arena* arena);
  RelRoot(::google::protobuf::Arena* arena, const RelRoot& from);
  RelRoot(::google::protobuf::Arena* arena, RelRoot&& from) noexcept
      : RelRoot(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNamesFieldNumber = 2,
    kInputFieldNumber = 1,
  };
  // repeated string names = 2;
  int names_size() const;
  private:
  int _internal_names_size() const;

  public:
  void clear_names() ;
  const std::string& names(int index) const;
  std::string* mutable_names(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_names(int index, Arg_&& value, Args_... args);
  std::string* add_names();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_names(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& names() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_names();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_names() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_names();

  public:
  // .substrait.Rel input = 1;
  bool has_input() const;
  void clear_input() ;
  const ::substrait::Rel& input() const;
  [[nodiscard]] ::substrait::Rel* release_input();
  ::substrait::Rel* mutable_input();
  void set_allocated_input(::substrait::Rel* value);
  void unsafe_arena_set_allocated_input(::substrait::Rel* value);
  ::substrait::Rel* unsafe_arena_release_input();

  private:
  const ::substrait::Rel& _internal_input() const;
  ::substrait::Rel* _internal_mutable_input();

  public:
  // @@protoc_insertion_point(class_scope:substrait.RelRoot)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      31, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RelRoot& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> names_;
    ::substrait::Rel* input_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RelRoot_class_data_;
// -------------------------------------------------------------------

class Expression_EmbeddedFunction final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:substrait.Expression.EmbeddedFunction) */ {
 public:
  inline Expression_EmbeddedFunction() : Expression_EmbeddedFunction(nullptr) {}
  ~Expression_EmbeddedFunction() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Expression_EmbeddedFunction* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Expression_EmbeddedFunction));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Expression_EmbeddedFunction(
      ::google::protobuf::internal::ConstantInitialized);

  inline Expression_EmbeddedFunction(const Expression_EmbeddedFunction& from) : Expression_EmbeddedFunction(nullptr, from) {}
  inline Expression_EmbeddedFunction(Expression_EmbeddedFunction&& from) noexcept
      : Expression_EmbeddedFunction(nullptr, std::move(from)) {}
  inline Expression_EmbeddedFunction& operator=(const Expression_EmbeddedFunction& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expression_EmbeddedFunction& operator=(Expression_EmbeddedFunction&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expression_EmbeddedFunction& default_instance() {
    return *reinterpret_cast<const Expression_EmbeddedFunction*>(
        &_Expression_EmbeddedFunction_default_instance_);
  }
  enum KindCase {
    kPythonPickleFunction = 3,
    kWebAssemblyFunction = 4,
    KIND_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 88;
  friend void swap(Expression_EmbeddedFunction& a, Expression_EmbeddedFunction& b) { a.Swap(&b); }
  inline void Swap(Expression_EmbeddedFunction* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expression_EmbeddedFunction* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expression_EmbeddedFunction* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Expression_EmbeddedFunction>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expression_EmbeddedFunction& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Expression_EmbeddedFunction& from) { Expression_EmbeddedFunction::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Expression_EmbeddedFunction* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "substrait.Expression.EmbeddedFunction"; }

 protected:
  explicit Expression_EmbeddedFunction(::google::protobuf::Arena* arena);
  Expression_EmbeddedFunction(::google::protobuf::Arena* arena, const Expression_EmbeddedFunction& from);
  Expression_EmbeddedFunction(::google::protobuf::Arena* arena, Expression_EmbeddedFunction&& from) noexcept
      : Expression_EmbeddedFunction(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using PythonPickleFunction = Expression_EmbeddedFunction_PythonPickleFunction;
  using WebAssemblyFunction = Expression_EmbeddedFunction_WebAssemblyFunction;

  // accessors -------------------------------------------------------
  enum : int {
    kArgumentsFieldNumber = 1,
    kOutputTypeFieldNumber = 2,
    kPythonPickleFunctionFieldNumber = 3,
    kWebAssemblyFunctionFieldNumber = 4,
  };
  // repeated .substrait.Expression arguments = 1;
  int arguments_size() const;
  private:
  int _internal_arguments_size() const;

  public:
  void clear_arguments() ;
  ::substrait::Expression* mutable_arguments(int index);
  ::google::protobuf::RepeatedPtrField<::substrait::Expression>* mutable_arguments();

  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression>& _internal_arguments() const;
  ::google::protobuf::RepeatedPtrField<::substrait::Expression>* _internal_mutable_arguments();
  public:
  const ::substrait::Expression& arguments(int index) const;
  ::substrait::Expression* add_arguments();
  const ::google::protobuf::RepeatedPtrField<::substrait::Expression>& arguments() const;
  // .substrait.Type output_type = 2;
  bool has_output_type() const;
  void clear_output_type() ;
  const ::substrait::Type& output_type() const;
  [[nodiscard]] ::substrait::Type* release_output_type();
  ::substrait::Type* mutable_output_type();
  void set_allocated_output_type(::substrait::Type* value);
  void unsafe_arena_set_allocated_output_type(::substrait::Type* value);
  ::substrait::Type* unsafe_arena_release_output_type();

  private:
  const ::substrait::Type& _internal_output_type() const;
  ::substrait::Type* _internal_mutable_output_type();

  public:
  // .substrait.Expression.EmbeddedFunction.PythonPickleFunction python_pickle_function = 3;
  bool has_python_pickle_function() const;
  private:
  bool _internal_has_python_pickle_function() const;

  public:
  void clear_python_pickle_function() ;
  const ::substrait::Expression_EmbeddedFunction_PythonPickleFunction& python_pickle_function() const;
  [[nodiscard]] ::substrait::Expression_EmbeddedFunction_PythonPickleFunction* release_python_pickle_function();
  ::substrait::Expression_EmbeddedFunction_PythonPickleFunction* mutable_python_pickle_function();
  void set_allocated_python_pickle_function(::substrait::Expression_EmbeddedFunction_PythonPickleFunction* value);
  void unsafe_arena_set_allocated_python_pickle_function(::substrait::Expression_EmbeddedFunction_PythonPickleFunction* value);
  ::substrait::Expression_EmbeddedFunction_PythonPickleFunction* unsafe_arena_release_python_pickle_function();

  private:
  const ::substrait::Expression_EmbeddedFunction_PythonPickleFunction& _internal_python_pickle_function() const;
  ::substrait::Expression_EmbeddedFunction_PythonPickleFunction* _internal_mutable_python_pickle_function();

  public:
  // .substrait.Expression.EmbeddedFunction.WebAssemblyFunction web_assembly_function = 4;
  bool has_web_assembly_function() const;
  private:
  bool _internal_has_web_assembly_function() const;

  public:
  void clear_web_assembly_function() ;
  const ::substrait::Expression_EmbeddedFunction_WebAssemblyFunction& web_assembly_function() const;
  [[nodiscard]] ::substrait::Expression_EmbeddedFunction_WebAssemblyFunction* release_web_assembly_function();
  ::substrait::Expression_EmbeddedFunction_WebAssemblyFunction* mutable_web_assembly_function();
  void set_allocated_web_assembly_function(::substrait::Expression_EmbeddedFunction_WebAssemblyFunction* value);
  void unsafe_arena_set_allocated_web_assembly_function(::substrait::Expression_EmbeddedFunction_WebAssemblyFunction* value);
  ::substrait::Expression_EmbeddedFunction_WebAssemblyFunction* unsafe_arena_release_web_assembly_function();

  private:
  const ::substrait::Expression_EmbeddedFunction_WebAssemblyFunction& _internal_web_assembly_function() const;
  ::substrait::Expression_EmbeddedFunction_WebAssemblyFunction* _internal_mutable_web_assembly_function();

  public:
  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:substrait.Expression.EmbeddedFunction)
 private:
  class _Internal;
  void set_has_python_pickle_function();
  void set_has_web_assembly_function();
  inline bool has_kind() const;
  inline void clear_has_kind();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 4, 4,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Expression_EmbeddedFunction& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::substrait::Expression > arguments_;
    ::substrait::Type* output_type_;
    union KindUnion {
      constexpr KindUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::substrait::Expression_EmbeddedFunction_PythonPickleFunction* python_pickle_function_;
      ::substrait::Expression_EmbeddedFunction_WebAssemblyFunction* web_assembly_function_;
    } kind_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2falgebra_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Expression_EmbeddedFunction_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// RelCommon_Direct

// -------------------------------------------------------------------

// RelCommon_Emit

// repeated int32 output_mapping = 1;
inline int RelCommon_Emit::_internal_output_mapping_size() const {
  return _internal_output_mapping().size();
}
inline int RelCommon_Emit::output_mapping_size() const {
  return _internal_output_mapping_size();
}
inline void RelCommon_Emit::clear_output_mapping() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.output_mapping_.Clear();
}
inline ::int32_t RelCommon_Emit::output_mapping(int index) const {
  // @@protoc_insertion_point(field_get:substrait.RelCommon.Emit.output_mapping)
  return _internal_output_mapping().Get(index);
}
inline void RelCommon_Emit::set_output_mapping(int index, ::int32_t value) {
  _internal_mutable_output_mapping()->Set(index, value);
  // @@protoc_insertion_point(field_set:substrait.RelCommon.Emit.output_mapping)
}
inline void RelCommon_Emit::add_output_mapping(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_output_mapping()->Add(value);
  // @@protoc_insertion_point(field_add:substrait.RelCommon.Emit.output_mapping)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& RelCommon_Emit::output_mapping() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.RelCommon.Emit.output_mapping)
  return _internal_output_mapping();
}
inline ::google::protobuf::RepeatedField<::int32_t>* RelCommon_Emit::mutable_output_mapping()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.RelCommon.Emit.output_mapping)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_output_mapping();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
RelCommon_Emit::_internal_output_mapping() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.output_mapping_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* RelCommon_Emit::_internal_mutable_output_mapping() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.output_mapping_;
}

// -------------------------------------------------------------------

// RelCommon_Hint_Stats

// double row_count = 1;
inline void RelCommon_Hint_Stats::clear_row_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.row_count_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double RelCommon_Hint_Stats::row_count() const {
  // @@protoc_insertion_point(field_get:substrait.RelCommon.Hint.Stats.row_count)
  return _internal_row_count();
}
inline void RelCommon_Hint_Stats::set_row_count(double value) {
  _internal_set_row_count(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:substrait.RelCommon.Hint.Stats.row_count)
}
inline double RelCommon_Hint_Stats::_internal_row_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.row_count_;
}
inline void RelCommon_Hint_Stats::_internal_set_row_count(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.row_count_ = value;
}

// double record_size = 2;
inline void RelCommon_Hint_Stats::clear_record_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.record_size_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double RelCommon_Hint_Stats::record_size() const {
  // @@protoc_insertion_point(field_get:substrait.RelCommon.Hint.Stats.record_size)
  return _internal_record_size();
}
inline void RelCommon_Hint_Stats::set_record_size(double value) {
  _internal_set_record_size(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:substrait.RelCommon.Hint.Stats.record_size)
}
inline double RelCommon_Hint_Stats::_internal_record_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.record_size_;
}
inline void RelCommon_Hint_Stats::_internal_set_record_size(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.record_size_ = value;
}

// .substrait.extensions.AdvancedExtension advanced_extension = 10;
inline bool RelCommon_Hint_Stats::has_advanced_extension() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.advanced_extension_ != nullptr);
  return value;
}
inline const ::substrait::extensions::AdvancedExtension& RelCommon_Hint_Stats::_internal_advanced_extension() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::extensions::AdvancedExtension* p = _impl_.advanced_extension_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::extensions::AdvancedExtension&>(::substrait::extensions::_AdvancedExtension_default_instance_);
}
inline const ::substrait::extensions::AdvancedExtension& RelCommon_Hint_Stats::advanced_extension() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.RelCommon.Hint.Stats.advanced_extension)
  return _internal_advanced_extension();
}
inline void RelCommon_Hint_Stats::unsafe_arena_set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.advanced_extension_);
  }
  _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.RelCommon.Hint.Stats.advanced_extension)
}
inline ::substrait::extensions::AdvancedExtension* RelCommon_Hint_Stats::release_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::extensions::AdvancedExtension* released = _impl_.advanced_extension_;
  _impl_.advanced_extension_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::extensions::AdvancedExtension* RelCommon_Hint_Stats::unsafe_arena_release_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.RelCommon.Hint.Stats.advanced_extension)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::extensions::AdvancedExtension* temp = _impl_.advanced_extension_;
  _impl_.advanced_extension_ = nullptr;
  return temp;
}
inline ::substrait::extensions::AdvancedExtension* RelCommon_Hint_Stats::_internal_mutable_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.advanced_extension_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::extensions::AdvancedExtension>(GetArena());
    _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(p);
  }
  return _impl_.advanced_extension_;
}
inline ::substrait::extensions::AdvancedExtension* RelCommon_Hint_Stats::mutable_advanced_extension() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::extensions::AdvancedExtension* _msg = _internal_mutable_advanced_extension();
  // @@protoc_insertion_point(field_mutable:substrait.RelCommon.Hint.Stats.advanced_extension)
  return _msg;
}
inline void RelCommon_Hint_Stats::set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.advanced_extension_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.RelCommon.Hint.Stats.advanced_extension)
}

// -------------------------------------------------------------------

// RelCommon_Hint_RuntimeConstraint

// .substrait.extensions.AdvancedExtension advanced_extension = 10;
inline bool RelCommon_Hint_RuntimeConstraint::has_advanced_extension() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.advanced_extension_ != nullptr);
  return value;
}
inline const ::substrait::extensions::AdvancedExtension& RelCommon_Hint_RuntimeConstraint::_internal_advanced_extension() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::extensions::AdvancedExtension* p = _impl_.advanced_extension_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::extensions::AdvancedExtension&>(::substrait::extensions::_AdvancedExtension_default_instance_);
}
inline const ::substrait::extensions::AdvancedExtension& RelCommon_Hint_RuntimeConstraint::advanced_extension() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.RelCommon.Hint.RuntimeConstraint.advanced_extension)
  return _internal_advanced_extension();
}
inline void RelCommon_Hint_RuntimeConstraint::unsafe_arena_set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.advanced_extension_);
  }
  _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.RelCommon.Hint.RuntimeConstraint.advanced_extension)
}
inline ::substrait::extensions::AdvancedExtension* RelCommon_Hint_RuntimeConstraint::release_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::extensions::AdvancedExtension* released = _impl_.advanced_extension_;
  _impl_.advanced_extension_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::extensions::AdvancedExtension* RelCommon_Hint_RuntimeConstraint::unsafe_arena_release_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.RelCommon.Hint.RuntimeConstraint.advanced_extension)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::extensions::AdvancedExtension* temp = _impl_.advanced_extension_;
  _impl_.advanced_extension_ = nullptr;
  return temp;
}
inline ::substrait::extensions::AdvancedExtension* RelCommon_Hint_RuntimeConstraint::_internal_mutable_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.advanced_extension_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::extensions::AdvancedExtension>(GetArena());
    _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(p);
  }
  return _impl_.advanced_extension_;
}
inline ::substrait::extensions::AdvancedExtension* RelCommon_Hint_RuntimeConstraint::mutable_advanced_extension() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::extensions::AdvancedExtension* _msg = _internal_mutable_advanced_extension();
  // @@protoc_insertion_point(field_mutable:substrait.RelCommon.Hint.RuntimeConstraint.advanced_extension)
  return _msg;
}
inline void RelCommon_Hint_RuntimeConstraint::set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.advanced_extension_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.RelCommon.Hint.RuntimeConstraint.advanced_extension)
}

// -------------------------------------------------------------------

// RelCommon_Hint

// .substrait.RelCommon.Hint.Stats stats = 1;
inline bool RelCommon_Hint::has_stats() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stats_ != nullptr);
  return value;
}
inline void RelCommon_Hint::clear_stats() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.stats_ != nullptr) _impl_.stats_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::RelCommon_Hint_Stats& RelCommon_Hint::_internal_stats() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::RelCommon_Hint_Stats* p = _impl_.stats_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::RelCommon_Hint_Stats&>(::substrait::_RelCommon_Hint_Stats_default_instance_);
}
inline const ::substrait::RelCommon_Hint_Stats& RelCommon_Hint::stats() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.RelCommon.Hint.stats)
  return _internal_stats();
}
inline void RelCommon_Hint::unsafe_arena_set_allocated_stats(::substrait::RelCommon_Hint_Stats* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.stats_);
  }
  _impl_.stats_ = reinterpret_cast<::substrait::RelCommon_Hint_Stats*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.RelCommon.Hint.stats)
}
inline ::substrait::RelCommon_Hint_Stats* RelCommon_Hint::release_stats() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::RelCommon_Hint_Stats* released = _impl_.stats_;
  _impl_.stats_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::RelCommon_Hint_Stats* RelCommon_Hint::unsafe_arena_release_stats() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.RelCommon.Hint.stats)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::RelCommon_Hint_Stats* temp = _impl_.stats_;
  _impl_.stats_ = nullptr;
  return temp;
}
inline ::substrait::RelCommon_Hint_Stats* RelCommon_Hint::_internal_mutable_stats() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.stats_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::RelCommon_Hint_Stats>(GetArena());
    _impl_.stats_ = reinterpret_cast<::substrait::RelCommon_Hint_Stats*>(p);
  }
  return _impl_.stats_;
}
inline ::substrait::RelCommon_Hint_Stats* RelCommon_Hint::mutable_stats() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::RelCommon_Hint_Stats* _msg = _internal_mutable_stats();
  // @@protoc_insertion_point(field_mutable:substrait.RelCommon.Hint.stats)
  return _msg;
}
inline void RelCommon_Hint::set_allocated_stats(::substrait::RelCommon_Hint_Stats* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.stats_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.stats_ = reinterpret_cast<::substrait::RelCommon_Hint_Stats*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.RelCommon.Hint.stats)
}

// .substrait.RelCommon.Hint.RuntimeConstraint constraint = 2;
inline bool RelCommon_Hint::has_constraint() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.constraint_ != nullptr);
  return value;
}
inline void RelCommon_Hint::clear_constraint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.constraint_ != nullptr) _impl_.constraint_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::substrait::RelCommon_Hint_RuntimeConstraint& RelCommon_Hint::_internal_constraint() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::RelCommon_Hint_RuntimeConstraint* p = _impl_.constraint_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::RelCommon_Hint_RuntimeConstraint&>(::substrait::_RelCommon_Hint_RuntimeConstraint_default_instance_);
}
inline const ::substrait::RelCommon_Hint_RuntimeConstraint& RelCommon_Hint::constraint() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.RelCommon.Hint.constraint)
  return _internal_constraint();
}
inline void RelCommon_Hint::unsafe_arena_set_allocated_constraint(::substrait::RelCommon_Hint_RuntimeConstraint* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.constraint_);
  }
  _impl_.constraint_ = reinterpret_cast<::substrait::RelCommon_Hint_RuntimeConstraint*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.RelCommon.Hint.constraint)
}
inline ::substrait::RelCommon_Hint_RuntimeConstraint* RelCommon_Hint::release_constraint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::RelCommon_Hint_RuntimeConstraint* released = _impl_.constraint_;
  _impl_.constraint_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::RelCommon_Hint_RuntimeConstraint* RelCommon_Hint::unsafe_arena_release_constraint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.RelCommon.Hint.constraint)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::RelCommon_Hint_RuntimeConstraint* temp = _impl_.constraint_;
  _impl_.constraint_ = nullptr;
  return temp;
}
inline ::substrait::RelCommon_Hint_RuntimeConstraint* RelCommon_Hint::_internal_mutable_constraint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.constraint_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::RelCommon_Hint_RuntimeConstraint>(GetArena());
    _impl_.constraint_ = reinterpret_cast<::substrait::RelCommon_Hint_RuntimeConstraint*>(p);
  }
  return _impl_.constraint_;
}
inline ::substrait::RelCommon_Hint_RuntimeConstraint* RelCommon_Hint::mutable_constraint() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::substrait::RelCommon_Hint_RuntimeConstraint* _msg = _internal_mutable_constraint();
  // @@protoc_insertion_point(field_mutable:substrait.RelCommon.Hint.constraint)
  return _msg;
}
inline void RelCommon_Hint::set_allocated_constraint(::substrait::RelCommon_Hint_RuntimeConstraint* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.constraint_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.constraint_ = reinterpret_cast<::substrait::RelCommon_Hint_RuntimeConstraint*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.RelCommon.Hint.constraint)
}

// .substrait.extensions.AdvancedExtension advanced_extension = 10;
inline bool RelCommon_Hint::has_advanced_extension() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.advanced_extension_ != nullptr);
  return value;
}
inline const ::substrait::extensions::AdvancedExtension& RelCommon_Hint::_internal_advanced_extension() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::extensions::AdvancedExtension* p = _impl_.advanced_extension_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::extensions::AdvancedExtension&>(::substrait::extensions::_AdvancedExtension_default_instance_);
}
inline const ::substrait::extensions::AdvancedExtension& RelCommon_Hint::advanced_extension() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.RelCommon.Hint.advanced_extension)
  return _internal_advanced_extension();
}
inline void RelCommon_Hint::unsafe_arena_set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.advanced_extension_);
  }
  _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.RelCommon.Hint.advanced_extension)
}
inline ::substrait::extensions::AdvancedExtension* RelCommon_Hint::release_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::substrait::extensions::AdvancedExtension* released = _impl_.advanced_extension_;
  _impl_.advanced_extension_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::extensions::AdvancedExtension* RelCommon_Hint::unsafe_arena_release_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.RelCommon.Hint.advanced_extension)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::substrait::extensions::AdvancedExtension* temp = _impl_.advanced_extension_;
  _impl_.advanced_extension_ = nullptr;
  return temp;
}
inline ::substrait::extensions::AdvancedExtension* RelCommon_Hint::_internal_mutable_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.advanced_extension_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::extensions::AdvancedExtension>(GetArena());
    _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(p);
  }
  return _impl_.advanced_extension_;
}
inline ::substrait::extensions::AdvancedExtension* RelCommon_Hint::mutable_advanced_extension() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::substrait::extensions::AdvancedExtension* _msg = _internal_mutable_advanced_extension();
  // @@protoc_insertion_point(field_mutable:substrait.RelCommon.Hint.advanced_extension)
  return _msg;
}
inline void RelCommon_Hint::set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.advanced_extension_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.RelCommon.Hint.advanced_extension)
}

// -------------------------------------------------------------------

// RelCommon

// .substrait.RelCommon.Direct direct = 1;
inline bool RelCommon::has_direct() const {
  return emit_kind_case() == kDirect;
}
inline bool RelCommon::_internal_has_direct() const {
  return emit_kind_case() == kDirect;
}
inline void RelCommon::set_has_direct() {
  _impl_._oneof_case_[0] = kDirect;
}
inline void RelCommon::clear_direct() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (emit_kind_case() == kDirect) {
    if (GetArena() == nullptr) {
      delete _impl_.emit_kind_.direct_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.emit_kind_.direct_);
    }
    clear_has_emit_kind();
  }
}
inline ::substrait::RelCommon_Direct* RelCommon::release_direct() {
  // @@protoc_insertion_point(field_release:substrait.RelCommon.direct)
  if (emit_kind_case() == kDirect) {
    clear_has_emit_kind();
    auto* temp = _impl_.emit_kind_.direct_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.emit_kind_.direct_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::RelCommon_Direct& RelCommon::_internal_direct() const {
  return emit_kind_case() == kDirect ? *_impl_.emit_kind_.direct_ : reinterpret_cast<::substrait::RelCommon_Direct&>(::substrait::_RelCommon_Direct_default_instance_);
}
inline const ::substrait::RelCommon_Direct& RelCommon::direct() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.RelCommon.direct)
  return _internal_direct();
}
inline ::substrait::RelCommon_Direct* RelCommon::unsafe_arena_release_direct() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.RelCommon.direct)
  if (emit_kind_case() == kDirect) {
    clear_has_emit_kind();
    auto* temp = _impl_.emit_kind_.direct_;
    _impl_.emit_kind_.direct_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelCommon::unsafe_arena_set_allocated_direct(::substrait::RelCommon_Direct* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_emit_kind();
  if (value) {
    set_has_direct();
    _impl_.emit_kind_.direct_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.RelCommon.direct)
}
inline ::substrait::RelCommon_Direct* RelCommon::_internal_mutable_direct() {
  if (emit_kind_case() != kDirect) {
    clear_emit_kind();
    set_has_direct();
    _impl_.emit_kind_.direct_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::RelCommon_Direct>(GetArena());
  }
  return _impl_.emit_kind_.direct_;
}
inline ::substrait::RelCommon_Direct* RelCommon::mutable_direct() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::RelCommon_Direct* _msg = _internal_mutable_direct();
  // @@protoc_insertion_point(field_mutable:substrait.RelCommon.direct)
  return _msg;
}

// .substrait.RelCommon.Emit emit = 2;
inline bool RelCommon::has_emit() const {
  return emit_kind_case() == kEmit;
}
inline bool RelCommon::_internal_has_emit() const {
  return emit_kind_case() == kEmit;
}
inline void RelCommon::set_has_emit() {
  _impl_._oneof_case_[0] = kEmit;
}
inline void RelCommon::clear_emit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (emit_kind_case() == kEmit) {
    if (GetArena() == nullptr) {
      delete _impl_.emit_kind_.emit_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.emit_kind_.emit_);
    }
    clear_has_emit_kind();
  }
}
inline ::substrait::RelCommon_Emit* RelCommon::release_emit() {
  // @@protoc_insertion_point(field_release:substrait.RelCommon.emit)
  if (emit_kind_case() == kEmit) {
    clear_has_emit_kind();
    auto* temp = _impl_.emit_kind_.emit_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.emit_kind_.emit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::RelCommon_Emit& RelCommon::_internal_emit() const {
  return emit_kind_case() == kEmit ? *_impl_.emit_kind_.emit_ : reinterpret_cast<::substrait::RelCommon_Emit&>(::substrait::_RelCommon_Emit_default_instance_);
}
inline const ::substrait::RelCommon_Emit& RelCommon::emit() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.RelCommon.emit)
  return _internal_emit();
}
inline ::substrait::RelCommon_Emit* RelCommon::unsafe_arena_release_emit() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.RelCommon.emit)
  if (emit_kind_case() == kEmit) {
    clear_has_emit_kind();
    auto* temp = _impl_.emit_kind_.emit_;
    _impl_.emit_kind_.emit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RelCommon::unsafe_arena_set_allocated_emit(::substrait::RelCommon_Emit* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_emit_kind();
  if (value) {
    set_has_emit();
    _impl_.emit_kind_.emit_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.RelCommon.emit)
}
inline ::substrait::RelCommon_Emit* RelCommon::_internal_mutable_emit() {
  if (emit_kind_case() != kEmit) {
    clear_emit_kind();
    set_has_emit();
    _impl_.emit_kind_.emit_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::RelCommon_Emit>(GetArena());
  }
  return _impl_.emit_kind_.emit_;
}
inline ::substrait::RelCommon_Emit* RelCommon::mutable_emit() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::RelCommon_Emit* _msg = _internal_mutable_emit();
  // @@protoc_insertion_point(field_mutable:substrait.RelCommon.emit)
  return _msg;
}

// .substrait.RelCommon.Hint hint = 3;
inline bool RelCommon::has_hint() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.hint_ != nullptr);
  return value;
}
inline void RelCommon::clear_hint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.hint_ != nullptr) _impl_.hint_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::RelCommon_Hint& RelCommon::_internal_hint() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::RelCommon_Hint* p = _impl_.hint_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::RelCommon_Hint&>(::substrait::_RelCommon_Hint_default_instance_);
}
inline const ::substrait::RelCommon_Hint& RelCommon::hint() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.RelCommon.hint)
  return _internal_hint();
}
inline void RelCommon::unsafe_arena_set_allocated_hint(::substrait::RelCommon_Hint* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.hint_);
  }
  _impl_.hint_ = reinterpret_cast<::substrait::RelCommon_Hint*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.RelCommon.hint)
}
inline ::substrait::RelCommon_Hint* RelCommon::release_hint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::RelCommon_Hint* released = _impl_.hint_;
  _impl_.hint_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::RelCommon_Hint* RelCommon::unsafe_arena_release_hint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.RelCommon.hint)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::RelCommon_Hint* temp = _impl_.hint_;
  _impl_.hint_ = nullptr;
  return temp;
}
inline ::substrait::RelCommon_Hint* RelCommon::_internal_mutable_hint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.hint_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::RelCommon_Hint>(GetArena());
    _impl_.hint_ = reinterpret_cast<::substrait::RelCommon_Hint*>(p);
  }
  return _impl_.hint_;
}
inline ::substrait::RelCommon_Hint* RelCommon::mutable_hint() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::RelCommon_Hint* _msg = _internal_mutable_hint();
  // @@protoc_insertion_point(field_mutable:substrait.RelCommon.hint)
  return _msg;
}
inline void RelCommon::set_allocated_hint(::substrait::RelCommon_Hint* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.hint_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.hint_ = reinterpret_cast<::substrait::RelCommon_Hint*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.RelCommon.hint)
}

// .substrait.extensions.AdvancedExtension advanced_extension = 4;
inline bool RelCommon::has_advanced_extension() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.advanced_extension_ != nullptr);
  return value;
}
inline const ::substrait::extensions::AdvancedExtension& RelCommon::_internal_advanced_extension() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::extensions::AdvancedExtension* p = _impl_.advanced_extension_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::extensions::AdvancedExtension&>(::substrait::extensions::_AdvancedExtension_default_instance_);
}
inline const ::substrait::extensions::AdvancedExtension& RelCommon::advanced_extension() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.RelCommon.advanced_extension)
  return _internal_advanced_extension();
}
inline void RelCommon::unsafe_arena_set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.advanced_extension_);
  }
  _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.RelCommon.advanced_extension)
}
inline ::substrait::extensions::AdvancedExtension* RelCommon::release_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::extensions::AdvancedExtension* released = _impl_.advanced_extension_;
  _impl_.advanced_extension_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::extensions::AdvancedExtension* RelCommon::unsafe_arena_release_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.RelCommon.advanced_extension)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::extensions::AdvancedExtension* temp = _impl_.advanced_extension_;
  _impl_.advanced_extension_ = nullptr;
  return temp;
}
inline ::substrait::extensions::AdvancedExtension* RelCommon::_internal_mutable_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.advanced_extension_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::extensions::AdvancedExtension>(GetArena());
    _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(p);
  }
  return _impl_.advanced_extension_;
}
inline ::substrait::extensions::AdvancedExtension* RelCommon::mutable_advanced_extension() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::substrait::extensions::AdvancedExtension* _msg = _internal_mutable_advanced_extension();
  // @@protoc_insertion_point(field_mutable:substrait.RelCommon.advanced_extension)
  return _msg;
}
inline void RelCommon::set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.advanced_extension_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.RelCommon.advanced_extension)
}

inline bool RelCommon::has_emit_kind() const {
  return emit_kind_case() != EMIT_KIND_NOT_SET;
}
inline void RelCommon::clear_has_emit_kind() {
  _impl_._oneof_case_[0] = EMIT_KIND_NOT_SET;
}
inline RelCommon::EmitKindCase RelCommon::emit_kind_case() const {
  return RelCommon::EmitKindCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ReadRel_NamedTable

// repeated string names = 1;
inline int ReadRel_NamedTable::_internal_names_size() const {
  return _internal_names().size();
}
inline int ReadRel_NamedTable::names_size() const {
  return _internal_names_size();
}
inline void ReadRel_NamedTable::clear_names() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.names_.Clear();
}
inline std::string* ReadRel_NamedTable::add_names() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_names()->Add();
  // @@protoc_insertion_point(field_add_mutable:substrait.ReadRel.NamedTable.names)
  return _s;
}
inline const std::string& ReadRel_NamedTable::names(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ReadRel.NamedTable.names)
  return _internal_names().Get(index);
}
inline std::string* ReadRel_NamedTable::mutable_names(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.NamedTable.names)
  return _internal_mutable_names()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void ReadRel_NamedTable::set_names(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_names()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:substrait.ReadRel.NamedTable.names)
}
template <typename Arg_, typename... Args_>
inline void ReadRel_NamedTable::add_names(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_names(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:substrait.ReadRel.NamedTable.names)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ReadRel_NamedTable::names() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.ReadRel.NamedTable.names)
  return _internal_names();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ReadRel_NamedTable::mutable_names() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.ReadRel.NamedTable.names)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_names();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ReadRel_NamedTable::_internal_names() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.names_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ReadRel_NamedTable::_internal_mutable_names() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.names_;
}

// .substrait.extensions.AdvancedExtension advanced_extension = 10;
inline bool ReadRel_NamedTable::has_advanced_extension() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.advanced_extension_ != nullptr);
  return value;
}
inline const ::substrait::extensions::AdvancedExtension& ReadRel_NamedTable::_internal_advanced_extension() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::extensions::AdvancedExtension* p = _impl_.advanced_extension_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::extensions::AdvancedExtension&>(::substrait::extensions::_AdvancedExtension_default_instance_);
}
inline const ::substrait::extensions::AdvancedExtension& ReadRel_NamedTable::advanced_extension() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ReadRel.NamedTable.advanced_extension)
  return _internal_advanced_extension();
}
inline void ReadRel_NamedTable::unsafe_arena_set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.advanced_extension_);
  }
  _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ReadRel.NamedTable.advanced_extension)
}
inline ::substrait::extensions::AdvancedExtension* ReadRel_NamedTable::release_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::extensions::AdvancedExtension* released = _impl_.advanced_extension_;
  _impl_.advanced_extension_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::extensions::AdvancedExtension* ReadRel_NamedTable::unsafe_arena_release_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.ReadRel.NamedTable.advanced_extension)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::extensions::AdvancedExtension* temp = _impl_.advanced_extension_;
  _impl_.advanced_extension_ = nullptr;
  return temp;
}
inline ::substrait::extensions::AdvancedExtension* ReadRel_NamedTable::_internal_mutable_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.advanced_extension_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::extensions::AdvancedExtension>(GetArena());
    _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(p);
  }
  return _impl_.advanced_extension_;
}
inline ::substrait::extensions::AdvancedExtension* ReadRel_NamedTable::mutable_advanced_extension() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::extensions::AdvancedExtension* _msg = _internal_mutable_advanced_extension();
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.NamedTable.advanced_extension)
  return _msg;
}
inline void ReadRel_NamedTable::set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.advanced_extension_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.ReadRel.NamedTable.advanced_extension)
}

// -------------------------------------------------------------------

// ReadRel_VirtualTable

// repeated .substrait.Expression.Literal.Struct values = 1;
inline int ReadRel_VirtualTable::_internal_values_size() const {
  return _internal_values().size();
}
inline int ReadRel_VirtualTable::values_size() const {
  return _internal_values_size();
}
inline void ReadRel_VirtualTable::clear_values() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.values_.Clear();
}
inline ::substrait::Expression_Literal_Struct* ReadRel_VirtualTable::mutable_values(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.VirtualTable.values)
  return _internal_mutable_values()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression_Literal_Struct>* ReadRel_VirtualTable::mutable_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.ReadRel.VirtualTable.values)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_values();
}
inline const ::substrait::Expression_Literal_Struct& ReadRel_VirtualTable::values(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ReadRel.VirtualTable.values)
  return _internal_values().Get(index);
}
inline ::substrait::Expression_Literal_Struct* ReadRel_VirtualTable::add_values() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::Expression_Literal_Struct* _add = _internal_mutable_values()->Add();
  // @@protoc_insertion_point(field_add:substrait.ReadRel.VirtualTable.values)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression_Literal_Struct>& ReadRel_VirtualTable::values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.ReadRel.VirtualTable.values)
  return _internal_values();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression_Literal_Struct>&
ReadRel_VirtualTable::_internal_values() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression_Literal_Struct>*
ReadRel_VirtualTable::_internal_mutable_values() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// ReadRel_ExtensionTable

// .google.protobuf.Any detail = 1;
inline bool ReadRel_ExtensionTable::has_detail() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.detail_ != nullptr);
  return value;
}
inline const ::google::protobuf::Any& ReadRel_ExtensionTable::_internal_detail() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Any* p = _impl_.detail_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Any&>(::google::protobuf::_Any_default_instance_);
}
inline const ::google::protobuf::Any& ReadRel_ExtensionTable::detail() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ReadRel.ExtensionTable.detail)
  return _internal_detail();
}
inline void ReadRel_ExtensionTable::unsafe_arena_set_allocated_detail(::google::protobuf::Any* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detail_);
  }
  _impl_.detail_ = reinterpret_cast<::google::protobuf::Any*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ReadRel.ExtensionTable.detail)
}
inline ::google::protobuf::Any* ReadRel_ExtensionTable::release_detail() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Any* released = _impl_.detail_;
  _impl_.detail_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Any* ReadRel_ExtensionTable::unsafe_arena_release_detail() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.ReadRel.ExtensionTable.detail)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Any* temp = _impl_.detail_;
  _impl_.detail_ = nullptr;
  return temp;
}
inline ::google::protobuf::Any* ReadRel_ExtensionTable::_internal_mutable_detail() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.detail_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Any>(GetArena());
    _impl_.detail_ = reinterpret_cast<::google::protobuf::Any*>(p);
  }
  return _impl_.detail_;
}
inline ::google::protobuf::Any* ReadRel_ExtensionTable::mutable_detail() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Any* _msg = _internal_mutable_detail();
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.ExtensionTable.detail)
  return _msg;
}
inline void ReadRel_ExtensionTable::set_allocated_detail(::google::protobuf::Any* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detail_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.detail_ = reinterpret_cast<::google::protobuf::Any*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.ReadRel.ExtensionTable.detail)
}

// -------------------------------------------------------------------

// ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions

// -------------------------------------------------------------------

// ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions

// -------------------------------------------------------------------

// ReadRel_LocalFiles_FileOrFiles_OrcReadOptions

// -------------------------------------------------------------------

// ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions

// -------------------------------------------------------------------

// ReadRel_LocalFiles_FileOrFiles

// string uri_path = 1;
inline bool ReadRel_LocalFiles_FileOrFiles::has_uri_path() const {
  return path_type_case() == kUriPath;
}
inline void ReadRel_LocalFiles_FileOrFiles::set_has_uri_path() {
  _impl_._oneof_case_[0] = kUriPath;
}
inline void ReadRel_LocalFiles_FileOrFiles::clear_uri_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (path_type_case() == kUriPath) {
    _impl_.path_type_.uri_path_.Destroy();
    clear_has_path_type();
  }
}
inline const std::string& ReadRel_LocalFiles_FileOrFiles::uri_path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ReadRel.LocalFiles.FileOrFiles.uri_path)
  return _internal_uri_path();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ReadRel_LocalFiles_FileOrFiles::set_uri_path(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (path_type_case() != kUriPath) {
    clear_path_type();

    set_has_uri_path();
    _impl_.path_type_.uri_path_.InitDefault();
  }
  _impl_.path_type_.uri_path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:substrait.ReadRel.LocalFiles.FileOrFiles.uri_path)
}
inline std::string* ReadRel_LocalFiles_FileOrFiles::mutable_uri_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_uri_path();
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.LocalFiles.FileOrFiles.uri_path)
  return _s;
}
inline const std::string& ReadRel_LocalFiles_FileOrFiles::_internal_uri_path() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (path_type_case() != kUriPath) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.path_type_.uri_path_.Get();
}
inline void ReadRel_LocalFiles_FileOrFiles::_internal_set_uri_path(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (path_type_case() != kUriPath) {
    clear_path_type();

    set_has_uri_path();
    _impl_.path_type_.uri_path_.InitDefault();
  }
  _impl_.path_type_.uri_path_.Set(value, GetArena());
}
inline std::string* ReadRel_LocalFiles_FileOrFiles::_internal_mutable_uri_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (path_type_case() != kUriPath) {
    clear_path_type();

    set_has_uri_path();
    _impl_.path_type_.uri_path_.InitDefault();
  }
  return _impl_.path_type_.uri_path_.Mutable( GetArena());
}
inline std::string* ReadRel_LocalFiles_FileOrFiles::release_uri_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.ReadRel.LocalFiles.FileOrFiles.uri_path)
  if (path_type_case() != kUriPath) {
    return nullptr;
  }
  clear_has_path_type();
  return _impl_.path_type_.uri_path_.Release();
}
inline void ReadRel_LocalFiles_FileOrFiles::set_allocated_uri_path(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_path_type()) {
    clear_path_type();
  }
  if (value != nullptr) {
    set_has_uri_path();
    _impl_.path_type_.uri_path_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:substrait.ReadRel.LocalFiles.FileOrFiles.uri_path)
}

// string uri_path_glob = 2;
inline bool ReadRel_LocalFiles_FileOrFiles::has_uri_path_glob() const {
  return path_type_case() == kUriPathGlob;
}
inline void ReadRel_LocalFiles_FileOrFiles::set_has_uri_path_glob() {
  _impl_._oneof_case_[0] = kUriPathGlob;
}
inline void ReadRel_LocalFiles_FileOrFiles::clear_uri_path_glob() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (path_type_case() == kUriPathGlob) {
    _impl_.path_type_.uri_path_glob_.Destroy();
    clear_has_path_type();
  }
}
inline const std::string& ReadRel_LocalFiles_FileOrFiles::uri_path_glob() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ReadRel.LocalFiles.FileOrFiles.uri_path_glob)
  return _internal_uri_path_glob();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ReadRel_LocalFiles_FileOrFiles::set_uri_path_glob(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (path_type_case() != kUriPathGlob) {
    clear_path_type();

    set_has_uri_path_glob();
    _impl_.path_type_.uri_path_glob_.InitDefault();
  }
  _impl_.path_type_.uri_path_glob_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:substrait.ReadRel.LocalFiles.FileOrFiles.uri_path_glob)
}
inline std::string* ReadRel_LocalFiles_FileOrFiles::mutable_uri_path_glob() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_uri_path_glob();
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.LocalFiles.FileOrFiles.uri_path_glob)
  return _s;
}
inline const std::string& ReadRel_LocalFiles_FileOrFiles::_internal_uri_path_glob() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (path_type_case() != kUriPathGlob) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.path_type_.uri_path_glob_.Get();
}
inline void ReadRel_LocalFiles_FileOrFiles::_internal_set_uri_path_glob(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (path_type_case() != kUriPathGlob) {
    clear_path_type();

    set_has_uri_path_glob();
    _impl_.path_type_.uri_path_glob_.InitDefault();
  }
  _impl_.path_type_.uri_path_glob_.Set(value, GetArena());
}
inline std::string* ReadRel_LocalFiles_FileOrFiles::_internal_mutable_uri_path_glob() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (path_type_case() != kUriPathGlob) {
    clear_path_type();

    set_has_uri_path_glob();
    _impl_.path_type_.uri_path_glob_.InitDefault();
  }
  return _impl_.path_type_.uri_path_glob_.Mutable( GetArena());
}
inline std::string* ReadRel_LocalFiles_FileOrFiles::release_uri_path_glob() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.ReadRel.LocalFiles.FileOrFiles.uri_path_glob)
  if (path_type_case() != kUriPathGlob) {
    return nullptr;
  }
  clear_has_path_type();
  return _impl_.path_type_.uri_path_glob_.Release();
}
inline void ReadRel_LocalFiles_FileOrFiles::set_allocated_uri_path_glob(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_path_type()) {
    clear_path_type();
  }
  if (value != nullptr) {
    set_has_uri_path_glob();
    _impl_.path_type_.uri_path_glob_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:substrait.ReadRel.LocalFiles.FileOrFiles.uri_path_glob)
}

// string uri_file = 3;
inline bool ReadRel_LocalFiles_FileOrFiles::has_uri_file() const {
  return path_type_case() == kUriFile;
}
inline void ReadRel_LocalFiles_FileOrFiles::set_has_uri_file() {
  _impl_._oneof_case_[0] = kUriFile;
}
inline void ReadRel_LocalFiles_FileOrFiles::clear_uri_file() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (path_type_case() == kUriFile) {
    _impl_.path_type_.uri_file_.Destroy();
    clear_has_path_type();
  }
}
inline const std::string& ReadRel_LocalFiles_FileOrFiles::uri_file() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ReadRel.LocalFiles.FileOrFiles.uri_file)
  return _internal_uri_file();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ReadRel_LocalFiles_FileOrFiles::set_uri_file(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (path_type_case() != kUriFile) {
    clear_path_type();

    set_has_uri_file();
    _impl_.path_type_.uri_file_.InitDefault();
  }
  _impl_.path_type_.uri_file_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:substrait.ReadRel.LocalFiles.FileOrFiles.uri_file)
}
inline std::string* ReadRel_LocalFiles_FileOrFiles::mutable_uri_file() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_uri_file();
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.LocalFiles.FileOrFiles.uri_file)
  return _s;
}
inline const std::string& ReadRel_LocalFiles_FileOrFiles::_internal_uri_file() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (path_type_case() != kUriFile) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.path_type_.uri_file_.Get();
}
inline void ReadRel_LocalFiles_FileOrFiles::_internal_set_uri_file(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (path_type_case() != kUriFile) {
    clear_path_type();

    set_has_uri_file();
    _impl_.path_type_.uri_file_.InitDefault();
  }
  _impl_.path_type_.uri_file_.Set(value, GetArena());
}
inline std::string* ReadRel_LocalFiles_FileOrFiles::_internal_mutable_uri_file() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (path_type_case() != kUriFile) {
    clear_path_type();

    set_has_uri_file();
    _impl_.path_type_.uri_file_.InitDefault();
  }
  return _impl_.path_type_.uri_file_.Mutable( GetArena());
}
inline std::string* ReadRel_LocalFiles_FileOrFiles::release_uri_file() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.ReadRel.LocalFiles.FileOrFiles.uri_file)
  if (path_type_case() != kUriFile) {
    return nullptr;
  }
  clear_has_path_type();
  return _impl_.path_type_.uri_file_.Release();
}
inline void ReadRel_LocalFiles_FileOrFiles::set_allocated_uri_file(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_path_type()) {
    clear_path_type();
  }
  if (value != nullptr) {
    set_has_uri_file();
    _impl_.path_type_.uri_file_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:substrait.ReadRel.LocalFiles.FileOrFiles.uri_file)
}

// string uri_folder = 4;
inline bool ReadRel_LocalFiles_FileOrFiles::has_uri_folder() const {
  return path_type_case() == kUriFolder;
}
inline void ReadRel_LocalFiles_FileOrFiles::set_has_uri_folder() {
  _impl_._oneof_case_[0] = kUriFolder;
}
inline void ReadRel_LocalFiles_FileOrFiles::clear_uri_folder() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (path_type_case() == kUriFolder) {
    _impl_.path_type_.uri_folder_.Destroy();
    clear_has_path_type();
  }
}
inline const std::string& ReadRel_LocalFiles_FileOrFiles::uri_folder() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ReadRel.LocalFiles.FileOrFiles.uri_folder)
  return _internal_uri_folder();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ReadRel_LocalFiles_FileOrFiles::set_uri_folder(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (path_type_case() != kUriFolder) {
    clear_path_type();

    set_has_uri_folder();
    _impl_.path_type_.uri_folder_.InitDefault();
  }
  _impl_.path_type_.uri_folder_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:substrait.ReadRel.LocalFiles.FileOrFiles.uri_folder)
}
inline std::string* ReadRel_LocalFiles_FileOrFiles::mutable_uri_folder() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_uri_folder();
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.LocalFiles.FileOrFiles.uri_folder)
  return _s;
}
inline const std::string& ReadRel_LocalFiles_FileOrFiles::_internal_uri_folder() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (path_type_case() != kUriFolder) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.path_type_.uri_folder_.Get();
}
inline void ReadRel_LocalFiles_FileOrFiles::_internal_set_uri_folder(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (path_type_case() != kUriFolder) {
    clear_path_type();

    set_has_uri_folder();
    _impl_.path_type_.uri_folder_.InitDefault();
  }
  _impl_.path_type_.uri_folder_.Set(value, GetArena());
}
inline std::string* ReadRel_LocalFiles_FileOrFiles::_internal_mutable_uri_folder() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (path_type_case() != kUriFolder) {
    clear_path_type();

    set_has_uri_folder();
    _impl_.path_type_.uri_folder_.InitDefault();
  }
  return _impl_.path_type_.uri_folder_.Mutable( GetArena());
}
inline std::string* ReadRel_LocalFiles_FileOrFiles::release_uri_folder() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.ReadRel.LocalFiles.FileOrFiles.uri_folder)
  if (path_type_case() != kUriFolder) {
    return nullptr;
  }
  clear_has_path_type();
  return _impl_.path_type_.uri_folder_.Release();
}
inline void ReadRel_LocalFiles_FileOrFiles::set_allocated_uri_folder(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_path_type()) {
    clear_path_type();
  }
  if (value != nullptr) {
    set_has_uri_folder();
    _impl_.path_type_.uri_folder_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:substrait.ReadRel.LocalFiles.FileOrFiles.uri_folder)
}

// uint64 partition_index = 6;
inline void ReadRel_LocalFiles_FileOrFiles::clear_partition_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.partition_index_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t ReadRel_LocalFiles_FileOrFiles::partition_index() const {
  // @@protoc_insertion_point(field_get:substrait.ReadRel.LocalFiles.FileOrFiles.partition_index)
  return _internal_partition_index();
}
inline void ReadRel_LocalFiles_FileOrFiles::set_partition_index(::uint64_t value) {
  _internal_set_partition_index(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:substrait.ReadRel.LocalFiles.FileOrFiles.partition_index)
}
inline ::uint64_t ReadRel_LocalFiles_FileOrFiles::_internal_partition_index() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.partition_index_;
}
inline void ReadRel_LocalFiles_FileOrFiles::_internal_set_partition_index(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.partition_index_ = value;
}

// uint64 start = 7;
inline void ReadRel_LocalFiles_FileOrFiles::clear_start() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.start_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t ReadRel_LocalFiles_FileOrFiles::start() const {
  // @@protoc_insertion_point(field_get:substrait.ReadRel.LocalFiles.FileOrFiles.start)
  return _internal_start();
}
inline void ReadRel_LocalFiles_FileOrFiles::set_start(::uint64_t value) {
  _internal_set_start(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:substrait.ReadRel.LocalFiles.FileOrFiles.start)
}
inline ::uint64_t ReadRel_LocalFiles_FileOrFiles::_internal_start() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.start_;
}
inline void ReadRel_LocalFiles_FileOrFiles::_internal_set_start(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.start_ = value;
}

// uint64 length = 8;
inline void ReadRel_LocalFiles_FileOrFiles::clear_length() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.length_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t ReadRel_LocalFiles_FileOrFiles::length() const {
  // @@protoc_insertion_point(field_get:substrait.ReadRel.LocalFiles.FileOrFiles.length)
  return _internal_length();
}
inline void ReadRel_LocalFiles_FileOrFiles::set_length(::uint64_t value) {
  _internal_set_length(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:substrait.ReadRel.LocalFiles.FileOrFiles.length)
}
inline ::uint64_t ReadRel_LocalFiles_FileOrFiles::_internal_length() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.length_;
}
inline void ReadRel_LocalFiles_FileOrFiles::_internal_set_length(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.length_ = value;
}

// .substrait.ReadRel.LocalFiles.FileOrFiles.ParquetReadOptions parquet = 9;
inline bool ReadRel_LocalFiles_FileOrFiles::has_parquet() const {
  return file_format_case() == kParquet;
}
inline bool ReadRel_LocalFiles_FileOrFiles::_internal_has_parquet() const {
  return file_format_case() == kParquet;
}
inline void ReadRel_LocalFiles_FileOrFiles::set_has_parquet() {
  _impl_._oneof_case_[1] = kParquet;
}
inline void ReadRel_LocalFiles_FileOrFiles::clear_parquet() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (file_format_case() == kParquet) {
    if (GetArena() == nullptr) {
      delete _impl_.file_format_.parquet_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.file_format_.parquet_);
    }
    clear_has_file_format();
  }
}
inline ::substrait::ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions* ReadRel_LocalFiles_FileOrFiles::release_parquet() {
  // @@protoc_insertion_point(field_release:substrait.ReadRel.LocalFiles.FileOrFiles.parquet)
  if (file_format_case() == kParquet) {
    clear_has_file_format();
    auto* temp = _impl_.file_format_.parquet_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.file_format_.parquet_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions& ReadRel_LocalFiles_FileOrFiles::_internal_parquet() const {
  return file_format_case() == kParquet ? *_impl_.file_format_.parquet_ : reinterpret_cast<::substrait::ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions&>(::substrait::_ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions_default_instance_);
}
inline const ::substrait::ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions& ReadRel_LocalFiles_FileOrFiles::parquet() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ReadRel.LocalFiles.FileOrFiles.parquet)
  return _internal_parquet();
}
inline ::substrait::ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions* ReadRel_LocalFiles_FileOrFiles::unsafe_arena_release_parquet() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.ReadRel.LocalFiles.FileOrFiles.parquet)
  if (file_format_case() == kParquet) {
    clear_has_file_format();
    auto* temp = _impl_.file_format_.parquet_;
    _impl_.file_format_.parquet_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ReadRel_LocalFiles_FileOrFiles::unsafe_arena_set_allocated_parquet(::substrait::ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_file_format();
  if (value) {
    set_has_parquet();
    _impl_.file_format_.parquet_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ReadRel.LocalFiles.FileOrFiles.parquet)
}
inline ::substrait::ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions* ReadRel_LocalFiles_FileOrFiles::_internal_mutable_parquet() {
  if (file_format_case() != kParquet) {
    clear_file_format();
    set_has_parquet();
    _impl_.file_format_.parquet_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions>(GetArena());
  }
  return _impl_.file_format_.parquet_;
}
inline ::substrait::ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions* ReadRel_LocalFiles_FileOrFiles::mutable_parquet() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions* _msg = _internal_mutable_parquet();
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.LocalFiles.FileOrFiles.parquet)
  return _msg;
}

// .substrait.ReadRel.LocalFiles.FileOrFiles.ArrowReadOptions arrow = 10;
inline bool ReadRel_LocalFiles_FileOrFiles::has_arrow() const {
  return file_format_case() == kArrow;
}
inline bool ReadRel_LocalFiles_FileOrFiles::_internal_has_arrow() const {
  return file_format_case() == kArrow;
}
inline void ReadRel_LocalFiles_FileOrFiles::set_has_arrow() {
  _impl_._oneof_case_[1] = kArrow;
}
inline void ReadRel_LocalFiles_FileOrFiles::clear_arrow() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (file_format_case() == kArrow) {
    if (GetArena() == nullptr) {
      delete _impl_.file_format_.arrow_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.file_format_.arrow_);
    }
    clear_has_file_format();
  }
}
inline ::substrait::ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions* ReadRel_LocalFiles_FileOrFiles::release_arrow() {
  // @@protoc_insertion_point(field_release:substrait.ReadRel.LocalFiles.FileOrFiles.arrow)
  if (file_format_case() == kArrow) {
    clear_has_file_format();
    auto* temp = _impl_.file_format_.arrow_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.file_format_.arrow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions& ReadRel_LocalFiles_FileOrFiles::_internal_arrow() const {
  return file_format_case() == kArrow ? *_impl_.file_format_.arrow_ : reinterpret_cast<::substrait::ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions&>(::substrait::_ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions_default_instance_);
}
inline const ::substrait::ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions& ReadRel_LocalFiles_FileOrFiles::arrow() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ReadRel.LocalFiles.FileOrFiles.arrow)
  return _internal_arrow();
}
inline ::substrait::ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions* ReadRel_LocalFiles_FileOrFiles::unsafe_arena_release_arrow() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.ReadRel.LocalFiles.FileOrFiles.arrow)
  if (file_format_case() == kArrow) {
    clear_has_file_format();
    auto* temp = _impl_.file_format_.arrow_;
    _impl_.file_format_.arrow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ReadRel_LocalFiles_FileOrFiles::unsafe_arena_set_allocated_arrow(::substrait::ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_file_format();
  if (value) {
    set_has_arrow();
    _impl_.file_format_.arrow_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ReadRel.LocalFiles.FileOrFiles.arrow)
}
inline ::substrait::ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions* ReadRel_LocalFiles_FileOrFiles::_internal_mutable_arrow() {
  if (file_format_case() != kArrow) {
    clear_file_format();
    set_has_arrow();
    _impl_.file_format_.arrow_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions>(GetArena());
  }
  return _impl_.file_format_.arrow_;
}
inline ::substrait::ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions* ReadRel_LocalFiles_FileOrFiles::mutable_arrow() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions* _msg = _internal_mutable_arrow();
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.LocalFiles.FileOrFiles.arrow)
  return _msg;
}

// .substrait.ReadRel.LocalFiles.FileOrFiles.OrcReadOptions orc = 11;
inline bool ReadRel_LocalFiles_FileOrFiles::has_orc() const {
  return file_format_case() == kOrc;
}
inline bool ReadRel_LocalFiles_FileOrFiles::_internal_has_orc() const {
  return file_format_case() == kOrc;
}
inline void ReadRel_LocalFiles_FileOrFiles::set_has_orc() {
  _impl_._oneof_case_[1] = kOrc;
}
inline void ReadRel_LocalFiles_FileOrFiles::clear_orc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (file_format_case() == kOrc) {
    if (GetArena() == nullptr) {
      delete _impl_.file_format_.orc_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.file_format_.orc_);
    }
    clear_has_file_format();
  }
}
inline ::substrait::ReadRel_LocalFiles_FileOrFiles_OrcReadOptions* ReadRel_LocalFiles_FileOrFiles::release_orc() {
  // @@protoc_insertion_point(field_release:substrait.ReadRel.LocalFiles.FileOrFiles.orc)
  if (file_format_case() == kOrc) {
    clear_has_file_format();
    auto* temp = _impl_.file_format_.orc_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.file_format_.orc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::ReadRel_LocalFiles_FileOrFiles_OrcReadOptions& ReadRel_LocalFiles_FileOrFiles::_internal_orc() const {
  return file_format_case() == kOrc ? *_impl_.file_format_.orc_ : reinterpret_cast<::substrait::ReadRel_LocalFiles_FileOrFiles_OrcReadOptions&>(::substrait::_ReadRel_LocalFiles_FileOrFiles_OrcReadOptions_default_instance_);
}
inline const ::substrait::ReadRel_LocalFiles_FileOrFiles_OrcReadOptions& ReadRel_LocalFiles_FileOrFiles::orc() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ReadRel.LocalFiles.FileOrFiles.orc)
  return _internal_orc();
}
inline ::substrait::ReadRel_LocalFiles_FileOrFiles_OrcReadOptions* ReadRel_LocalFiles_FileOrFiles::unsafe_arena_release_orc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.ReadRel.LocalFiles.FileOrFiles.orc)
  if (file_format_case() == kOrc) {
    clear_has_file_format();
    auto* temp = _impl_.file_format_.orc_;
    _impl_.file_format_.orc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ReadRel_LocalFiles_FileOrFiles::unsafe_arena_set_allocated_orc(::substrait::ReadRel_LocalFiles_FileOrFiles_OrcReadOptions* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_file_format();
  if (value) {
    set_has_orc();
    _impl_.file_format_.orc_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ReadRel.LocalFiles.FileOrFiles.orc)
}
inline ::substrait::ReadRel_LocalFiles_FileOrFiles_OrcReadOptions* ReadRel_LocalFiles_FileOrFiles::_internal_mutable_orc() {
  if (file_format_case() != kOrc) {
    clear_file_format();
    set_has_orc();
    _impl_.file_format_.orc_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::ReadRel_LocalFiles_FileOrFiles_OrcReadOptions>(GetArena());
  }
  return _impl_.file_format_.orc_;
}
inline ::substrait::ReadRel_LocalFiles_FileOrFiles_OrcReadOptions* ReadRel_LocalFiles_FileOrFiles::mutable_orc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::ReadRel_LocalFiles_FileOrFiles_OrcReadOptions* _msg = _internal_mutable_orc();
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.LocalFiles.FileOrFiles.orc)
  return _msg;
}

// .google.protobuf.Any extension = 12;
inline bool ReadRel_LocalFiles_FileOrFiles::has_extension() const {
  return file_format_case() == kExtension;
}
inline bool ReadRel_LocalFiles_FileOrFiles::_internal_has_extension() const {
  return file_format_case() == kExtension;
}
inline void ReadRel_LocalFiles_FileOrFiles::set_has_extension() {
  _impl_._oneof_case_[1] = kExtension;
}
inline ::google::protobuf::Any* ReadRel_LocalFiles_FileOrFiles::release_extension() {
  // @@protoc_insertion_point(field_release:substrait.ReadRel.LocalFiles.FileOrFiles.extension)
  if (file_format_case() == kExtension) {
    clear_has_file_format();
    auto* temp = _impl_.file_format_.extension_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.file_format_.extension_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Any& ReadRel_LocalFiles_FileOrFiles::_internal_extension() const {
  return file_format_case() == kExtension ? *_impl_.file_format_.extension_ : reinterpret_cast<::google::protobuf::Any&>(::google::protobuf::_Any_default_instance_);
}
inline const ::google::protobuf::Any& ReadRel_LocalFiles_FileOrFiles::extension() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ReadRel.LocalFiles.FileOrFiles.extension)
  return _internal_extension();
}
inline ::google::protobuf::Any* ReadRel_LocalFiles_FileOrFiles::unsafe_arena_release_extension() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.ReadRel.LocalFiles.FileOrFiles.extension)
  if (file_format_case() == kExtension) {
    clear_has_file_format();
    auto* temp = _impl_.file_format_.extension_;
    _impl_.file_format_.extension_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ReadRel_LocalFiles_FileOrFiles::unsafe_arena_set_allocated_extension(::google::protobuf::Any* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_file_format();
  if (value) {
    set_has_extension();
    _impl_.file_format_.extension_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ReadRel.LocalFiles.FileOrFiles.extension)
}
inline ::google::protobuf::Any* ReadRel_LocalFiles_FileOrFiles::_internal_mutable_extension() {
  if (file_format_case() != kExtension) {
    clear_file_format();
    set_has_extension();
    _impl_.file_format_.extension_ =
        ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Any>(GetArena());
  }
  return _impl_.file_format_.extension_;
}
inline ::google::protobuf::Any* ReadRel_LocalFiles_FileOrFiles::mutable_extension() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Any* _msg = _internal_mutable_extension();
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.LocalFiles.FileOrFiles.extension)
  return _msg;
}

// .substrait.ReadRel.LocalFiles.FileOrFiles.DwrfReadOptions dwrf = 13;
inline bool ReadRel_LocalFiles_FileOrFiles::has_dwrf() const {
  return file_format_case() == kDwrf;
}
inline bool ReadRel_LocalFiles_FileOrFiles::_internal_has_dwrf() const {
  return file_format_case() == kDwrf;
}
inline void ReadRel_LocalFiles_FileOrFiles::set_has_dwrf() {
  _impl_._oneof_case_[1] = kDwrf;
}
inline void ReadRel_LocalFiles_FileOrFiles::clear_dwrf() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (file_format_case() == kDwrf) {
    if (GetArena() == nullptr) {
      delete _impl_.file_format_.dwrf_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.file_format_.dwrf_);
    }
    clear_has_file_format();
  }
}
inline ::substrait::ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions* ReadRel_LocalFiles_FileOrFiles::release_dwrf() {
  // @@protoc_insertion_point(field_release:substrait.ReadRel.LocalFiles.FileOrFiles.dwrf)
  if (file_format_case() == kDwrf) {
    clear_has_file_format();
    auto* temp = _impl_.file_format_.dwrf_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.file_format_.dwrf_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions& ReadRel_LocalFiles_FileOrFiles::_internal_dwrf() const {
  return file_format_case() == kDwrf ? *_impl_.file_format_.dwrf_ : reinterpret_cast<::substrait::ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions&>(::substrait::_ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions_default_instance_);
}
inline const ::substrait::ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions& ReadRel_LocalFiles_FileOrFiles::dwrf() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ReadRel.LocalFiles.FileOrFiles.dwrf)
  return _internal_dwrf();
}
inline ::substrait::ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions* ReadRel_LocalFiles_FileOrFiles::unsafe_arena_release_dwrf() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.ReadRel.LocalFiles.FileOrFiles.dwrf)
  if (file_format_case() == kDwrf) {
    clear_has_file_format();
    auto* temp = _impl_.file_format_.dwrf_;
    _impl_.file_format_.dwrf_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ReadRel_LocalFiles_FileOrFiles::unsafe_arena_set_allocated_dwrf(::substrait::ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_file_format();
  if (value) {
    set_has_dwrf();
    _impl_.file_format_.dwrf_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ReadRel.LocalFiles.FileOrFiles.dwrf)
}
inline ::substrait::ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions* ReadRel_LocalFiles_FileOrFiles::_internal_mutable_dwrf() {
  if (file_format_case() != kDwrf) {
    clear_file_format();
    set_has_dwrf();
    _impl_.file_format_.dwrf_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions>(GetArena());
  }
  return _impl_.file_format_.dwrf_;
}
inline ::substrait::ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions* ReadRel_LocalFiles_FileOrFiles::mutable_dwrf() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions* _msg = _internal_mutable_dwrf();
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.LocalFiles.FileOrFiles.dwrf)
  return _msg;
}

inline bool ReadRel_LocalFiles_FileOrFiles::has_path_type() const {
  return path_type_case() != PATH_TYPE_NOT_SET;
}
inline void ReadRel_LocalFiles_FileOrFiles::clear_has_path_type() {
  _impl_._oneof_case_[0] = PATH_TYPE_NOT_SET;
}
inline bool ReadRel_LocalFiles_FileOrFiles::has_file_format() const {
  return file_format_case() != FILE_FORMAT_NOT_SET;
}
inline void ReadRel_LocalFiles_FileOrFiles::clear_has_file_format() {
  _impl_._oneof_case_[1] = FILE_FORMAT_NOT_SET;
}
inline ReadRel_LocalFiles_FileOrFiles::PathTypeCase ReadRel_LocalFiles_FileOrFiles::path_type_case() const {
  return ReadRel_LocalFiles_FileOrFiles::PathTypeCase(_impl_._oneof_case_[0]);
}
inline ReadRel_LocalFiles_FileOrFiles::FileFormatCase ReadRel_LocalFiles_FileOrFiles::file_format_case() const {
  return ReadRel_LocalFiles_FileOrFiles::FileFormatCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// ReadRel_LocalFiles

// repeated .substrait.ReadRel.LocalFiles.FileOrFiles items = 1;
inline int ReadRel_LocalFiles::_internal_items_size() const {
  return _internal_items().size();
}
inline int ReadRel_LocalFiles::items_size() const {
  return _internal_items_size();
}
inline void ReadRel_LocalFiles::clear_items() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.items_.Clear();
}
inline ::substrait::ReadRel_LocalFiles_FileOrFiles* ReadRel_LocalFiles::mutable_items(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.LocalFiles.items)
  return _internal_mutable_items()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::ReadRel_LocalFiles_FileOrFiles>* ReadRel_LocalFiles::mutable_items()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.ReadRel.LocalFiles.items)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_items();
}
inline const ::substrait::ReadRel_LocalFiles_FileOrFiles& ReadRel_LocalFiles::items(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ReadRel.LocalFiles.items)
  return _internal_items().Get(index);
}
inline ::substrait::ReadRel_LocalFiles_FileOrFiles* ReadRel_LocalFiles::add_items() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::ReadRel_LocalFiles_FileOrFiles* _add = _internal_mutable_items()->Add();
  // @@protoc_insertion_point(field_add:substrait.ReadRel.LocalFiles.items)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::ReadRel_LocalFiles_FileOrFiles>& ReadRel_LocalFiles::items() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.ReadRel.LocalFiles.items)
  return _internal_items();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::ReadRel_LocalFiles_FileOrFiles>&
ReadRel_LocalFiles::_internal_items() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.items_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::ReadRel_LocalFiles_FileOrFiles>*
ReadRel_LocalFiles::_internal_mutable_items() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.items_;
}

// .substrait.extensions.AdvancedExtension advanced_extension = 10;
inline bool ReadRel_LocalFiles::has_advanced_extension() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.advanced_extension_ != nullptr);
  return value;
}
inline const ::substrait::extensions::AdvancedExtension& ReadRel_LocalFiles::_internal_advanced_extension() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::extensions::AdvancedExtension* p = _impl_.advanced_extension_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::extensions::AdvancedExtension&>(::substrait::extensions::_AdvancedExtension_default_instance_);
}
inline const ::substrait::extensions::AdvancedExtension& ReadRel_LocalFiles::advanced_extension() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ReadRel.LocalFiles.advanced_extension)
  return _internal_advanced_extension();
}
inline void ReadRel_LocalFiles::unsafe_arena_set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.advanced_extension_);
  }
  _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ReadRel.LocalFiles.advanced_extension)
}
inline ::substrait::extensions::AdvancedExtension* ReadRel_LocalFiles::release_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::extensions::AdvancedExtension* released = _impl_.advanced_extension_;
  _impl_.advanced_extension_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::extensions::AdvancedExtension* ReadRel_LocalFiles::unsafe_arena_release_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.ReadRel.LocalFiles.advanced_extension)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::extensions::AdvancedExtension* temp = _impl_.advanced_extension_;
  _impl_.advanced_extension_ = nullptr;
  return temp;
}
inline ::substrait::extensions::AdvancedExtension* ReadRel_LocalFiles::_internal_mutable_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.advanced_extension_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::extensions::AdvancedExtension>(GetArena());
    _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(p);
  }
  return _impl_.advanced_extension_;
}
inline ::substrait::extensions::AdvancedExtension* ReadRel_LocalFiles::mutable_advanced_extension() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::extensions::AdvancedExtension* _msg = _internal_mutable_advanced_extension();
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.LocalFiles.advanced_extension)
  return _msg;
}
inline void ReadRel_LocalFiles::set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.advanced_extension_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.ReadRel.LocalFiles.advanced_extension)
}

// -------------------------------------------------------------------

// ReadRel

// .substrait.RelCommon common = 1;
inline bool ReadRel::has_common() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.common_ != nullptr);
  return value;
}
inline void ReadRel::clear_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.common_ != nullptr) _impl_.common_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::RelCommon& ReadRel::_internal_common() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::RelCommon* p = _impl_.common_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::RelCommon&>(::substrait::_RelCommon_default_instance_);
}
inline const ::substrait::RelCommon& ReadRel::common() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ReadRel.common)
  return _internal_common();
}
inline void ReadRel::unsafe_arena_set_allocated_common(::substrait::RelCommon* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.common_);
  }
  _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ReadRel.common)
}
inline ::substrait::RelCommon* ReadRel::release_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::RelCommon* released = _impl_.common_;
  _impl_.common_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::RelCommon* ReadRel::unsafe_arena_release_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.ReadRel.common)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::RelCommon* temp = _impl_.common_;
  _impl_.common_ = nullptr;
  return temp;
}
inline ::substrait::RelCommon* ReadRel::_internal_mutable_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.common_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::RelCommon>(GetArena());
    _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(p);
  }
  return _impl_.common_;
}
inline ::substrait::RelCommon* ReadRel::mutable_common() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::RelCommon* _msg = _internal_mutable_common();
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.common)
  return _msg;
}
inline void ReadRel::set_allocated_common(::substrait::RelCommon* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.common_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.ReadRel.common)
}

// .substrait.NamedStruct base_schema = 2;
inline bool ReadRel::has_base_schema() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.base_schema_ != nullptr);
  return value;
}
inline const ::substrait::NamedStruct& ReadRel::_internal_base_schema() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::NamedStruct* p = _impl_.base_schema_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::NamedStruct&>(::substrait::_NamedStruct_default_instance_);
}
inline const ::substrait::NamedStruct& ReadRel::base_schema() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ReadRel.base_schema)
  return _internal_base_schema();
}
inline void ReadRel::unsafe_arena_set_allocated_base_schema(::substrait::NamedStruct* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.base_schema_);
  }
  _impl_.base_schema_ = reinterpret_cast<::substrait::NamedStruct*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ReadRel.base_schema)
}
inline ::substrait::NamedStruct* ReadRel::release_base_schema() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::NamedStruct* released = _impl_.base_schema_;
  _impl_.base_schema_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::NamedStruct* ReadRel::unsafe_arena_release_base_schema() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.ReadRel.base_schema)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::NamedStruct* temp = _impl_.base_schema_;
  _impl_.base_schema_ = nullptr;
  return temp;
}
inline ::substrait::NamedStruct* ReadRel::_internal_mutable_base_schema() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.base_schema_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::NamedStruct>(GetArena());
    _impl_.base_schema_ = reinterpret_cast<::substrait::NamedStruct*>(p);
  }
  return _impl_.base_schema_;
}
inline ::substrait::NamedStruct* ReadRel::mutable_base_schema() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::substrait::NamedStruct* _msg = _internal_mutable_base_schema();
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.base_schema)
  return _msg;
}
inline void ReadRel::set_allocated_base_schema(::substrait::NamedStruct* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.base_schema_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.base_schema_ = reinterpret_cast<::substrait::NamedStruct*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.ReadRel.base_schema)
}

// .substrait.Expression filter = 3;
inline bool ReadRel::has_filter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.filter_ != nullptr);
  return value;
}
inline void ReadRel::clear_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.filter_ != nullptr) _impl_.filter_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::substrait::Expression& ReadRel::_internal_filter() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Expression* p = _impl_.filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression&>(::substrait::_Expression_default_instance_);
}
inline const ::substrait::Expression& ReadRel::filter() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ReadRel.filter)
  return _internal_filter();
}
inline void ReadRel::unsafe_arena_set_allocated_filter(::substrait::Expression* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.filter_);
  }
  _impl_.filter_ = reinterpret_cast<::substrait::Expression*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ReadRel.filter)
}
inline ::substrait::Expression* ReadRel::release_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::substrait::Expression* released = _impl_.filter_;
  _impl_.filter_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Expression* ReadRel::unsafe_arena_release_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.ReadRel.filter)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::substrait::Expression* temp = _impl_.filter_;
  _impl_.filter_ = nullptr;
  return temp;
}
inline ::substrait::Expression* ReadRel::_internal_mutable_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.filter_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Expression>(GetArena());
    _impl_.filter_ = reinterpret_cast<::substrait::Expression*>(p);
  }
  return _impl_.filter_;
}
inline ::substrait::Expression* ReadRel::mutable_filter() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::substrait::Expression* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.filter)
  return _msg;
}
inline void ReadRel::set_allocated_filter(::substrait::Expression* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.filter_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.filter_ = reinterpret_cast<::substrait::Expression*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.ReadRel.filter)
}

// .substrait.Expression best_effort_filter = 11;
inline bool ReadRel::has_best_effort_filter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.best_effort_filter_ != nullptr);
  return value;
}
inline void ReadRel::clear_best_effort_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.best_effort_filter_ != nullptr) _impl_.best_effort_filter_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::substrait::Expression& ReadRel::_internal_best_effort_filter() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Expression* p = _impl_.best_effort_filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression&>(::substrait::_Expression_default_instance_);
}
inline const ::substrait::Expression& ReadRel::best_effort_filter() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ReadRel.best_effort_filter)
  return _internal_best_effort_filter();
}
inline void ReadRel::unsafe_arena_set_allocated_best_effort_filter(::substrait::Expression* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.best_effort_filter_);
  }
  _impl_.best_effort_filter_ = reinterpret_cast<::substrait::Expression*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ReadRel.best_effort_filter)
}
inline ::substrait::Expression* ReadRel::release_best_effort_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::substrait::Expression* released = _impl_.best_effort_filter_;
  _impl_.best_effort_filter_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Expression* ReadRel::unsafe_arena_release_best_effort_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.ReadRel.best_effort_filter)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::substrait::Expression* temp = _impl_.best_effort_filter_;
  _impl_.best_effort_filter_ = nullptr;
  return temp;
}
inline ::substrait::Expression* ReadRel::_internal_mutable_best_effort_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.best_effort_filter_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Expression>(GetArena());
    _impl_.best_effort_filter_ = reinterpret_cast<::substrait::Expression*>(p);
  }
  return _impl_.best_effort_filter_;
}
inline ::substrait::Expression* ReadRel::mutable_best_effort_filter() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000020u;
  ::substrait::Expression* _msg = _internal_mutable_best_effort_filter();
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.best_effort_filter)
  return _msg;
}
inline void ReadRel::set_allocated_best_effort_filter(::substrait::Expression* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.best_effort_filter_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.best_effort_filter_ = reinterpret_cast<::substrait::Expression*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.ReadRel.best_effort_filter)
}

// .substrait.Expression.MaskExpression projection = 4;
inline bool ReadRel::has_projection() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.projection_ != nullptr);
  return value;
}
inline void ReadRel::clear_projection() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.projection_ != nullptr) _impl_.projection_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::substrait::Expression_MaskExpression& ReadRel::_internal_projection() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Expression_MaskExpression* p = _impl_.projection_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression_MaskExpression&>(::substrait::_Expression_MaskExpression_default_instance_);
}
inline const ::substrait::Expression_MaskExpression& ReadRel::projection() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ReadRel.projection)
  return _internal_projection();
}
inline void ReadRel::unsafe_arena_set_allocated_projection(::substrait::Expression_MaskExpression* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.projection_);
  }
  _impl_.projection_ = reinterpret_cast<::substrait::Expression_MaskExpression*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ReadRel.projection)
}
inline ::substrait::Expression_MaskExpression* ReadRel::release_projection() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::substrait::Expression_MaskExpression* released = _impl_.projection_;
  _impl_.projection_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Expression_MaskExpression* ReadRel::unsafe_arena_release_projection() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.ReadRel.projection)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::substrait::Expression_MaskExpression* temp = _impl_.projection_;
  _impl_.projection_ = nullptr;
  return temp;
}
inline ::substrait::Expression_MaskExpression* ReadRel::_internal_mutable_projection() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.projection_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_MaskExpression>(GetArena());
    _impl_.projection_ = reinterpret_cast<::substrait::Expression_MaskExpression*>(p);
  }
  return _impl_.projection_;
}
inline ::substrait::Expression_MaskExpression* ReadRel::mutable_projection() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::substrait::Expression_MaskExpression* _msg = _internal_mutable_projection();
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.projection)
  return _msg;
}
inline void ReadRel::set_allocated_projection(::substrait::Expression_MaskExpression* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.projection_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.projection_ = reinterpret_cast<::substrait::Expression_MaskExpression*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.ReadRel.projection)
}

// .substrait.extensions.AdvancedExtension advanced_extension = 10;
inline bool ReadRel::has_advanced_extension() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.advanced_extension_ != nullptr);
  return value;
}
inline const ::substrait::extensions::AdvancedExtension& ReadRel::_internal_advanced_extension() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::extensions::AdvancedExtension* p = _impl_.advanced_extension_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::extensions::AdvancedExtension&>(::substrait::extensions::_AdvancedExtension_default_instance_);
}
inline const ::substrait::extensions::AdvancedExtension& ReadRel::advanced_extension() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ReadRel.advanced_extension)
  return _internal_advanced_extension();
}
inline void ReadRel::unsafe_arena_set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.advanced_extension_);
  }
  _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ReadRel.advanced_extension)
}
inline ::substrait::extensions::AdvancedExtension* ReadRel::release_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::substrait::extensions::AdvancedExtension* released = _impl_.advanced_extension_;
  _impl_.advanced_extension_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::extensions::AdvancedExtension* ReadRel::unsafe_arena_release_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.ReadRel.advanced_extension)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::substrait::extensions::AdvancedExtension* temp = _impl_.advanced_extension_;
  _impl_.advanced_extension_ = nullptr;
  return temp;
}
inline ::substrait::extensions::AdvancedExtension* ReadRel::_internal_mutable_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.advanced_extension_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::extensions::AdvancedExtension>(GetArena());
    _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(p);
  }
  return _impl_.advanced_extension_;
}
inline ::substrait::extensions::AdvancedExtension* ReadRel::mutable_advanced_extension() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::substrait::extensions::AdvancedExtension* _msg = _internal_mutable_advanced_extension();
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.advanced_extension)
  return _msg;
}
inline void ReadRel::set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.advanced_extension_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.ReadRel.advanced_extension)
}

// .substrait.ReadRel.VirtualTable virtual_table = 5;
inline bool ReadRel::has_virtual_table() const {
  return read_type_case() == kVirtualTable;
}
inline bool ReadRel::_internal_has_virtual_table() const {
  return read_type_case() == kVirtualTable;
}
inline void ReadRel::set_has_virtual_table() {
  _impl_._oneof_case_[0] = kVirtualTable;
}
inline void ReadRel::clear_virtual_table() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (read_type_case() == kVirtualTable) {
    if (GetArena() == nullptr) {
      delete _impl_.read_type_.virtual_table_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.read_type_.virtual_table_);
    }
    clear_has_read_type();
  }
}
inline ::substrait::ReadRel_VirtualTable* ReadRel::release_virtual_table() {
  // @@protoc_insertion_point(field_release:substrait.ReadRel.virtual_table)
  if (read_type_case() == kVirtualTable) {
    clear_has_read_type();
    auto* temp = _impl_.read_type_.virtual_table_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.read_type_.virtual_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::ReadRel_VirtualTable& ReadRel::_internal_virtual_table() const {
  return read_type_case() == kVirtualTable ? *_impl_.read_type_.virtual_table_ : reinterpret_cast<::substrait::ReadRel_VirtualTable&>(::substrait::_ReadRel_VirtualTable_default_instance_);
}
inline const ::substrait::ReadRel_VirtualTable& ReadRel::virtual_table() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ReadRel.virtual_table)
  return _internal_virtual_table();
}
inline ::substrait::ReadRel_VirtualTable* ReadRel::unsafe_arena_release_virtual_table() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.ReadRel.virtual_table)
  if (read_type_case() == kVirtualTable) {
    clear_has_read_type();
    auto* temp = _impl_.read_type_.virtual_table_;
    _impl_.read_type_.virtual_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ReadRel::unsafe_arena_set_allocated_virtual_table(::substrait::ReadRel_VirtualTable* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_read_type();
  if (value) {
    set_has_virtual_table();
    _impl_.read_type_.virtual_table_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ReadRel.virtual_table)
}
inline ::substrait::ReadRel_VirtualTable* ReadRel::_internal_mutable_virtual_table() {
  if (read_type_case() != kVirtualTable) {
    clear_read_type();
    set_has_virtual_table();
    _impl_.read_type_.virtual_table_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::ReadRel_VirtualTable>(GetArena());
  }
  return _impl_.read_type_.virtual_table_;
}
inline ::substrait::ReadRel_VirtualTable* ReadRel::mutable_virtual_table() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::ReadRel_VirtualTable* _msg = _internal_mutable_virtual_table();
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.virtual_table)
  return _msg;
}

// .substrait.ReadRel.LocalFiles local_files = 6;
inline bool ReadRel::has_local_files() const {
  return read_type_case() == kLocalFiles;
}
inline bool ReadRel::_internal_has_local_files() const {
  return read_type_case() == kLocalFiles;
}
inline void ReadRel::set_has_local_files() {
  _impl_._oneof_case_[0] = kLocalFiles;
}
inline void ReadRel::clear_local_files() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (read_type_case() == kLocalFiles) {
    if (GetArena() == nullptr) {
      delete _impl_.read_type_.local_files_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.read_type_.local_files_);
    }
    clear_has_read_type();
  }
}
inline ::substrait::ReadRel_LocalFiles* ReadRel::release_local_files() {
  // @@protoc_insertion_point(field_release:substrait.ReadRel.local_files)
  if (read_type_case() == kLocalFiles) {
    clear_has_read_type();
    auto* temp = _impl_.read_type_.local_files_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.read_type_.local_files_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::ReadRel_LocalFiles& ReadRel::_internal_local_files() const {
  return read_type_case() == kLocalFiles ? *_impl_.read_type_.local_files_ : reinterpret_cast<::substrait::ReadRel_LocalFiles&>(::substrait::_ReadRel_LocalFiles_default_instance_);
}
inline const ::substrait::ReadRel_LocalFiles& ReadRel::local_files() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ReadRel.local_files)
  return _internal_local_files();
}
inline ::substrait::ReadRel_LocalFiles* ReadRel::unsafe_arena_release_local_files() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.ReadRel.local_files)
  if (read_type_case() == kLocalFiles) {
    clear_has_read_type();
    auto* temp = _impl_.read_type_.local_files_;
    _impl_.read_type_.local_files_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ReadRel::unsafe_arena_set_allocated_local_files(::substrait::ReadRel_LocalFiles* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_read_type();
  if (value) {
    set_has_local_files();
    _impl_.read_type_.local_files_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ReadRel.local_files)
}
inline ::substrait::ReadRel_LocalFiles* ReadRel::_internal_mutable_local_files() {
  if (read_type_case() != kLocalFiles) {
    clear_read_type();
    set_has_local_files();
    _impl_.read_type_.local_files_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::ReadRel_LocalFiles>(GetArena());
  }
  return _impl_.read_type_.local_files_;
}
inline ::substrait::ReadRel_LocalFiles* ReadRel::mutable_local_files() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::ReadRel_LocalFiles* _msg = _internal_mutable_local_files();
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.local_files)
  return _msg;
}

// .substrait.ReadRel.NamedTable named_table = 7;
inline bool ReadRel::has_named_table() const {
  return read_type_case() == kNamedTable;
}
inline bool ReadRel::_internal_has_named_table() const {
  return read_type_case() == kNamedTable;
}
inline void ReadRel::set_has_named_table() {
  _impl_._oneof_case_[0] = kNamedTable;
}
inline void ReadRel::clear_named_table() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (read_type_case() == kNamedTable) {
    if (GetArena() == nullptr) {
      delete _impl_.read_type_.named_table_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.read_type_.named_table_);
    }
    clear_has_read_type();
  }
}
inline ::substrait::ReadRel_NamedTable* ReadRel::release_named_table() {
  // @@protoc_insertion_point(field_release:substrait.ReadRel.named_table)
  if (read_type_case() == kNamedTable) {
    clear_has_read_type();
    auto* temp = _impl_.read_type_.named_table_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.read_type_.named_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::ReadRel_NamedTable& ReadRel::_internal_named_table() const {
  return read_type_case() == kNamedTable ? *_impl_.read_type_.named_table_ : reinterpret_cast<::substrait::ReadRel_NamedTable&>(::substrait::_ReadRel_NamedTable_default_instance_);
}
inline const ::substrait::ReadRel_NamedTable& ReadRel::named_table() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ReadRel.named_table)
  return _internal_named_table();
}
inline ::substrait::ReadRel_NamedTable* ReadRel::unsafe_arena_release_named_table() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.ReadRel.named_table)
  if (read_type_case() == kNamedTable) {
    clear_has_read_type();
    auto* temp = _impl_.read_type_.named_table_;
    _impl_.read_type_.named_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ReadRel::unsafe_arena_set_allocated_named_table(::substrait::ReadRel_NamedTable* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_read_type();
  if (value) {
    set_has_named_table();
    _impl_.read_type_.named_table_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ReadRel.named_table)
}
inline ::substrait::ReadRel_NamedTable* ReadRel::_internal_mutable_named_table() {
  if (read_type_case() != kNamedTable) {
    clear_read_type();
    set_has_named_table();
    _impl_.read_type_.named_table_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::ReadRel_NamedTable>(GetArena());
  }
  return _impl_.read_type_.named_table_;
}
inline ::substrait::ReadRel_NamedTable* ReadRel::mutable_named_table() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::ReadRel_NamedTable* _msg = _internal_mutable_named_table();
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.named_table)
  return _msg;
}

// .substrait.ReadRel.ExtensionTable extension_table = 8;
inline bool ReadRel::has_extension_table() const {
  return read_type_case() == kExtensionTable;
}
inline bool ReadRel::_internal_has_extension_table() const {
  return read_type_case() == kExtensionTable;
}
inline void ReadRel::set_has_extension_table() {
  _impl_._oneof_case_[0] = kExtensionTable;
}
inline void ReadRel::clear_extension_table() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (read_type_case() == kExtensionTable) {
    if (GetArena() == nullptr) {
      delete _impl_.read_type_.extension_table_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.read_type_.extension_table_);
    }
    clear_has_read_type();
  }
}
inline ::substrait::ReadRel_ExtensionTable* ReadRel::release_extension_table() {
  // @@protoc_insertion_point(field_release:substrait.ReadRel.extension_table)
  if (read_type_case() == kExtensionTable) {
    clear_has_read_type();
    auto* temp = _impl_.read_type_.extension_table_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.read_type_.extension_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::ReadRel_ExtensionTable& ReadRel::_internal_extension_table() const {
  return read_type_case() == kExtensionTable ? *_impl_.read_type_.extension_table_ : reinterpret_cast<::substrait::ReadRel_ExtensionTable&>(::substrait::_ReadRel_ExtensionTable_default_instance_);
}
inline const ::substrait::ReadRel_ExtensionTable& ReadRel::extension_table() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ReadRel.extension_table)
  return _internal_extension_table();
}
inline ::substrait::ReadRel_ExtensionTable* ReadRel::unsafe_arena_release_extension_table() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.ReadRel.extension_table)
  if (read_type_case() == kExtensionTable) {
    clear_has_read_type();
    auto* temp = _impl_.read_type_.extension_table_;
    _impl_.read_type_.extension_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ReadRel::unsafe_arena_set_allocated_extension_table(::substrait::ReadRel_ExtensionTable* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_read_type();
  if (value) {
    set_has_extension_table();
    _impl_.read_type_.extension_table_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ReadRel.extension_table)
}
inline ::substrait::ReadRel_ExtensionTable* ReadRel::_internal_mutable_extension_table() {
  if (read_type_case() != kExtensionTable) {
    clear_read_type();
    set_has_extension_table();
    _impl_.read_type_.extension_table_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::ReadRel_ExtensionTable>(GetArena());
  }
  return _impl_.read_type_.extension_table_;
}
inline ::substrait::ReadRel_ExtensionTable* ReadRel::mutable_extension_table() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::ReadRel_ExtensionTable* _msg = _internal_mutable_extension_table();
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.extension_table)
  return _msg;
}

inline bool ReadRel::has_read_type() const {
  return read_type_case() != READ_TYPE_NOT_SET;
}
inline void ReadRel::clear_has_read_type() {
  _impl_._oneof_case_[0] = READ_TYPE_NOT_SET;
}
inline ReadRel::ReadTypeCase ReadRel::read_type_case() const {
  return ReadRel::ReadTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ProjectRel

// .substrait.RelCommon common = 1;
inline bool ProjectRel::has_common() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.common_ != nullptr);
  return value;
}
inline void ProjectRel::clear_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.common_ != nullptr) _impl_.common_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::RelCommon& ProjectRel::_internal_common() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::RelCommon* p = _impl_.common_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::RelCommon&>(::substrait::_RelCommon_default_instance_);
}
inline const ::substrait::RelCommon& ProjectRel::common() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ProjectRel.common)
  return _internal_common();
}
inline void ProjectRel::unsafe_arena_set_allocated_common(::substrait::RelCommon* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.common_);
  }
  _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ProjectRel.common)
}
inline ::substrait::RelCommon* ProjectRel::release_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::RelCommon* released = _impl_.common_;
  _impl_.common_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::RelCommon* ProjectRel::unsafe_arena_release_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.ProjectRel.common)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::RelCommon* temp = _impl_.common_;
  _impl_.common_ = nullptr;
  return temp;
}
inline ::substrait::RelCommon* ProjectRel::_internal_mutable_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.common_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::RelCommon>(GetArena());
    _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(p);
  }
  return _impl_.common_;
}
inline ::substrait::RelCommon* ProjectRel::mutable_common() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::RelCommon* _msg = _internal_mutable_common();
  // @@protoc_insertion_point(field_mutable:substrait.ProjectRel.common)
  return _msg;
}
inline void ProjectRel::set_allocated_common(::substrait::RelCommon* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.common_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.ProjectRel.common)
}

// .substrait.Rel input = 2;
inline bool ProjectRel::has_input() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.input_ != nullptr);
  return value;
}
inline void ProjectRel::clear_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.input_ != nullptr) _impl_.input_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::substrait::Rel& ProjectRel::_internal_input() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Rel* p = _impl_.input_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Rel&>(::substrait::_Rel_default_instance_);
}
inline const ::substrait::Rel& ProjectRel::input() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ProjectRel.input)
  return _internal_input();
}
inline void ProjectRel::unsafe_arena_set_allocated_input(::substrait::Rel* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.input_);
  }
  _impl_.input_ = reinterpret_cast<::substrait::Rel*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ProjectRel.input)
}
inline ::substrait::Rel* ProjectRel::release_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Rel* released = _impl_.input_;
  _impl_.input_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Rel* ProjectRel::unsafe_arena_release_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.ProjectRel.input)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Rel* temp = _impl_.input_;
  _impl_.input_ = nullptr;
  return temp;
}
inline ::substrait::Rel* ProjectRel::_internal_mutable_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.input_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Rel>(GetArena());
    _impl_.input_ = reinterpret_cast<::substrait::Rel*>(p);
  }
  return _impl_.input_;
}
inline ::substrait::Rel* ProjectRel::mutable_input() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::substrait::Rel* _msg = _internal_mutable_input();
  // @@protoc_insertion_point(field_mutable:substrait.ProjectRel.input)
  return _msg;
}
inline void ProjectRel::set_allocated_input(::substrait::Rel* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.input_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.input_ = reinterpret_cast<::substrait::Rel*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.ProjectRel.input)
}

// repeated .substrait.Expression expressions = 3;
inline int ProjectRel::_internal_expressions_size() const {
  return _internal_expressions().size();
}
inline int ProjectRel::expressions_size() const {
  return _internal_expressions_size();
}
inline void ProjectRel::clear_expressions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expressions_.Clear();
}
inline ::substrait::Expression* ProjectRel::mutable_expressions(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.ProjectRel.expressions)
  return _internal_mutable_expressions()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression>* ProjectRel::mutable_expressions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.ProjectRel.expressions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_expressions();
}
inline const ::substrait::Expression& ProjectRel::expressions(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ProjectRel.expressions)
  return _internal_expressions().Get(index);
}
inline ::substrait::Expression* ProjectRel::add_expressions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::Expression* _add = _internal_mutable_expressions()->Add();
  // @@protoc_insertion_point(field_add:substrait.ProjectRel.expressions)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression>& ProjectRel::expressions() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.ProjectRel.expressions)
  return _internal_expressions();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression>&
ProjectRel::_internal_expressions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.expressions_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression>*
ProjectRel::_internal_mutable_expressions() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.expressions_;
}

// .substrait.extensions.AdvancedExtension advanced_extension = 10;
inline bool ProjectRel::has_advanced_extension() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.advanced_extension_ != nullptr);
  return value;
}
inline const ::substrait::extensions::AdvancedExtension& ProjectRel::_internal_advanced_extension() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::extensions::AdvancedExtension* p = _impl_.advanced_extension_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::extensions::AdvancedExtension&>(::substrait::extensions::_AdvancedExtension_default_instance_);
}
inline const ::substrait::extensions::AdvancedExtension& ProjectRel::advanced_extension() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ProjectRel.advanced_extension)
  return _internal_advanced_extension();
}
inline void ProjectRel::unsafe_arena_set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.advanced_extension_);
  }
  _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ProjectRel.advanced_extension)
}
inline ::substrait::extensions::AdvancedExtension* ProjectRel::release_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::substrait::extensions::AdvancedExtension* released = _impl_.advanced_extension_;
  _impl_.advanced_extension_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::extensions::AdvancedExtension* ProjectRel::unsafe_arena_release_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.ProjectRel.advanced_extension)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::substrait::extensions::AdvancedExtension* temp = _impl_.advanced_extension_;
  _impl_.advanced_extension_ = nullptr;
  return temp;
}
inline ::substrait::extensions::AdvancedExtension* ProjectRel::_internal_mutable_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.advanced_extension_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::extensions::AdvancedExtension>(GetArena());
    _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(p);
  }
  return _impl_.advanced_extension_;
}
inline ::substrait::extensions::AdvancedExtension* ProjectRel::mutable_advanced_extension() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::substrait::extensions::AdvancedExtension* _msg = _internal_mutable_advanced_extension();
  // @@protoc_insertion_point(field_mutable:substrait.ProjectRel.advanced_extension)
  return _msg;
}
inline void ProjectRel::set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.advanced_extension_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.ProjectRel.advanced_extension)
}

// -------------------------------------------------------------------

// JoinRel

// .substrait.RelCommon common = 1;
inline bool JoinRel::has_common() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.common_ != nullptr);
  return value;
}
inline void JoinRel::clear_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.common_ != nullptr) _impl_.common_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::RelCommon& JoinRel::_internal_common() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::RelCommon* p = _impl_.common_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::RelCommon&>(::substrait::_RelCommon_default_instance_);
}
inline const ::substrait::RelCommon& JoinRel::common() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.JoinRel.common)
  return _internal_common();
}
inline void JoinRel::unsafe_arena_set_allocated_common(::substrait::RelCommon* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.common_);
  }
  _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.JoinRel.common)
}
inline ::substrait::RelCommon* JoinRel::release_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::RelCommon* released = _impl_.common_;
  _impl_.common_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::RelCommon* JoinRel::unsafe_arena_release_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.JoinRel.common)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::RelCommon* temp = _impl_.common_;
  _impl_.common_ = nullptr;
  return temp;
}
inline ::substrait::RelCommon* JoinRel::_internal_mutable_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.common_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::RelCommon>(GetArena());
    _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(p);
  }
  return _impl_.common_;
}
inline ::substrait::RelCommon* JoinRel::mutable_common() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::RelCommon* _msg = _internal_mutable_common();
  // @@protoc_insertion_point(field_mutable:substrait.JoinRel.common)
  return _msg;
}
inline void JoinRel::set_allocated_common(::substrait::RelCommon* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.common_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.JoinRel.common)
}

// .substrait.Rel left = 2;
inline bool JoinRel::has_left() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.left_ != nullptr);
  return value;
}
inline void JoinRel::clear_left() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.left_ != nullptr) _impl_.left_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::substrait::Rel& JoinRel::_internal_left() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Rel* p = _impl_.left_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Rel&>(::substrait::_Rel_default_instance_);
}
inline const ::substrait::Rel& JoinRel::left() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.JoinRel.left)
  return _internal_left();
}
inline void JoinRel::unsafe_arena_set_allocated_left(::substrait::Rel* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.left_);
  }
  _impl_.left_ = reinterpret_cast<::substrait::Rel*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.JoinRel.left)
}
inline ::substrait::Rel* JoinRel::release_left() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Rel* released = _impl_.left_;
  _impl_.left_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Rel* JoinRel::unsafe_arena_release_left() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.JoinRel.left)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Rel* temp = _impl_.left_;
  _impl_.left_ = nullptr;
  return temp;
}
inline ::substrait::Rel* JoinRel::_internal_mutable_left() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.left_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Rel>(GetArena());
    _impl_.left_ = reinterpret_cast<::substrait::Rel*>(p);
  }
  return _impl_.left_;
}
inline ::substrait::Rel* JoinRel::mutable_left() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::substrait::Rel* _msg = _internal_mutable_left();
  // @@protoc_insertion_point(field_mutable:substrait.JoinRel.left)
  return _msg;
}
inline void JoinRel::set_allocated_left(::substrait::Rel* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.left_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.left_ = reinterpret_cast<::substrait::Rel*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.JoinRel.left)
}

// .substrait.Rel right = 3;
inline bool JoinRel::has_right() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.right_ != nullptr);
  return value;
}
inline void JoinRel::clear_right() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.right_ != nullptr) _impl_.right_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::substrait::Rel& JoinRel::_internal_right() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Rel* p = _impl_.right_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Rel&>(::substrait::_Rel_default_instance_);
}
inline const ::substrait::Rel& JoinRel::right() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.JoinRel.right)
  return _internal_right();
}
inline void JoinRel::unsafe_arena_set_allocated_right(::substrait::Rel* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.right_);
  }
  _impl_.right_ = reinterpret_cast<::substrait::Rel*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.JoinRel.right)
}
inline ::substrait::Rel* JoinRel::release_right() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::substrait::Rel* released = _impl_.right_;
  _impl_.right_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Rel* JoinRel::unsafe_arena_release_right() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.JoinRel.right)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::substrait::Rel* temp = _impl_.right_;
  _impl_.right_ = nullptr;
  return temp;
}
inline ::substrait::Rel* JoinRel::_internal_mutable_right() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.right_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Rel>(GetArena());
    _impl_.right_ = reinterpret_cast<::substrait::Rel*>(p);
  }
  return _impl_.right_;
}
inline ::substrait::Rel* JoinRel::mutable_right() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::substrait::Rel* _msg = _internal_mutable_right();
  // @@protoc_insertion_point(field_mutable:substrait.JoinRel.right)
  return _msg;
}
inline void JoinRel::set_allocated_right(::substrait::Rel* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.right_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.right_ = reinterpret_cast<::substrait::Rel*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.JoinRel.right)
}

// .substrait.Expression expression = 4;
inline bool JoinRel::has_expression() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.expression_ != nullptr);
  return value;
}
inline void JoinRel::clear_expression() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.expression_ != nullptr) _impl_.expression_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::substrait::Expression& JoinRel::_internal_expression() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Expression* p = _impl_.expression_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression&>(::substrait::_Expression_default_instance_);
}
inline const ::substrait::Expression& JoinRel::expression() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.JoinRel.expression)
  return _internal_expression();
}
inline void JoinRel::unsafe_arena_set_allocated_expression(::substrait::Expression* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.expression_);
  }
  _impl_.expression_ = reinterpret_cast<::substrait::Expression*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.JoinRel.expression)
}
inline ::substrait::Expression* JoinRel::release_expression() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::substrait::Expression* released = _impl_.expression_;
  _impl_.expression_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Expression* JoinRel::unsafe_arena_release_expression() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.JoinRel.expression)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::substrait::Expression* temp = _impl_.expression_;
  _impl_.expression_ = nullptr;
  return temp;
}
inline ::substrait::Expression* JoinRel::_internal_mutable_expression() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.expression_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Expression>(GetArena());
    _impl_.expression_ = reinterpret_cast<::substrait::Expression*>(p);
  }
  return _impl_.expression_;
}
inline ::substrait::Expression* JoinRel::mutable_expression() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::substrait::Expression* _msg = _internal_mutable_expression();
  // @@protoc_insertion_point(field_mutable:substrait.JoinRel.expression)
  return _msg;
}
inline void JoinRel::set_allocated_expression(::substrait::Expression* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.expression_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.expression_ = reinterpret_cast<::substrait::Expression*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.JoinRel.expression)
}

// .substrait.Expression post_join_filter = 5;
inline bool JoinRel::has_post_join_filter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.post_join_filter_ != nullptr);
  return value;
}
inline void JoinRel::clear_post_join_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.post_join_filter_ != nullptr) _impl_.post_join_filter_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::substrait::Expression& JoinRel::_internal_post_join_filter() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Expression* p = _impl_.post_join_filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression&>(::substrait::_Expression_default_instance_);
}
inline const ::substrait::Expression& JoinRel::post_join_filter() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.JoinRel.post_join_filter)
  return _internal_post_join_filter();
}
inline void JoinRel::unsafe_arena_set_allocated_post_join_filter(::substrait::Expression* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.post_join_filter_);
  }
  _impl_.post_join_filter_ = reinterpret_cast<::substrait::Expression*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.JoinRel.post_join_filter)
}
inline ::substrait::Expression* JoinRel::release_post_join_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::substrait::Expression* released = _impl_.post_join_filter_;
  _impl_.post_join_filter_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Expression* JoinRel::unsafe_arena_release_post_join_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.JoinRel.post_join_filter)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::substrait::Expression* temp = _impl_.post_join_filter_;
  _impl_.post_join_filter_ = nullptr;
  return temp;
}
inline ::substrait::Expression* JoinRel::_internal_mutable_post_join_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.post_join_filter_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Expression>(GetArena());
    _impl_.post_join_filter_ = reinterpret_cast<::substrait::Expression*>(p);
  }
  return _impl_.post_join_filter_;
}
inline ::substrait::Expression* JoinRel::mutable_post_join_filter() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::substrait::Expression* _msg = _internal_mutable_post_join_filter();
  // @@protoc_insertion_point(field_mutable:substrait.JoinRel.post_join_filter)
  return _msg;
}
inline void JoinRel::set_allocated_post_join_filter(::substrait::Expression* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.post_join_filter_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.post_join_filter_ = reinterpret_cast<::substrait::Expression*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.JoinRel.post_join_filter)
}

// .substrait.JoinRel.JoinType type = 6;
inline void JoinRel::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::substrait::JoinRel_JoinType JoinRel::type() const {
  // @@protoc_insertion_point(field_get:substrait.JoinRel.type)
  return _internal_type();
}
inline void JoinRel::set_type(::substrait::JoinRel_JoinType value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:substrait.JoinRel.type)
}
inline ::substrait::JoinRel_JoinType JoinRel::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::substrait::JoinRel_JoinType>(_impl_.type_);
}
inline void JoinRel::_internal_set_type(::substrait::JoinRel_JoinType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// .substrait.extensions.AdvancedExtension advanced_extension = 10;
inline bool JoinRel::has_advanced_extension() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.advanced_extension_ != nullptr);
  return value;
}
inline const ::substrait::extensions::AdvancedExtension& JoinRel::_internal_advanced_extension() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::extensions::AdvancedExtension* p = _impl_.advanced_extension_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::extensions::AdvancedExtension&>(::substrait::extensions::_AdvancedExtension_default_instance_);
}
inline const ::substrait::extensions::AdvancedExtension& JoinRel::advanced_extension() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.JoinRel.advanced_extension)
  return _internal_advanced_extension();
}
inline void JoinRel::unsafe_arena_set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.advanced_extension_);
  }
  _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.JoinRel.advanced_extension)
}
inline ::substrait::extensions::AdvancedExtension* JoinRel::release_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::substrait::extensions::AdvancedExtension* released = _impl_.advanced_extension_;
  _impl_.advanced_extension_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::extensions::AdvancedExtension* JoinRel::unsafe_arena_release_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.JoinRel.advanced_extension)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::substrait::extensions::AdvancedExtension* temp = _impl_.advanced_extension_;
  _impl_.advanced_extension_ = nullptr;
  return temp;
}
inline ::substrait::extensions::AdvancedExtension* JoinRel::_internal_mutable_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.advanced_extension_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::extensions::AdvancedExtension>(GetArena());
    _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(p);
  }
  return _impl_.advanced_extension_;
}
inline ::substrait::extensions::AdvancedExtension* JoinRel::mutable_advanced_extension() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000020u;
  ::substrait::extensions::AdvancedExtension* _msg = _internal_mutable_advanced_extension();
  // @@protoc_insertion_point(field_mutable:substrait.JoinRel.advanced_extension)
  return _msg;
}
inline void JoinRel::set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.advanced_extension_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.JoinRel.advanced_extension)
}

// -------------------------------------------------------------------

// CrossRel

// .substrait.RelCommon common = 1;
inline bool CrossRel::has_common() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.common_ != nullptr);
  return value;
}
inline void CrossRel::clear_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.common_ != nullptr) _impl_.common_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::RelCommon& CrossRel::_internal_common() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::RelCommon* p = _impl_.common_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::RelCommon&>(::substrait::_RelCommon_default_instance_);
}
inline const ::substrait::RelCommon& CrossRel::common() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.CrossRel.common)
  return _internal_common();
}
inline void CrossRel::unsafe_arena_set_allocated_common(::substrait::RelCommon* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.common_);
  }
  _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.CrossRel.common)
}
inline ::substrait::RelCommon* CrossRel::release_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::RelCommon* released = _impl_.common_;
  _impl_.common_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::RelCommon* CrossRel::unsafe_arena_release_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.CrossRel.common)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::RelCommon* temp = _impl_.common_;
  _impl_.common_ = nullptr;
  return temp;
}
inline ::substrait::RelCommon* CrossRel::_internal_mutable_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.common_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::RelCommon>(GetArena());
    _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(p);
  }
  return _impl_.common_;
}
inline ::substrait::RelCommon* CrossRel::mutable_common() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::RelCommon* _msg = _internal_mutable_common();
  // @@protoc_insertion_point(field_mutable:substrait.CrossRel.common)
  return _msg;
}
inline void CrossRel::set_allocated_common(::substrait::RelCommon* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.common_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.CrossRel.common)
}

// .substrait.Rel left = 2;
inline bool CrossRel::has_left() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.left_ != nullptr);
  return value;
}
inline void CrossRel::clear_left() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.left_ != nullptr) _impl_.left_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::substrait::Rel& CrossRel::_internal_left() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Rel* p = _impl_.left_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Rel&>(::substrait::_Rel_default_instance_);
}
inline const ::substrait::Rel& CrossRel::left() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.CrossRel.left)
  return _internal_left();
}
inline void CrossRel::unsafe_arena_set_allocated_left(::substrait::Rel* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.left_);
  }
  _impl_.left_ = reinterpret_cast<::substrait::Rel*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.CrossRel.left)
}
inline ::substrait::Rel* CrossRel::release_left() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Rel* released = _impl_.left_;
  _impl_.left_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Rel* CrossRel::unsafe_arena_release_left() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.CrossRel.left)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Rel* temp = _impl_.left_;
  _impl_.left_ = nullptr;
  return temp;
}
inline ::substrait::Rel* CrossRel::_internal_mutable_left() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.left_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Rel>(GetArena());
    _impl_.left_ = reinterpret_cast<::substrait::Rel*>(p);
  }
  return _impl_.left_;
}
inline ::substrait::Rel* CrossRel::mutable_left() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::substrait::Rel* _msg = _internal_mutable_left();
  // @@protoc_insertion_point(field_mutable:substrait.CrossRel.left)
  return _msg;
}
inline void CrossRel::set_allocated_left(::substrait::Rel* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.left_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.left_ = reinterpret_cast<::substrait::Rel*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.CrossRel.left)
}

// .substrait.Rel right = 3;
inline bool CrossRel::has_right() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.right_ != nullptr);
  return value;
}
inline void CrossRel::clear_right() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.right_ != nullptr) _impl_.right_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::substrait::Rel& CrossRel::_internal_right() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Rel* p = _impl_.right_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Rel&>(::substrait::_Rel_default_instance_);
}
inline const ::substrait::Rel& CrossRel::right() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.CrossRel.right)
  return _internal_right();
}
inline void CrossRel::unsafe_arena_set_allocated_right(::substrait::Rel* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.right_);
  }
  _impl_.right_ = reinterpret_cast<::substrait::Rel*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.CrossRel.right)
}
inline ::substrait::Rel* CrossRel::release_right() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::substrait::Rel* released = _impl_.right_;
  _impl_.right_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Rel* CrossRel::unsafe_arena_release_right() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.CrossRel.right)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::substrait::Rel* temp = _impl_.right_;
  _impl_.right_ = nullptr;
  return temp;
}
inline ::substrait::Rel* CrossRel::_internal_mutable_right() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.right_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Rel>(GetArena());
    _impl_.right_ = reinterpret_cast<::substrait::Rel*>(p);
  }
  return _impl_.right_;
}
inline ::substrait::Rel* CrossRel::mutable_right() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::substrait::Rel* _msg = _internal_mutable_right();
  // @@protoc_insertion_point(field_mutable:substrait.CrossRel.right)
  return _msg;
}
inline void CrossRel::set_allocated_right(::substrait::Rel* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.right_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.right_ = reinterpret_cast<::substrait::Rel*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.CrossRel.right)
}

// .substrait.extensions.AdvancedExtension advanced_extension = 10;
inline bool CrossRel::has_advanced_extension() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.advanced_extension_ != nullptr);
  return value;
}
inline const ::substrait::extensions::AdvancedExtension& CrossRel::_internal_advanced_extension() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::extensions::AdvancedExtension* p = _impl_.advanced_extension_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::extensions::AdvancedExtension&>(::substrait::extensions::_AdvancedExtension_default_instance_);
}
inline const ::substrait::extensions::AdvancedExtension& CrossRel::advanced_extension() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.CrossRel.advanced_extension)
  return _internal_advanced_extension();
}
inline void CrossRel::unsafe_arena_set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.advanced_extension_);
  }
  _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.CrossRel.advanced_extension)
}
inline ::substrait::extensions::AdvancedExtension* CrossRel::release_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::substrait::extensions::AdvancedExtension* released = _impl_.advanced_extension_;
  _impl_.advanced_extension_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::extensions::AdvancedExtension* CrossRel::unsafe_arena_release_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.CrossRel.advanced_extension)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::substrait::extensions::AdvancedExtension* temp = _impl_.advanced_extension_;
  _impl_.advanced_extension_ = nullptr;
  return temp;
}
inline ::substrait::extensions::AdvancedExtension* CrossRel::_internal_mutable_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.advanced_extension_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::extensions::AdvancedExtension>(GetArena());
    _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(p);
  }
  return _impl_.advanced_extension_;
}
inline ::substrait::extensions::AdvancedExtension* CrossRel::mutable_advanced_extension() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::substrait::extensions::AdvancedExtension* _msg = _internal_mutable_advanced_extension();
  // @@protoc_insertion_point(field_mutable:substrait.CrossRel.advanced_extension)
  return _msg;
}
inline void CrossRel::set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.advanced_extension_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.CrossRel.advanced_extension)
}

// -------------------------------------------------------------------

// FetchRel

// .substrait.RelCommon common = 1;
inline bool FetchRel::has_common() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.common_ != nullptr);
  return value;
}
inline void FetchRel::clear_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.common_ != nullptr) _impl_.common_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::RelCommon& FetchRel::_internal_common() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::RelCommon* p = _impl_.common_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::RelCommon&>(::substrait::_RelCommon_default_instance_);
}
inline const ::substrait::RelCommon& FetchRel::common() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.FetchRel.common)
  return _internal_common();
}
inline void FetchRel::unsafe_arena_set_allocated_common(::substrait::RelCommon* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.common_);
  }
  _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.FetchRel.common)
}
inline ::substrait::RelCommon* FetchRel::release_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::RelCommon* released = _impl_.common_;
  _impl_.common_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::RelCommon* FetchRel::unsafe_arena_release_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.FetchRel.common)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::RelCommon* temp = _impl_.common_;
  _impl_.common_ = nullptr;
  return temp;
}
inline ::substrait::RelCommon* FetchRel::_internal_mutable_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.common_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::RelCommon>(GetArena());
    _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(p);
  }
  return _impl_.common_;
}
inline ::substrait::RelCommon* FetchRel::mutable_common() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::RelCommon* _msg = _internal_mutable_common();
  // @@protoc_insertion_point(field_mutable:substrait.FetchRel.common)
  return _msg;
}
inline void FetchRel::set_allocated_common(::substrait::RelCommon* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.common_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.FetchRel.common)
}

// .substrait.Rel input = 2;
inline bool FetchRel::has_input() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.input_ != nullptr);
  return value;
}
inline void FetchRel::clear_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.input_ != nullptr) _impl_.input_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::substrait::Rel& FetchRel::_internal_input() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Rel* p = _impl_.input_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Rel&>(::substrait::_Rel_default_instance_);
}
inline const ::substrait::Rel& FetchRel::input() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.FetchRel.input)
  return _internal_input();
}
inline void FetchRel::unsafe_arena_set_allocated_input(::substrait::Rel* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.input_);
  }
  _impl_.input_ = reinterpret_cast<::substrait::Rel*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.FetchRel.input)
}
inline ::substrait::Rel* FetchRel::release_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Rel* released = _impl_.input_;
  _impl_.input_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Rel* FetchRel::unsafe_arena_release_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.FetchRel.input)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Rel* temp = _impl_.input_;
  _impl_.input_ = nullptr;
  return temp;
}
inline ::substrait::Rel* FetchRel::_internal_mutable_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.input_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Rel>(GetArena());
    _impl_.input_ = reinterpret_cast<::substrait::Rel*>(p);
  }
  return _impl_.input_;
}
inline ::substrait::Rel* FetchRel::mutable_input() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::substrait::Rel* _msg = _internal_mutable_input();
  // @@protoc_insertion_point(field_mutable:substrait.FetchRel.input)
  return _msg;
}
inline void FetchRel::set_allocated_input(::substrait::Rel* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.input_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.input_ = reinterpret_cast<::substrait::Rel*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.FetchRel.input)
}

// int64 offset = 3;
inline void FetchRel::clear_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.offset_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int64_t FetchRel::offset() const {
  // @@protoc_insertion_point(field_get:substrait.FetchRel.offset)
  return _internal_offset();
}
inline void FetchRel::set_offset(::int64_t value) {
  _internal_set_offset(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:substrait.FetchRel.offset)
}
inline ::int64_t FetchRel::_internal_offset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.offset_;
}
inline void FetchRel::_internal_set_offset(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.offset_ = value;
}

// int64 count = 4;
inline void FetchRel::clear_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.count_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int64_t FetchRel::count() const {
  // @@protoc_insertion_point(field_get:substrait.FetchRel.count)
  return _internal_count();
}
inline void FetchRel::set_count(::int64_t value) {
  _internal_set_count(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:substrait.FetchRel.count)
}
inline ::int64_t FetchRel::_internal_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.count_;
}
inline void FetchRel::_internal_set_count(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.count_ = value;
}

// .substrait.extensions.AdvancedExtension advanced_extension = 10;
inline bool FetchRel::has_advanced_extension() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.advanced_extension_ != nullptr);
  return value;
}
inline const ::substrait::extensions::AdvancedExtension& FetchRel::_internal_advanced_extension() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::extensions::AdvancedExtension* p = _impl_.advanced_extension_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::extensions::AdvancedExtension&>(::substrait::extensions::_AdvancedExtension_default_instance_);
}
inline const ::substrait::extensions::AdvancedExtension& FetchRel::advanced_extension() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.FetchRel.advanced_extension)
  return _internal_advanced_extension();
}
inline void FetchRel::unsafe_arena_set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.advanced_extension_);
  }
  _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.FetchRel.advanced_extension)
}
inline ::substrait::extensions::AdvancedExtension* FetchRel::release_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::substrait::extensions::AdvancedExtension* released = _impl_.advanced_extension_;
  _impl_.advanced_extension_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::extensions::AdvancedExtension* FetchRel::unsafe_arena_release_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.FetchRel.advanced_extension)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::substrait::extensions::AdvancedExtension* temp = _impl_.advanced_extension_;
  _impl_.advanced_extension_ = nullptr;
  return temp;
}
inline ::substrait::extensions::AdvancedExtension* FetchRel::_internal_mutable_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.advanced_extension_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::extensions::AdvancedExtension>(GetArena());
    _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(p);
  }
  return _impl_.advanced_extension_;
}
inline ::substrait::extensions::AdvancedExtension* FetchRel::mutable_advanced_extension() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::substrait::extensions::AdvancedExtension* _msg = _internal_mutable_advanced_extension();
  // @@protoc_insertion_point(field_mutable:substrait.FetchRel.advanced_extension)
  return _msg;
}
inline void FetchRel::set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.advanced_extension_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.FetchRel.advanced_extension)
}

// -------------------------------------------------------------------

// AggregateRel_Grouping

// repeated .substrait.Expression grouping_expressions = 1;
inline int AggregateRel_Grouping::_internal_grouping_expressions_size() const {
  return _internal_grouping_expressions().size();
}
inline int AggregateRel_Grouping::grouping_expressions_size() const {
  return _internal_grouping_expressions_size();
}
inline void AggregateRel_Grouping::clear_grouping_expressions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.grouping_expressions_.Clear();
}
inline ::substrait::Expression* AggregateRel_Grouping::mutable_grouping_expressions(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.AggregateRel.Grouping.grouping_expressions)
  return _internal_mutable_grouping_expressions()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression>* AggregateRel_Grouping::mutable_grouping_expressions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.AggregateRel.Grouping.grouping_expressions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_grouping_expressions();
}
inline const ::substrait::Expression& AggregateRel_Grouping::grouping_expressions(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.AggregateRel.Grouping.grouping_expressions)
  return _internal_grouping_expressions().Get(index);
}
inline ::substrait::Expression* AggregateRel_Grouping::add_grouping_expressions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::Expression* _add = _internal_mutable_grouping_expressions()->Add();
  // @@protoc_insertion_point(field_add:substrait.AggregateRel.Grouping.grouping_expressions)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression>& AggregateRel_Grouping::grouping_expressions() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.AggregateRel.Grouping.grouping_expressions)
  return _internal_grouping_expressions();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression>&
AggregateRel_Grouping::_internal_grouping_expressions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.grouping_expressions_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression>*
AggregateRel_Grouping::_internal_mutable_grouping_expressions() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.grouping_expressions_;
}

// -------------------------------------------------------------------

// AggregateRel_Measure

// .substrait.AggregateFunction measure = 1;
inline bool AggregateRel_Measure::has_measure() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.measure_ != nullptr);
  return value;
}
inline void AggregateRel_Measure::clear_measure() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.measure_ != nullptr) _impl_.measure_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::AggregateFunction& AggregateRel_Measure::_internal_measure() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::AggregateFunction* p = _impl_.measure_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::AggregateFunction&>(::substrait::_AggregateFunction_default_instance_);
}
inline const ::substrait::AggregateFunction& AggregateRel_Measure::measure() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.AggregateRel.Measure.measure)
  return _internal_measure();
}
inline void AggregateRel_Measure::unsafe_arena_set_allocated_measure(::substrait::AggregateFunction* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.measure_);
  }
  _impl_.measure_ = reinterpret_cast<::substrait::AggregateFunction*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.AggregateRel.Measure.measure)
}
inline ::substrait::AggregateFunction* AggregateRel_Measure::release_measure() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::AggregateFunction* released = _impl_.measure_;
  _impl_.measure_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::AggregateFunction* AggregateRel_Measure::unsafe_arena_release_measure() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.AggregateRel.Measure.measure)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::AggregateFunction* temp = _impl_.measure_;
  _impl_.measure_ = nullptr;
  return temp;
}
inline ::substrait::AggregateFunction* AggregateRel_Measure::_internal_mutable_measure() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.measure_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::AggregateFunction>(GetArena());
    _impl_.measure_ = reinterpret_cast<::substrait::AggregateFunction*>(p);
  }
  return _impl_.measure_;
}
inline ::substrait::AggregateFunction* AggregateRel_Measure::mutable_measure() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::AggregateFunction* _msg = _internal_mutable_measure();
  // @@protoc_insertion_point(field_mutable:substrait.AggregateRel.Measure.measure)
  return _msg;
}
inline void AggregateRel_Measure::set_allocated_measure(::substrait::AggregateFunction* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.measure_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.measure_ = reinterpret_cast<::substrait::AggregateFunction*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.AggregateRel.Measure.measure)
}

// .substrait.Expression filter = 2;
inline bool AggregateRel_Measure::has_filter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.filter_ != nullptr);
  return value;
}
inline void AggregateRel_Measure::clear_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.filter_ != nullptr) _impl_.filter_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::substrait::Expression& AggregateRel_Measure::_internal_filter() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Expression* p = _impl_.filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression&>(::substrait::_Expression_default_instance_);
}
inline const ::substrait::Expression& AggregateRel_Measure::filter() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.AggregateRel.Measure.filter)
  return _internal_filter();
}
inline void AggregateRel_Measure::unsafe_arena_set_allocated_filter(::substrait::Expression* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.filter_);
  }
  _impl_.filter_ = reinterpret_cast<::substrait::Expression*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.AggregateRel.Measure.filter)
}
inline ::substrait::Expression* AggregateRel_Measure::release_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Expression* released = _impl_.filter_;
  _impl_.filter_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Expression* AggregateRel_Measure::unsafe_arena_release_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.AggregateRel.Measure.filter)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Expression* temp = _impl_.filter_;
  _impl_.filter_ = nullptr;
  return temp;
}
inline ::substrait::Expression* AggregateRel_Measure::_internal_mutable_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.filter_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Expression>(GetArena());
    _impl_.filter_ = reinterpret_cast<::substrait::Expression*>(p);
  }
  return _impl_.filter_;
}
inline ::substrait::Expression* AggregateRel_Measure::mutable_filter() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::substrait::Expression* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:substrait.AggregateRel.Measure.filter)
  return _msg;
}
inline void AggregateRel_Measure::set_allocated_filter(::substrait::Expression* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.filter_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.filter_ = reinterpret_cast<::substrait::Expression*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.AggregateRel.Measure.filter)
}

// -------------------------------------------------------------------

// AggregateRel

// .substrait.RelCommon common = 1;
inline bool AggregateRel::has_common() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.common_ != nullptr);
  return value;
}
inline void AggregateRel::clear_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.common_ != nullptr) _impl_.common_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::RelCommon& AggregateRel::_internal_common() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::RelCommon* p = _impl_.common_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::RelCommon&>(::substrait::_RelCommon_default_instance_);
}
inline const ::substrait::RelCommon& AggregateRel::common() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.AggregateRel.common)
  return _internal_common();
}
inline void AggregateRel::unsafe_arena_set_allocated_common(::substrait::RelCommon* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.common_);
  }
  _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.AggregateRel.common)
}
inline ::substrait::RelCommon* AggregateRel::release_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::RelCommon* released = _impl_.common_;
  _impl_.common_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::RelCommon* AggregateRel::unsafe_arena_release_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.AggregateRel.common)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::RelCommon* temp = _impl_.common_;
  _impl_.common_ = nullptr;
  return temp;
}
inline ::substrait::RelCommon* AggregateRel::_internal_mutable_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.common_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::RelCommon>(GetArena());
    _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(p);
  }
  return _impl_.common_;
}
inline ::substrait::RelCommon* AggregateRel::mutable_common() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::RelCommon* _msg = _internal_mutable_common();
  // @@protoc_insertion_point(field_mutable:substrait.AggregateRel.common)
  return _msg;
}
inline void AggregateRel::set_allocated_common(::substrait::RelCommon* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.common_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.AggregateRel.common)
}

// .substrait.Rel input = 2;
inline bool AggregateRel::has_input() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.input_ != nullptr);
  return value;
}
inline void AggregateRel::clear_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.input_ != nullptr) _impl_.input_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::substrait::Rel& AggregateRel::_internal_input() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Rel* p = _impl_.input_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Rel&>(::substrait::_Rel_default_instance_);
}
inline const ::substrait::Rel& AggregateRel::input() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.AggregateRel.input)
  return _internal_input();
}
inline void AggregateRel::unsafe_arena_set_allocated_input(::substrait::Rel* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.input_);
  }
  _impl_.input_ = reinterpret_cast<::substrait::Rel*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.AggregateRel.input)
}
inline ::substrait::Rel* AggregateRel::release_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Rel* released = _impl_.input_;
  _impl_.input_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Rel* AggregateRel::unsafe_arena_release_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.AggregateRel.input)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Rel* temp = _impl_.input_;
  _impl_.input_ = nullptr;
  return temp;
}
inline ::substrait::Rel* AggregateRel::_internal_mutable_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.input_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Rel>(GetArena());
    _impl_.input_ = reinterpret_cast<::substrait::Rel*>(p);
  }
  return _impl_.input_;
}
inline ::substrait::Rel* AggregateRel::mutable_input() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::substrait::Rel* _msg = _internal_mutable_input();
  // @@protoc_insertion_point(field_mutable:substrait.AggregateRel.input)
  return _msg;
}
inline void AggregateRel::set_allocated_input(::substrait::Rel* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.input_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.input_ = reinterpret_cast<::substrait::Rel*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.AggregateRel.input)
}

// repeated .substrait.AggregateRel.Grouping groupings = 3;
inline int AggregateRel::_internal_groupings_size() const {
  return _internal_groupings().size();
}
inline int AggregateRel::groupings_size() const {
  return _internal_groupings_size();
}
inline void AggregateRel::clear_groupings() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.groupings_.Clear();
}
inline ::substrait::AggregateRel_Grouping* AggregateRel::mutable_groupings(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.AggregateRel.groupings)
  return _internal_mutable_groupings()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::AggregateRel_Grouping>* AggregateRel::mutable_groupings()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.AggregateRel.groupings)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_groupings();
}
inline const ::substrait::AggregateRel_Grouping& AggregateRel::groupings(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.AggregateRel.groupings)
  return _internal_groupings().Get(index);
}
inline ::substrait::AggregateRel_Grouping* AggregateRel::add_groupings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::AggregateRel_Grouping* _add = _internal_mutable_groupings()->Add();
  // @@protoc_insertion_point(field_add:substrait.AggregateRel.groupings)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::AggregateRel_Grouping>& AggregateRel::groupings() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.AggregateRel.groupings)
  return _internal_groupings();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::AggregateRel_Grouping>&
AggregateRel::_internal_groupings() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.groupings_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::AggregateRel_Grouping>*
AggregateRel::_internal_mutable_groupings() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.groupings_;
}

// repeated .substrait.AggregateRel.Measure measures = 4;
inline int AggregateRel::_internal_measures_size() const {
  return _internal_measures().size();
}
inline int AggregateRel::measures_size() const {
  return _internal_measures_size();
}
inline void AggregateRel::clear_measures() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.measures_.Clear();
}
inline ::substrait::AggregateRel_Measure* AggregateRel::mutable_measures(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.AggregateRel.measures)
  return _internal_mutable_measures()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::AggregateRel_Measure>* AggregateRel::mutable_measures()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.AggregateRel.measures)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_measures();
}
inline const ::substrait::AggregateRel_Measure& AggregateRel::measures(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.AggregateRel.measures)
  return _internal_measures().Get(index);
}
inline ::substrait::AggregateRel_Measure* AggregateRel::add_measures() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::AggregateRel_Measure* _add = _internal_mutable_measures()->Add();
  // @@protoc_insertion_point(field_add:substrait.AggregateRel.measures)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::AggregateRel_Measure>& AggregateRel::measures() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.AggregateRel.measures)
  return _internal_measures();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::AggregateRel_Measure>&
AggregateRel::_internal_measures() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.measures_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::AggregateRel_Measure>*
AggregateRel::_internal_mutable_measures() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.measures_;
}

// .substrait.extensions.AdvancedExtension advanced_extension = 10;
inline bool AggregateRel::has_advanced_extension() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.advanced_extension_ != nullptr);
  return value;
}
inline const ::substrait::extensions::AdvancedExtension& AggregateRel::_internal_advanced_extension() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::extensions::AdvancedExtension* p = _impl_.advanced_extension_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::extensions::AdvancedExtension&>(::substrait::extensions::_AdvancedExtension_default_instance_);
}
inline const ::substrait::extensions::AdvancedExtension& AggregateRel::advanced_extension() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.AggregateRel.advanced_extension)
  return _internal_advanced_extension();
}
inline void AggregateRel::unsafe_arena_set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.advanced_extension_);
  }
  _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.AggregateRel.advanced_extension)
}
inline ::substrait::extensions::AdvancedExtension* AggregateRel::release_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::substrait::extensions::AdvancedExtension* released = _impl_.advanced_extension_;
  _impl_.advanced_extension_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::extensions::AdvancedExtension* AggregateRel::unsafe_arena_release_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.AggregateRel.advanced_extension)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::substrait::extensions::AdvancedExtension* temp = _impl_.advanced_extension_;
  _impl_.advanced_extension_ = nullptr;
  return temp;
}
inline ::substrait::extensions::AdvancedExtension* AggregateRel::_internal_mutable_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.advanced_extension_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::extensions::AdvancedExtension>(GetArena());
    _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(p);
  }
  return _impl_.advanced_extension_;
}
inline ::substrait::extensions::AdvancedExtension* AggregateRel::mutable_advanced_extension() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::substrait::extensions::AdvancedExtension* _msg = _internal_mutable_advanced_extension();
  // @@protoc_insertion_point(field_mutable:substrait.AggregateRel.advanced_extension)
  return _msg;
}
inline void AggregateRel::set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.advanced_extension_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.AggregateRel.advanced_extension)
}

// -------------------------------------------------------------------

// ConsistentPartitionWindowRel_WindowRelFunction

// uint32 function_reference = 1;
inline void ConsistentPartitionWindowRel_WindowRelFunction::clear_function_reference() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.function_reference_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t ConsistentPartitionWindowRel_WindowRelFunction::function_reference() const {
  // @@protoc_insertion_point(field_get:substrait.ConsistentPartitionWindowRel.WindowRelFunction.function_reference)
  return _internal_function_reference();
}
inline void ConsistentPartitionWindowRel_WindowRelFunction::set_function_reference(::uint32_t value) {
  _internal_set_function_reference(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:substrait.ConsistentPartitionWindowRel.WindowRelFunction.function_reference)
}
inline ::uint32_t ConsistentPartitionWindowRel_WindowRelFunction::_internal_function_reference() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.function_reference_;
}
inline void ConsistentPartitionWindowRel_WindowRelFunction::_internal_set_function_reference(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.function_reference_ = value;
}

// repeated .substrait.FunctionArgument arguments = 9;
inline int ConsistentPartitionWindowRel_WindowRelFunction::_internal_arguments_size() const {
  return _internal_arguments().size();
}
inline int ConsistentPartitionWindowRel_WindowRelFunction::arguments_size() const {
  return _internal_arguments_size();
}
inline void ConsistentPartitionWindowRel_WindowRelFunction::clear_arguments() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.arguments_.Clear();
}
inline ::substrait::FunctionArgument* ConsistentPartitionWindowRel_WindowRelFunction::mutable_arguments(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.ConsistentPartitionWindowRel.WindowRelFunction.arguments)
  return _internal_mutable_arguments()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::FunctionArgument>* ConsistentPartitionWindowRel_WindowRelFunction::mutable_arguments()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.ConsistentPartitionWindowRel.WindowRelFunction.arguments)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_arguments();
}
inline const ::substrait::FunctionArgument& ConsistentPartitionWindowRel_WindowRelFunction::arguments(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ConsistentPartitionWindowRel.WindowRelFunction.arguments)
  return _internal_arguments().Get(index);
}
inline ::substrait::FunctionArgument* ConsistentPartitionWindowRel_WindowRelFunction::add_arguments() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::FunctionArgument* _add = _internal_mutable_arguments()->Add();
  // @@protoc_insertion_point(field_add:substrait.ConsistentPartitionWindowRel.WindowRelFunction.arguments)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::FunctionArgument>& ConsistentPartitionWindowRel_WindowRelFunction::arguments() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.ConsistentPartitionWindowRel.WindowRelFunction.arguments)
  return _internal_arguments();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::FunctionArgument>&
ConsistentPartitionWindowRel_WindowRelFunction::_internal_arguments() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.arguments_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::FunctionArgument>*
ConsistentPartitionWindowRel_WindowRelFunction::_internal_mutable_arguments() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.arguments_;
}

// repeated .substrait.FunctionOption options = 11;
inline int ConsistentPartitionWindowRel_WindowRelFunction::_internal_options_size() const {
  return _internal_options().size();
}
inline int ConsistentPartitionWindowRel_WindowRelFunction::options_size() const {
  return _internal_options_size();
}
inline void ConsistentPartitionWindowRel_WindowRelFunction::clear_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.options_.Clear();
}
inline ::substrait::FunctionOption* ConsistentPartitionWindowRel_WindowRelFunction::mutable_options(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.ConsistentPartitionWindowRel.WindowRelFunction.options)
  return _internal_mutable_options()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::FunctionOption>* ConsistentPartitionWindowRel_WindowRelFunction::mutable_options()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.ConsistentPartitionWindowRel.WindowRelFunction.options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_options();
}
inline const ::substrait::FunctionOption& ConsistentPartitionWindowRel_WindowRelFunction::options(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ConsistentPartitionWindowRel.WindowRelFunction.options)
  return _internal_options().Get(index);
}
inline ::substrait::FunctionOption* ConsistentPartitionWindowRel_WindowRelFunction::add_options() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::FunctionOption* _add = _internal_mutable_options()->Add();
  // @@protoc_insertion_point(field_add:substrait.ConsistentPartitionWindowRel.WindowRelFunction.options)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::FunctionOption>& ConsistentPartitionWindowRel_WindowRelFunction::options() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.ConsistentPartitionWindowRel.WindowRelFunction.options)
  return _internal_options();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::FunctionOption>&
ConsistentPartitionWindowRel_WindowRelFunction::_internal_options() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.options_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::FunctionOption>*
ConsistentPartitionWindowRel_WindowRelFunction::_internal_mutable_options() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.options_;
}

// .substrait.Type output_type = 7;
inline bool ConsistentPartitionWindowRel_WindowRelFunction::has_output_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.output_type_ != nullptr);
  return value;
}
inline const ::substrait::Type& ConsistentPartitionWindowRel_WindowRelFunction::_internal_output_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Type* p = _impl_.output_type_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Type&>(::substrait::_Type_default_instance_);
}
inline const ::substrait::Type& ConsistentPartitionWindowRel_WindowRelFunction::output_type() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ConsistentPartitionWindowRel.WindowRelFunction.output_type)
  return _internal_output_type();
}
inline void ConsistentPartitionWindowRel_WindowRelFunction::unsafe_arena_set_allocated_output_type(::substrait::Type* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.output_type_);
  }
  _impl_.output_type_ = reinterpret_cast<::substrait::Type*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ConsistentPartitionWindowRel.WindowRelFunction.output_type)
}
inline ::substrait::Type* ConsistentPartitionWindowRel_WindowRelFunction::release_output_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::substrait::Type* released = _impl_.output_type_;
  _impl_.output_type_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Type* ConsistentPartitionWindowRel_WindowRelFunction::unsafe_arena_release_output_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.ConsistentPartitionWindowRel.WindowRelFunction.output_type)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::substrait::Type* temp = _impl_.output_type_;
  _impl_.output_type_ = nullptr;
  return temp;
}
inline ::substrait::Type* ConsistentPartitionWindowRel_WindowRelFunction::_internal_mutable_output_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.output_type_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Type>(GetArena());
    _impl_.output_type_ = reinterpret_cast<::substrait::Type*>(p);
  }
  return _impl_.output_type_;
}
inline ::substrait::Type* ConsistentPartitionWindowRel_WindowRelFunction::mutable_output_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::substrait::Type* _msg = _internal_mutable_output_type();
  // @@protoc_insertion_point(field_mutable:substrait.ConsistentPartitionWindowRel.WindowRelFunction.output_type)
  return _msg;
}
inline void ConsistentPartitionWindowRel_WindowRelFunction::set_allocated_output_type(::substrait::Type* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.output_type_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.output_type_ = reinterpret_cast<::substrait::Type*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.ConsistentPartitionWindowRel.WindowRelFunction.output_type)
}

// .substrait.AggregationPhase phase = 6;
inline void ConsistentPartitionWindowRel_WindowRelFunction::clear_phase() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.phase_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::substrait::AggregationPhase ConsistentPartitionWindowRel_WindowRelFunction::phase() const {
  // @@protoc_insertion_point(field_get:substrait.ConsistentPartitionWindowRel.WindowRelFunction.phase)
  return _internal_phase();
}
inline void ConsistentPartitionWindowRel_WindowRelFunction::set_phase(::substrait::AggregationPhase value) {
  _internal_set_phase(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:substrait.ConsistentPartitionWindowRel.WindowRelFunction.phase)
}
inline ::substrait::AggregationPhase ConsistentPartitionWindowRel_WindowRelFunction::_internal_phase() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::substrait::AggregationPhase>(_impl_.phase_);
}
inline void ConsistentPartitionWindowRel_WindowRelFunction::_internal_set_phase(::substrait::AggregationPhase value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.phase_ = value;
}

// .substrait.AggregateFunction.AggregationInvocation invocation = 10;
inline void ConsistentPartitionWindowRel_WindowRelFunction::clear_invocation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.invocation_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::substrait::AggregateFunction_AggregationInvocation ConsistentPartitionWindowRel_WindowRelFunction::invocation() const {
  // @@protoc_insertion_point(field_get:substrait.ConsistentPartitionWindowRel.WindowRelFunction.invocation)
  return _internal_invocation();
}
inline void ConsistentPartitionWindowRel_WindowRelFunction::set_invocation(::substrait::AggregateFunction_AggregationInvocation value) {
  _internal_set_invocation(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:substrait.ConsistentPartitionWindowRel.WindowRelFunction.invocation)
}
inline ::substrait::AggregateFunction_AggregationInvocation ConsistentPartitionWindowRel_WindowRelFunction::_internal_invocation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::substrait::AggregateFunction_AggregationInvocation>(_impl_.invocation_);
}
inline void ConsistentPartitionWindowRel_WindowRelFunction::_internal_set_invocation(::substrait::AggregateFunction_AggregationInvocation value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.invocation_ = value;
}

// .substrait.Expression.WindowFunction.Bound lower_bound = 5;
inline bool ConsistentPartitionWindowRel_WindowRelFunction::has_lower_bound() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lower_bound_ != nullptr);
  return value;
}
inline void ConsistentPartitionWindowRel_WindowRelFunction::clear_lower_bound() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lower_bound_ != nullptr) _impl_.lower_bound_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::substrait::Expression_WindowFunction_Bound& ConsistentPartitionWindowRel_WindowRelFunction::_internal_lower_bound() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Expression_WindowFunction_Bound* p = _impl_.lower_bound_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression_WindowFunction_Bound&>(::substrait::_Expression_WindowFunction_Bound_default_instance_);
}
inline const ::substrait::Expression_WindowFunction_Bound& ConsistentPartitionWindowRel_WindowRelFunction::lower_bound() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ConsistentPartitionWindowRel.WindowRelFunction.lower_bound)
  return _internal_lower_bound();
}
inline void ConsistentPartitionWindowRel_WindowRelFunction::unsafe_arena_set_allocated_lower_bound(::substrait::Expression_WindowFunction_Bound* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lower_bound_);
  }
  _impl_.lower_bound_ = reinterpret_cast<::substrait::Expression_WindowFunction_Bound*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ConsistentPartitionWindowRel.WindowRelFunction.lower_bound)
}
inline ::substrait::Expression_WindowFunction_Bound* ConsistentPartitionWindowRel_WindowRelFunction::release_lower_bound() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Expression_WindowFunction_Bound* released = _impl_.lower_bound_;
  _impl_.lower_bound_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Expression_WindowFunction_Bound* ConsistentPartitionWindowRel_WindowRelFunction::unsafe_arena_release_lower_bound() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.ConsistentPartitionWindowRel.WindowRelFunction.lower_bound)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Expression_WindowFunction_Bound* temp = _impl_.lower_bound_;
  _impl_.lower_bound_ = nullptr;
  return temp;
}
inline ::substrait::Expression_WindowFunction_Bound* ConsistentPartitionWindowRel_WindowRelFunction::_internal_mutable_lower_bound() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lower_bound_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_WindowFunction_Bound>(GetArena());
    _impl_.lower_bound_ = reinterpret_cast<::substrait::Expression_WindowFunction_Bound*>(p);
  }
  return _impl_.lower_bound_;
}
inline ::substrait::Expression_WindowFunction_Bound* ConsistentPartitionWindowRel_WindowRelFunction::mutable_lower_bound() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::substrait::Expression_WindowFunction_Bound* _msg = _internal_mutable_lower_bound();
  // @@protoc_insertion_point(field_mutable:substrait.ConsistentPartitionWindowRel.WindowRelFunction.lower_bound)
  return _msg;
}
inline void ConsistentPartitionWindowRel_WindowRelFunction::set_allocated_lower_bound(::substrait::Expression_WindowFunction_Bound* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.lower_bound_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.lower_bound_ = reinterpret_cast<::substrait::Expression_WindowFunction_Bound*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.ConsistentPartitionWindowRel.WindowRelFunction.lower_bound)
}

// .substrait.Expression.WindowFunction.Bound upper_bound = 4;
inline bool ConsistentPartitionWindowRel_WindowRelFunction::has_upper_bound() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.upper_bound_ != nullptr);
  return value;
}
inline void ConsistentPartitionWindowRel_WindowRelFunction::clear_upper_bound() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.upper_bound_ != nullptr) _impl_.upper_bound_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::Expression_WindowFunction_Bound& ConsistentPartitionWindowRel_WindowRelFunction::_internal_upper_bound() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Expression_WindowFunction_Bound* p = _impl_.upper_bound_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression_WindowFunction_Bound&>(::substrait::_Expression_WindowFunction_Bound_default_instance_);
}
inline const ::substrait::Expression_WindowFunction_Bound& ConsistentPartitionWindowRel_WindowRelFunction::upper_bound() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ConsistentPartitionWindowRel.WindowRelFunction.upper_bound)
  return _internal_upper_bound();
}
inline void ConsistentPartitionWindowRel_WindowRelFunction::unsafe_arena_set_allocated_upper_bound(::substrait::Expression_WindowFunction_Bound* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.upper_bound_);
  }
  _impl_.upper_bound_ = reinterpret_cast<::substrait::Expression_WindowFunction_Bound*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ConsistentPartitionWindowRel.WindowRelFunction.upper_bound)
}
inline ::substrait::Expression_WindowFunction_Bound* ConsistentPartitionWindowRel_WindowRelFunction::release_upper_bound() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Expression_WindowFunction_Bound* released = _impl_.upper_bound_;
  _impl_.upper_bound_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Expression_WindowFunction_Bound* ConsistentPartitionWindowRel_WindowRelFunction::unsafe_arena_release_upper_bound() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.ConsistentPartitionWindowRel.WindowRelFunction.upper_bound)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Expression_WindowFunction_Bound* temp = _impl_.upper_bound_;
  _impl_.upper_bound_ = nullptr;
  return temp;
}
inline ::substrait::Expression_WindowFunction_Bound* ConsistentPartitionWindowRel_WindowRelFunction::_internal_mutable_upper_bound() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.upper_bound_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_WindowFunction_Bound>(GetArena());
    _impl_.upper_bound_ = reinterpret_cast<::substrait::Expression_WindowFunction_Bound*>(p);
  }
  return _impl_.upper_bound_;
}
inline ::substrait::Expression_WindowFunction_Bound* ConsistentPartitionWindowRel_WindowRelFunction::mutable_upper_bound() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::Expression_WindowFunction_Bound* _msg = _internal_mutable_upper_bound();
  // @@protoc_insertion_point(field_mutable:substrait.ConsistentPartitionWindowRel.WindowRelFunction.upper_bound)
  return _msg;
}
inline void ConsistentPartitionWindowRel_WindowRelFunction::set_allocated_upper_bound(::substrait::Expression_WindowFunction_Bound* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.upper_bound_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.upper_bound_ = reinterpret_cast<::substrait::Expression_WindowFunction_Bound*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.ConsistentPartitionWindowRel.WindowRelFunction.upper_bound)
}

// .substrait.Expression.WindowFunction.BoundsType bounds_type = 12;
inline void ConsistentPartitionWindowRel_WindowRelFunction::clear_bounds_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bounds_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::substrait::Expression_WindowFunction_BoundsType ConsistentPartitionWindowRel_WindowRelFunction::bounds_type() const {
  // @@protoc_insertion_point(field_get:substrait.ConsistentPartitionWindowRel.WindowRelFunction.bounds_type)
  return _internal_bounds_type();
}
inline void ConsistentPartitionWindowRel_WindowRelFunction::set_bounds_type(::substrait::Expression_WindowFunction_BoundsType value) {
  _internal_set_bounds_type(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:substrait.ConsistentPartitionWindowRel.WindowRelFunction.bounds_type)
}
inline ::substrait::Expression_WindowFunction_BoundsType ConsistentPartitionWindowRel_WindowRelFunction::_internal_bounds_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::substrait::Expression_WindowFunction_BoundsType>(_impl_.bounds_type_);
}
inline void ConsistentPartitionWindowRel_WindowRelFunction::_internal_set_bounds_type(::substrait::Expression_WindowFunction_BoundsType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bounds_type_ = value;
}

// -------------------------------------------------------------------

// ConsistentPartitionWindowRel

// .substrait.RelCommon common = 1;
inline bool ConsistentPartitionWindowRel::has_common() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.common_ != nullptr);
  return value;
}
inline void ConsistentPartitionWindowRel::clear_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.common_ != nullptr) _impl_.common_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::RelCommon& ConsistentPartitionWindowRel::_internal_common() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::RelCommon* p = _impl_.common_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::RelCommon&>(::substrait::_RelCommon_default_instance_);
}
inline const ::substrait::RelCommon& ConsistentPartitionWindowRel::common() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ConsistentPartitionWindowRel.common)
  return _internal_common();
}
inline void ConsistentPartitionWindowRel::unsafe_arena_set_allocated_common(::substrait::RelCommon* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.common_);
  }
  _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ConsistentPartitionWindowRel.common)
}
inline ::substrait::RelCommon* ConsistentPartitionWindowRel::release_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::RelCommon* released = _impl_.common_;
  _impl_.common_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::RelCommon* ConsistentPartitionWindowRel::unsafe_arena_release_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.ConsistentPartitionWindowRel.common)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::RelCommon* temp = _impl_.common_;
  _impl_.common_ = nullptr;
  return temp;
}
inline ::substrait::RelCommon* ConsistentPartitionWindowRel::_internal_mutable_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.common_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::RelCommon>(GetArena());
    _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(p);
  }
  return _impl_.common_;
}
inline ::substrait::RelCommon* ConsistentPartitionWindowRel::mutable_common() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::RelCommon* _msg = _internal_mutable_common();
  // @@protoc_insertion_point(field_mutable:substrait.ConsistentPartitionWindowRel.common)
  return _msg;
}
inline void ConsistentPartitionWindowRel::set_allocated_common(::substrait::RelCommon* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.common_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.ConsistentPartitionWindowRel.common)
}

// .substrait.Rel input = 2;
inline bool ConsistentPartitionWindowRel::has_input() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.input_ != nullptr);
  return value;
}
inline void ConsistentPartitionWindowRel::clear_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.input_ != nullptr) _impl_.input_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::substrait::Rel& ConsistentPartitionWindowRel::_internal_input() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Rel* p = _impl_.input_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Rel&>(::substrait::_Rel_default_instance_);
}
inline const ::substrait::Rel& ConsistentPartitionWindowRel::input() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ConsistentPartitionWindowRel.input)
  return _internal_input();
}
inline void ConsistentPartitionWindowRel::unsafe_arena_set_allocated_input(::substrait::Rel* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.input_);
  }
  _impl_.input_ = reinterpret_cast<::substrait::Rel*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ConsistentPartitionWindowRel.input)
}
inline ::substrait::Rel* ConsistentPartitionWindowRel::release_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Rel* released = _impl_.input_;
  _impl_.input_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Rel* ConsistentPartitionWindowRel::unsafe_arena_release_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.ConsistentPartitionWindowRel.input)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Rel* temp = _impl_.input_;
  _impl_.input_ = nullptr;
  return temp;
}
inline ::substrait::Rel* ConsistentPartitionWindowRel::_internal_mutable_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.input_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Rel>(GetArena());
    _impl_.input_ = reinterpret_cast<::substrait::Rel*>(p);
  }
  return _impl_.input_;
}
inline ::substrait::Rel* ConsistentPartitionWindowRel::mutable_input() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::substrait::Rel* _msg = _internal_mutable_input();
  // @@protoc_insertion_point(field_mutable:substrait.ConsistentPartitionWindowRel.input)
  return _msg;
}
inline void ConsistentPartitionWindowRel::set_allocated_input(::substrait::Rel* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.input_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.input_ = reinterpret_cast<::substrait::Rel*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.ConsistentPartitionWindowRel.input)
}

// repeated .substrait.ConsistentPartitionWindowRel.WindowRelFunction window_functions = 3;
inline int ConsistentPartitionWindowRel::_internal_window_functions_size() const {
  return _internal_window_functions().size();
}
inline int ConsistentPartitionWindowRel::window_functions_size() const {
  return _internal_window_functions_size();
}
inline void ConsistentPartitionWindowRel::clear_window_functions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.window_functions_.Clear();
}
inline ::substrait::ConsistentPartitionWindowRel_WindowRelFunction* ConsistentPartitionWindowRel::mutable_window_functions(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.ConsistentPartitionWindowRel.window_functions)
  return _internal_mutable_window_functions()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::ConsistentPartitionWindowRel_WindowRelFunction>* ConsistentPartitionWindowRel::mutable_window_functions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.ConsistentPartitionWindowRel.window_functions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_window_functions();
}
inline const ::substrait::ConsistentPartitionWindowRel_WindowRelFunction& ConsistentPartitionWindowRel::window_functions(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ConsistentPartitionWindowRel.window_functions)
  return _internal_window_functions().Get(index);
}
inline ::substrait::ConsistentPartitionWindowRel_WindowRelFunction* ConsistentPartitionWindowRel::add_window_functions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::ConsistentPartitionWindowRel_WindowRelFunction* _add = _internal_mutable_window_functions()->Add();
  // @@protoc_insertion_point(field_add:substrait.ConsistentPartitionWindowRel.window_functions)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::ConsistentPartitionWindowRel_WindowRelFunction>& ConsistentPartitionWindowRel::window_functions() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.ConsistentPartitionWindowRel.window_functions)
  return _internal_window_functions();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::ConsistentPartitionWindowRel_WindowRelFunction>&
ConsistentPartitionWindowRel::_internal_window_functions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.window_functions_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::ConsistentPartitionWindowRel_WindowRelFunction>*
ConsistentPartitionWindowRel::_internal_mutable_window_functions() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.window_functions_;
}

// repeated .substrait.Expression partition_expressions = 4;
inline int ConsistentPartitionWindowRel::_internal_partition_expressions_size() const {
  return _internal_partition_expressions().size();
}
inline int ConsistentPartitionWindowRel::partition_expressions_size() const {
  return _internal_partition_expressions_size();
}
inline void ConsistentPartitionWindowRel::clear_partition_expressions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.partition_expressions_.Clear();
}
inline ::substrait::Expression* ConsistentPartitionWindowRel::mutable_partition_expressions(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.ConsistentPartitionWindowRel.partition_expressions)
  return _internal_mutable_partition_expressions()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression>* ConsistentPartitionWindowRel::mutable_partition_expressions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.ConsistentPartitionWindowRel.partition_expressions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_partition_expressions();
}
inline const ::substrait::Expression& ConsistentPartitionWindowRel::partition_expressions(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ConsistentPartitionWindowRel.partition_expressions)
  return _internal_partition_expressions().Get(index);
}
inline ::substrait::Expression* ConsistentPartitionWindowRel::add_partition_expressions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::Expression* _add = _internal_mutable_partition_expressions()->Add();
  // @@protoc_insertion_point(field_add:substrait.ConsistentPartitionWindowRel.partition_expressions)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression>& ConsistentPartitionWindowRel::partition_expressions() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.ConsistentPartitionWindowRel.partition_expressions)
  return _internal_partition_expressions();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression>&
ConsistentPartitionWindowRel::_internal_partition_expressions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.partition_expressions_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression>*
ConsistentPartitionWindowRel::_internal_mutable_partition_expressions() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.partition_expressions_;
}

// repeated .substrait.SortField sorts = 5;
inline int ConsistentPartitionWindowRel::_internal_sorts_size() const {
  return _internal_sorts().size();
}
inline int ConsistentPartitionWindowRel::sorts_size() const {
  return _internal_sorts_size();
}
inline void ConsistentPartitionWindowRel::clear_sorts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sorts_.Clear();
}
inline ::substrait::SortField* ConsistentPartitionWindowRel::mutable_sorts(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.ConsistentPartitionWindowRel.sorts)
  return _internal_mutable_sorts()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::SortField>* ConsistentPartitionWindowRel::mutable_sorts()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.ConsistentPartitionWindowRel.sorts)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_sorts();
}
inline const ::substrait::SortField& ConsistentPartitionWindowRel::sorts(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ConsistentPartitionWindowRel.sorts)
  return _internal_sorts().Get(index);
}
inline ::substrait::SortField* ConsistentPartitionWindowRel::add_sorts() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::SortField* _add = _internal_mutable_sorts()->Add();
  // @@protoc_insertion_point(field_add:substrait.ConsistentPartitionWindowRel.sorts)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::SortField>& ConsistentPartitionWindowRel::sorts() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.ConsistentPartitionWindowRel.sorts)
  return _internal_sorts();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::SortField>&
ConsistentPartitionWindowRel::_internal_sorts() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sorts_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::SortField>*
ConsistentPartitionWindowRel::_internal_mutable_sorts() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.sorts_;
}

// .substrait.extensions.AdvancedExtension advanced_extension = 10;
inline bool ConsistentPartitionWindowRel::has_advanced_extension() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.advanced_extension_ != nullptr);
  return value;
}
inline const ::substrait::extensions::AdvancedExtension& ConsistentPartitionWindowRel::_internal_advanced_extension() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::extensions::AdvancedExtension* p = _impl_.advanced_extension_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::extensions::AdvancedExtension&>(::substrait::extensions::_AdvancedExtension_default_instance_);
}
inline const ::substrait::extensions::AdvancedExtension& ConsistentPartitionWindowRel::advanced_extension() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ConsistentPartitionWindowRel.advanced_extension)
  return _internal_advanced_extension();
}
inline void ConsistentPartitionWindowRel::unsafe_arena_set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.advanced_extension_);
  }
  _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ConsistentPartitionWindowRel.advanced_extension)
}
inline ::substrait::extensions::AdvancedExtension* ConsistentPartitionWindowRel::release_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::substrait::extensions::AdvancedExtension* released = _impl_.advanced_extension_;
  _impl_.advanced_extension_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::extensions::AdvancedExtension* ConsistentPartitionWindowRel::unsafe_arena_release_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.ConsistentPartitionWindowRel.advanced_extension)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::substrait::extensions::AdvancedExtension* temp = _impl_.advanced_extension_;
  _impl_.advanced_extension_ = nullptr;
  return temp;
}
inline ::substrait::extensions::AdvancedExtension* ConsistentPartitionWindowRel::_internal_mutable_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.advanced_extension_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::extensions::AdvancedExtension>(GetArena());
    _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(p);
  }
  return _impl_.advanced_extension_;
}
inline ::substrait::extensions::AdvancedExtension* ConsistentPartitionWindowRel::mutable_advanced_extension() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::substrait::extensions::AdvancedExtension* _msg = _internal_mutable_advanced_extension();
  // @@protoc_insertion_point(field_mutable:substrait.ConsistentPartitionWindowRel.advanced_extension)
  return _msg;
}
inline void ConsistentPartitionWindowRel::set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.advanced_extension_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.ConsistentPartitionWindowRel.advanced_extension)
}

// -------------------------------------------------------------------

// SortRel

// .substrait.RelCommon common = 1;
inline bool SortRel::has_common() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.common_ != nullptr);
  return value;
}
inline void SortRel::clear_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.common_ != nullptr) _impl_.common_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::RelCommon& SortRel::_internal_common() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::RelCommon* p = _impl_.common_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::RelCommon&>(::substrait::_RelCommon_default_instance_);
}
inline const ::substrait::RelCommon& SortRel::common() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.SortRel.common)
  return _internal_common();
}
inline void SortRel::unsafe_arena_set_allocated_common(::substrait::RelCommon* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.common_);
  }
  _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.SortRel.common)
}
inline ::substrait::RelCommon* SortRel::release_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::RelCommon* released = _impl_.common_;
  _impl_.common_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::RelCommon* SortRel::unsafe_arena_release_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.SortRel.common)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::RelCommon* temp = _impl_.common_;
  _impl_.common_ = nullptr;
  return temp;
}
inline ::substrait::RelCommon* SortRel::_internal_mutable_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.common_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::RelCommon>(GetArena());
    _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(p);
  }
  return _impl_.common_;
}
inline ::substrait::RelCommon* SortRel::mutable_common() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::RelCommon* _msg = _internal_mutable_common();
  // @@protoc_insertion_point(field_mutable:substrait.SortRel.common)
  return _msg;
}
inline void SortRel::set_allocated_common(::substrait::RelCommon* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.common_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.SortRel.common)
}

// .substrait.Rel input = 2;
inline bool SortRel::has_input() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.input_ != nullptr);
  return value;
}
inline void SortRel::clear_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.input_ != nullptr) _impl_.input_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::substrait::Rel& SortRel::_internal_input() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Rel* p = _impl_.input_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Rel&>(::substrait::_Rel_default_instance_);
}
inline const ::substrait::Rel& SortRel::input() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.SortRel.input)
  return _internal_input();
}
inline void SortRel::unsafe_arena_set_allocated_input(::substrait::Rel* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.input_);
  }
  _impl_.input_ = reinterpret_cast<::substrait::Rel*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.SortRel.input)
}
inline ::substrait::Rel* SortRel::release_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Rel* released = _impl_.input_;
  _impl_.input_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Rel* SortRel::unsafe_arena_release_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.SortRel.input)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Rel* temp = _impl_.input_;
  _impl_.input_ = nullptr;
  return temp;
}
inline ::substrait::Rel* SortRel::_internal_mutable_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.input_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Rel>(GetArena());
    _impl_.input_ = reinterpret_cast<::substrait::Rel*>(p);
  }
  return _impl_.input_;
}
inline ::substrait::Rel* SortRel::mutable_input() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::substrait::Rel* _msg = _internal_mutable_input();
  // @@protoc_insertion_point(field_mutable:substrait.SortRel.input)
  return _msg;
}
inline void SortRel::set_allocated_input(::substrait::Rel* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.input_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.input_ = reinterpret_cast<::substrait::Rel*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.SortRel.input)
}

// repeated .substrait.SortField sorts = 3;
inline int SortRel::_internal_sorts_size() const {
  return _internal_sorts().size();
}
inline int SortRel::sorts_size() const {
  return _internal_sorts_size();
}
inline void SortRel::clear_sorts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sorts_.Clear();
}
inline ::substrait::SortField* SortRel::mutable_sorts(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.SortRel.sorts)
  return _internal_mutable_sorts()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::SortField>* SortRel::mutable_sorts()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.SortRel.sorts)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_sorts();
}
inline const ::substrait::SortField& SortRel::sorts(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.SortRel.sorts)
  return _internal_sorts().Get(index);
}
inline ::substrait::SortField* SortRel::add_sorts() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::SortField* _add = _internal_mutable_sorts()->Add();
  // @@protoc_insertion_point(field_add:substrait.SortRel.sorts)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::SortField>& SortRel::sorts() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.SortRel.sorts)
  return _internal_sorts();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::SortField>&
SortRel::_internal_sorts() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sorts_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::SortField>*
SortRel::_internal_mutable_sorts() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.sorts_;
}

// .substrait.extensions.AdvancedExtension advanced_extension = 10;
inline bool SortRel::has_advanced_extension() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.advanced_extension_ != nullptr);
  return value;
}
inline const ::substrait::extensions::AdvancedExtension& SortRel::_internal_advanced_extension() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::extensions::AdvancedExtension* p = _impl_.advanced_extension_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::extensions::AdvancedExtension&>(::substrait::extensions::_AdvancedExtension_default_instance_);
}
inline const ::substrait::extensions::AdvancedExtension& SortRel::advanced_extension() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.SortRel.advanced_extension)
  return _internal_advanced_extension();
}
inline void SortRel::unsafe_arena_set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.advanced_extension_);
  }
  _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.SortRel.advanced_extension)
}
inline ::substrait::extensions::AdvancedExtension* SortRel::release_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::substrait::extensions::AdvancedExtension* released = _impl_.advanced_extension_;
  _impl_.advanced_extension_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::extensions::AdvancedExtension* SortRel::unsafe_arena_release_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.SortRel.advanced_extension)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::substrait::extensions::AdvancedExtension* temp = _impl_.advanced_extension_;
  _impl_.advanced_extension_ = nullptr;
  return temp;
}
inline ::substrait::extensions::AdvancedExtension* SortRel::_internal_mutable_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.advanced_extension_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::extensions::AdvancedExtension>(GetArena());
    _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(p);
  }
  return _impl_.advanced_extension_;
}
inline ::substrait::extensions::AdvancedExtension* SortRel::mutable_advanced_extension() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::substrait::extensions::AdvancedExtension* _msg = _internal_mutable_advanced_extension();
  // @@protoc_insertion_point(field_mutable:substrait.SortRel.advanced_extension)
  return _msg;
}
inline void SortRel::set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.advanced_extension_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.SortRel.advanced_extension)
}

// -------------------------------------------------------------------

// FilterRel

// .substrait.RelCommon common = 1;
inline bool FilterRel::has_common() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.common_ != nullptr);
  return value;
}
inline void FilterRel::clear_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.common_ != nullptr) _impl_.common_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::RelCommon& FilterRel::_internal_common() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::RelCommon* p = _impl_.common_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::RelCommon&>(::substrait::_RelCommon_default_instance_);
}
inline const ::substrait::RelCommon& FilterRel::common() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.FilterRel.common)
  return _internal_common();
}
inline void FilterRel::unsafe_arena_set_allocated_common(::substrait::RelCommon* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.common_);
  }
  _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.FilterRel.common)
}
inline ::substrait::RelCommon* FilterRel::release_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::RelCommon* released = _impl_.common_;
  _impl_.common_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::RelCommon* FilterRel::unsafe_arena_release_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.FilterRel.common)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::RelCommon* temp = _impl_.common_;
  _impl_.common_ = nullptr;
  return temp;
}
inline ::substrait::RelCommon* FilterRel::_internal_mutable_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.common_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::RelCommon>(GetArena());
    _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(p);
  }
  return _impl_.common_;
}
inline ::substrait::RelCommon* FilterRel::mutable_common() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::RelCommon* _msg = _internal_mutable_common();
  // @@protoc_insertion_point(field_mutable:substrait.FilterRel.common)
  return _msg;
}
inline void FilterRel::set_allocated_common(::substrait::RelCommon* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.common_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.FilterRel.common)
}

// .substrait.Rel input = 2;
inline bool FilterRel::has_input() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.input_ != nullptr);
  return value;
}
inline void FilterRel::clear_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.input_ != nullptr) _impl_.input_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::substrait::Rel& FilterRel::_internal_input() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Rel* p = _impl_.input_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Rel&>(::substrait::_Rel_default_instance_);
}
inline const ::substrait::Rel& FilterRel::input() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.FilterRel.input)
  return _internal_input();
}
inline void FilterRel::unsafe_arena_set_allocated_input(::substrait::Rel* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.input_);
  }
  _impl_.input_ = reinterpret_cast<::substrait::Rel*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.FilterRel.input)
}
inline ::substrait::Rel* FilterRel::release_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Rel* released = _impl_.input_;
  _impl_.input_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Rel* FilterRel::unsafe_arena_release_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.FilterRel.input)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Rel* temp = _impl_.input_;
  _impl_.input_ = nullptr;
  return temp;
}
inline ::substrait::Rel* FilterRel::_internal_mutable_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.input_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Rel>(GetArena());
    _impl_.input_ = reinterpret_cast<::substrait::Rel*>(p);
  }
  return _impl_.input_;
}
inline ::substrait::Rel* FilterRel::mutable_input() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::substrait::Rel* _msg = _internal_mutable_input();
  // @@protoc_insertion_point(field_mutable:substrait.FilterRel.input)
  return _msg;
}
inline void FilterRel::set_allocated_input(::substrait::Rel* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.input_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.input_ = reinterpret_cast<::substrait::Rel*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.FilterRel.input)
}

// .substrait.Expression condition = 3;
inline bool FilterRel::has_condition() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.condition_ != nullptr);
  return value;
}
inline void FilterRel::clear_condition() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.condition_ != nullptr) _impl_.condition_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::substrait::Expression& FilterRel::_internal_condition() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Expression* p = _impl_.condition_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression&>(::substrait::_Expression_default_instance_);
}
inline const ::substrait::Expression& FilterRel::condition() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.FilterRel.condition)
  return _internal_condition();
}
inline void FilterRel::unsafe_arena_set_allocated_condition(::substrait::Expression* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.condition_);
  }
  _impl_.condition_ = reinterpret_cast<::substrait::Expression*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.FilterRel.condition)
}
inline ::substrait::Expression* FilterRel::release_condition() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::substrait::Expression* released = _impl_.condition_;
  _impl_.condition_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Expression* FilterRel::unsafe_arena_release_condition() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.FilterRel.condition)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::substrait::Expression* temp = _impl_.condition_;
  _impl_.condition_ = nullptr;
  return temp;
}
inline ::substrait::Expression* FilterRel::_internal_mutable_condition() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.condition_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Expression>(GetArena());
    _impl_.condition_ = reinterpret_cast<::substrait::Expression*>(p);
  }
  return _impl_.condition_;
}
inline ::substrait::Expression* FilterRel::mutable_condition() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::substrait::Expression* _msg = _internal_mutable_condition();
  // @@protoc_insertion_point(field_mutable:substrait.FilterRel.condition)
  return _msg;
}
inline void FilterRel::set_allocated_condition(::substrait::Expression* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.condition_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.condition_ = reinterpret_cast<::substrait::Expression*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.FilterRel.condition)
}

// .substrait.extensions.AdvancedExtension advanced_extension = 10;
inline bool FilterRel::has_advanced_extension() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.advanced_extension_ != nullptr);
  return value;
}
inline const ::substrait::extensions::AdvancedExtension& FilterRel::_internal_advanced_extension() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::extensions::AdvancedExtension* p = _impl_.advanced_extension_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::extensions::AdvancedExtension&>(::substrait::extensions::_AdvancedExtension_default_instance_);
}
inline const ::substrait::extensions::AdvancedExtension& FilterRel::advanced_extension() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.FilterRel.advanced_extension)
  return _internal_advanced_extension();
}
inline void FilterRel::unsafe_arena_set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.advanced_extension_);
  }
  _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.FilterRel.advanced_extension)
}
inline ::substrait::extensions::AdvancedExtension* FilterRel::release_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::substrait::extensions::AdvancedExtension* released = _impl_.advanced_extension_;
  _impl_.advanced_extension_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::extensions::AdvancedExtension* FilterRel::unsafe_arena_release_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.FilterRel.advanced_extension)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::substrait::extensions::AdvancedExtension* temp = _impl_.advanced_extension_;
  _impl_.advanced_extension_ = nullptr;
  return temp;
}
inline ::substrait::extensions::AdvancedExtension* FilterRel::_internal_mutable_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.advanced_extension_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::extensions::AdvancedExtension>(GetArena());
    _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(p);
  }
  return _impl_.advanced_extension_;
}
inline ::substrait::extensions::AdvancedExtension* FilterRel::mutable_advanced_extension() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::substrait::extensions::AdvancedExtension* _msg = _internal_mutable_advanced_extension();
  // @@protoc_insertion_point(field_mutable:substrait.FilterRel.advanced_extension)
  return _msg;
}
inline void FilterRel::set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.advanced_extension_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.FilterRel.advanced_extension)
}

// -------------------------------------------------------------------

// SetRel

// .substrait.RelCommon common = 1;
inline bool SetRel::has_common() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.common_ != nullptr);
  return value;
}
inline void SetRel::clear_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.common_ != nullptr) _impl_.common_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::RelCommon& SetRel::_internal_common() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::RelCommon* p = _impl_.common_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::RelCommon&>(::substrait::_RelCommon_default_instance_);
}
inline const ::substrait::RelCommon& SetRel::common() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.SetRel.common)
  return _internal_common();
}
inline void SetRel::unsafe_arena_set_allocated_common(::substrait::RelCommon* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.common_);
  }
  _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.SetRel.common)
}
inline ::substrait::RelCommon* SetRel::release_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::RelCommon* released = _impl_.common_;
  _impl_.common_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::RelCommon* SetRel::unsafe_arena_release_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.SetRel.common)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::RelCommon* temp = _impl_.common_;
  _impl_.common_ = nullptr;
  return temp;
}
inline ::substrait::RelCommon* SetRel::_internal_mutable_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.common_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::RelCommon>(GetArena());
    _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(p);
  }
  return _impl_.common_;
}
inline ::substrait::RelCommon* SetRel::mutable_common() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::RelCommon* _msg = _internal_mutable_common();
  // @@protoc_insertion_point(field_mutable:substrait.SetRel.common)
  return _msg;
}
inline void SetRel::set_allocated_common(::substrait::RelCommon* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.common_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.SetRel.common)
}

// repeated .substrait.Rel inputs = 2;
inline int SetRel::_internal_inputs_size() const {
  return _internal_inputs().size();
}
inline int SetRel::inputs_size() const {
  return _internal_inputs_size();
}
inline void SetRel::clear_inputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inputs_.Clear();
}
inline ::substrait::Rel* SetRel::mutable_inputs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.SetRel.inputs)
  return _internal_mutable_inputs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Rel>* SetRel::mutable_inputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.SetRel.inputs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_inputs();
}
inline const ::substrait::Rel& SetRel::inputs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.SetRel.inputs)
  return _internal_inputs().Get(index);
}
inline ::substrait::Rel* SetRel::add_inputs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::Rel* _add = _internal_mutable_inputs()->Add();
  // @@protoc_insertion_point(field_add:substrait.SetRel.inputs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Rel>& SetRel::inputs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.SetRel.inputs)
  return _internal_inputs();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Rel>&
SetRel::_internal_inputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.inputs_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Rel>*
SetRel::_internal_mutable_inputs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.inputs_;
}

// .substrait.SetRel.SetOp op = 3;
inline void SetRel::clear_op() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.op_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::substrait::SetRel_SetOp SetRel::op() const {
  // @@protoc_insertion_point(field_get:substrait.SetRel.op)
  return _internal_op();
}
inline void SetRel::set_op(::substrait::SetRel_SetOp value) {
  _internal_set_op(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:substrait.SetRel.op)
}
inline ::substrait::SetRel_SetOp SetRel::_internal_op() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::substrait::SetRel_SetOp>(_impl_.op_);
}
inline void SetRel::_internal_set_op(::substrait::SetRel_SetOp value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.op_ = value;
}

// .substrait.extensions.AdvancedExtension advanced_extension = 10;
inline bool SetRel::has_advanced_extension() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.advanced_extension_ != nullptr);
  return value;
}
inline const ::substrait::extensions::AdvancedExtension& SetRel::_internal_advanced_extension() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::extensions::AdvancedExtension* p = _impl_.advanced_extension_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::extensions::AdvancedExtension&>(::substrait::extensions::_AdvancedExtension_default_instance_);
}
inline const ::substrait::extensions::AdvancedExtension& SetRel::advanced_extension() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.SetRel.advanced_extension)
  return _internal_advanced_extension();
}
inline void SetRel::unsafe_arena_set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.advanced_extension_);
  }
  _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.SetRel.advanced_extension)
}
inline ::substrait::extensions::AdvancedExtension* SetRel::release_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::extensions::AdvancedExtension* released = _impl_.advanced_extension_;
  _impl_.advanced_extension_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::extensions::AdvancedExtension* SetRel::unsafe_arena_release_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.SetRel.advanced_extension)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::extensions::AdvancedExtension* temp = _impl_.advanced_extension_;
  _impl_.advanced_extension_ = nullptr;
  return temp;
}
inline ::substrait::extensions::AdvancedExtension* SetRel::_internal_mutable_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.advanced_extension_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::extensions::AdvancedExtension>(GetArena());
    _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(p);
  }
  return _impl_.advanced_extension_;
}
inline ::substrait::extensions::AdvancedExtension* SetRel::mutable_advanced_extension() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::substrait::extensions::AdvancedExtension* _msg = _internal_mutable_advanced_extension();
  // @@protoc_insertion_point(field_mutable:substrait.SetRel.advanced_extension)
  return _msg;
}
inline void SetRel::set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.advanced_extension_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.SetRel.advanced_extension)
}

// -------------------------------------------------------------------

// ExtensionSingleRel

// .substrait.RelCommon common = 1;
inline bool ExtensionSingleRel::has_common() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.common_ != nullptr);
  return value;
}
inline void ExtensionSingleRel::clear_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.common_ != nullptr) _impl_.common_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::RelCommon& ExtensionSingleRel::_internal_common() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::RelCommon* p = _impl_.common_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::RelCommon&>(::substrait::_RelCommon_default_instance_);
}
inline const ::substrait::RelCommon& ExtensionSingleRel::common() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ExtensionSingleRel.common)
  return _internal_common();
}
inline void ExtensionSingleRel::unsafe_arena_set_allocated_common(::substrait::RelCommon* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.common_);
  }
  _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ExtensionSingleRel.common)
}
inline ::substrait::RelCommon* ExtensionSingleRel::release_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::RelCommon* released = _impl_.common_;
  _impl_.common_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::RelCommon* ExtensionSingleRel::unsafe_arena_release_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.ExtensionSingleRel.common)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::RelCommon* temp = _impl_.common_;
  _impl_.common_ = nullptr;
  return temp;
}
inline ::substrait::RelCommon* ExtensionSingleRel::_internal_mutable_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.common_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::RelCommon>(GetArena());
    _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(p);
  }
  return _impl_.common_;
}
inline ::substrait::RelCommon* ExtensionSingleRel::mutable_common() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::RelCommon* _msg = _internal_mutable_common();
  // @@protoc_insertion_point(field_mutable:substrait.ExtensionSingleRel.common)
  return _msg;
}
inline void ExtensionSingleRel::set_allocated_common(::substrait::RelCommon* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.common_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.ExtensionSingleRel.common)
}

// .substrait.Rel input = 2;
inline bool ExtensionSingleRel::has_input() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.input_ != nullptr);
  return value;
}
inline void ExtensionSingleRel::clear_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.input_ != nullptr) _impl_.input_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::substrait::Rel& ExtensionSingleRel::_internal_input() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Rel* p = _impl_.input_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Rel&>(::substrait::_Rel_default_instance_);
}
inline const ::substrait::Rel& ExtensionSingleRel::input() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ExtensionSingleRel.input)
  return _internal_input();
}
inline void ExtensionSingleRel::unsafe_arena_set_allocated_input(::substrait::Rel* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.input_);
  }
  _impl_.input_ = reinterpret_cast<::substrait::Rel*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ExtensionSingleRel.input)
}
inline ::substrait::Rel* ExtensionSingleRel::release_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Rel* released = _impl_.input_;
  _impl_.input_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Rel* ExtensionSingleRel::unsafe_arena_release_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.ExtensionSingleRel.input)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Rel* temp = _impl_.input_;
  _impl_.input_ = nullptr;
  return temp;
}
inline ::substrait::Rel* ExtensionSingleRel::_internal_mutable_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.input_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Rel>(GetArena());
    _impl_.input_ = reinterpret_cast<::substrait::Rel*>(p);
  }
  return _impl_.input_;
}
inline ::substrait::Rel* ExtensionSingleRel::mutable_input() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::substrait::Rel* _msg = _internal_mutable_input();
  // @@protoc_insertion_point(field_mutable:substrait.ExtensionSingleRel.input)
  return _msg;
}
inline void ExtensionSingleRel::set_allocated_input(::substrait::Rel* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.input_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.input_ = reinterpret_cast<::substrait::Rel*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.ExtensionSingleRel.input)
}

// .google.protobuf.Any detail = 3;
inline bool ExtensionSingleRel::has_detail() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.detail_ != nullptr);
  return value;
}
inline const ::google::protobuf::Any& ExtensionSingleRel::_internal_detail() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Any* p = _impl_.detail_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Any&>(::google::protobuf::_Any_default_instance_);
}
inline const ::google::protobuf::Any& ExtensionSingleRel::detail() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ExtensionSingleRel.detail)
  return _internal_detail();
}
inline void ExtensionSingleRel::unsafe_arena_set_allocated_detail(::google::protobuf::Any* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detail_);
  }
  _impl_.detail_ = reinterpret_cast<::google::protobuf::Any*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ExtensionSingleRel.detail)
}
inline ::google::protobuf::Any* ExtensionSingleRel::release_detail() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Any* released = _impl_.detail_;
  _impl_.detail_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Any* ExtensionSingleRel::unsafe_arena_release_detail() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.ExtensionSingleRel.detail)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Any* temp = _impl_.detail_;
  _impl_.detail_ = nullptr;
  return temp;
}
inline ::google::protobuf::Any* ExtensionSingleRel::_internal_mutable_detail() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.detail_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Any>(GetArena());
    _impl_.detail_ = reinterpret_cast<::google::protobuf::Any*>(p);
  }
  return _impl_.detail_;
}
inline ::google::protobuf::Any* ExtensionSingleRel::mutable_detail() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::google::protobuf::Any* _msg = _internal_mutable_detail();
  // @@protoc_insertion_point(field_mutable:substrait.ExtensionSingleRel.detail)
  return _msg;
}
inline void ExtensionSingleRel::set_allocated_detail(::google::protobuf::Any* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detail_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.detail_ = reinterpret_cast<::google::protobuf::Any*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.ExtensionSingleRel.detail)
}

// -------------------------------------------------------------------

// ExtensionLeafRel

// .substrait.RelCommon common = 1;
inline bool ExtensionLeafRel::has_common() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.common_ != nullptr);
  return value;
}
inline void ExtensionLeafRel::clear_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.common_ != nullptr) _impl_.common_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::RelCommon& ExtensionLeafRel::_internal_common() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::RelCommon* p = _impl_.common_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::RelCommon&>(::substrait::_RelCommon_default_instance_);
}
inline const ::substrait::RelCommon& ExtensionLeafRel::common() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ExtensionLeafRel.common)
  return _internal_common();
}
inline void ExtensionLeafRel::unsafe_arena_set_allocated_common(::substrait::RelCommon* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.common_);
  }
  _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ExtensionLeafRel.common)
}
inline ::substrait::RelCommon* ExtensionLeafRel::release_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::RelCommon* released = _impl_.common_;
  _impl_.common_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::RelCommon* ExtensionLeafRel::unsafe_arena_release_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.ExtensionLeafRel.common)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::RelCommon* temp = _impl_.common_;
  _impl_.common_ = nullptr;
  return temp;
}
inline ::substrait::RelCommon* ExtensionLeafRel::_internal_mutable_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.common_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::RelCommon>(GetArena());
    _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(p);
  }
  return _impl_.common_;
}
inline ::substrait::RelCommon* ExtensionLeafRel::mutable_common() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::RelCommon* _msg = _internal_mutable_common();
  // @@protoc_insertion_point(field_mutable:substrait.ExtensionLeafRel.common)
  return _msg;
}
inline void ExtensionLeafRel::set_allocated_common(::substrait::RelCommon* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.common_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.ExtensionLeafRel.common)
}

// .google.protobuf.Any detail = 2;
inline bool ExtensionLeafRel::has_detail() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.detail_ != nullptr);
  return value;
}
inline const ::google::protobuf::Any& ExtensionLeafRel::_internal_detail() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Any* p = _impl_.detail_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Any&>(::google::protobuf::_Any_default_instance_);
}
inline const ::google::protobuf::Any& ExtensionLeafRel::detail() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ExtensionLeafRel.detail)
  return _internal_detail();
}
inline void ExtensionLeafRel::unsafe_arena_set_allocated_detail(::google::protobuf::Any* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detail_);
  }
  _impl_.detail_ = reinterpret_cast<::google::protobuf::Any*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ExtensionLeafRel.detail)
}
inline ::google::protobuf::Any* ExtensionLeafRel::release_detail() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Any* released = _impl_.detail_;
  _impl_.detail_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Any* ExtensionLeafRel::unsafe_arena_release_detail() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.ExtensionLeafRel.detail)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Any* temp = _impl_.detail_;
  _impl_.detail_ = nullptr;
  return temp;
}
inline ::google::protobuf::Any* ExtensionLeafRel::_internal_mutable_detail() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.detail_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Any>(GetArena());
    _impl_.detail_ = reinterpret_cast<::google::protobuf::Any*>(p);
  }
  return _impl_.detail_;
}
inline ::google::protobuf::Any* ExtensionLeafRel::mutable_detail() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::Any* _msg = _internal_mutable_detail();
  // @@protoc_insertion_point(field_mutable:substrait.ExtensionLeafRel.detail)
  return _msg;
}
inline void ExtensionLeafRel::set_allocated_detail(::google::protobuf::Any* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detail_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.detail_ = reinterpret_cast<::google::protobuf::Any*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.ExtensionLeafRel.detail)
}

// -------------------------------------------------------------------

// ExtensionMultiRel

// .substrait.RelCommon common = 1;
inline bool ExtensionMultiRel::has_common() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.common_ != nullptr);
  return value;
}
inline void ExtensionMultiRel::clear_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.common_ != nullptr) _impl_.common_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::RelCommon& ExtensionMultiRel::_internal_common() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::RelCommon* p = _impl_.common_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::RelCommon&>(::substrait::_RelCommon_default_instance_);
}
inline const ::substrait::RelCommon& ExtensionMultiRel::common() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ExtensionMultiRel.common)
  return _internal_common();
}
inline void ExtensionMultiRel::unsafe_arena_set_allocated_common(::substrait::RelCommon* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.common_);
  }
  _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ExtensionMultiRel.common)
}
inline ::substrait::RelCommon* ExtensionMultiRel::release_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::RelCommon* released = _impl_.common_;
  _impl_.common_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::RelCommon* ExtensionMultiRel::unsafe_arena_release_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.ExtensionMultiRel.common)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::RelCommon* temp = _impl_.common_;
  _impl_.common_ = nullptr;
  return temp;
}
inline ::substrait::RelCommon* ExtensionMultiRel::_internal_mutable_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.common_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::RelCommon>(GetArena());
    _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(p);
  }
  return _impl_.common_;
}
inline ::substrait::RelCommon* ExtensionMultiRel::mutable_common() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::RelCommon* _msg = _internal_mutable_common();
  // @@protoc_insertion_point(field_mutable:substrait.ExtensionMultiRel.common)
  return _msg;
}
inline void ExtensionMultiRel::set_allocated_common(::substrait::RelCommon* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.common_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.ExtensionMultiRel.common)
}

// repeated .substrait.Rel inputs = 2;
inline int ExtensionMultiRel::_internal_inputs_size() const {
  return _internal_inputs().size();
}
inline int ExtensionMultiRel::inputs_size() const {
  return _internal_inputs_size();
}
inline void ExtensionMultiRel::clear_inputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.inputs_.Clear();
}
inline ::substrait::Rel* ExtensionMultiRel::mutable_inputs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.ExtensionMultiRel.inputs)
  return _internal_mutable_inputs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Rel>* ExtensionMultiRel::mutable_inputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.ExtensionMultiRel.inputs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_inputs();
}
inline const ::substrait::Rel& ExtensionMultiRel::inputs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ExtensionMultiRel.inputs)
  return _internal_inputs().Get(index);
}
inline ::substrait::Rel* ExtensionMultiRel::add_inputs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::Rel* _add = _internal_mutable_inputs()->Add();
  // @@protoc_insertion_point(field_add:substrait.ExtensionMultiRel.inputs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Rel>& ExtensionMultiRel::inputs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.ExtensionMultiRel.inputs)
  return _internal_inputs();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Rel>&
ExtensionMultiRel::_internal_inputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.inputs_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Rel>*
ExtensionMultiRel::_internal_mutable_inputs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.inputs_;
}

// .google.protobuf.Any detail = 3;
inline bool ExtensionMultiRel::has_detail() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.detail_ != nullptr);
  return value;
}
inline const ::google::protobuf::Any& ExtensionMultiRel::_internal_detail() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Any* p = _impl_.detail_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Any&>(::google::protobuf::_Any_default_instance_);
}
inline const ::google::protobuf::Any& ExtensionMultiRel::detail() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ExtensionMultiRel.detail)
  return _internal_detail();
}
inline void ExtensionMultiRel::unsafe_arena_set_allocated_detail(::google::protobuf::Any* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detail_);
  }
  _impl_.detail_ = reinterpret_cast<::google::protobuf::Any*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ExtensionMultiRel.detail)
}
inline ::google::protobuf::Any* ExtensionMultiRel::release_detail() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Any* released = _impl_.detail_;
  _impl_.detail_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Any* ExtensionMultiRel::unsafe_arena_release_detail() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.ExtensionMultiRel.detail)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Any* temp = _impl_.detail_;
  _impl_.detail_ = nullptr;
  return temp;
}
inline ::google::protobuf::Any* ExtensionMultiRel::_internal_mutable_detail() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.detail_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Any>(GetArena());
    _impl_.detail_ = reinterpret_cast<::google::protobuf::Any*>(p);
  }
  return _impl_.detail_;
}
inline ::google::protobuf::Any* ExtensionMultiRel::mutable_detail() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::Any* _msg = _internal_mutable_detail();
  // @@protoc_insertion_point(field_mutable:substrait.ExtensionMultiRel.detail)
  return _msg;
}
inline void ExtensionMultiRel::set_allocated_detail(::google::protobuf::Any* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detail_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.detail_ = reinterpret_cast<::google::protobuf::Any*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.ExtensionMultiRel.detail)
}

// -------------------------------------------------------------------

// ExchangeRel_ScatterFields

// repeated .substrait.Expression.FieldReference fields = 1;
inline int ExchangeRel_ScatterFields::_internal_fields_size() const {
  return _internal_fields().size();
}
inline int ExchangeRel_ScatterFields::fields_size() const {
  return _internal_fields_size();
}
inline void ExchangeRel_ScatterFields::clear_fields() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fields_.Clear();
}
inline ::substrait::Expression_FieldReference* ExchangeRel_ScatterFields::mutable_fields(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.ExchangeRel.ScatterFields.fields)
  return _internal_mutable_fields()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression_FieldReference>* ExchangeRel_ScatterFields::mutable_fields()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.ExchangeRel.ScatterFields.fields)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_fields();
}
inline const ::substrait::Expression_FieldReference& ExchangeRel_ScatterFields::fields(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ExchangeRel.ScatterFields.fields)
  return _internal_fields().Get(index);
}
inline ::substrait::Expression_FieldReference* ExchangeRel_ScatterFields::add_fields() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::Expression_FieldReference* _add = _internal_mutable_fields()->Add();
  // @@protoc_insertion_point(field_add:substrait.ExchangeRel.ScatterFields.fields)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression_FieldReference>& ExchangeRel_ScatterFields::fields() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.ExchangeRel.ScatterFields.fields)
  return _internal_fields();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression_FieldReference>&
ExchangeRel_ScatterFields::_internal_fields() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fields_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression_FieldReference>*
ExchangeRel_ScatterFields::_internal_mutable_fields() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.fields_;
}

// -------------------------------------------------------------------

// ExchangeRel_SingleBucketExpression

// .substrait.Expression expression = 1;
inline bool ExchangeRel_SingleBucketExpression::has_expression() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.expression_ != nullptr);
  return value;
}
inline void ExchangeRel_SingleBucketExpression::clear_expression() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.expression_ != nullptr) _impl_.expression_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::Expression& ExchangeRel_SingleBucketExpression::_internal_expression() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Expression* p = _impl_.expression_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression&>(::substrait::_Expression_default_instance_);
}
inline const ::substrait::Expression& ExchangeRel_SingleBucketExpression::expression() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ExchangeRel.SingleBucketExpression.expression)
  return _internal_expression();
}
inline void ExchangeRel_SingleBucketExpression::unsafe_arena_set_allocated_expression(::substrait::Expression* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.expression_);
  }
  _impl_.expression_ = reinterpret_cast<::substrait::Expression*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ExchangeRel.SingleBucketExpression.expression)
}
inline ::substrait::Expression* ExchangeRel_SingleBucketExpression::release_expression() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Expression* released = _impl_.expression_;
  _impl_.expression_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Expression* ExchangeRel_SingleBucketExpression::unsafe_arena_release_expression() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.ExchangeRel.SingleBucketExpression.expression)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Expression* temp = _impl_.expression_;
  _impl_.expression_ = nullptr;
  return temp;
}
inline ::substrait::Expression* ExchangeRel_SingleBucketExpression::_internal_mutable_expression() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.expression_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Expression>(GetArena());
    _impl_.expression_ = reinterpret_cast<::substrait::Expression*>(p);
  }
  return _impl_.expression_;
}
inline ::substrait::Expression* ExchangeRel_SingleBucketExpression::mutable_expression() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::Expression* _msg = _internal_mutable_expression();
  // @@protoc_insertion_point(field_mutable:substrait.ExchangeRel.SingleBucketExpression.expression)
  return _msg;
}
inline void ExchangeRel_SingleBucketExpression::set_allocated_expression(::substrait::Expression* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.expression_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.expression_ = reinterpret_cast<::substrait::Expression*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.ExchangeRel.SingleBucketExpression.expression)
}

// -------------------------------------------------------------------

// ExchangeRel_MultiBucketExpression

// .substrait.Expression expression = 1;
inline bool ExchangeRel_MultiBucketExpression::has_expression() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.expression_ != nullptr);
  return value;
}
inline void ExchangeRel_MultiBucketExpression::clear_expression() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.expression_ != nullptr) _impl_.expression_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::Expression& ExchangeRel_MultiBucketExpression::_internal_expression() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Expression* p = _impl_.expression_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression&>(::substrait::_Expression_default_instance_);
}
inline const ::substrait::Expression& ExchangeRel_MultiBucketExpression::expression() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ExchangeRel.MultiBucketExpression.expression)
  return _internal_expression();
}
inline void ExchangeRel_MultiBucketExpression::unsafe_arena_set_allocated_expression(::substrait::Expression* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.expression_);
  }
  _impl_.expression_ = reinterpret_cast<::substrait::Expression*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ExchangeRel.MultiBucketExpression.expression)
}
inline ::substrait::Expression* ExchangeRel_MultiBucketExpression::release_expression() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Expression* released = _impl_.expression_;
  _impl_.expression_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Expression* ExchangeRel_MultiBucketExpression::unsafe_arena_release_expression() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.ExchangeRel.MultiBucketExpression.expression)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Expression* temp = _impl_.expression_;
  _impl_.expression_ = nullptr;
  return temp;
}
inline ::substrait::Expression* ExchangeRel_MultiBucketExpression::_internal_mutable_expression() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.expression_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Expression>(GetArena());
    _impl_.expression_ = reinterpret_cast<::substrait::Expression*>(p);
  }
  return _impl_.expression_;
}
inline ::substrait::Expression* ExchangeRel_MultiBucketExpression::mutable_expression() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::Expression* _msg = _internal_mutable_expression();
  // @@protoc_insertion_point(field_mutable:substrait.ExchangeRel.MultiBucketExpression.expression)
  return _msg;
}
inline void ExchangeRel_MultiBucketExpression::set_allocated_expression(::substrait::Expression* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.expression_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.expression_ = reinterpret_cast<::substrait::Expression*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.ExchangeRel.MultiBucketExpression.expression)
}

// bool constrained_to_count = 2;
inline void ExchangeRel_MultiBucketExpression::clear_constrained_to_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.constrained_to_count_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool ExchangeRel_MultiBucketExpression::constrained_to_count() const {
  // @@protoc_insertion_point(field_get:substrait.ExchangeRel.MultiBucketExpression.constrained_to_count)
  return _internal_constrained_to_count();
}
inline void ExchangeRel_MultiBucketExpression::set_constrained_to_count(bool value) {
  _internal_set_constrained_to_count(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:substrait.ExchangeRel.MultiBucketExpression.constrained_to_count)
}
inline bool ExchangeRel_MultiBucketExpression::_internal_constrained_to_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.constrained_to_count_;
}
inline void ExchangeRel_MultiBucketExpression::_internal_set_constrained_to_count(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.constrained_to_count_ = value;
}

// -------------------------------------------------------------------

// ExchangeRel_Broadcast

// -------------------------------------------------------------------

// ExchangeRel_RoundRobin

// bool exact = 1;
inline void ExchangeRel_RoundRobin::clear_exact() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.exact_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool ExchangeRel_RoundRobin::exact() const {
  // @@protoc_insertion_point(field_get:substrait.ExchangeRel.RoundRobin.exact)
  return _internal_exact();
}
inline void ExchangeRel_RoundRobin::set_exact(bool value) {
  _internal_set_exact(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:substrait.ExchangeRel.RoundRobin.exact)
}
inline bool ExchangeRel_RoundRobin::_internal_exact() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.exact_;
}
inline void ExchangeRel_RoundRobin::_internal_set_exact(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.exact_ = value;
}

// -------------------------------------------------------------------

// ExchangeRel_ExchangeTarget

// repeated int32 partition_id = 1;
inline int ExchangeRel_ExchangeTarget::_internal_partition_id_size() const {
  return _internal_partition_id().size();
}
inline int ExchangeRel_ExchangeTarget::partition_id_size() const {
  return _internal_partition_id_size();
}
inline void ExchangeRel_ExchangeTarget::clear_partition_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.partition_id_.Clear();
}
inline ::int32_t ExchangeRel_ExchangeTarget::partition_id(int index) const {
  // @@protoc_insertion_point(field_get:substrait.ExchangeRel.ExchangeTarget.partition_id)
  return _internal_partition_id().Get(index);
}
inline void ExchangeRel_ExchangeTarget::set_partition_id(int index, ::int32_t value) {
  _internal_mutable_partition_id()->Set(index, value);
  // @@protoc_insertion_point(field_set:substrait.ExchangeRel.ExchangeTarget.partition_id)
}
inline void ExchangeRel_ExchangeTarget::add_partition_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_partition_id()->Add(value);
  // @@protoc_insertion_point(field_add:substrait.ExchangeRel.ExchangeTarget.partition_id)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& ExchangeRel_ExchangeTarget::partition_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.ExchangeRel.ExchangeTarget.partition_id)
  return _internal_partition_id();
}
inline ::google::protobuf::RepeatedField<::int32_t>* ExchangeRel_ExchangeTarget::mutable_partition_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.ExchangeRel.ExchangeTarget.partition_id)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_partition_id();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
ExchangeRel_ExchangeTarget::_internal_partition_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.partition_id_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* ExchangeRel_ExchangeTarget::_internal_mutable_partition_id() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.partition_id_;
}

// string uri = 2;
inline bool ExchangeRel_ExchangeTarget::has_uri() const {
  return target_type_case() == kUri;
}
inline void ExchangeRel_ExchangeTarget::set_has_uri() {
  _impl_._oneof_case_[0] = kUri;
}
inline void ExchangeRel_ExchangeTarget::clear_uri() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (target_type_case() == kUri) {
    _impl_.target_type_.uri_.Destroy();
    clear_has_target_type();
  }
}
inline const std::string& ExchangeRel_ExchangeTarget::uri() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ExchangeRel.ExchangeTarget.uri)
  return _internal_uri();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ExchangeRel_ExchangeTarget::set_uri(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (target_type_case() != kUri) {
    clear_target_type();

    set_has_uri();
    _impl_.target_type_.uri_.InitDefault();
  }
  _impl_.target_type_.uri_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:substrait.ExchangeRel.ExchangeTarget.uri)
}
inline std::string* ExchangeRel_ExchangeTarget::mutable_uri() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:substrait.ExchangeRel.ExchangeTarget.uri)
  return _s;
}
inline const std::string& ExchangeRel_ExchangeTarget::_internal_uri() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (target_type_case() != kUri) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.target_type_.uri_.Get();
}
inline void ExchangeRel_ExchangeTarget::_internal_set_uri(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (target_type_case() != kUri) {
    clear_target_type();

    set_has_uri();
    _impl_.target_type_.uri_.InitDefault();
  }
  _impl_.target_type_.uri_.Set(value, GetArena());
}
inline std::string* ExchangeRel_ExchangeTarget::_internal_mutable_uri() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (target_type_case() != kUri) {
    clear_target_type();

    set_has_uri();
    _impl_.target_type_.uri_.InitDefault();
  }
  return _impl_.target_type_.uri_.Mutable( GetArena());
}
inline std::string* ExchangeRel_ExchangeTarget::release_uri() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.ExchangeRel.ExchangeTarget.uri)
  if (target_type_case() != kUri) {
    return nullptr;
  }
  clear_has_target_type();
  return _impl_.target_type_.uri_.Release();
}
inline void ExchangeRel_ExchangeTarget::set_allocated_uri(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_target_type()) {
    clear_target_type();
  }
  if (value != nullptr) {
    set_has_uri();
    _impl_.target_type_.uri_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:substrait.ExchangeRel.ExchangeTarget.uri)
}

// .google.protobuf.Any extended = 3;
inline bool ExchangeRel_ExchangeTarget::has_extended() const {
  return target_type_case() == kExtended;
}
inline bool ExchangeRel_ExchangeTarget::_internal_has_extended() const {
  return target_type_case() == kExtended;
}
inline void ExchangeRel_ExchangeTarget::set_has_extended() {
  _impl_._oneof_case_[0] = kExtended;
}
inline ::google::protobuf::Any* ExchangeRel_ExchangeTarget::release_extended() {
  // @@protoc_insertion_point(field_release:substrait.ExchangeRel.ExchangeTarget.extended)
  if (target_type_case() == kExtended) {
    clear_has_target_type();
    auto* temp = _impl_.target_type_.extended_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.target_type_.extended_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Any& ExchangeRel_ExchangeTarget::_internal_extended() const {
  return target_type_case() == kExtended ? *_impl_.target_type_.extended_ : reinterpret_cast<::google::protobuf::Any&>(::google::protobuf::_Any_default_instance_);
}
inline const ::google::protobuf::Any& ExchangeRel_ExchangeTarget::extended() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ExchangeRel.ExchangeTarget.extended)
  return _internal_extended();
}
inline ::google::protobuf::Any* ExchangeRel_ExchangeTarget::unsafe_arena_release_extended() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.ExchangeRel.ExchangeTarget.extended)
  if (target_type_case() == kExtended) {
    clear_has_target_type();
    auto* temp = _impl_.target_type_.extended_;
    _impl_.target_type_.extended_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ExchangeRel_ExchangeTarget::unsafe_arena_set_allocated_extended(::google::protobuf::Any* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_target_type();
  if (value) {
    set_has_extended();
    _impl_.target_type_.extended_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ExchangeRel.ExchangeTarget.extended)
}
inline ::google::protobuf::Any* ExchangeRel_ExchangeTarget::_internal_mutable_extended() {
  if (target_type_case() != kExtended) {
    clear_target_type();
    set_has_extended();
    _impl_.target_type_.extended_ =
        ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Any>(GetArena());
  }
  return _impl_.target_type_.extended_;
}
inline ::google::protobuf::Any* ExchangeRel_ExchangeTarget::mutable_extended() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Any* _msg = _internal_mutable_extended();
  // @@protoc_insertion_point(field_mutable:substrait.ExchangeRel.ExchangeTarget.extended)
  return _msg;
}

inline bool ExchangeRel_ExchangeTarget::has_target_type() const {
  return target_type_case() != TARGET_TYPE_NOT_SET;
}
inline void ExchangeRel_ExchangeTarget::clear_has_target_type() {
  _impl_._oneof_case_[0] = TARGET_TYPE_NOT_SET;
}
inline ExchangeRel_ExchangeTarget::TargetTypeCase ExchangeRel_ExchangeTarget::target_type_case() const {
  return ExchangeRel_ExchangeTarget::TargetTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ExchangeRel

// .substrait.RelCommon common = 1;
inline bool ExchangeRel::has_common() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.common_ != nullptr);
  return value;
}
inline void ExchangeRel::clear_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.common_ != nullptr) _impl_.common_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::RelCommon& ExchangeRel::_internal_common() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::RelCommon* p = _impl_.common_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::RelCommon&>(::substrait::_RelCommon_default_instance_);
}
inline const ::substrait::RelCommon& ExchangeRel::common() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ExchangeRel.common)
  return _internal_common();
}
inline void ExchangeRel::unsafe_arena_set_allocated_common(::substrait::RelCommon* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.common_);
  }
  _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ExchangeRel.common)
}
inline ::substrait::RelCommon* ExchangeRel::release_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::RelCommon* released = _impl_.common_;
  _impl_.common_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::RelCommon* ExchangeRel::unsafe_arena_release_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.ExchangeRel.common)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::RelCommon* temp = _impl_.common_;
  _impl_.common_ = nullptr;
  return temp;
}
inline ::substrait::RelCommon* ExchangeRel::_internal_mutable_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.common_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::RelCommon>(GetArena());
    _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(p);
  }
  return _impl_.common_;
}
inline ::substrait::RelCommon* ExchangeRel::mutable_common() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::RelCommon* _msg = _internal_mutable_common();
  // @@protoc_insertion_point(field_mutable:substrait.ExchangeRel.common)
  return _msg;
}
inline void ExchangeRel::set_allocated_common(::substrait::RelCommon* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.common_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.ExchangeRel.common)
}

// .substrait.Rel input = 2;
inline bool ExchangeRel::has_input() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.input_ != nullptr);
  return value;
}
inline void ExchangeRel::clear_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.input_ != nullptr) _impl_.input_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::substrait::Rel& ExchangeRel::_internal_input() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Rel* p = _impl_.input_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Rel&>(::substrait::_Rel_default_instance_);
}
inline const ::substrait::Rel& ExchangeRel::input() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ExchangeRel.input)
  return _internal_input();
}
inline void ExchangeRel::unsafe_arena_set_allocated_input(::substrait::Rel* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.input_);
  }
  _impl_.input_ = reinterpret_cast<::substrait::Rel*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ExchangeRel.input)
}
inline ::substrait::Rel* ExchangeRel::release_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Rel* released = _impl_.input_;
  _impl_.input_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Rel* ExchangeRel::unsafe_arena_release_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.ExchangeRel.input)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Rel* temp = _impl_.input_;
  _impl_.input_ = nullptr;
  return temp;
}
inline ::substrait::Rel* ExchangeRel::_internal_mutable_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.input_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Rel>(GetArena());
    _impl_.input_ = reinterpret_cast<::substrait::Rel*>(p);
  }
  return _impl_.input_;
}
inline ::substrait::Rel* ExchangeRel::mutable_input() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::substrait::Rel* _msg = _internal_mutable_input();
  // @@protoc_insertion_point(field_mutable:substrait.ExchangeRel.input)
  return _msg;
}
inline void ExchangeRel::set_allocated_input(::substrait::Rel* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.input_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.input_ = reinterpret_cast<::substrait::Rel*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.ExchangeRel.input)
}

// int32 partition_count = 3;
inline void ExchangeRel::clear_partition_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.partition_count_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t ExchangeRel::partition_count() const {
  // @@protoc_insertion_point(field_get:substrait.ExchangeRel.partition_count)
  return _internal_partition_count();
}
inline void ExchangeRel::set_partition_count(::int32_t value) {
  _internal_set_partition_count(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:substrait.ExchangeRel.partition_count)
}
inline ::int32_t ExchangeRel::_internal_partition_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.partition_count_;
}
inline void ExchangeRel::_internal_set_partition_count(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.partition_count_ = value;
}

// repeated .substrait.ExchangeRel.ExchangeTarget targets = 4;
inline int ExchangeRel::_internal_targets_size() const {
  return _internal_targets().size();
}
inline int ExchangeRel::targets_size() const {
  return _internal_targets_size();
}
inline void ExchangeRel::clear_targets() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.targets_.Clear();
}
inline ::substrait::ExchangeRel_ExchangeTarget* ExchangeRel::mutable_targets(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.ExchangeRel.targets)
  return _internal_mutable_targets()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::ExchangeRel_ExchangeTarget>* ExchangeRel::mutable_targets()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.ExchangeRel.targets)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_targets();
}
inline const ::substrait::ExchangeRel_ExchangeTarget& ExchangeRel::targets(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ExchangeRel.targets)
  return _internal_targets().Get(index);
}
inline ::substrait::ExchangeRel_ExchangeTarget* ExchangeRel::add_targets() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::ExchangeRel_ExchangeTarget* _add = _internal_mutable_targets()->Add();
  // @@protoc_insertion_point(field_add:substrait.ExchangeRel.targets)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::ExchangeRel_ExchangeTarget>& ExchangeRel::targets() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.ExchangeRel.targets)
  return _internal_targets();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::ExchangeRel_ExchangeTarget>&
ExchangeRel::_internal_targets() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.targets_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::ExchangeRel_ExchangeTarget>*
ExchangeRel::_internal_mutable_targets() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.targets_;
}

// .substrait.ExchangeRel.ScatterFields scatter_by_fields = 5;
inline bool ExchangeRel::has_scatter_by_fields() const {
  return exchange_kind_case() == kScatterByFields;
}
inline bool ExchangeRel::_internal_has_scatter_by_fields() const {
  return exchange_kind_case() == kScatterByFields;
}
inline void ExchangeRel::set_has_scatter_by_fields() {
  _impl_._oneof_case_[0] = kScatterByFields;
}
inline void ExchangeRel::clear_scatter_by_fields() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (exchange_kind_case() == kScatterByFields) {
    if (GetArena() == nullptr) {
      delete _impl_.exchange_kind_.scatter_by_fields_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.exchange_kind_.scatter_by_fields_);
    }
    clear_has_exchange_kind();
  }
}
inline ::substrait::ExchangeRel_ScatterFields* ExchangeRel::release_scatter_by_fields() {
  // @@protoc_insertion_point(field_release:substrait.ExchangeRel.scatter_by_fields)
  if (exchange_kind_case() == kScatterByFields) {
    clear_has_exchange_kind();
    auto* temp = _impl_.exchange_kind_.scatter_by_fields_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.exchange_kind_.scatter_by_fields_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::ExchangeRel_ScatterFields& ExchangeRel::_internal_scatter_by_fields() const {
  return exchange_kind_case() == kScatterByFields ? *_impl_.exchange_kind_.scatter_by_fields_ : reinterpret_cast<::substrait::ExchangeRel_ScatterFields&>(::substrait::_ExchangeRel_ScatterFields_default_instance_);
}
inline const ::substrait::ExchangeRel_ScatterFields& ExchangeRel::scatter_by_fields() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ExchangeRel.scatter_by_fields)
  return _internal_scatter_by_fields();
}
inline ::substrait::ExchangeRel_ScatterFields* ExchangeRel::unsafe_arena_release_scatter_by_fields() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.ExchangeRel.scatter_by_fields)
  if (exchange_kind_case() == kScatterByFields) {
    clear_has_exchange_kind();
    auto* temp = _impl_.exchange_kind_.scatter_by_fields_;
    _impl_.exchange_kind_.scatter_by_fields_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ExchangeRel::unsafe_arena_set_allocated_scatter_by_fields(::substrait::ExchangeRel_ScatterFields* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_exchange_kind();
  if (value) {
    set_has_scatter_by_fields();
    _impl_.exchange_kind_.scatter_by_fields_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ExchangeRel.scatter_by_fields)
}
inline ::substrait::ExchangeRel_ScatterFields* ExchangeRel::_internal_mutable_scatter_by_fields() {
  if (exchange_kind_case() != kScatterByFields) {
    clear_exchange_kind();
    set_has_scatter_by_fields();
    _impl_.exchange_kind_.scatter_by_fields_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::ExchangeRel_ScatterFields>(GetArena());
  }
  return _impl_.exchange_kind_.scatter_by_fields_;
}
inline ::substrait::ExchangeRel_ScatterFields* ExchangeRel::mutable_scatter_by_fields() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::ExchangeRel_ScatterFields* _msg = _internal_mutable_scatter_by_fields();
  // @@protoc_insertion_point(field_mutable:substrait.ExchangeRel.scatter_by_fields)
  return _msg;
}

// .substrait.ExchangeRel.SingleBucketExpression single_target = 6;
inline bool ExchangeRel::has_single_target() const {
  return exchange_kind_case() == kSingleTarget;
}
inline bool ExchangeRel::_internal_has_single_target() const {
  return exchange_kind_case() == kSingleTarget;
}
inline void ExchangeRel::set_has_single_target() {
  _impl_._oneof_case_[0] = kSingleTarget;
}
inline void ExchangeRel::clear_single_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (exchange_kind_case() == kSingleTarget) {
    if (GetArena() == nullptr) {
      delete _impl_.exchange_kind_.single_target_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.exchange_kind_.single_target_);
    }
    clear_has_exchange_kind();
  }
}
inline ::substrait::ExchangeRel_SingleBucketExpression* ExchangeRel::release_single_target() {
  // @@protoc_insertion_point(field_release:substrait.ExchangeRel.single_target)
  if (exchange_kind_case() == kSingleTarget) {
    clear_has_exchange_kind();
    auto* temp = _impl_.exchange_kind_.single_target_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.exchange_kind_.single_target_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::ExchangeRel_SingleBucketExpression& ExchangeRel::_internal_single_target() const {
  return exchange_kind_case() == kSingleTarget ? *_impl_.exchange_kind_.single_target_ : reinterpret_cast<::substrait::ExchangeRel_SingleBucketExpression&>(::substrait::_ExchangeRel_SingleBucketExpression_default_instance_);
}
inline const ::substrait::ExchangeRel_SingleBucketExpression& ExchangeRel::single_target() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ExchangeRel.single_target)
  return _internal_single_target();
}
inline ::substrait::ExchangeRel_SingleBucketExpression* ExchangeRel::unsafe_arena_release_single_target() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.ExchangeRel.single_target)
  if (exchange_kind_case() == kSingleTarget) {
    clear_has_exchange_kind();
    auto* temp = _impl_.exchange_kind_.single_target_;
    _impl_.exchange_kind_.single_target_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ExchangeRel::unsafe_arena_set_allocated_single_target(::substrait::ExchangeRel_SingleBucketExpression* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_exchange_kind();
  if (value) {
    set_has_single_target();
    _impl_.exchange_kind_.single_target_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ExchangeRel.single_target)
}
inline ::substrait::ExchangeRel_SingleBucketExpression* ExchangeRel::_internal_mutable_single_target() {
  if (exchange_kind_case() != kSingleTarget) {
    clear_exchange_kind();
    set_has_single_target();
    _impl_.exchange_kind_.single_target_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::ExchangeRel_SingleBucketExpression>(GetArena());
  }
  return _impl_.exchange_kind_.single_target_;
}
inline ::substrait::ExchangeRel_SingleBucketExpression* ExchangeRel::mutable_single_target() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::ExchangeRel_SingleBucketExpression* _msg = _internal_mutable_single_target();
  // @@protoc_insertion_point(field_mutable:substrait.ExchangeRel.single_target)
  return _msg;
}

// .substrait.ExchangeRel.MultiBucketExpression multi_target = 7;
inline bool ExchangeRel::has_multi_target() const {
  return exchange_kind_case() == kMultiTarget;
}
inline bool ExchangeRel::_internal_has_multi_target() const {
  return exchange_kind_case() == kMultiTarget;
}
inline void ExchangeRel::set_has_multi_target() {
  _impl_._oneof_case_[0] = kMultiTarget;
}
inline void ExchangeRel::clear_multi_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (exchange_kind_case() == kMultiTarget) {
    if (GetArena() == nullptr) {
      delete _impl_.exchange_kind_.multi_target_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.exchange_kind_.multi_target_);
    }
    clear_has_exchange_kind();
  }
}
inline ::substrait::ExchangeRel_MultiBucketExpression* ExchangeRel::release_multi_target() {
  // @@protoc_insertion_point(field_release:substrait.ExchangeRel.multi_target)
  if (exchange_kind_case() == kMultiTarget) {
    clear_has_exchange_kind();
    auto* temp = _impl_.exchange_kind_.multi_target_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.exchange_kind_.multi_target_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::ExchangeRel_MultiBucketExpression& ExchangeRel::_internal_multi_target() const {
  return exchange_kind_case() == kMultiTarget ? *_impl_.exchange_kind_.multi_target_ : reinterpret_cast<::substrait::ExchangeRel_MultiBucketExpression&>(::substrait::_ExchangeRel_MultiBucketExpression_default_instance_);
}
inline const ::substrait::ExchangeRel_MultiBucketExpression& ExchangeRel::multi_target() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ExchangeRel.multi_target)
  return _internal_multi_target();
}
inline ::substrait::ExchangeRel_MultiBucketExpression* ExchangeRel::unsafe_arena_release_multi_target() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.ExchangeRel.multi_target)
  if (exchange_kind_case() == kMultiTarget) {
    clear_has_exchange_kind();
    auto* temp = _impl_.exchange_kind_.multi_target_;
    _impl_.exchange_kind_.multi_target_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ExchangeRel::unsafe_arena_set_allocated_multi_target(::substrait::ExchangeRel_MultiBucketExpression* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_exchange_kind();
  if (value) {
    set_has_multi_target();
    _impl_.exchange_kind_.multi_target_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ExchangeRel.multi_target)
}
inline ::substrait::ExchangeRel_MultiBucketExpression* ExchangeRel::_internal_mutable_multi_target() {
  if (exchange_kind_case() != kMultiTarget) {
    clear_exchange_kind();
    set_has_multi_target();
    _impl_.exchange_kind_.multi_target_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::ExchangeRel_MultiBucketExpression>(GetArena());
  }
  return _impl_.exchange_kind_.multi_target_;
}
inline ::substrait::ExchangeRel_MultiBucketExpression* ExchangeRel::mutable_multi_target() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::ExchangeRel_MultiBucketExpression* _msg = _internal_mutable_multi_target();
  // @@protoc_insertion_point(field_mutable:substrait.ExchangeRel.multi_target)
  return _msg;
}

// .substrait.ExchangeRel.RoundRobin round_robin = 8;
inline bool ExchangeRel::has_round_robin() const {
  return exchange_kind_case() == kRoundRobin;
}
inline bool ExchangeRel::_internal_has_round_robin() const {
  return exchange_kind_case() == kRoundRobin;
}
inline void ExchangeRel::set_has_round_robin() {
  _impl_._oneof_case_[0] = kRoundRobin;
}
inline void ExchangeRel::clear_round_robin() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (exchange_kind_case() == kRoundRobin) {
    if (GetArena() == nullptr) {
      delete _impl_.exchange_kind_.round_robin_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.exchange_kind_.round_robin_);
    }
    clear_has_exchange_kind();
  }
}
inline ::substrait::ExchangeRel_RoundRobin* ExchangeRel::release_round_robin() {
  // @@protoc_insertion_point(field_release:substrait.ExchangeRel.round_robin)
  if (exchange_kind_case() == kRoundRobin) {
    clear_has_exchange_kind();
    auto* temp = _impl_.exchange_kind_.round_robin_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.exchange_kind_.round_robin_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::ExchangeRel_RoundRobin& ExchangeRel::_internal_round_robin() const {
  return exchange_kind_case() == kRoundRobin ? *_impl_.exchange_kind_.round_robin_ : reinterpret_cast<::substrait::ExchangeRel_RoundRobin&>(::substrait::_ExchangeRel_RoundRobin_default_instance_);
}
inline const ::substrait::ExchangeRel_RoundRobin& ExchangeRel::round_robin() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ExchangeRel.round_robin)
  return _internal_round_robin();
}
inline ::substrait::ExchangeRel_RoundRobin* ExchangeRel::unsafe_arena_release_round_robin() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.ExchangeRel.round_robin)
  if (exchange_kind_case() == kRoundRobin) {
    clear_has_exchange_kind();
    auto* temp = _impl_.exchange_kind_.round_robin_;
    _impl_.exchange_kind_.round_robin_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ExchangeRel::unsafe_arena_set_allocated_round_robin(::substrait::ExchangeRel_RoundRobin* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_exchange_kind();
  if (value) {
    set_has_round_robin();
    _impl_.exchange_kind_.round_robin_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ExchangeRel.round_robin)
}
inline ::substrait::ExchangeRel_RoundRobin* ExchangeRel::_internal_mutable_round_robin() {
  if (exchange_kind_case() != kRoundRobin) {
    clear_exchange_kind();
    set_has_round_robin();
    _impl_.exchange_kind_.round_robin_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::ExchangeRel_RoundRobin>(GetArena());
  }
  return _impl_.exchange_kind_.round_robin_;
}
inline ::substrait::ExchangeRel_RoundRobin* ExchangeRel::mutable_round_robin() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::ExchangeRel_RoundRobin* _msg = _internal_mutable_round_robin();
  // @@protoc_insertion_point(field_mutable:substrait.ExchangeRel.round_robin)
  return _msg;
}

// .substrait.ExchangeRel.Broadcast broadcast = 9;
inline bool ExchangeRel::has_broadcast() const {
  return exchange_kind_case() == kBroadcast;
}
inline bool ExchangeRel::_internal_has_broadcast() const {
  return exchange_kind_case() == kBroadcast;
}
inline void ExchangeRel::set_has_broadcast() {
  _impl_._oneof_case_[0] = kBroadcast;
}
inline void ExchangeRel::clear_broadcast() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (exchange_kind_case() == kBroadcast) {
    if (GetArena() == nullptr) {
      delete _impl_.exchange_kind_.broadcast_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.exchange_kind_.broadcast_);
    }
    clear_has_exchange_kind();
  }
}
inline ::substrait::ExchangeRel_Broadcast* ExchangeRel::release_broadcast() {
  // @@protoc_insertion_point(field_release:substrait.ExchangeRel.broadcast)
  if (exchange_kind_case() == kBroadcast) {
    clear_has_exchange_kind();
    auto* temp = _impl_.exchange_kind_.broadcast_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.exchange_kind_.broadcast_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::ExchangeRel_Broadcast& ExchangeRel::_internal_broadcast() const {
  return exchange_kind_case() == kBroadcast ? *_impl_.exchange_kind_.broadcast_ : reinterpret_cast<::substrait::ExchangeRel_Broadcast&>(::substrait::_ExchangeRel_Broadcast_default_instance_);
}
inline const ::substrait::ExchangeRel_Broadcast& ExchangeRel::broadcast() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ExchangeRel.broadcast)
  return _internal_broadcast();
}
inline ::substrait::ExchangeRel_Broadcast* ExchangeRel::unsafe_arena_release_broadcast() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.ExchangeRel.broadcast)
  if (exchange_kind_case() == kBroadcast) {
    clear_has_exchange_kind();
    auto* temp = _impl_.exchange_kind_.broadcast_;
    _impl_.exchange_kind_.broadcast_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ExchangeRel::unsafe_arena_set_allocated_broadcast(::substrait::ExchangeRel_Broadcast* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_exchange_kind();
  if (value) {
    set_has_broadcast();
    _impl_.exchange_kind_.broadcast_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ExchangeRel.broadcast)
}
inline ::substrait::ExchangeRel_Broadcast* ExchangeRel::_internal_mutable_broadcast() {
  if (exchange_kind_case() != kBroadcast) {
    clear_exchange_kind();
    set_has_broadcast();
    _impl_.exchange_kind_.broadcast_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::ExchangeRel_Broadcast>(GetArena());
  }
  return _impl_.exchange_kind_.broadcast_;
}
inline ::substrait::ExchangeRel_Broadcast* ExchangeRel::mutable_broadcast() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::ExchangeRel_Broadcast* _msg = _internal_mutable_broadcast();
  // @@protoc_insertion_point(field_mutable:substrait.ExchangeRel.broadcast)
  return _msg;
}

// .substrait.extensions.AdvancedExtension advanced_extension = 10;
inline bool ExchangeRel::has_advanced_extension() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.advanced_extension_ != nullptr);
  return value;
}
inline const ::substrait::extensions::AdvancedExtension& ExchangeRel::_internal_advanced_extension() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::extensions::AdvancedExtension* p = _impl_.advanced_extension_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::extensions::AdvancedExtension&>(::substrait::extensions::_AdvancedExtension_default_instance_);
}
inline const ::substrait::extensions::AdvancedExtension& ExchangeRel::advanced_extension() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ExchangeRel.advanced_extension)
  return _internal_advanced_extension();
}
inline void ExchangeRel::unsafe_arena_set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.advanced_extension_);
  }
  _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ExchangeRel.advanced_extension)
}
inline ::substrait::extensions::AdvancedExtension* ExchangeRel::release_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::substrait::extensions::AdvancedExtension* released = _impl_.advanced_extension_;
  _impl_.advanced_extension_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::extensions::AdvancedExtension* ExchangeRel::unsafe_arena_release_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.ExchangeRel.advanced_extension)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::substrait::extensions::AdvancedExtension* temp = _impl_.advanced_extension_;
  _impl_.advanced_extension_ = nullptr;
  return temp;
}
inline ::substrait::extensions::AdvancedExtension* ExchangeRel::_internal_mutable_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.advanced_extension_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::extensions::AdvancedExtension>(GetArena());
    _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(p);
  }
  return _impl_.advanced_extension_;
}
inline ::substrait::extensions::AdvancedExtension* ExchangeRel::mutable_advanced_extension() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::substrait::extensions::AdvancedExtension* _msg = _internal_mutable_advanced_extension();
  // @@protoc_insertion_point(field_mutable:substrait.ExchangeRel.advanced_extension)
  return _msg;
}
inline void ExchangeRel::set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.advanced_extension_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.ExchangeRel.advanced_extension)
}

inline bool ExchangeRel::has_exchange_kind() const {
  return exchange_kind_case() != EXCHANGE_KIND_NOT_SET;
}
inline void ExchangeRel::clear_has_exchange_kind() {
  _impl_._oneof_case_[0] = EXCHANGE_KIND_NOT_SET;
}
inline ExchangeRel::ExchangeKindCase ExchangeRel::exchange_kind_case() const {
  return ExchangeRel::ExchangeKindCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ExpandRel_ExpandField

// .substrait.ExpandRel.SwitchingField switching_field = 2;
inline bool ExpandRel_ExpandField::has_switching_field() const {
  return field_type_case() == kSwitchingField;
}
inline bool ExpandRel_ExpandField::_internal_has_switching_field() const {
  return field_type_case() == kSwitchingField;
}
inline void ExpandRel_ExpandField::set_has_switching_field() {
  _impl_._oneof_case_[0] = kSwitchingField;
}
inline void ExpandRel_ExpandField::clear_switching_field() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (field_type_case() == kSwitchingField) {
    if (GetArena() == nullptr) {
      delete _impl_.field_type_.switching_field_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.field_type_.switching_field_);
    }
    clear_has_field_type();
  }
}
inline ::substrait::ExpandRel_SwitchingField* ExpandRel_ExpandField::release_switching_field() {
  // @@protoc_insertion_point(field_release:substrait.ExpandRel.ExpandField.switching_field)
  if (field_type_case() == kSwitchingField) {
    clear_has_field_type();
    auto* temp = _impl_.field_type_.switching_field_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.field_type_.switching_field_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::ExpandRel_SwitchingField& ExpandRel_ExpandField::_internal_switching_field() const {
  return field_type_case() == kSwitchingField ? *_impl_.field_type_.switching_field_ : reinterpret_cast<::substrait::ExpandRel_SwitchingField&>(::substrait::_ExpandRel_SwitchingField_default_instance_);
}
inline const ::substrait::ExpandRel_SwitchingField& ExpandRel_ExpandField::switching_field() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ExpandRel.ExpandField.switching_field)
  return _internal_switching_field();
}
inline ::substrait::ExpandRel_SwitchingField* ExpandRel_ExpandField::unsafe_arena_release_switching_field() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.ExpandRel.ExpandField.switching_field)
  if (field_type_case() == kSwitchingField) {
    clear_has_field_type();
    auto* temp = _impl_.field_type_.switching_field_;
    _impl_.field_type_.switching_field_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ExpandRel_ExpandField::unsafe_arena_set_allocated_switching_field(::substrait::ExpandRel_SwitchingField* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_field_type();
  if (value) {
    set_has_switching_field();
    _impl_.field_type_.switching_field_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ExpandRel.ExpandField.switching_field)
}
inline ::substrait::ExpandRel_SwitchingField* ExpandRel_ExpandField::_internal_mutable_switching_field() {
  if (field_type_case() != kSwitchingField) {
    clear_field_type();
    set_has_switching_field();
    _impl_.field_type_.switching_field_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::ExpandRel_SwitchingField>(GetArena());
  }
  return _impl_.field_type_.switching_field_;
}
inline ::substrait::ExpandRel_SwitchingField* ExpandRel_ExpandField::mutable_switching_field() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::ExpandRel_SwitchingField* _msg = _internal_mutable_switching_field();
  // @@protoc_insertion_point(field_mutable:substrait.ExpandRel.ExpandField.switching_field)
  return _msg;
}

// .substrait.Expression consistent_field = 3;
inline bool ExpandRel_ExpandField::has_consistent_field() const {
  return field_type_case() == kConsistentField;
}
inline bool ExpandRel_ExpandField::_internal_has_consistent_field() const {
  return field_type_case() == kConsistentField;
}
inline void ExpandRel_ExpandField::set_has_consistent_field() {
  _impl_._oneof_case_[0] = kConsistentField;
}
inline void ExpandRel_ExpandField::clear_consistent_field() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (field_type_case() == kConsistentField) {
    if (GetArena() == nullptr) {
      delete _impl_.field_type_.consistent_field_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.field_type_.consistent_field_);
    }
    clear_has_field_type();
  }
}
inline ::substrait::Expression* ExpandRel_ExpandField::release_consistent_field() {
  // @@protoc_insertion_point(field_release:substrait.ExpandRel.ExpandField.consistent_field)
  if (field_type_case() == kConsistentField) {
    clear_has_field_type();
    auto* temp = _impl_.field_type_.consistent_field_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.field_type_.consistent_field_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression& ExpandRel_ExpandField::_internal_consistent_field() const {
  return field_type_case() == kConsistentField ? *_impl_.field_type_.consistent_field_ : reinterpret_cast<::substrait::Expression&>(::substrait::_Expression_default_instance_);
}
inline const ::substrait::Expression& ExpandRel_ExpandField::consistent_field() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ExpandRel.ExpandField.consistent_field)
  return _internal_consistent_field();
}
inline ::substrait::Expression* ExpandRel_ExpandField::unsafe_arena_release_consistent_field() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.ExpandRel.ExpandField.consistent_field)
  if (field_type_case() == kConsistentField) {
    clear_has_field_type();
    auto* temp = _impl_.field_type_.consistent_field_;
    _impl_.field_type_.consistent_field_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ExpandRel_ExpandField::unsafe_arena_set_allocated_consistent_field(::substrait::Expression* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_field_type();
  if (value) {
    set_has_consistent_field();
    _impl_.field_type_.consistent_field_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ExpandRel.ExpandField.consistent_field)
}
inline ::substrait::Expression* ExpandRel_ExpandField::_internal_mutable_consistent_field() {
  if (field_type_case() != kConsistentField) {
    clear_field_type();
    set_has_consistent_field();
    _impl_.field_type_.consistent_field_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression>(GetArena());
  }
  return _impl_.field_type_.consistent_field_;
}
inline ::substrait::Expression* ExpandRel_ExpandField::mutable_consistent_field() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression* _msg = _internal_mutable_consistent_field();
  // @@protoc_insertion_point(field_mutable:substrait.ExpandRel.ExpandField.consistent_field)
  return _msg;
}

inline bool ExpandRel_ExpandField::has_field_type() const {
  return field_type_case() != FIELD_TYPE_NOT_SET;
}
inline void ExpandRel_ExpandField::clear_has_field_type() {
  _impl_._oneof_case_[0] = FIELD_TYPE_NOT_SET;
}
inline ExpandRel_ExpandField::FieldTypeCase ExpandRel_ExpandField::field_type_case() const {
  return ExpandRel_ExpandField::FieldTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ExpandRel_SwitchingField

// repeated .substrait.Expression duplicates = 1;
inline int ExpandRel_SwitchingField::_internal_duplicates_size() const {
  return _internal_duplicates().size();
}
inline int ExpandRel_SwitchingField::duplicates_size() const {
  return _internal_duplicates_size();
}
inline void ExpandRel_SwitchingField::clear_duplicates() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.duplicates_.Clear();
}
inline ::substrait::Expression* ExpandRel_SwitchingField::mutable_duplicates(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.ExpandRel.SwitchingField.duplicates)
  return _internal_mutable_duplicates()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression>* ExpandRel_SwitchingField::mutable_duplicates()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.ExpandRel.SwitchingField.duplicates)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_duplicates();
}
inline const ::substrait::Expression& ExpandRel_SwitchingField::duplicates(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ExpandRel.SwitchingField.duplicates)
  return _internal_duplicates().Get(index);
}
inline ::substrait::Expression* ExpandRel_SwitchingField::add_duplicates() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::Expression* _add = _internal_mutable_duplicates()->Add();
  // @@protoc_insertion_point(field_add:substrait.ExpandRel.SwitchingField.duplicates)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression>& ExpandRel_SwitchingField::duplicates() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.ExpandRel.SwitchingField.duplicates)
  return _internal_duplicates();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression>&
ExpandRel_SwitchingField::_internal_duplicates() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.duplicates_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression>*
ExpandRel_SwitchingField::_internal_mutable_duplicates() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.duplicates_;
}

// -------------------------------------------------------------------

// ExpandRel

// .substrait.RelCommon common = 1;
inline bool ExpandRel::has_common() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.common_ != nullptr);
  return value;
}
inline void ExpandRel::clear_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.common_ != nullptr) _impl_.common_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::RelCommon& ExpandRel::_internal_common() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::RelCommon* p = _impl_.common_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::RelCommon&>(::substrait::_RelCommon_default_instance_);
}
inline const ::substrait::RelCommon& ExpandRel::common() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ExpandRel.common)
  return _internal_common();
}
inline void ExpandRel::unsafe_arena_set_allocated_common(::substrait::RelCommon* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.common_);
  }
  _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ExpandRel.common)
}
inline ::substrait::RelCommon* ExpandRel::release_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::RelCommon* released = _impl_.common_;
  _impl_.common_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::RelCommon* ExpandRel::unsafe_arena_release_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.ExpandRel.common)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::RelCommon* temp = _impl_.common_;
  _impl_.common_ = nullptr;
  return temp;
}
inline ::substrait::RelCommon* ExpandRel::_internal_mutable_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.common_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::RelCommon>(GetArena());
    _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(p);
  }
  return _impl_.common_;
}
inline ::substrait::RelCommon* ExpandRel::mutable_common() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::RelCommon* _msg = _internal_mutable_common();
  // @@protoc_insertion_point(field_mutable:substrait.ExpandRel.common)
  return _msg;
}
inline void ExpandRel::set_allocated_common(::substrait::RelCommon* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.common_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.ExpandRel.common)
}

// .substrait.Rel input = 2;
inline bool ExpandRel::has_input() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.input_ != nullptr);
  return value;
}
inline void ExpandRel::clear_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.input_ != nullptr) _impl_.input_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::substrait::Rel& ExpandRel::_internal_input() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Rel* p = _impl_.input_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Rel&>(::substrait::_Rel_default_instance_);
}
inline const ::substrait::Rel& ExpandRel::input() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ExpandRel.input)
  return _internal_input();
}
inline void ExpandRel::unsafe_arena_set_allocated_input(::substrait::Rel* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.input_);
  }
  _impl_.input_ = reinterpret_cast<::substrait::Rel*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ExpandRel.input)
}
inline ::substrait::Rel* ExpandRel::release_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Rel* released = _impl_.input_;
  _impl_.input_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Rel* ExpandRel::unsafe_arena_release_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.ExpandRel.input)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Rel* temp = _impl_.input_;
  _impl_.input_ = nullptr;
  return temp;
}
inline ::substrait::Rel* ExpandRel::_internal_mutable_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.input_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Rel>(GetArena());
    _impl_.input_ = reinterpret_cast<::substrait::Rel*>(p);
  }
  return _impl_.input_;
}
inline ::substrait::Rel* ExpandRel::mutable_input() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::substrait::Rel* _msg = _internal_mutable_input();
  // @@protoc_insertion_point(field_mutable:substrait.ExpandRel.input)
  return _msg;
}
inline void ExpandRel::set_allocated_input(::substrait::Rel* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.input_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.input_ = reinterpret_cast<::substrait::Rel*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.ExpandRel.input)
}

// repeated .substrait.ExpandRel.ExpandField fields = 4;
inline int ExpandRel::_internal_fields_size() const {
  return _internal_fields().size();
}
inline int ExpandRel::fields_size() const {
  return _internal_fields_size();
}
inline void ExpandRel::clear_fields() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fields_.Clear();
}
inline ::substrait::ExpandRel_ExpandField* ExpandRel::mutable_fields(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.ExpandRel.fields)
  return _internal_mutable_fields()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::ExpandRel_ExpandField>* ExpandRel::mutable_fields()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.ExpandRel.fields)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_fields();
}
inline const ::substrait::ExpandRel_ExpandField& ExpandRel::fields(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ExpandRel.fields)
  return _internal_fields().Get(index);
}
inline ::substrait::ExpandRel_ExpandField* ExpandRel::add_fields() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::ExpandRel_ExpandField* _add = _internal_mutable_fields()->Add();
  // @@protoc_insertion_point(field_add:substrait.ExpandRel.fields)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::ExpandRel_ExpandField>& ExpandRel::fields() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.ExpandRel.fields)
  return _internal_fields();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::ExpandRel_ExpandField>&
ExpandRel::_internal_fields() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fields_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::ExpandRel_ExpandField>*
ExpandRel::_internal_mutable_fields() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.fields_;
}

// -------------------------------------------------------------------

// RelRoot

// .substrait.Rel input = 1;
inline bool RelRoot::has_input() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.input_ != nullptr);
  return value;
}
inline void RelRoot::clear_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.input_ != nullptr) _impl_.input_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::Rel& RelRoot::_internal_input() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Rel* p = _impl_.input_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Rel&>(::substrait::_Rel_default_instance_);
}
inline const ::substrait::Rel& RelRoot::input() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.RelRoot.input)
  return _internal_input();
}
inline void RelRoot::unsafe_arena_set_allocated_input(::substrait::Rel* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.input_);
  }
  _impl_.input_ = reinterpret_cast<::substrait::Rel*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.RelRoot.input)
}
inline ::substrait::Rel* RelRoot::release_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Rel* released = _impl_.input_;
  _impl_.input_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Rel* RelRoot::unsafe_arena_release_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.RelRoot.input)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Rel* temp = _impl_.input_;
  _impl_.input_ = nullptr;
  return temp;
}
inline ::substrait::Rel* RelRoot::_internal_mutable_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.input_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Rel>(GetArena());
    _impl_.input_ = reinterpret_cast<::substrait::Rel*>(p);
  }
  return _impl_.input_;
}
inline ::substrait::Rel* RelRoot::mutable_input() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::Rel* _msg = _internal_mutable_input();
  // @@protoc_insertion_point(field_mutable:substrait.RelRoot.input)
  return _msg;
}
inline void RelRoot::set_allocated_input(::substrait::Rel* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.input_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.input_ = reinterpret_cast<::substrait::Rel*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.RelRoot.input)
}

// repeated string names = 2;
inline int RelRoot::_internal_names_size() const {
  return _internal_names().size();
}
inline int RelRoot::names_size() const {
  return _internal_names_size();
}
inline void RelRoot::clear_names() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.names_.Clear();
}
inline std::string* RelRoot::add_names() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_names()->Add();
  // @@protoc_insertion_point(field_add_mutable:substrait.RelRoot.names)
  return _s;
}
inline const std::string& RelRoot::names(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.RelRoot.names)
  return _internal_names().Get(index);
}
inline std::string* RelRoot::mutable_names(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.RelRoot.names)
  return _internal_mutable_names()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void RelRoot::set_names(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_names()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:substrait.RelRoot.names)
}
template <typename Arg_, typename... Args_>
inline void RelRoot::add_names(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_names(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:substrait.RelRoot.names)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RelRoot::names() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.RelRoot.names)
  return _internal_names();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RelRoot::mutable_names() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.RelRoot.names)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_names();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RelRoot::_internal_names() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.names_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RelRoot::_internal_mutable_names() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.names_;
}

// -------------------------------------------------------------------

// Rel

// .substrait.ReadRel read = 1;
inline bool Rel::has_read() const {
  return rel_type_case() == kRead;
}
inline bool Rel::_internal_has_read() const {
  return rel_type_case() == kRead;
}
inline void Rel::set_has_read() {
  _impl_._oneof_case_[0] = kRead;
}
inline void Rel::clear_read() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (rel_type_case() == kRead) {
    if (GetArena() == nullptr) {
      delete _impl_.rel_type_.read_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.rel_type_.read_);
    }
    clear_has_rel_type();
  }
}
inline ::substrait::ReadRel* Rel::release_read() {
  // @@protoc_insertion_point(field_release:substrait.Rel.read)
  if (rel_type_case() == kRead) {
    clear_has_rel_type();
    auto* temp = _impl_.rel_type_.read_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.rel_type_.read_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::ReadRel& Rel::_internal_read() const {
  return rel_type_case() == kRead ? *_impl_.rel_type_.read_ : reinterpret_cast<::substrait::ReadRel&>(::substrait::_ReadRel_default_instance_);
}
inline const ::substrait::ReadRel& Rel::read() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Rel.read)
  return _internal_read();
}
inline ::substrait::ReadRel* Rel::unsafe_arena_release_read() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Rel.read)
  if (rel_type_case() == kRead) {
    clear_has_rel_type();
    auto* temp = _impl_.rel_type_.read_;
    _impl_.rel_type_.read_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Rel::unsafe_arena_set_allocated_read(::substrait::ReadRel* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_rel_type();
  if (value) {
    set_has_read();
    _impl_.rel_type_.read_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Rel.read)
}
inline ::substrait::ReadRel* Rel::_internal_mutable_read() {
  if (rel_type_case() != kRead) {
    clear_rel_type();
    set_has_read();
    _impl_.rel_type_.read_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::ReadRel>(GetArena());
  }
  return _impl_.rel_type_.read_;
}
inline ::substrait::ReadRel* Rel::mutable_read() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::ReadRel* _msg = _internal_mutable_read();
  // @@protoc_insertion_point(field_mutable:substrait.Rel.read)
  return _msg;
}

// .substrait.FilterRel filter = 2;
inline bool Rel::has_filter() const {
  return rel_type_case() == kFilter;
}
inline bool Rel::_internal_has_filter() const {
  return rel_type_case() == kFilter;
}
inline void Rel::set_has_filter() {
  _impl_._oneof_case_[0] = kFilter;
}
inline void Rel::clear_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (rel_type_case() == kFilter) {
    if (GetArena() == nullptr) {
      delete _impl_.rel_type_.filter_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.rel_type_.filter_);
    }
    clear_has_rel_type();
  }
}
inline ::substrait::FilterRel* Rel::release_filter() {
  // @@protoc_insertion_point(field_release:substrait.Rel.filter)
  if (rel_type_case() == kFilter) {
    clear_has_rel_type();
    auto* temp = _impl_.rel_type_.filter_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.rel_type_.filter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::FilterRel& Rel::_internal_filter() const {
  return rel_type_case() == kFilter ? *_impl_.rel_type_.filter_ : reinterpret_cast<::substrait::FilterRel&>(::substrait::_FilterRel_default_instance_);
}
inline const ::substrait::FilterRel& Rel::filter() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Rel.filter)
  return _internal_filter();
}
inline ::substrait::FilterRel* Rel::unsafe_arena_release_filter() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Rel.filter)
  if (rel_type_case() == kFilter) {
    clear_has_rel_type();
    auto* temp = _impl_.rel_type_.filter_;
    _impl_.rel_type_.filter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Rel::unsafe_arena_set_allocated_filter(::substrait::FilterRel* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_rel_type();
  if (value) {
    set_has_filter();
    _impl_.rel_type_.filter_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Rel.filter)
}
inline ::substrait::FilterRel* Rel::_internal_mutable_filter() {
  if (rel_type_case() != kFilter) {
    clear_rel_type();
    set_has_filter();
    _impl_.rel_type_.filter_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::FilterRel>(GetArena());
  }
  return _impl_.rel_type_.filter_;
}
inline ::substrait::FilterRel* Rel::mutable_filter() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::FilterRel* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:substrait.Rel.filter)
  return _msg;
}

// .substrait.FetchRel fetch = 3;
inline bool Rel::has_fetch() const {
  return rel_type_case() == kFetch;
}
inline bool Rel::_internal_has_fetch() const {
  return rel_type_case() == kFetch;
}
inline void Rel::set_has_fetch() {
  _impl_._oneof_case_[0] = kFetch;
}
inline void Rel::clear_fetch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (rel_type_case() == kFetch) {
    if (GetArena() == nullptr) {
      delete _impl_.rel_type_.fetch_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.rel_type_.fetch_);
    }
    clear_has_rel_type();
  }
}
inline ::substrait::FetchRel* Rel::release_fetch() {
  // @@protoc_insertion_point(field_release:substrait.Rel.fetch)
  if (rel_type_case() == kFetch) {
    clear_has_rel_type();
    auto* temp = _impl_.rel_type_.fetch_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.rel_type_.fetch_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::FetchRel& Rel::_internal_fetch() const {
  return rel_type_case() == kFetch ? *_impl_.rel_type_.fetch_ : reinterpret_cast<::substrait::FetchRel&>(::substrait::_FetchRel_default_instance_);
}
inline const ::substrait::FetchRel& Rel::fetch() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Rel.fetch)
  return _internal_fetch();
}
inline ::substrait::FetchRel* Rel::unsafe_arena_release_fetch() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Rel.fetch)
  if (rel_type_case() == kFetch) {
    clear_has_rel_type();
    auto* temp = _impl_.rel_type_.fetch_;
    _impl_.rel_type_.fetch_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Rel::unsafe_arena_set_allocated_fetch(::substrait::FetchRel* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_rel_type();
  if (value) {
    set_has_fetch();
    _impl_.rel_type_.fetch_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Rel.fetch)
}
inline ::substrait::FetchRel* Rel::_internal_mutable_fetch() {
  if (rel_type_case() != kFetch) {
    clear_rel_type();
    set_has_fetch();
    _impl_.rel_type_.fetch_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::FetchRel>(GetArena());
  }
  return _impl_.rel_type_.fetch_;
}
inline ::substrait::FetchRel* Rel::mutable_fetch() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::FetchRel* _msg = _internal_mutable_fetch();
  // @@protoc_insertion_point(field_mutable:substrait.Rel.fetch)
  return _msg;
}

// .substrait.AggregateRel aggregate = 4;
inline bool Rel::has_aggregate() const {
  return rel_type_case() == kAggregate;
}
inline bool Rel::_internal_has_aggregate() const {
  return rel_type_case() == kAggregate;
}
inline void Rel::set_has_aggregate() {
  _impl_._oneof_case_[0] = kAggregate;
}
inline void Rel::clear_aggregate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (rel_type_case() == kAggregate) {
    if (GetArena() == nullptr) {
      delete _impl_.rel_type_.aggregate_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.rel_type_.aggregate_);
    }
    clear_has_rel_type();
  }
}
inline ::substrait::AggregateRel* Rel::release_aggregate() {
  // @@protoc_insertion_point(field_release:substrait.Rel.aggregate)
  if (rel_type_case() == kAggregate) {
    clear_has_rel_type();
    auto* temp = _impl_.rel_type_.aggregate_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.rel_type_.aggregate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::AggregateRel& Rel::_internal_aggregate() const {
  return rel_type_case() == kAggregate ? *_impl_.rel_type_.aggregate_ : reinterpret_cast<::substrait::AggregateRel&>(::substrait::_AggregateRel_default_instance_);
}
inline const ::substrait::AggregateRel& Rel::aggregate() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Rel.aggregate)
  return _internal_aggregate();
}
inline ::substrait::AggregateRel* Rel::unsafe_arena_release_aggregate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Rel.aggregate)
  if (rel_type_case() == kAggregate) {
    clear_has_rel_type();
    auto* temp = _impl_.rel_type_.aggregate_;
    _impl_.rel_type_.aggregate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Rel::unsafe_arena_set_allocated_aggregate(::substrait::AggregateRel* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_rel_type();
  if (value) {
    set_has_aggregate();
    _impl_.rel_type_.aggregate_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Rel.aggregate)
}
inline ::substrait::AggregateRel* Rel::_internal_mutable_aggregate() {
  if (rel_type_case() != kAggregate) {
    clear_rel_type();
    set_has_aggregate();
    _impl_.rel_type_.aggregate_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::AggregateRel>(GetArena());
  }
  return _impl_.rel_type_.aggregate_;
}
inline ::substrait::AggregateRel* Rel::mutable_aggregate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::AggregateRel* _msg = _internal_mutable_aggregate();
  // @@protoc_insertion_point(field_mutable:substrait.Rel.aggregate)
  return _msg;
}

// .substrait.SortRel sort = 5;
inline bool Rel::has_sort() const {
  return rel_type_case() == kSort;
}
inline bool Rel::_internal_has_sort() const {
  return rel_type_case() == kSort;
}
inline void Rel::set_has_sort() {
  _impl_._oneof_case_[0] = kSort;
}
inline void Rel::clear_sort() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (rel_type_case() == kSort) {
    if (GetArena() == nullptr) {
      delete _impl_.rel_type_.sort_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.rel_type_.sort_);
    }
    clear_has_rel_type();
  }
}
inline ::substrait::SortRel* Rel::release_sort() {
  // @@protoc_insertion_point(field_release:substrait.Rel.sort)
  if (rel_type_case() == kSort) {
    clear_has_rel_type();
    auto* temp = _impl_.rel_type_.sort_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.rel_type_.sort_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::SortRel& Rel::_internal_sort() const {
  return rel_type_case() == kSort ? *_impl_.rel_type_.sort_ : reinterpret_cast<::substrait::SortRel&>(::substrait::_SortRel_default_instance_);
}
inline const ::substrait::SortRel& Rel::sort() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Rel.sort)
  return _internal_sort();
}
inline ::substrait::SortRel* Rel::unsafe_arena_release_sort() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Rel.sort)
  if (rel_type_case() == kSort) {
    clear_has_rel_type();
    auto* temp = _impl_.rel_type_.sort_;
    _impl_.rel_type_.sort_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Rel::unsafe_arena_set_allocated_sort(::substrait::SortRel* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_rel_type();
  if (value) {
    set_has_sort();
    _impl_.rel_type_.sort_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Rel.sort)
}
inline ::substrait::SortRel* Rel::_internal_mutable_sort() {
  if (rel_type_case() != kSort) {
    clear_rel_type();
    set_has_sort();
    _impl_.rel_type_.sort_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::SortRel>(GetArena());
  }
  return _impl_.rel_type_.sort_;
}
inline ::substrait::SortRel* Rel::mutable_sort() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::SortRel* _msg = _internal_mutable_sort();
  // @@protoc_insertion_point(field_mutable:substrait.Rel.sort)
  return _msg;
}

// .substrait.JoinRel join = 6;
inline bool Rel::has_join() const {
  return rel_type_case() == kJoin;
}
inline bool Rel::_internal_has_join() const {
  return rel_type_case() == kJoin;
}
inline void Rel::set_has_join() {
  _impl_._oneof_case_[0] = kJoin;
}
inline void Rel::clear_join() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (rel_type_case() == kJoin) {
    if (GetArena() == nullptr) {
      delete _impl_.rel_type_.join_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.rel_type_.join_);
    }
    clear_has_rel_type();
  }
}
inline ::substrait::JoinRel* Rel::release_join() {
  // @@protoc_insertion_point(field_release:substrait.Rel.join)
  if (rel_type_case() == kJoin) {
    clear_has_rel_type();
    auto* temp = _impl_.rel_type_.join_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.rel_type_.join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::JoinRel& Rel::_internal_join() const {
  return rel_type_case() == kJoin ? *_impl_.rel_type_.join_ : reinterpret_cast<::substrait::JoinRel&>(::substrait::_JoinRel_default_instance_);
}
inline const ::substrait::JoinRel& Rel::join() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Rel.join)
  return _internal_join();
}
inline ::substrait::JoinRel* Rel::unsafe_arena_release_join() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Rel.join)
  if (rel_type_case() == kJoin) {
    clear_has_rel_type();
    auto* temp = _impl_.rel_type_.join_;
    _impl_.rel_type_.join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Rel::unsafe_arena_set_allocated_join(::substrait::JoinRel* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_rel_type();
  if (value) {
    set_has_join();
    _impl_.rel_type_.join_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Rel.join)
}
inline ::substrait::JoinRel* Rel::_internal_mutable_join() {
  if (rel_type_case() != kJoin) {
    clear_rel_type();
    set_has_join();
    _impl_.rel_type_.join_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::JoinRel>(GetArena());
  }
  return _impl_.rel_type_.join_;
}
inline ::substrait::JoinRel* Rel::mutable_join() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::JoinRel* _msg = _internal_mutable_join();
  // @@protoc_insertion_point(field_mutable:substrait.Rel.join)
  return _msg;
}

// .substrait.ProjectRel project = 7;
inline bool Rel::has_project() const {
  return rel_type_case() == kProject;
}
inline bool Rel::_internal_has_project() const {
  return rel_type_case() == kProject;
}
inline void Rel::set_has_project() {
  _impl_._oneof_case_[0] = kProject;
}
inline void Rel::clear_project() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (rel_type_case() == kProject) {
    if (GetArena() == nullptr) {
      delete _impl_.rel_type_.project_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.rel_type_.project_);
    }
    clear_has_rel_type();
  }
}
inline ::substrait::ProjectRel* Rel::release_project() {
  // @@protoc_insertion_point(field_release:substrait.Rel.project)
  if (rel_type_case() == kProject) {
    clear_has_rel_type();
    auto* temp = _impl_.rel_type_.project_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.rel_type_.project_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::ProjectRel& Rel::_internal_project() const {
  return rel_type_case() == kProject ? *_impl_.rel_type_.project_ : reinterpret_cast<::substrait::ProjectRel&>(::substrait::_ProjectRel_default_instance_);
}
inline const ::substrait::ProjectRel& Rel::project() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Rel.project)
  return _internal_project();
}
inline ::substrait::ProjectRel* Rel::unsafe_arena_release_project() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Rel.project)
  if (rel_type_case() == kProject) {
    clear_has_rel_type();
    auto* temp = _impl_.rel_type_.project_;
    _impl_.rel_type_.project_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Rel::unsafe_arena_set_allocated_project(::substrait::ProjectRel* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_rel_type();
  if (value) {
    set_has_project();
    _impl_.rel_type_.project_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Rel.project)
}
inline ::substrait::ProjectRel* Rel::_internal_mutable_project() {
  if (rel_type_case() != kProject) {
    clear_rel_type();
    set_has_project();
    _impl_.rel_type_.project_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::ProjectRel>(GetArena());
  }
  return _impl_.rel_type_.project_;
}
inline ::substrait::ProjectRel* Rel::mutable_project() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::ProjectRel* _msg = _internal_mutable_project();
  // @@protoc_insertion_point(field_mutable:substrait.Rel.project)
  return _msg;
}

// .substrait.SetRel set = 8;
inline bool Rel::has_set() const {
  return rel_type_case() == kSet;
}
inline bool Rel::_internal_has_set() const {
  return rel_type_case() == kSet;
}
inline void Rel::set_has_set() {
  _impl_._oneof_case_[0] = kSet;
}
inline void Rel::clear_set() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (rel_type_case() == kSet) {
    if (GetArena() == nullptr) {
      delete _impl_.rel_type_.set_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.rel_type_.set_);
    }
    clear_has_rel_type();
  }
}
inline ::substrait::SetRel* Rel::release_set() {
  // @@protoc_insertion_point(field_release:substrait.Rel.set)
  if (rel_type_case() == kSet) {
    clear_has_rel_type();
    auto* temp = _impl_.rel_type_.set_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.rel_type_.set_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::SetRel& Rel::_internal_set() const {
  return rel_type_case() == kSet ? *_impl_.rel_type_.set_ : reinterpret_cast<::substrait::SetRel&>(::substrait::_SetRel_default_instance_);
}
inline const ::substrait::SetRel& Rel::set() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Rel.set)
  return _internal_set();
}
inline ::substrait::SetRel* Rel::unsafe_arena_release_set() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Rel.set)
  if (rel_type_case() == kSet) {
    clear_has_rel_type();
    auto* temp = _impl_.rel_type_.set_;
    _impl_.rel_type_.set_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Rel::unsafe_arena_set_allocated_set(::substrait::SetRel* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_rel_type();
  if (value) {
    set_has_set();
    _impl_.rel_type_.set_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Rel.set)
}
inline ::substrait::SetRel* Rel::_internal_mutable_set() {
  if (rel_type_case() != kSet) {
    clear_rel_type();
    set_has_set();
    _impl_.rel_type_.set_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::SetRel>(GetArena());
  }
  return _impl_.rel_type_.set_;
}
inline ::substrait::SetRel* Rel::mutable_set() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::SetRel* _msg = _internal_mutable_set();
  // @@protoc_insertion_point(field_mutable:substrait.Rel.set)
  return _msg;
}

// .substrait.ExtensionSingleRel extension_single = 9;
inline bool Rel::has_extension_single() const {
  return rel_type_case() == kExtensionSingle;
}
inline bool Rel::_internal_has_extension_single() const {
  return rel_type_case() == kExtensionSingle;
}
inline void Rel::set_has_extension_single() {
  _impl_._oneof_case_[0] = kExtensionSingle;
}
inline void Rel::clear_extension_single() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (rel_type_case() == kExtensionSingle) {
    if (GetArena() == nullptr) {
      delete _impl_.rel_type_.extension_single_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.rel_type_.extension_single_);
    }
    clear_has_rel_type();
  }
}
inline ::substrait::ExtensionSingleRel* Rel::release_extension_single() {
  // @@protoc_insertion_point(field_release:substrait.Rel.extension_single)
  if (rel_type_case() == kExtensionSingle) {
    clear_has_rel_type();
    auto* temp = _impl_.rel_type_.extension_single_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.rel_type_.extension_single_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::ExtensionSingleRel& Rel::_internal_extension_single() const {
  return rel_type_case() == kExtensionSingle ? *_impl_.rel_type_.extension_single_ : reinterpret_cast<::substrait::ExtensionSingleRel&>(::substrait::_ExtensionSingleRel_default_instance_);
}
inline const ::substrait::ExtensionSingleRel& Rel::extension_single() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Rel.extension_single)
  return _internal_extension_single();
}
inline ::substrait::ExtensionSingleRel* Rel::unsafe_arena_release_extension_single() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Rel.extension_single)
  if (rel_type_case() == kExtensionSingle) {
    clear_has_rel_type();
    auto* temp = _impl_.rel_type_.extension_single_;
    _impl_.rel_type_.extension_single_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Rel::unsafe_arena_set_allocated_extension_single(::substrait::ExtensionSingleRel* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_rel_type();
  if (value) {
    set_has_extension_single();
    _impl_.rel_type_.extension_single_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Rel.extension_single)
}
inline ::substrait::ExtensionSingleRel* Rel::_internal_mutable_extension_single() {
  if (rel_type_case() != kExtensionSingle) {
    clear_rel_type();
    set_has_extension_single();
    _impl_.rel_type_.extension_single_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::ExtensionSingleRel>(GetArena());
  }
  return _impl_.rel_type_.extension_single_;
}
inline ::substrait::ExtensionSingleRel* Rel::mutable_extension_single() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::ExtensionSingleRel* _msg = _internal_mutable_extension_single();
  // @@protoc_insertion_point(field_mutable:substrait.Rel.extension_single)
  return _msg;
}

// .substrait.ExtensionMultiRel extension_multi = 10;
inline bool Rel::has_extension_multi() const {
  return rel_type_case() == kExtensionMulti;
}
inline bool Rel::_internal_has_extension_multi() const {
  return rel_type_case() == kExtensionMulti;
}
inline void Rel::set_has_extension_multi() {
  _impl_._oneof_case_[0] = kExtensionMulti;
}
inline void Rel::clear_extension_multi() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (rel_type_case() == kExtensionMulti) {
    if (GetArena() == nullptr) {
      delete _impl_.rel_type_.extension_multi_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.rel_type_.extension_multi_);
    }
    clear_has_rel_type();
  }
}
inline ::substrait::ExtensionMultiRel* Rel::release_extension_multi() {
  // @@protoc_insertion_point(field_release:substrait.Rel.extension_multi)
  if (rel_type_case() == kExtensionMulti) {
    clear_has_rel_type();
    auto* temp = _impl_.rel_type_.extension_multi_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.rel_type_.extension_multi_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::ExtensionMultiRel& Rel::_internal_extension_multi() const {
  return rel_type_case() == kExtensionMulti ? *_impl_.rel_type_.extension_multi_ : reinterpret_cast<::substrait::ExtensionMultiRel&>(::substrait::_ExtensionMultiRel_default_instance_);
}
inline const ::substrait::ExtensionMultiRel& Rel::extension_multi() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Rel.extension_multi)
  return _internal_extension_multi();
}
inline ::substrait::ExtensionMultiRel* Rel::unsafe_arena_release_extension_multi() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Rel.extension_multi)
  if (rel_type_case() == kExtensionMulti) {
    clear_has_rel_type();
    auto* temp = _impl_.rel_type_.extension_multi_;
    _impl_.rel_type_.extension_multi_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Rel::unsafe_arena_set_allocated_extension_multi(::substrait::ExtensionMultiRel* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_rel_type();
  if (value) {
    set_has_extension_multi();
    _impl_.rel_type_.extension_multi_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Rel.extension_multi)
}
inline ::substrait::ExtensionMultiRel* Rel::_internal_mutable_extension_multi() {
  if (rel_type_case() != kExtensionMulti) {
    clear_rel_type();
    set_has_extension_multi();
    _impl_.rel_type_.extension_multi_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::ExtensionMultiRel>(GetArena());
  }
  return _impl_.rel_type_.extension_multi_;
}
inline ::substrait::ExtensionMultiRel* Rel::mutable_extension_multi() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::ExtensionMultiRel* _msg = _internal_mutable_extension_multi();
  // @@protoc_insertion_point(field_mutable:substrait.Rel.extension_multi)
  return _msg;
}

// .substrait.ExtensionLeafRel extension_leaf = 11;
inline bool Rel::has_extension_leaf() const {
  return rel_type_case() == kExtensionLeaf;
}
inline bool Rel::_internal_has_extension_leaf() const {
  return rel_type_case() == kExtensionLeaf;
}
inline void Rel::set_has_extension_leaf() {
  _impl_._oneof_case_[0] = kExtensionLeaf;
}
inline void Rel::clear_extension_leaf() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (rel_type_case() == kExtensionLeaf) {
    if (GetArena() == nullptr) {
      delete _impl_.rel_type_.extension_leaf_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.rel_type_.extension_leaf_);
    }
    clear_has_rel_type();
  }
}
inline ::substrait::ExtensionLeafRel* Rel::release_extension_leaf() {
  // @@protoc_insertion_point(field_release:substrait.Rel.extension_leaf)
  if (rel_type_case() == kExtensionLeaf) {
    clear_has_rel_type();
    auto* temp = _impl_.rel_type_.extension_leaf_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.rel_type_.extension_leaf_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::ExtensionLeafRel& Rel::_internal_extension_leaf() const {
  return rel_type_case() == kExtensionLeaf ? *_impl_.rel_type_.extension_leaf_ : reinterpret_cast<::substrait::ExtensionLeafRel&>(::substrait::_ExtensionLeafRel_default_instance_);
}
inline const ::substrait::ExtensionLeafRel& Rel::extension_leaf() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Rel.extension_leaf)
  return _internal_extension_leaf();
}
inline ::substrait::ExtensionLeafRel* Rel::unsafe_arena_release_extension_leaf() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Rel.extension_leaf)
  if (rel_type_case() == kExtensionLeaf) {
    clear_has_rel_type();
    auto* temp = _impl_.rel_type_.extension_leaf_;
    _impl_.rel_type_.extension_leaf_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Rel::unsafe_arena_set_allocated_extension_leaf(::substrait::ExtensionLeafRel* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_rel_type();
  if (value) {
    set_has_extension_leaf();
    _impl_.rel_type_.extension_leaf_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Rel.extension_leaf)
}
inline ::substrait::ExtensionLeafRel* Rel::_internal_mutable_extension_leaf() {
  if (rel_type_case() != kExtensionLeaf) {
    clear_rel_type();
    set_has_extension_leaf();
    _impl_.rel_type_.extension_leaf_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::ExtensionLeafRel>(GetArena());
  }
  return _impl_.rel_type_.extension_leaf_;
}
inline ::substrait::ExtensionLeafRel* Rel::mutable_extension_leaf() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::ExtensionLeafRel* _msg = _internal_mutable_extension_leaf();
  // @@protoc_insertion_point(field_mutable:substrait.Rel.extension_leaf)
  return _msg;
}

// .substrait.CrossRel cross = 12;
inline bool Rel::has_cross() const {
  return rel_type_case() == kCross;
}
inline bool Rel::_internal_has_cross() const {
  return rel_type_case() == kCross;
}
inline void Rel::set_has_cross() {
  _impl_._oneof_case_[0] = kCross;
}
inline void Rel::clear_cross() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (rel_type_case() == kCross) {
    if (GetArena() == nullptr) {
      delete _impl_.rel_type_.cross_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.rel_type_.cross_);
    }
    clear_has_rel_type();
  }
}
inline ::substrait::CrossRel* Rel::release_cross() {
  // @@protoc_insertion_point(field_release:substrait.Rel.cross)
  if (rel_type_case() == kCross) {
    clear_has_rel_type();
    auto* temp = _impl_.rel_type_.cross_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.rel_type_.cross_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::CrossRel& Rel::_internal_cross() const {
  return rel_type_case() == kCross ? *_impl_.rel_type_.cross_ : reinterpret_cast<::substrait::CrossRel&>(::substrait::_CrossRel_default_instance_);
}
inline const ::substrait::CrossRel& Rel::cross() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Rel.cross)
  return _internal_cross();
}
inline ::substrait::CrossRel* Rel::unsafe_arena_release_cross() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Rel.cross)
  if (rel_type_case() == kCross) {
    clear_has_rel_type();
    auto* temp = _impl_.rel_type_.cross_;
    _impl_.rel_type_.cross_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Rel::unsafe_arena_set_allocated_cross(::substrait::CrossRel* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_rel_type();
  if (value) {
    set_has_cross();
    _impl_.rel_type_.cross_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Rel.cross)
}
inline ::substrait::CrossRel* Rel::_internal_mutable_cross() {
  if (rel_type_case() != kCross) {
    clear_rel_type();
    set_has_cross();
    _impl_.rel_type_.cross_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::CrossRel>(GetArena());
  }
  return _impl_.rel_type_.cross_;
}
inline ::substrait::CrossRel* Rel::mutable_cross() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::CrossRel* _msg = _internal_mutable_cross();
  // @@protoc_insertion_point(field_mutable:substrait.Rel.cross)
  return _msg;
}

// .substrait.ReferenceRel reference = 21;
inline bool Rel::has_reference() const {
  return rel_type_case() == kReference;
}
inline bool Rel::_internal_has_reference() const {
  return rel_type_case() == kReference;
}
inline void Rel::set_has_reference() {
  _impl_._oneof_case_[0] = kReference;
}
inline void Rel::clear_reference() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (rel_type_case() == kReference) {
    if (GetArena() == nullptr) {
      delete _impl_.rel_type_.reference_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.rel_type_.reference_);
    }
    clear_has_rel_type();
  }
}
inline ::substrait::ReferenceRel* Rel::release_reference() {
  // @@protoc_insertion_point(field_release:substrait.Rel.reference)
  if (rel_type_case() == kReference) {
    clear_has_rel_type();
    auto* temp = _impl_.rel_type_.reference_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.rel_type_.reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::ReferenceRel& Rel::_internal_reference() const {
  return rel_type_case() == kReference ? *_impl_.rel_type_.reference_ : reinterpret_cast<::substrait::ReferenceRel&>(::substrait::_ReferenceRel_default_instance_);
}
inline const ::substrait::ReferenceRel& Rel::reference() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Rel.reference)
  return _internal_reference();
}
inline ::substrait::ReferenceRel* Rel::unsafe_arena_release_reference() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Rel.reference)
  if (rel_type_case() == kReference) {
    clear_has_rel_type();
    auto* temp = _impl_.rel_type_.reference_;
    _impl_.rel_type_.reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Rel::unsafe_arena_set_allocated_reference(::substrait::ReferenceRel* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_rel_type();
  if (value) {
    set_has_reference();
    _impl_.rel_type_.reference_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Rel.reference)
}
inline ::substrait::ReferenceRel* Rel::_internal_mutable_reference() {
  if (rel_type_case() != kReference) {
    clear_rel_type();
    set_has_reference();
    _impl_.rel_type_.reference_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::ReferenceRel>(GetArena());
  }
  return _impl_.rel_type_.reference_;
}
inline ::substrait::ReferenceRel* Rel::mutable_reference() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::ReferenceRel* _msg = _internal_mutable_reference();
  // @@protoc_insertion_point(field_mutable:substrait.Rel.reference)
  return _msg;
}

// .substrait.WriteRel write = 19;
inline bool Rel::has_write() const {
  return rel_type_case() == kWrite;
}
inline bool Rel::_internal_has_write() const {
  return rel_type_case() == kWrite;
}
inline void Rel::set_has_write() {
  _impl_._oneof_case_[0] = kWrite;
}
inline void Rel::clear_write() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (rel_type_case() == kWrite) {
    if (GetArena() == nullptr) {
      delete _impl_.rel_type_.write_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.rel_type_.write_);
    }
    clear_has_rel_type();
  }
}
inline ::substrait::WriteRel* Rel::release_write() {
  // @@protoc_insertion_point(field_release:substrait.Rel.write)
  if (rel_type_case() == kWrite) {
    clear_has_rel_type();
    auto* temp = _impl_.rel_type_.write_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.rel_type_.write_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::WriteRel& Rel::_internal_write() const {
  return rel_type_case() == kWrite ? *_impl_.rel_type_.write_ : reinterpret_cast<::substrait::WriteRel&>(::substrait::_WriteRel_default_instance_);
}
inline const ::substrait::WriteRel& Rel::write() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Rel.write)
  return _internal_write();
}
inline ::substrait::WriteRel* Rel::unsafe_arena_release_write() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Rel.write)
  if (rel_type_case() == kWrite) {
    clear_has_rel_type();
    auto* temp = _impl_.rel_type_.write_;
    _impl_.rel_type_.write_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Rel::unsafe_arena_set_allocated_write(::substrait::WriteRel* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_rel_type();
  if (value) {
    set_has_write();
    _impl_.rel_type_.write_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Rel.write)
}
inline ::substrait::WriteRel* Rel::_internal_mutable_write() {
  if (rel_type_case() != kWrite) {
    clear_rel_type();
    set_has_write();
    _impl_.rel_type_.write_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::WriteRel>(GetArena());
  }
  return _impl_.rel_type_.write_;
}
inline ::substrait::WriteRel* Rel::mutable_write() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::WriteRel* _msg = _internal_mutable_write();
  // @@protoc_insertion_point(field_mutable:substrait.Rel.write)
  return _msg;
}

// .substrait.DdlRel ddl = 20;
inline bool Rel::has_ddl() const {
  return rel_type_case() == kDdl;
}
inline bool Rel::_internal_has_ddl() const {
  return rel_type_case() == kDdl;
}
inline void Rel::set_has_ddl() {
  _impl_._oneof_case_[0] = kDdl;
}
inline void Rel::clear_ddl() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (rel_type_case() == kDdl) {
    if (GetArena() == nullptr) {
      delete _impl_.rel_type_.ddl_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.rel_type_.ddl_);
    }
    clear_has_rel_type();
  }
}
inline ::substrait::DdlRel* Rel::release_ddl() {
  // @@protoc_insertion_point(field_release:substrait.Rel.ddl)
  if (rel_type_case() == kDdl) {
    clear_has_rel_type();
    auto* temp = _impl_.rel_type_.ddl_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.rel_type_.ddl_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::DdlRel& Rel::_internal_ddl() const {
  return rel_type_case() == kDdl ? *_impl_.rel_type_.ddl_ : reinterpret_cast<::substrait::DdlRel&>(::substrait::_DdlRel_default_instance_);
}
inline const ::substrait::DdlRel& Rel::ddl() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Rel.ddl)
  return _internal_ddl();
}
inline ::substrait::DdlRel* Rel::unsafe_arena_release_ddl() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Rel.ddl)
  if (rel_type_case() == kDdl) {
    clear_has_rel_type();
    auto* temp = _impl_.rel_type_.ddl_;
    _impl_.rel_type_.ddl_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Rel::unsafe_arena_set_allocated_ddl(::substrait::DdlRel* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_rel_type();
  if (value) {
    set_has_ddl();
    _impl_.rel_type_.ddl_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Rel.ddl)
}
inline ::substrait::DdlRel* Rel::_internal_mutable_ddl() {
  if (rel_type_case() != kDdl) {
    clear_rel_type();
    set_has_ddl();
    _impl_.rel_type_.ddl_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::DdlRel>(GetArena());
  }
  return _impl_.rel_type_.ddl_;
}
inline ::substrait::DdlRel* Rel::mutable_ddl() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::DdlRel* _msg = _internal_mutable_ddl();
  // @@protoc_insertion_point(field_mutable:substrait.Rel.ddl)
  return _msg;
}

// .substrait.HashJoinRel hash_join = 13;
inline bool Rel::has_hash_join() const {
  return rel_type_case() == kHashJoin;
}
inline bool Rel::_internal_has_hash_join() const {
  return rel_type_case() == kHashJoin;
}
inline void Rel::set_has_hash_join() {
  _impl_._oneof_case_[0] = kHashJoin;
}
inline void Rel::clear_hash_join() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (rel_type_case() == kHashJoin) {
    if (GetArena() == nullptr) {
      delete _impl_.rel_type_.hash_join_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.rel_type_.hash_join_);
    }
    clear_has_rel_type();
  }
}
inline ::substrait::HashJoinRel* Rel::release_hash_join() {
  // @@protoc_insertion_point(field_release:substrait.Rel.hash_join)
  if (rel_type_case() == kHashJoin) {
    clear_has_rel_type();
    auto* temp = _impl_.rel_type_.hash_join_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.rel_type_.hash_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::HashJoinRel& Rel::_internal_hash_join() const {
  return rel_type_case() == kHashJoin ? *_impl_.rel_type_.hash_join_ : reinterpret_cast<::substrait::HashJoinRel&>(::substrait::_HashJoinRel_default_instance_);
}
inline const ::substrait::HashJoinRel& Rel::hash_join() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Rel.hash_join)
  return _internal_hash_join();
}
inline ::substrait::HashJoinRel* Rel::unsafe_arena_release_hash_join() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Rel.hash_join)
  if (rel_type_case() == kHashJoin) {
    clear_has_rel_type();
    auto* temp = _impl_.rel_type_.hash_join_;
    _impl_.rel_type_.hash_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Rel::unsafe_arena_set_allocated_hash_join(::substrait::HashJoinRel* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_rel_type();
  if (value) {
    set_has_hash_join();
    _impl_.rel_type_.hash_join_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Rel.hash_join)
}
inline ::substrait::HashJoinRel* Rel::_internal_mutable_hash_join() {
  if (rel_type_case() != kHashJoin) {
    clear_rel_type();
    set_has_hash_join();
    _impl_.rel_type_.hash_join_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::HashJoinRel>(GetArena());
  }
  return _impl_.rel_type_.hash_join_;
}
inline ::substrait::HashJoinRel* Rel::mutable_hash_join() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::HashJoinRel* _msg = _internal_mutable_hash_join();
  // @@protoc_insertion_point(field_mutable:substrait.Rel.hash_join)
  return _msg;
}

// .substrait.MergeJoinRel merge_join = 14;
inline bool Rel::has_merge_join() const {
  return rel_type_case() == kMergeJoin;
}
inline bool Rel::_internal_has_merge_join() const {
  return rel_type_case() == kMergeJoin;
}
inline void Rel::set_has_merge_join() {
  _impl_._oneof_case_[0] = kMergeJoin;
}
inline void Rel::clear_merge_join() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (rel_type_case() == kMergeJoin) {
    if (GetArena() == nullptr) {
      delete _impl_.rel_type_.merge_join_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.rel_type_.merge_join_);
    }
    clear_has_rel_type();
  }
}
inline ::substrait::MergeJoinRel* Rel::release_merge_join() {
  // @@protoc_insertion_point(field_release:substrait.Rel.merge_join)
  if (rel_type_case() == kMergeJoin) {
    clear_has_rel_type();
    auto* temp = _impl_.rel_type_.merge_join_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.rel_type_.merge_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::MergeJoinRel& Rel::_internal_merge_join() const {
  return rel_type_case() == kMergeJoin ? *_impl_.rel_type_.merge_join_ : reinterpret_cast<::substrait::MergeJoinRel&>(::substrait::_MergeJoinRel_default_instance_);
}
inline const ::substrait::MergeJoinRel& Rel::merge_join() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Rel.merge_join)
  return _internal_merge_join();
}
inline ::substrait::MergeJoinRel* Rel::unsafe_arena_release_merge_join() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Rel.merge_join)
  if (rel_type_case() == kMergeJoin) {
    clear_has_rel_type();
    auto* temp = _impl_.rel_type_.merge_join_;
    _impl_.rel_type_.merge_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Rel::unsafe_arena_set_allocated_merge_join(::substrait::MergeJoinRel* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_rel_type();
  if (value) {
    set_has_merge_join();
    _impl_.rel_type_.merge_join_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Rel.merge_join)
}
inline ::substrait::MergeJoinRel* Rel::_internal_mutable_merge_join() {
  if (rel_type_case() != kMergeJoin) {
    clear_rel_type();
    set_has_merge_join();
    _impl_.rel_type_.merge_join_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::MergeJoinRel>(GetArena());
  }
  return _impl_.rel_type_.merge_join_;
}
inline ::substrait::MergeJoinRel* Rel::mutable_merge_join() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::MergeJoinRel* _msg = _internal_mutable_merge_join();
  // @@protoc_insertion_point(field_mutable:substrait.Rel.merge_join)
  return _msg;
}

// .substrait.NestedLoopJoinRel nested_loop_join = 18;
inline bool Rel::has_nested_loop_join() const {
  return rel_type_case() == kNestedLoopJoin;
}
inline bool Rel::_internal_has_nested_loop_join() const {
  return rel_type_case() == kNestedLoopJoin;
}
inline void Rel::set_has_nested_loop_join() {
  _impl_._oneof_case_[0] = kNestedLoopJoin;
}
inline void Rel::clear_nested_loop_join() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (rel_type_case() == kNestedLoopJoin) {
    if (GetArena() == nullptr) {
      delete _impl_.rel_type_.nested_loop_join_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.rel_type_.nested_loop_join_);
    }
    clear_has_rel_type();
  }
}
inline ::substrait::NestedLoopJoinRel* Rel::release_nested_loop_join() {
  // @@protoc_insertion_point(field_release:substrait.Rel.nested_loop_join)
  if (rel_type_case() == kNestedLoopJoin) {
    clear_has_rel_type();
    auto* temp = _impl_.rel_type_.nested_loop_join_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.rel_type_.nested_loop_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::NestedLoopJoinRel& Rel::_internal_nested_loop_join() const {
  return rel_type_case() == kNestedLoopJoin ? *_impl_.rel_type_.nested_loop_join_ : reinterpret_cast<::substrait::NestedLoopJoinRel&>(::substrait::_NestedLoopJoinRel_default_instance_);
}
inline const ::substrait::NestedLoopJoinRel& Rel::nested_loop_join() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Rel.nested_loop_join)
  return _internal_nested_loop_join();
}
inline ::substrait::NestedLoopJoinRel* Rel::unsafe_arena_release_nested_loop_join() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Rel.nested_loop_join)
  if (rel_type_case() == kNestedLoopJoin) {
    clear_has_rel_type();
    auto* temp = _impl_.rel_type_.nested_loop_join_;
    _impl_.rel_type_.nested_loop_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Rel::unsafe_arena_set_allocated_nested_loop_join(::substrait::NestedLoopJoinRel* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_rel_type();
  if (value) {
    set_has_nested_loop_join();
    _impl_.rel_type_.nested_loop_join_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Rel.nested_loop_join)
}
inline ::substrait::NestedLoopJoinRel* Rel::_internal_mutable_nested_loop_join() {
  if (rel_type_case() != kNestedLoopJoin) {
    clear_rel_type();
    set_has_nested_loop_join();
    _impl_.rel_type_.nested_loop_join_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::NestedLoopJoinRel>(GetArena());
  }
  return _impl_.rel_type_.nested_loop_join_;
}
inline ::substrait::NestedLoopJoinRel* Rel::mutable_nested_loop_join() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::NestedLoopJoinRel* _msg = _internal_mutable_nested_loop_join();
  // @@protoc_insertion_point(field_mutable:substrait.Rel.nested_loop_join)
  return _msg;
}

// .substrait.ConsistentPartitionWindowRel window = 17;
inline bool Rel::has_window() const {
  return rel_type_case() == kWindow;
}
inline bool Rel::_internal_has_window() const {
  return rel_type_case() == kWindow;
}
inline void Rel::set_has_window() {
  _impl_._oneof_case_[0] = kWindow;
}
inline void Rel::clear_window() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (rel_type_case() == kWindow) {
    if (GetArena() == nullptr) {
      delete _impl_.rel_type_.window_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.rel_type_.window_);
    }
    clear_has_rel_type();
  }
}
inline ::substrait::ConsistentPartitionWindowRel* Rel::release_window() {
  // @@protoc_insertion_point(field_release:substrait.Rel.window)
  if (rel_type_case() == kWindow) {
    clear_has_rel_type();
    auto* temp = _impl_.rel_type_.window_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.rel_type_.window_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::ConsistentPartitionWindowRel& Rel::_internal_window() const {
  return rel_type_case() == kWindow ? *_impl_.rel_type_.window_ : reinterpret_cast<::substrait::ConsistentPartitionWindowRel&>(::substrait::_ConsistentPartitionWindowRel_default_instance_);
}
inline const ::substrait::ConsistentPartitionWindowRel& Rel::window() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Rel.window)
  return _internal_window();
}
inline ::substrait::ConsistentPartitionWindowRel* Rel::unsafe_arena_release_window() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Rel.window)
  if (rel_type_case() == kWindow) {
    clear_has_rel_type();
    auto* temp = _impl_.rel_type_.window_;
    _impl_.rel_type_.window_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Rel::unsafe_arena_set_allocated_window(::substrait::ConsistentPartitionWindowRel* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_rel_type();
  if (value) {
    set_has_window();
    _impl_.rel_type_.window_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Rel.window)
}
inline ::substrait::ConsistentPartitionWindowRel* Rel::_internal_mutable_window() {
  if (rel_type_case() != kWindow) {
    clear_rel_type();
    set_has_window();
    _impl_.rel_type_.window_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::ConsistentPartitionWindowRel>(GetArena());
  }
  return _impl_.rel_type_.window_;
}
inline ::substrait::ConsistentPartitionWindowRel* Rel::mutable_window() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::ConsistentPartitionWindowRel* _msg = _internal_mutable_window();
  // @@protoc_insertion_point(field_mutable:substrait.Rel.window)
  return _msg;
}

// .substrait.ExchangeRel exchange = 15;
inline bool Rel::has_exchange() const {
  return rel_type_case() == kExchange;
}
inline bool Rel::_internal_has_exchange() const {
  return rel_type_case() == kExchange;
}
inline void Rel::set_has_exchange() {
  _impl_._oneof_case_[0] = kExchange;
}
inline void Rel::clear_exchange() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (rel_type_case() == kExchange) {
    if (GetArena() == nullptr) {
      delete _impl_.rel_type_.exchange_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.rel_type_.exchange_);
    }
    clear_has_rel_type();
  }
}
inline ::substrait::ExchangeRel* Rel::release_exchange() {
  // @@protoc_insertion_point(field_release:substrait.Rel.exchange)
  if (rel_type_case() == kExchange) {
    clear_has_rel_type();
    auto* temp = _impl_.rel_type_.exchange_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.rel_type_.exchange_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::ExchangeRel& Rel::_internal_exchange() const {
  return rel_type_case() == kExchange ? *_impl_.rel_type_.exchange_ : reinterpret_cast<::substrait::ExchangeRel&>(::substrait::_ExchangeRel_default_instance_);
}
inline const ::substrait::ExchangeRel& Rel::exchange() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Rel.exchange)
  return _internal_exchange();
}
inline ::substrait::ExchangeRel* Rel::unsafe_arena_release_exchange() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Rel.exchange)
  if (rel_type_case() == kExchange) {
    clear_has_rel_type();
    auto* temp = _impl_.rel_type_.exchange_;
    _impl_.rel_type_.exchange_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Rel::unsafe_arena_set_allocated_exchange(::substrait::ExchangeRel* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_rel_type();
  if (value) {
    set_has_exchange();
    _impl_.rel_type_.exchange_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Rel.exchange)
}
inline ::substrait::ExchangeRel* Rel::_internal_mutable_exchange() {
  if (rel_type_case() != kExchange) {
    clear_rel_type();
    set_has_exchange();
    _impl_.rel_type_.exchange_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::ExchangeRel>(GetArena());
  }
  return _impl_.rel_type_.exchange_;
}
inline ::substrait::ExchangeRel* Rel::mutable_exchange() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::ExchangeRel* _msg = _internal_mutable_exchange();
  // @@protoc_insertion_point(field_mutable:substrait.Rel.exchange)
  return _msg;
}

// .substrait.ExpandRel expand = 16;
inline bool Rel::has_expand() const {
  return rel_type_case() == kExpand;
}
inline bool Rel::_internal_has_expand() const {
  return rel_type_case() == kExpand;
}
inline void Rel::set_has_expand() {
  _impl_._oneof_case_[0] = kExpand;
}
inline void Rel::clear_expand() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (rel_type_case() == kExpand) {
    if (GetArena() == nullptr) {
      delete _impl_.rel_type_.expand_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.rel_type_.expand_);
    }
    clear_has_rel_type();
  }
}
inline ::substrait::ExpandRel* Rel::release_expand() {
  // @@protoc_insertion_point(field_release:substrait.Rel.expand)
  if (rel_type_case() == kExpand) {
    clear_has_rel_type();
    auto* temp = _impl_.rel_type_.expand_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.rel_type_.expand_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::ExpandRel& Rel::_internal_expand() const {
  return rel_type_case() == kExpand ? *_impl_.rel_type_.expand_ : reinterpret_cast<::substrait::ExpandRel&>(::substrait::_ExpandRel_default_instance_);
}
inline const ::substrait::ExpandRel& Rel::expand() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Rel.expand)
  return _internal_expand();
}
inline ::substrait::ExpandRel* Rel::unsafe_arena_release_expand() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Rel.expand)
  if (rel_type_case() == kExpand) {
    clear_has_rel_type();
    auto* temp = _impl_.rel_type_.expand_;
    _impl_.rel_type_.expand_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Rel::unsafe_arena_set_allocated_expand(::substrait::ExpandRel* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_rel_type();
  if (value) {
    set_has_expand();
    _impl_.rel_type_.expand_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Rel.expand)
}
inline ::substrait::ExpandRel* Rel::_internal_mutable_expand() {
  if (rel_type_case() != kExpand) {
    clear_rel_type();
    set_has_expand();
    _impl_.rel_type_.expand_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::ExpandRel>(GetArena());
  }
  return _impl_.rel_type_.expand_;
}
inline ::substrait::ExpandRel* Rel::mutable_expand() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::ExpandRel* _msg = _internal_mutable_expand();
  // @@protoc_insertion_point(field_mutable:substrait.Rel.expand)
  return _msg;
}

inline bool Rel::has_rel_type() const {
  return rel_type_case() != REL_TYPE_NOT_SET;
}
inline void Rel::clear_has_rel_type() {
  _impl_._oneof_case_[0] = REL_TYPE_NOT_SET;
}
inline Rel::RelTypeCase Rel::rel_type_case() const {
  return Rel::RelTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// NamedObjectWrite

// repeated string names = 1;
inline int NamedObjectWrite::_internal_names_size() const {
  return _internal_names().size();
}
inline int NamedObjectWrite::names_size() const {
  return _internal_names_size();
}
inline void NamedObjectWrite::clear_names() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.names_.Clear();
}
inline std::string* NamedObjectWrite::add_names() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_names()->Add();
  // @@protoc_insertion_point(field_add_mutable:substrait.NamedObjectWrite.names)
  return _s;
}
inline const std::string& NamedObjectWrite::names(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.NamedObjectWrite.names)
  return _internal_names().Get(index);
}
inline std::string* NamedObjectWrite::mutable_names(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.NamedObjectWrite.names)
  return _internal_mutable_names()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void NamedObjectWrite::set_names(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_names()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:substrait.NamedObjectWrite.names)
}
template <typename Arg_, typename... Args_>
inline void NamedObjectWrite::add_names(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_names(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:substrait.NamedObjectWrite.names)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
NamedObjectWrite::names() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.NamedObjectWrite.names)
  return _internal_names();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
NamedObjectWrite::mutable_names() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.NamedObjectWrite.names)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_names();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
NamedObjectWrite::_internal_names() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.names_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
NamedObjectWrite::_internal_mutable_names() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.names_;
}

// .substrait.extensions.AdvancedExtension advanced_extension = 10;
inline bool NamedObjectWrite::has_advanced_extension() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.advanced_extension_ != nullptr);
  return value;
}
inline const ::substrait::extensions::AdvancedExtension& NamedObjectWrite::_internal_advanced_extension() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::extensions::AdvancedExtension* p = _impl_.advanced_extension_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::extensions::AdvancedExtension&>(::substrait::extensions::_AdvancedExtension_default_instance_);
}
inline const ::substrait::extensions::AdvancedExtension& NamedObjectWrite::advanced_extension() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.NamedObjectWrite.advanced_extension)
  return _internal_advanced_extension();
}
inline void NamedObjectWrite::unsafe_arena_set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.advanced_extension_);
  }
  _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.NamedObjectWrite.advanced_extension)
}
inline ::substrait::extensions::AdvancedExtension* NamedObjectWrite::release_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::extensions::AdvancedExtension* released = _impl_.advanced_extension_;
  _impl_.advanced_extension_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::extensions::AdvancedExtension* NamedObjectWrite::unsafe_arena_release_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.NamedObjectWrite.advanced_extension)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::extensions::AdvancedExtension* temp = _impl_.advanced_extension_;
  _impl_.advanced_extension_ = nullptr;
  return temp;
}
inline ::substrait::extensions::AdvancedExtension* NamedObjectWrite::_internal_mutable_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.advanced_extension_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::extensions::AdvancedExtension>(GetArena());
    _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(p);
  }
  return _impl_.advanced_extension_;
}
inline ::substrait::extensions::AdvancedExtension* NamedObjectWrite::mutable_advanced_extension() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::extensions::AdvancedExtension* _msg = _internal_mutable_advanced_extension();
  // @@protoc_insertion_point(field_mutable:substrait.NamedObjectWrite.advanced_extension)
  return _msg;
}
inline void NamedObjectWrite::set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.advanced_extension_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.NamedObjectWrite.advanced_extension)
}

// -------------------------------------------------------------------

// ExtensionObject

// .google.protobuf.Any detail = 1;
inline bool ExtensionObject::has_detail() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.detail_ != nullptr);
  return value;
}
inline const ::google::protobuf::Any& ExtensionObject::_internal_detail() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Any* p = _impl_.detail_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Any&>(::google::protobuf::_Any_default_instance_);
}
inline const ::google::protobuf::Any& ExtensionObject::detail() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ExtensionObject.detail)
  return _internal_detail();
}
inline void ExtensionObject::unsafe_arena_set_allocated_detail(::google::protobuf::Any* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detail_);
  }
  _impl_.detail_ = reinterpret_cast<::google::protobuf::Any*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ExtensionObject.detail)
}
inline ::google::protobuf::Any* ExtensionObject::release_detail() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Any* released = _impl_.detail_;
  _impl_.detail_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Any* ExtensionObject::unsafe_arena_release_detail() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.ExtensionObject.detail)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Any* temp = _impl_.detail_;
  _impl_.detail_ = nullptr;
  return temp;
}
inline ::google::protobuf::Any* ExtensionObject::_internal_mutable_detail() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.detail_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Any>(GetArena());
    _impl_.detail_ = reinterpret_cast<::google::protobuf::Any*>(p);
  }
  return _impl_.detail_;
}
inline ::google::protobuf::Any* ExtensionObject::mutable_detail() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Any* _msg = _internal_mutable_detail();
  // @@protoc_insertion_point(field_mutable:substrait.ExtensionObject.detail)
  return _msg;
}
inline void ExtensionObject::set_allocated_detail(::google::protobuf::Any* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detail_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.detail_ = reinterpret_cast<::google::protobuf::Any*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.ExtensionObject.detail)
}

// -------------------------------------------------------------------

// DdlRel

// .substrait.NamedObjectWrite named_object = 1;
inline bool DdlRel::has_named_object() const {
  return write_type_case() == kNamedObject;
}
inline bool DdlRel::_internal_has_named_object() const {
  return write_type_case() == kNamedObject;
}
inline void DdlRel::set_has_named_object() {
  _impl_._oneof_case_[0] = kNamedObject;
}
inline void DdlRel::clear_named_object() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (write_type_case() == kNamedObject) {
    if (GetArena() == nullptr) {
      delete _impl_.write_type_.named_object_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.write_type_.named_object_);
    }
    clear_has_write_type();
  }
}
inline ::substrait::NamedObjectWrite* DdlRel::release_named_object() {
  // @@protoc_insertion_point(field_release:substrait.DdlRel.named_object)
  if (write_type_case() == kNamedObject) {
    clear_has_write_type();
    auto* temp = _impl_.write_type_.named_object_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.write_type_.named_object_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::NamedObjectWrite& DdlRel::_internal_named_object() const {
  return write_type_case() == kNamedObject ? *_impl_.write_type_.named_object_ : reinterpret_cast<::substrait::NamedObjectWrite&>(::substrait::_NamedObjectWrite_default_instance_);
}
inline const ::substrait::NamedObjectWrite& DdlRel::named_object() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DdlRel.named_object)
  return _internal_named_object();
}
inline ::substrait::NamedObjectWrite* DdlRel::unsafe_arena_release_named_object() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.DdlRel.named_object)
  if (write_type_case() == kNamedObject) {
    clear_has_write_type();
    auto* temp = _impl_.write_type_.named_object_;
    _impl_.write_type_.named_object_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DdlRel::unsafe_arena_set_allocated_named_object(::substrait::NamedObjectWrite* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_write_type();
  if (value) {
    set_has_named_object();
    _impl_.write_type_.named_object_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DdlRel.named_object)
}
inline ::substrait::NamedObjectWrite* DdlRel::_internal_mutable_named_object() {
  if (write_type_case() != kNamedObject) {
    clear_write_type();
    set_has_named_object();
    _impl_.write_type_.named_object_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::NamedObjectWrite>(GetArena());
  }
  return _impl_.write_type_.named_object_;
}
inline ::substrait::NamedObjectWrite* DdlRel::mutable_named_object() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::NamedObjectWrite* _msg = _internal_mutable_named_object();
  // @@protoc_insertion_point(field_mutable:substrait.DdlRel.named_object)
  return _msg;
}

// .substrait.ExtensionObject extension_object = 2;
inline bool DdlRel::has_extension_object() const {
  return write_type_case() == kExtensionObject;
}
inline bool DdlRel::_internal_has_extension_object() const {
  return write_type_case() == kExtensionObject;
}
inline void DdlRel::set_has_extension_object() {
  _impl_._oneof_case_[0] = kExtensionObject;
}
inline void DdlRel::clear_extension_object() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (write_type_case() == kExtensionObject) {
    if (GetArena() == nullptr) {
      delete _impl_.write_type_.extension_object_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.write_type_.extension_object_);
    }
    clear_has_write_type();
  }
}
inline ::substrait::ExtensionObject* DdlRel::release_extension_object() {
  // @@protoc_insertion_point(field_release:substrait.DdlRel.extension_object)
  if (write_type_case() == kExtensionObject) {
    clear_has_write_type();
    auto* temp = _impl_.write_type_.extension_object_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.write_type_.extension_object_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::ExtensionObject& DdlRel::_internal_extension_object() const {
  return write_type_case() == kExtensionObject ? *_impl_.write_type_.extension_object_ : reinterpret_cast<::substrait::ExtensionObject&>(::substrait::_ExtensionObject_default_instance_);
}
inline const ::substrait::ExtensionObject& DdlRel::extension_object() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DdlRel.extension_object)
  return _internal_extension_object();
}
inline ::substrait::ExtensionObject* DdlRel::unsafe_arena_release_extension_object() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.DdlRel.extension_object)
  if (write_type_case() == kExtensionObject) {
    clear_has_write_type();
    auto* temp = _impl_.write_type_.extension_object_;
    _impl_.write_type_.extension_object_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DdlRel::unsafe_arena_set_allocated_extension_object(::substrait::ExtensionObject* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_write_type();
  if (value) {
    set_has_extension_object();
    _impl_.write_type_.extension_object_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DdlRel.extension_object)
}
inline ::substrait::ExtensionObject* DdlRel::_internal_mutable_extension_object() {
  if (write_type_case() != kExtensionObject) {
    clear_write_type();
    set_has_extension_object();
    _impl_.write_type_.extension_object_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::ExtensionObject>(GetArena());
  }
  return _impl_.write_type_.extension_object_;
}
inline ::substrait::ExtensionObject* DdlRel::mutable_extension_object() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::ExtensionObject* _msg = _internal_mutable_extension_object();
  // @@protoc_insertion_point(field_mutable:substrait.DdlRel.extension_object)
  return _msg;
}

// .substrait.NamedStruct table_schema = 3;
inline bool DdlRel::has_table_schema() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.table_schema_ != nullptr);
  return value;
}
inline const ::substrait::NamedStruct& DdlRel::_internal_table_schema() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::NamedStruct* p = _impl_.table_schema_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::NamedStruct&>(::substrait::_NamedStruct_default_instance_);
}
inline const ::substrait::NamedStruct& DdlRel::table_schema() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DdlRel.table_schema)
  return _internal_table_schema();
}
inline void DdlRel::unsafe_arena_set_allocated_table_schema(::substrait::NamedStruct* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.table_schema_);
  }
  _impl_.table_schema_ = reinterpret_cast<::substrait::NamedStruct*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DdlRel.table_schema)
}
inline ::substrait::NamedStruct* DdlRel::release_table_schema() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::NamedStruct* released = _impl_.table_schema_;
  _impl_.table_schema_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::NamedStruct* DdlRel::unsafe_arena_release_table_schema() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.DdlRel.table_schema)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::NamedStruct* temp = _impl_.table_schema_;
  _impl_.table_schema_ = nullptr;
  return temp;
}
inline ::substrait::NamedStruct* DdlRel::_internal_mutable_table_schema() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.table_schema_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::NamedStruct>(GetArena());
    _impl_.table_schema_ = reinterpret_cast<::substrait::NamedStruct*>(p);
  }
  return _impl_.table_schema_;
}
inline ::substrait::NamedStruct* DdlRel::mutable_table_schema() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::NamedStruct* _msg = _internal_mutable_table_schema();
  // @@protoc_insertion_point(field_mutable:substrait.DdlRel.table_schema)
  return _msg;
}
inline void DdlRel::set_allocated_table_schema(::substrait::NamedStruct* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.table_schema_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.table_schema_ = reinterpret_cast<::substrait::NamedStruct*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.DdlRel.table_schema)
}

// .substrait.Expression.Literal.Struct table_defaults = 4;
inline bool DdlRel::has_table_defaults() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.table_defaults_ != nullptr);
  return value;
}
inline void DdlRel::clear_table_defaults() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.table_defaults_ != nullptr) _impl_.table_defaults_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::substrait::Expression_Literal_Struct& DdlRel::_internal_table_defaults() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Expression_Literal_Struct* p = _impl_.table_defaults_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression_Literal_Struct&>(::substrait::_Expression_Literal_Struct_default_instance_);
}
inline const ::substrait::Expression_Literal_Struct& DdlRel::table_defaults() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DdlRel.table_defaults)
  return _internal_table_defaults();
}
inline void DdlRel::unsafe_arena_set_allocated_table_defaults(::substrait::Expression_Literal_Struct* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.table_defaults_);
  }
  _impl_.table_defaults_ = reinterpret_cast<::substrait::Expression_Literal_Struct*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DdlRel.table_defaults)
}
inline ::substrait::Expression_Literal_Struct* DdlRel::release_table_defaults() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Expression_Literal_Struct* released = _impl_.table_defaults_;
  _impl_.table_defaults_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Expression_Literal_Struct* DdlRel::unsafe_arena_release_table_defaults() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.DdlRel.table_defaults)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Expression_Literal_Struct* temp = _impl_.table_defaults_;
  _impl_.table_defaults_ = nullptr;
  return temp;
}
inline ::substrait::Expression_Literal_Struct* DdlRel::_internal_mutable_table_defaults() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.table_defaults_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_Literal_Struct>(GetArena());
    _impl_.table_defaults_ = reinterpret_cast<::substrait::Expression_Literal_Struct*>(p);
  }
  return _impl_.table_defaults_;
}
inline ::substrait::Expression_Literal_Struct* DdlRel::mutable_table_defaults() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::substrait::Expression_Literal_Struct* _msg = _internal_mutable_table_defaults();
  // @@protoc_insertion_point(field_mutable:substrait.DdlRel.table_defaults)
  return _msg;
}
inline void DdlRel::set_allocated_table_defaults(::substrait::Expression_Literal_Struct* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.table_defaults_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.table_defaults_ = reinterpret_cast<::substrait::Expression_Literal_Struct*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.DdlRel.table_defaults)
}

// .substrait.DdlRel.DdlObject object = 5;
inline void DdlRel::clear_object() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.object_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::substrait::DdlRel_DdlObject DdlRel::object() const {
  // @@protoc_insertion_point(field_get:substrait.DdlRel.object)
  return _internal_object();
}
inline void DdlRel::set_object(::substrait::DdlRel_DdlObject value) {
  _internal_set_object(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:substrait.DdlRel.object)
}
inline ::substrait::DdlRel_DdlObject DdlRel::_internal_object() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::substrait::DdlRel_DdlObject>(_impl_.object_);
}
inline void DdlRel::_internal_set_object(::substrait::DdlRel_DdlObject value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.object_ = value;
}

// .substrait.DdlRel.DdlOp op = 6;
inline void DdlRel::clear_op() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.op_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::substrait::DdlRel_DdlOp DdlRel::op() const {
  // @@protoc_insertion_point(field_get:substrait.DdlRel.op)
  return _internal_op();
}
inline void DdlRel::set_op(::substrait::DdlRel_DdlOp value) {
  _internal_set_op(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:substrait.DdlRel.op)
}
inline ::substrait::DdlRel_DdlOp DdlRel::_internal_op() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::substrait::DdlRel_DdlOp>(_impl_.op_);
}
inline void DdlRel::_internal_set_op(::substrait::DdlRel_DdlOp value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.op_ = value;
}

// .substrait.Rel view_definition = 7;
inline bool DdlRel::has_view_definition() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.view_definition_ != nullptr);
  return value;
}
inline void DdlRel::clear_view_definition() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.view_definition_ != nullptr) _impl_.view_definition_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::substrait::Rel& DdlRel::_internal_view_definition() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Rel* p = _impl_.view_definition_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Rel&>(::substrait::_Rel_default_instance_);
}
inline const ::substrait::Rel& DdlRel::view_definition() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DdlRel.view_definition)
  return _internal_view_definition();
}
inline void DdlRel::unsafe_arena_set_allocated_view_definition(::substrait::Rel* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.view_definition_);
  }
  _impl_.view_definition_ = reinterpret_cast<::substrait::Rel*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DdlRel.view_definition)
}
inline ::substrait::Rel* DdlRel::release_view_definition() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::substrait::Rel* released = _impl_.view_definition_;
  _impl_.view_definition_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Rel* DdlRel::unsafe_arena_release_view_definition() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.DdlRel.view_definition)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::substrait::Rel* temp = _impl_.view_definition_;
  _impl_.view_definition_ = nullptr;
  return temp;
}
inline ::substrait::Rel* DdlRel::_internal_mutable_view_definition() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.view_definition_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Rel>(GetArena());
    _impl_.view_definition_ = reinterpret_cast<::substrait::Rel*>(p);
  }
  return _impl_.view_definition_;
}
inline ::substrait::Rel* DdlRel::mutable_view_definition() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::substrait::Rel* _msg = _internal_mutable_view_definition();
  // @@protoc_insertion_point(field_mutable:substrait.DdlRel.view_definition)
  return _msg;
}
inline void DdlRel::set_allocated_view_definition(::substrait::Rel* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.view_definition_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.view_definition_ = reinterpret_cast<::substrait::Rel*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.DdlRel.view_definition)
}

// .substrait.RelCommon common = 8;
inline bool DdlRel::has_common() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.common_ != nullptr);
  return value;
}
inline void DdlRel::clear_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.common_ != nullptr) _impl_.common_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::substrait::RelCommon& DdlRel::_internal_common() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::RelCommon* p = _impl_.common_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::RelCommon&>(::substrait::_RelCommon_default_instance_);
}
inline const ::substrait::RelCommon& DdlRel::common() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DdlRel.common)
  return _internal_common();
}
inline void DdlRel::unsafe_arena_set_allocated_common(::substrait::RelCommon* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.common_);
  }
  _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DdlRel.common)
}
inline ::substrait::RelCommon* DdlRel::release_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::substrait::RelCommon* released = _impl_.common_;
  _impl_.common_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::RelCommon* DdlRel::unsafe_arena_release_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.DdlRel.common)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::substrait::RelCommon* temp = _impl_.common_;
  _impl_.common_ = nullptr;
  return temp;
}
inline ::substrait::RelCommon* DdlRel::_internal_mutable_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.common_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::RelCommon>(GetArena());
    _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(p);
  }
  return _impl_.common_;
}
inline ::substrait::RelCommon* DdlRel::mutable_common() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::substrait::RelCommon* _msg = _internal_mutable_common();
  // @@protoc_insertion_point(field_mutable:substrait.DdlRel.common)
  return _msg;
}
inline void DdlRel::set_allocated_common(::substrait::RelCommon* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.common_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.DdlRel.common)
}

inline bool DdlRel::has_write_type() const {
  return write_type_case() != WRITE_TYPE_NOT_SET;
}
inline void DdlRel::clear_has_write_type() {
  _impl_._oneof_case_[0] = WRITE_TYPE_NOT_SET;
}
inline DdlRel::WriteTypeCase DdlRel::write_type_case() const {
  return DdlRel::WriteTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// WriteRel

// .substrait.NamedObjectWrite named_table = 1;
inline bool WriteRel::has_named_table() const {
  return write_type_case() == kNamedTable;
}
inline bool WriteRel::_internal_has_named_table() const {
  return write_type_case() == kNamedTable;
}
inline void WriteRel::set_has_named_table() {
  _impl_._oneof_case_[0] = kNamedTable;
}
inline void WriteRel::clear_named_table() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (write_type_case() == kNamedTable) {
    if (GetArena() == nullptr) {
      delete _impl_.write_type_.named_table_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.write_type_.named_table_);
    }
    clear_has_write_type();
  }
}
inline ::substrait::NamedObjectWrite* WriteRel::release_named_table() {
  // @@protoc_insertion_point(field_release:substrait.WriteRel.named_table)
  if (write_type_case() == kNamedTable) {
    clear_has_write_type();
    auto* temp = _impl_.write_type_.named_table_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.write_type_.named_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::NamedObjectWrite& WriteRel::_internal_named_table() const {
  return write_type_case() == kNamedTable ? *_impl_.write_type_.named_table_ : reinterpret_cast<::substrait::NamedObjectWrite&>(::substrait::_NamedObjectWrite_default_instance_);
}
inline const ::substrait::NamedObjectWrite& WriteRel::named_table() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.WriteRel.named_table)
  return _internal_named_table();
}
inline ::substrait::NamedObjectWrite* WriteRel::unsafe_arena_release_named_table() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.WriteRel.named_table)
  if (write_type_case() == kNamedTable) {
    clear_has_write_type();
    auto* temp = _impl_.write_type_.named_table_;
    _impl_.write_type_.named_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WriteRel::unsafe_arena_set_allocated_named_table(::substrait::NamedObjectWrite* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_write_type();
  if (value) {
    set_has_named_table();
    _impl_.write_type_.named_table_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.WriteRel.named_table)
}
inline ::substrait::NamedObjectWrite* WriteRel::_internal_mutable_named_table() {
  if (write_type_case() != kNamedTable) {
    clear_write_type();
    set_has_named_table();
    _impl_.write_type_.named_table_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::NamedObjectWrite>(GetArena());
  }
  return _impl_.write_type_.named_table_;
}
inline ::substrait::NamedObjectWrite* WriteRel::mutable_named_table() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::NamedObjectWrite* _msg = _internal_mutable_named_table();
  // @@protoc_insertion_point(field_mutable:substrait.WriteRel.named_table)
  return _msg;
}

// .substrait.ExtensionObject extension_table = 2;
inline bool WriteRel::has_extension_table() const {
  return write_type_case() == kExtensionTable;
}
inline bool WriteRel::_internal_has_extension_table() const {
  return write_type_case() == kExtensionTable;
}
inline void WriteRel::set_has_extension_table() {
  _impl_._oneof_case_[0] = kExtensionTable;
}
inline void WriteRel::clear_extension_table() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (write_type_case() == kExtensionTable) {
    if (GetArena() == nullptr) {
      delete _impl_.write_type_.extension_table_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.write_type_.extension_table_);
    }
    clear_has_write_type();
  }
}
inline ::substrait::ExtensionObject* WriteRel::release_extension_table() {
  // @@protoc_insertion_point(field_release:substrait.WriteRel.extension_table)
  if (write_type_case() == kExtensionTable) {
    clear_has_write_type();
    auto* temp = _impl_.write_type_.extension_table_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.write_type_.extension_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::ExtensionObject& WriteRel::_internal_extension_table() const {
  return write_type_case() == kExtensionTable ? *_impl_.write_type_.extension_table_ : reinterpret_cast<::substrait::ExtensionObject&>(::substrait::_ExtensionObject_default_instance_);
}
inline const ::substrait::ExtensionObject& WriteRel::extension_table() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.WriteRel.extension_table)
  return _internal_extension_table();
}
inline ::substrait::ExtensionObject* WriteRel::unsafe_arena_release_extension_table() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.WriteRel.extension_table)
  if (write_type_case() == kExtensionTable) {
    clear_has_write_type();
    auto* temp = _impl_.write_type_.extension_table_;
    _impl_.write_type_.extension_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WriteRel::unsafe_arena_set_allocated_extension_table(::substrait::ExtensionObject* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_write_type();
  if (value) {
    set_has_extension_table();
    _impl_.write_type_.extension_table_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.WriteRel.extension_table)
}
inline ::substrait::ExtensionObject* WriteRel::_internal_mutable_extension_table() {
  if (write_type_case() != kExtensionTable) {
    clear_write_type();
    set_has_extension_table();
    _impl_.write_type_.extension_table_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::ExtensionObject>(GetArena());
  }
  return _impl_.write_type_.extension_table_;
}
inline ::substrait::ExtensionObject* WriteRel::mutable_extension_table() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::ExtensionObject* _msg = _internal_mutable_extension_table();
  // @@protoc_insertion_point(field_mutable:substrait.WriteRel.extension_table)
  return _msg;
}

// .substrait.NamedStruct table_schema = 3;
inline bool WriteRel::has_table_schema() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.table_schema_ != nullptr);
  return value;
}
inline const ::substrait::NamedStruct& WriteRel::_internal_table_schema() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::NamedStruct* p = _impl_.table_schema_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::NamedStruct&>(::substrait::_NamedStruct_default_instance_);
}
inline const ::substrait::NamedStruct& WriteRel::table_schema() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.WriteRel.table_schema)
  return _internal_table_schema();
}
inline void WriteRel::unsafe_arena_set_allocated_table_schema(::substrait::NamedStruct* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.table_schema_);
  }
  _impl_.table_schema_ = reinterpret_cast<::substrait::NamedStruct*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.WriteRel.table_schema)
}
inline ::substrait::NamedStruct* WriteRel::release_table_schema() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::NamedStruct* released = _impl_.table_schema_;
  _impl_.table_schema_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::NamedStruct* WriteRel::unsafe_arena_release_table_schema() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.WriteRel.table_schema)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::NamedStruct* temp = _impl_.table_schema_;
  _impl_.table_schema_ = nullptr;
  return temp;
}
inline ::substrait::NamedStruct* WriteRel::_internal_mutable_table_schema() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.table_schema_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::NamedStruct>(GetArena());
    _impl_.table_schema_ = reinterpret_cast<::substrait::NamedStruct*>(p);
  }
  return _impl_.table_schema_;
}
inline ::substrait::NamedStruct* WriteRel::mutable_table_schema() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::NamedStruct* _msg = _internal_mutable_table_schema();
  // @@protoc_insertion_point(field_mutable:substrait.WriteRel.table_schema)
  return _msg;
}
inline void WriteRel::set_allocated_table_schema(::substrait::NamedStruct* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.table_schema_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.table_schema_ = reinterpret_cast<::substrait::NamedStruct*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.WriteRel.table_schema)
}

// .substrait.WriteRel.WriteOp op = 4;
inline void WriteRel::clear_op() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.op_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::substrait::WriteRel_WriteOp WriteRel::op() const {
  // @@protoc_insertion_point(field_get:substrait.WriteRel.op)
  return _internal_op();
}
inline void WriteRel::set_op(::substrait::WriteRel_WriteOp value) {
  _internal_set_op(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:substrait.WriteRel.op)
}
inline ::substrait::WriteRel_WriteOp WriteRel::_internal_op() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::substrait::WriteRel_WriteOp>(_impl_.op_);
}
inline void WriteRel::_internal_set_op(::substrait::WriteRel_WriteOp value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.op_ = value;
}

// .substrait.Rel input = 5;
inline bool WriteRel::has_input() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.input_ != nullptr);
  return value;
}
inline void WriteRel::clear_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.input_ != nullptr) _impl_.input_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::substrait::Rel& WriteRel::_internal_input() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Rel* p = _impl_.input_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Rel&>(::substrait::_Rel_default_instance_);
}
inline const ::substrait::Rel& WriteRel::input() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.WriteRel.input)
  return _internal_input();
}
inline void WriteRel::unsafe_arena_set_allocated_input(::substrait::Rel* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.input_);
  }
  _impl_.input_ = reinterpret_cast<::substrait::Rel*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.WriteRel.input)
}
inline ::substrait::Rel* WriteRel::release_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Rel* released = _impl_.input_;
  _impl_.input_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Rel* WriteRel::unsafe_arena_release_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.WriteRel.input)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Rel* temp = _impl_.input_;
  _impl_.input_ = nullptr;
  return temp;
}
inline ::substrait::Rel* WriteRel::_internal_mutable_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.input_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Rel>(GetArena());
    _impl_.input_ = reinterpret_cast<::substrait::Rel*>(p);
  }
  return _impl_.input_;
}
inline ::substrait::Rel* WriteRel::mutable_input() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::substrait::Rel* _msg = _internal_mutable_input();
  // @@protoc_insertion_point(field_mutable:substrait.WriteRel.input)
  return _msg;
}
inline void WriteRel::set_allocated_input(::substrait::Rel* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.input_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.input_ = reinterpret_cast<::substrait::Rel*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.WriteRel.input)
}

// .substrait.WriteRel.OutputMode output = 6;
inline void WriteRel::clear_output() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.output_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::substrait::WriteRel_OutputMode WriteRel::output() const {
  // @@protoc_insertion_point(field_get:substrait.WriteRel.output)
  return _internal_output();
}
inline void WriteRel::set_output(::substrait::WriteRel_OutputMode value) {
  _internal_set_output(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:substrait.WriteRel.output)
}
inline ::substrait::WriteRel_OutputMode WriteRel::_internal_output() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::substrait::WriteRel_OutputMode>(_impl_.output_);
}
inline void WriteRel::_internal_set_output(::substrait::WriteRel_OutputMode value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.output_ = value;
}

// .substrait.RelCommon common = 7;
inline bool WriteRel::has_common() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.common_ != nullptr);
  return value;
}
inline void WriteRel::clear_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.common_ != nullptr) _impl_.common_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::substrait::RelCommon& WriteRel::_internal_common() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::RelCommon* p = _impl_.common_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::RelCommon&>(::substrait::_RelCommon_default_instance_);
}
inline const ::substrait::RelCommon& WriteRel::common() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.WriteRel.common)
  return _internal_common();
}
inline void WriteRel::unsafe_arena_set_allocated_common(::substrait::RelCommon* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.common_);
  }
  _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.WriteRel.common)
}
inline ::substrait::RelCommon* WriteRel::release_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::substrait::RelCommon* released = _impl_.common_;
  _impl_.common_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::RelCommon* WriteRel::unsafe_arena_release_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.WriteRel.common)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::substrait::RelCommon* temp = _impl_.common_;
  _impl_.common_ = nullptr;
  return temp;
}
inline ::substrait::RelCommon* WriteRel::_internal_mutable_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.common_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::RelCommon>(GetArena());
    _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(p);
  }
  return _impl_.common_;
}
inline ::substrait::RelCommon* WriteRel::mutable_common() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::substrait::RelCommon* _msg = _internal_mutable_common();
  // @@protoc_insertion_point(field_mutable:substrait.WriteRel.common)
  return _msg;
}
inline void WriteRel::set_allocated_common(::substrait::RelCommon* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.common_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.WriteRel.common)
}

inline bool WriteRel::has_write_type() const {
  return write_type_case() != WRITE_TYPE_NOT_SET;
}
inline void WriteRel::clear_has_write_type() {
  _impl_._oneof_case_[0] = WRITE_TYPE_NOT_SET;
}
inline WriteRel::WriteTypeCase WriteRel::write_type_case() const {
  return WriteRel::WriteTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ComparisonJoinKey_ComparisonType

// .substrait.ComparisonJoinKey.SimpleComparisonType simple = 1;
inline bool ComparisonJoinKey_ComparisonType::has_simple() const {
  return inner_type_case() == kSimple;
}
inline void ComparisonJoinKey_ComparisonType::set_has_simple() {
  _impl_._oneof_case_[0] = kSimple;
}
inline void ComparisonJoinKey_ComparisonType::clear_simple() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (inner_type_case() == kSimple) {
    _impl_.inner_type_.simple_ = 0;
    clear_has_inner_type();
  }
}
inline ::substrait::ComparisonJoinKey_SimpleComparisonType ComparisonJoinKey_ComparisonType::simple() const {
  // @@protoc_insertion_point(field_get:substrait.ComparisonJoinKey.ComparisonType.simple)
  return _internal_simple();
}
inline void ComparisonJoinKey_ComparisonType::set_simple(::substrait::ComparisonJoinKey_SimpleComparisonType value) {
  if (inner_type_case() != kSimple) {
    clear_inner_type();
    set_has_simple();
  }
  _impl_.inner_type_.simple_ = value;
  // @@protoc_insertion_point(field_set:substrait.ComparisonJoinKey.ComparisonType.simple)
}
inline ::substrait::ComparisonJoinKey_SimpleComparisonType ComparisonJoinKey_ComparisonType::_internal_simple() const {
  if (inner_type_case() == kSimple) {
    return static_cast<::substrait::ComparisonJoinKey_SimpleComparisonType>(_impl_.inner_type_.simple_);
  }
  return static_cast<::substrait::ComparisonJoinKey_SimpleComparisonType>(0);
}

// uint32 custom_function_reference = 2;
inline bool ComparisonJoinKey_ComparisonType::has_custom_function_reference() const {
  return inner_type_case() == kCustomFunctionReference;
}
inline void ComparisonJoinKey_ComparisonType::set_has_custom_function_reference() {
  _impl_._oneof_case_[0] = kCustomFunctionReference;
}
inline void ComparisonJoinKey_ComparisonType::clear_custom_function_reference() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (inner_type_case() == kCustomFunctionReference) {
    _impl_.inner_type_.custom_function_reference_ = 0u;
    clear_has_inner_type();
  }
}
inline ::uint32_t ComparisonJoinKey_ComparisonType::custom_function_reference() const {
  // @@protoc_insertion_point(field_get:substrait.ComparisonJoinKey.ComparisonType.custom_function_reference)
  return _internal_custom_function_reference();
}
inline void ComparisonJoinKey_ComparisonType::set_custom_function_reference(::uint32_t value) {
  if (inner_type_case() != kCustomFunctionReference) {
    clear_inner_type();
    set_has_custom_function_reference();
  }
  _impl_.inner_type_.custom_function_reference_ = value;
  // @@protoc_insertion_point(field_set:substrait.ComparisonJoinKey.ComparisonType.custom_function_reference)
}
inline ::uint32_t ComparisonJoinKey_ComparisonType::_internal_custom_function_reference() const {
  if (inner_type_case() == kCustomFunctionReference) {
    return _impl_.inner_type_.custom_function_reference_;
  }
  return 0u;
}

inline bool ComparisonJoinKey_ComparisonType::has_inner_type() const {
  return inner_type_case() != INNER_TYPE_NOT_SET;
}
inline void ComparisonJoinKey_ComparisonType::clear_has_inner_type() {
  _impl_._oneof_case_[0] = INNER_TYPE_NOT_SET;
}
inline ComparisonJoinKey_ComparisonType::InnerTypeCase ComparisonJoinKey_ComparisonType::inner_type_case() const {
  return ComparisonJoinKey_ComparisonType::InnerTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ComparisonJoinKey

// .substrait.Expression.FieldReference left = 1;
inline bool ComparisonJoinKey::has_left() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.left_ != nullptr);
  return value;
}
inline void ComparisonJoinKey::clear_left() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.left_ != nullptr) _impl_.left_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::Expression_FieldReference& ComparisonJoinKey::_internal_left() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Expression_FieldReference* p = _impl_.left_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression_FieldReference&>(::substrait::_Expression_FieldReference_default_instance_);
}
inline const ::substrait::Expression_FieldReference& ComparisonJoinKey::left() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ComparisonJoinKey.left)
  return _internal_left();
}
inline void ComparisonJoinKey::unsafe_arena_set_allocated_left(::substrait::Expression_FieldReference* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.left_);
  }
  _impl_.left_ = reinterpret_cast<::substrait::Expression_FieldReference*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ComparisonJoinKey.left)
}
inline ::substrait::Expression_FieldReference* ComparisonJoinKey::release_left() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Expression_FieldReference* released = _impl_.left_;
  _impl_.left_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Expression_FieldReference* ComparisonJoinKey::unsafe_arena_release_left() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.ComparisonJoinKey.left)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Expression_FieldReference* temp = _impl_.left_;
  _impl_.left_ = nullptr;
  return temp;
}
inline ::substrait::Expression_FieldReference* ComparisonJoinKey::_internal_mutable_left() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.left_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_FieldReference>(GetArena());
    _impl_.left_ = reinterpret_cast<::substrait::Expression_FieldReference*>(p);
  }
  return _impl_.left_;
}
inline ::substrait::Expression_FieldReference* ComparisonJoinKey::mutable_left() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::Expression_FieldReference* _msg = _internal_mutable_left();
  // @@protoc_insertion_point(field_mutable:substrait.ComparisonJoinKey.left)
  return _msg;
}
inline void ComparisonJoinKey::set_allocated_left(::substrait::Expression_FieldReference* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.left_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.left_ = reinterpret_cast<::substrait::Expression_FieldReference*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.ComparisonJoinKey.left)
}

// .substrait.Expression.FieldReference right = 2;
inline bool ComparisonJoinKey::has_right() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.right_ != nullptr);
  return value;
}
inline void ComparisonJoinKey::clear_right() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.right_ != nullptr) _impl_.right_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::substrait::Expression_FieldReference& ComparisonJoinKey::_internal_right() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Expression_FieldReference* p = _impl_.right_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression_FieldReference&>(::substrait::_Expression_FieldReference_default_instance_);
}
inline const ::substrait::Expression_FieldReference& ComparisonJoinKey::right() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ComparisonJoinKey.right)
  return _internal_right();
}
inline void ComparisonJoinKey::unsafe_arena_set_allocated_right(::substrait::Expression_FieldReference* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.right_);
  }
  _impl_.right_ = reinterpret_cast<::substrait::Expression_FieldReference*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ComparisonJoinKey.right)
}
inline ::substrait::Expression_FieldReference* ComparisonJoinKey::release_right() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Expression_FieldReference* released = _impl_.right_;
  _impl_.right_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Expression_FieldReference* ComparisonJoinKey::unsafe_arena_release_right() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.ComparisonJoinKey.right)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Expression_FieldReference* temp = _impl_.right_;
  _impl_.right_ = nullptr;
  return temp;
}
inline ::substrait::Expression_FieldReference* ComparisonJoinKey::_internal_mutable_right() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.right_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_FieldReference>(GetArena());
    _impl_.right_ = reinterpret_cast<::substrait::Expression_FieldReference*>(p);
  }
  return _impl_.right_;
}
inline ::substrait::Expression_FieldReference* ComparisonJoinKey::mutable_right() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::substrait::Expression_FieldReference* _msg = _internal_mutable_right();
  // @@protoc_insertion_point(field_mutable:substrait.ComparisonJoinKey.right)
  return _msg;
}
inline void ComparisonJoinKey::set_allocated_right(::substrait::Expression_FieldReference* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.right_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.right_ = reinterpret_cast<::substrait::Expression_FieldReference*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.ComparisonJoinKey.right)
}

// .substrait.ComparisonJoinKey.ComparisonType comparison = 3;
inline bool ComparisonJoinKey::has_comparison() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.comparison_ != nullptr);
  return value;
}
inline void ComparisonJoinKey::clear_comparison() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.comparison_ != nullptr) _impl_.comparison_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::substrait::ComparisonJoinKey_ComparisonType& ComparisonJoinKey::_internal_comparison() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::ComparisonJoinKey_ComparisonType* p = _impl_.comparison_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::ComparisonJoinKey_ComparisonType&>(::substrait::_ComparisonJoinKey_ComparisonType_default_instance_);
}
inline const ::substrait::ComparisonJoinKey_ComparisonType& ComparisonJoinKey::comparison() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.ComparisonJoinKey.comparison)
  return _internal_comparison();
}
inline void ComparisonJoinKey::unsafe_arena_set_allocated_comparison(::substrait::ComparisonJoinKey_ComparisonType* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.comparison_);
  }
  _impl_.comparison_ = reinterpret_cast<::substrait::ComparisonJoinKey_ComparisonType*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.ComparisonJoinKey.comparison)
}
inline ::substrait::ComparisonJoinKey_ComparisonType* ComparisonJoinKey::release_comparison() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::substrait::ComparisonJoinKey_ComparisonType* released = _impl_.comparison_;
  _impl_.comparison_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::ComparisonJoinKey_ComparisonType* ComparisonJoinKey::unsafe_arena_release_comparison() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.ComparisonJoinKey.comparison)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::substrait::ComparisonJoinKey_ComparisonType* temp = _impl_.comparison_;
  _impl_.comparison_ = nullptr;
  return temp;
}
inline ::substrait::ComparisonJoinKey_ComparisonType* ComparisonJoinKey::_internal_mutable_comparison() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.comparison_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::ComparisonJoinKey_ComparisonType>(GetArena());
    _impl_.comparison_ = reinterpret_cast<::substrait::ComparisonJoinKey_ComparisonType*>(p);
  }
  return _impl_.comparison_;
}
inline ::substrait::ComparisonJoinKey_ComparisonType* ComparisonJoinKey::mutable_comparison() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::substrait::ComparisonJoinKey_ComparisonType* _msg = _internal_mutable_comparison();
  // @@protoc_insertion_point(field_mutable:substrait.ComparisonJoinKey.comparison)
  return _msg;
}
inline void ComparisonJoinKey::set_allocated_comparison(::substrait::ComparisonJoinKey_ComparisonType* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.comparison_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.comparison_ = reinterpret_cast<::substrait::ComparisonJoinKey_ComparisonType*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.ComparisonJoinKey.comparison)
}

// -------------------------------------------------------------------

// HashJoinRel

// .substrait.RelCommon common = 1;
inline bool HashJoinRel::has_common() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.common_ != nullptr);
  return value;
}
inline void HashJoinRel::clear_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.common_ != nullptr) _impl_.common_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::RelCommon& HashJoinRel::_internal_common() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::RelCommon* p = _impl_.common_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::RelCommon&>(::substrait::_RelCommon_default_instance_);
}
inline const ::substrait::RelCommon& HashJoinRel::common() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.HashJoinRel.common)
  return _internal_common();
}
inline void HashJoinRel::unsafe_arena_set_allocated_common(::substrait::RelCommon* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.common_);
  }
  _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.HashJoinRel.common)
}
inline ::substrait::RelCommon* HashJoinRel::release_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::RelCommon* released = _impl_.common_;
  _impl_.common_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::RelCommon* HashJoinRel::unsafe_arena_release_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.HashJoinRel.common)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::RelCommon* temp = _impl_.common_;
  _impl_.common_ = nullptr;
  return temp;
}
inline ::substrait::RelCommon* HashJoinRel::_internal_mutable_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.common_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::RelCommon>(GetArena());
    _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(p);
  }
  return _impl_.common_;
}
inline ::substrait::RelCommon* HashJoinRel::mutable_common() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::RelCommon* _msg = _internal_mutable_common();
  // @@protoc_insertion_point(field_mutable:substrait.HashJoinRel.common)
  return _msg;
}
inline void HashJoinRel::set_allocated_common(::substrait::RelCommon* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.common_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.HashJoinRel.common)
}

// .substrait.Rel left = 2;
inline bool HashJoinRel::has_left() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.left_ != nullptr);
  return value;
}
inline void HashJoinRel::clear_left() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.left_ != nullptr) _impl_.left_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::substrait::Rel& HashJoinRel::_internal_left() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Rel* p = _impl_.left_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Rel&>(::substrait::_Rel_default_instance_);
}
inline const ::substrait::Rel& HashJoinRel::left() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.HashJoinRel.left)
  return _internal_left();
}
inline void HashJoinRel::unsafe_arena_set_allocated_left(::substrait::Rel* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.left_);
  }
  _impl_.left_ = reinterpret_cast<::substrait::Rel*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.HashJoinRel.left)
}
inline ::substrait::Rel* HashJoinRel::release_left() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Rel* released = _impl_.left_;
  _impl_.left_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Rel* HashJoinRel::unsafe_arena_release_left() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.HashJoinRel.left)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Rel* temp = _impl_.left_;
  _impl_.left_ = nullptr;
  return temp;
}
inline ::substrait::Rel* HashJoinRel::_internal_mutable_left() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.left_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Rel>(GetArena());
    _impl_.left_ = reinterpret_cast<::substrait::Rel*>(p);
  }
  return _impl_.left_;
}
inline ::substrait::Rel* HashJoinRel::mutable_left() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::substrait::Rel* _msg = _internal_mutable_left();
  // @@protoc_insertion_point(field_mutable:substrait.HashJoinRel.left)
  return _msg;
}
inline void HashJoinRel::set_allocated_left(::substrait::Rel* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.left_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.left_ = reinterpret_cast<::substrait::Rel*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.HashJoinRel.left)
}

// .substrait.Rel right = 3;
inline bool HashJoinRel::has_right() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.right_ != nullptr);
  return value;
}
inline void HashJoinRel::clear_right() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.right_ != nullptr) _impl_.right_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::substrait::Rel& HashJoinRel::_internal_right() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Rel* p = _impl_.right_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Rel&>(::substrait::_Rel_default_instance_);
}
inline const ::substrait::Rel& HashJoinRel::right() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.HashJoinRel.right)
  return _internal_right();
}
inline void HashJoinRel::unsafe_arena_set_allocated_right(::substrait::Rel* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.right_);
  }
  _impl_.right_ = reinterpret_cast<::substrait::Rel*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.HashJoinRel.right)
}
inline ::substrait::Rel* HashJoinRel::release_right() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::substrait::Rel* released = _impl_.right_;
  _impl_.right_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Rel* HashJoinRel::unsafe_arena_release_right() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.HashJoinRel.right)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::substrait::Rel* temp = _impl_.right_;
  _impl_.right_ = nullptr;
  return temp;
}
inline ::substrait::Rel* HashJoinRel::_internal_mutable_right() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.right_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Rel>(GetArena());
    _impl_.right_ = reinterpret_cast<::substrait::Rel*>(p);
  }
  return _impl_.right_;
}
inline ::substrait::Rel* HashJoinRel::mutable_right() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::substrait::Rel* _msg = _internal_mutable_right();
  // @@protoc_insertion_point(field_mutable:substrait.HashJoinRel.right)
  return _msg;
}
inline void HashJoinRel::set_allocated_right(::substrait::Rel* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.right_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.right_ = reinterpret_cast<::substrait::Rel*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.HashJoinRel.right)
}

// repeated .substrait.Expression.FieldReference left_keys = 4 [deprecated = true];
inline int HashJoinRel::_internal_left_keys_size() const {
  return _internal_left_keys().size();
}
inline int HashJoinRel::left_keys_size() const {
  return _internal_left_keys_size();
}
inline void HashJoinRel::clear_left_keys() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.left_keys_.Clear();
}
inline ::substrait::Expression_FieldReference* HashJoinRel::mutable_left_keys(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.HashJoinRel.left_keys)
  return _internal_mutable_left_keys()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression_FieldReference>* HashJoinRel::mutable_left_keys()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.HashJoinRel.left_keys)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_left_keys();
}
inline const ::substrait::Expression_FieldReference& HashJoinRel::left_keys(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.HashJoinRel.left_keys)
  return _internal_left_keys().Get(index);
}
inline ::substrait::Expression_FieldReference* HashJoinRel::add_left_keys() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::Expression_FieldReference* _add = _internal_mutable_left_keys()->Add();
  // @@protoc_insertion_point(field_add:substrait.HashJoinRel.left_keys)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression_FieldReference>& HashJoinRel::left_keys() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.HashJoinRel.left_keys)
  return _internal_left_keys();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression_FieldReference>&
HashJoinRel::_internal_left_keys() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.left_keys_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression_FieldReference>*
HashJoinRel::_internal_mutable_left_keys() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.left_keys_;
}

// repeated .substrait.Expression.FieldReference right_keys = 5 [deprecated = true];
inline int HashJoinRel::_internal_right_keys_size() const {
  return _internal_right_keys().size();
}
inline int HashJoinRel::right_keys_size() const {
  return _internal_right_keys_size();
}
inline void HashJoinRel::clear_right_keys() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.right_keys_.Clear();
}
inline ::substrait::Expression_FieldReference* HashJoinRel::mutable_right_keys(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.HashJoinRel.right_keys)
  return _internal_mutable_right_keys()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression_FieldReference>* HashJoinRel::mutable_right_keys()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.HashJoinRel.right_keys)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_right_keys();
}
inline const ::substrait::Expression_FieldReference& HashJoinRel::right_keys(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.HashJoinRel.right_keys)
  return _internal_right_keys().Get(index);
}
inline ::substrait::Expression_FieldReference* HashJoinRel::add_right_keys() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::Expression_FieldReference* _add = _internal_mutable_right_keys()->Add();
  // @@protoc_insertion_point(field_add:substrait.HashJoinRel.right_keys)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression_FieldReference>& HashJoinRel::right_keys() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.HashJoinRel.right_keys)
  return _internal_right_keys();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression_FieldReference>&
HashJoinRel::_internal_right_keys() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.right_keys_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression_FieldReference>*
HashJoinRel::_internal_mutable_right_keys() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.right_keys_;
}

// repeated .substrait.ComparisonJoinKey keys = 8;
inline int HashJoinRel::_internal_keys_size() const {
  return _internal_keys().size();
}
inline int HashJoinRel::keys_size() const {
  return _internal_keys_size();
}
inline void HashJoinRel::clear_keys() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.keys_.Clear();
}
inline ::substrait::ComparisonJoinKey* HashJoinRel::mutable_keys(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.HashJoinRel.keys)
  return _internal_mutable_keys()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::ComparisonJoinKey>* HashJoinRel::mutable_keys()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.HashJoinRel.keys)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_keys();
}
inline const ::substrait::ComparisonJoinKey& HashJoinRel::keys(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.HashJoinRel.keys)
  return _internal_keys().Get(index);
}
inline ::substrait::ComparisonJoinKey* HashJoinRel::add_keys() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::ComparisonJoinKey* _add = _internal_mutable_keys()->Add();
  // @@protoc_insertion_point(field_add:substrait.HashJoinRel.keys)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::ComparisonJoinKey>& HashJoinRel::keys() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.HashJoinRel.keys)
  return _internal_keys();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::ComparisonJoinKey>&
HashJoinRel::_internal_keys() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.keys_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::ComparisonJoinKey>*
HashJoinRel::_internal_mutable_keys() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.keys_;
}

// .substrait.Expression post_join_filter = 6;
inline bool HashJoinRel::has_post_join_filter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.post_join_filter_ != nullptr);
  return value;
}
inline void HashJoinRel::clear_post_join_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.post_join_filter_ != nullptr) _impl_.post_join_filter_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::substrait::Expression& HashJoinRel::_internal_post_join_filter() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Expression* p = _impl_.post_join_filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression&>(::substrait::_Expression_default_instance_);
}
inline const ::substrait::Expression& HashJoinRel::post_join_filter() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.HashJoinRel.post_join_filter)
  return _internal_post_join_filter();
}
inline void HashJoinRel::unsafe_arena_set_allocated_post_join_filter(::substrait::Expression* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.post_join_filter_);
  }
  _impl_.post_join_filter_ = reinterpret_cast<::substrait::Expression*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.HashJoinRel.post_join_filter)
}
inline ::substrait::Expression* HashJoinRel::release_post_join_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::substrait::Expression* released = _impl_.post_join_filter_;
  _impl_.post_join_filter_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Expression* HashJoinRel::unsafe_arena_release_post_join_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.HashJoinRel.post_join_filter)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::substrait::Expression* temp = _impl_.post_join_filter_;
  _impl_.post_join_filter_ = nullptr;
  return temp;
}
inline ::substrait::Expression* HashJoinRel::_internal_mutable_post_join_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.post_join_filter_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Expression>(GetArena());
    _impl_.post_join_filter_ = reinterpret_cast<::substrait::Expression*>(p);
  }
  return _impl_.post_join_filter_;
}
inline ::substrait::Expression* HashJoinRel::mutable_post_join_filter() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::substrait::Expression* _msg = _internal_mutable_post_join_filter();
  // @@protoc_insertion_point(field_mutable:substrait.HashJoinRel.post_join_filter)
  return _msg;
}
inline void HashJoinRel::set_allocated_post_join_filter(::substrait::Expression* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.post_join_filter_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.post_join_filter_ = reinterpret_cast<::substrait::Expression*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.HashJoinRel.post_join_filter)
}

// .substrait.HashJoinRel.JoinType type = 7;
inline void HashJoinRel::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::substrait::HashJoinRel_JoinType HashJoinRel::type() const {
  // @@protoc_insertion_point(field_get:substrait.HashJoinRel.type)
  return _internal_type();
}
inline void HashJoinRel::set_type(::substrait::HashJoinRel_JoinType value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:substrait.HashJoinRel.type)
}
inline ::substrait::HashJoinRel_JoinType HashJoinRel::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::substrait::HashJoinRel_JoinType>(_impl_.type_);
}
inline void HashJoinRel::_internal_set_type(::substrait::HashJoinRel_JoinType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// .substrait.extensions.AdvancedExtension advanced_extension = 10;
inline bool HashJoinRel::has_advanced_extension() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.advanced_extension_ != nullptr);
  return value;
}
inline const ::substrait::extensions::AdvancedExtension& HashJoinRel::_internal_advanced_extension() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::extensions::AdvancedExtension* p = _impl_.advanced_extension_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::extensions::AdvancedExtension&>(::substrait::extensions::_AdvancedExtension_default_instance_);
}
inline const ::substrait::extensions::AdvancedExtension& HashJoinRel::advanced_extension() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.HashJoinRel.advanced_extension)
  return _internal_advanced_extension();
}
inline void HashJoinRel::unsafe_arena_set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.advanced_extension_);
  }
  _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.HashJoinRel.advanced_extension)
}
inline ::substrait::extensions::AdvancedExtension* HashJoinRel::release_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::substrait::extensions::AdvancedExtension* released = _impl_.advanced_extension_;
  _impl_.advanced_extension_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::extensions::AdvancedExtension* HashJoinRel::unsafe_arena_release_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.HashJoinRel.advanced_extension)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::substrait::extensions::AdvancedExtension* temp = _impl_.advanced_extension_;
  _impl_.advanced_extension_ = nullptr;
  return temp;
}
inline ::substrait::extensions::AdvancedExtension* HashJoinRel::_internal_mutable_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.advanced_extension_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::extensions::AdvancedExtension>(GetArena());
    _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(p);
  }
  return _impl_.advanced_extension_;
}
inline ::substrait::extensions::AdvancedExtension* HashJoinRel::mutable_advanced_extension() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::substrait::extensions::AdvancedExtension* _msg = _internal_mutable_advanced_extension();
  // @@protoc_insertion_point(field_mutable:substrait.HashJoinRel.advanced_extension)
  return _msg;
}
inline void HashJoinRel::set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.advanced_extension_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.HashJoinRel.advanced_extension)
}

// -------------------------------------------------------------------

// MergeJoinRel

// .substrait.RelCommon common = 1;
inline bool MergeJoinRel::has_common() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.common_ != nullptr);
  return value;
}
inline void MergeJoinRel::clear_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.common_ != nullptr) _impl_.common_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::RelCommon& MergeJoinRel::_internal_common() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::RelCommon* p = _impl_.common_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::RelCommon&>(::substrait::_RelCommon_default_instance_);
}
inline const ::substrait::RelCommon& MergeJoinRel::common() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.MergeJoinRel.common)
  return _internal_common();
}
inline void MergeJoinRel::unsafe_arena_set_allocated_common(::substrait::RelCommon* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.common_);
  }
  _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.MergeJoinRel.common)
}
inline ::substrait::RelCommon* MergeJoinRel::release_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::RelCommon* released = _impl_.common_;
  _impl_.common_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::RelCommon* MergeJoinRel::unsafe_arena_release_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.MergeJoinRel.common)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::RelCommon* temp = _impl_.common_;
  _impl_.common_ = nullptr;
  return temp;
}
inline ::substrait::RelCommon* MergeJoinRel::_internal_mutable_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.common_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::RelCommon>(GetArena());
    _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(p);
  }
  return _impl_.common_;
}
inline ::substrait::RelCommon* MergeJoinRel::mutable_common() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::RelCommon* _msg = _internal_mutable_common();
  // @@protoc_insertion_point(field_mutable:substrait.MergeJoinRel.common)
  return _msg;
}
inline void MergeJoinRel::set_allocated_common(::substrait::RelCommon* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.common_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.MergeJoinRel.common)
}

// .substrait.Rel left = 2;
inline bool MergeJoinRel::has_left() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.left_ != nullptr);
  return value;
}
inline void MergeJoinRel::clear_left() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.left_ != nullptr) _impl_.left_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::substrait::Rel& MergeJoinRel::_internal_left() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Rel* p = _impl_.left_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Rel&>(::substrait::_Rel_default_instance_);
}
inline const ::substrait::Rel& MergeJoinRel::left() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.MergeJoinRel.left)
  return _internal_left();
}
inline void MergeJoinRel::unsafe_arena_set_allocated_left(::substrait::Rel* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.left_);
  }
  _impl_.left_ = reinterpret_cast<::substrait::Rel*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.MergeJoinRel.left)
}
inline ::substrait::Rel* MergeJoinRel::release_left() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Rel* released = _impl_.left_;
  _impl_.left_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Rel* MergeJoinRel::unsafe_arena_release_left() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.MergeJoinRel.left)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Rel* temp = _impl_.left_;
  _impl_.left_ = nullptr;
  return temp;
}
inline ::substrait::Rel* MergeJoinRel::_internal_mutable_left() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.left_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Rel>(GetArena());
    _impl_.left_ = reinterpret_cast<::substrait::Rel*>(p);
  }
  return _impl_.left_;
}
inline ::substrait::Rel* MergeJoinRel::mutable_left() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::substrait::Rel* _msg = _internal_mutable_left();
  // @@protoc_insertion_point(field_mutable:substrait.MergeJoinRel.left)
  return _msg;
}
inline void MergeJoinRel::set_allocated_left(::substrait::Rel* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.left_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.left_ = reinterpret_cast<::substrait::Rel*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.MergeJoinRel.left)
}

// .substrait.Rel right = 3;
inline bool MergeJoinRel::has_right() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.right_ != nullptr);
  return value;
}
inline void MergeJoinRel::clear_right() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.right_ != nullptr) _impl_.right_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::substrait::Rel& MergeJoinRel::_internal_right() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Rel* p = _impl_.right_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Rel&>(::substrait::_Rel_default_instance_);
}
inline const ::substrait::Rel& MergeJoinRel::right() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.MergeJoinRel.right)
  return _internal_right();
}
inline void MergeJoinRel::unsafe_arena_set_allocated_right(::substrait::Rel* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.right_);
  }
  _impl_.right_ = reinterpret_cast<::substrait::Rel*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.MergeJoinRel.right)
}
inline ::substrait::Rel* MergeJoinRel::release_right() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::substrait::Rel* released = _impl_.right_;
  _impl_.right_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Rel* MergeJoinRel::unsafe_arena_release_right() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.MergeJoinRel.right)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::substrait::Rel* temp = _impl_.right_;
  _impl_.right_ = nullptr;
  return temp;
}
inline ::substrait::Rel* MergeJoinRel::_internal_mutable_right() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.right_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Rel>(GetArena());
    _impl_.right_ = reinterpret_cast<::substrait::Rel*>(p);
  }
  return _impl_.right_;
}
inline ::substrait::Rel* MergeJoinRel::mutable_right() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::substrait::Rel* _msg = _internal_mutable_right();
  // @@protoc_insertion_point(field_mutable:substrait.MergeJoinRel.right)
  return _msg;
}
inline void MergeJoinRel::set_allocated_right(::substrait::Rel* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.right_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.right_ = reinterpret_cast<::substrait::Rel*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.MergeJoinRel.right)
}

// repeated .substrait.Expression.FieldReference left_keys = 4 [deprecated = true];
inline int MergeJoinRel::_internal_left_keys_size() const {
  return _internal_left_keys().size();
}
inline int MergeJoinRel::left_keys_size() const {
  return _internal_left_keys_size();
}
inline void MergeJoinRel::clear_left_keys() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.left_keys_.Clear();
}
inline ::substrait::Expression_FieldReference* MergeJoinRel::mutable_left_keys(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.MergeJoinRel.left_keys)
  return _internal_mutable_left_keys()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression_FieldReference>* MergeJoinRel::mutable_left_keys()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.MergeJoinRel.left_keys)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_left_keys();
}
inline const ::substrait::Expression_FieldReference& MergeJoinRel::left_keys(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.MergeJoinRel.left_keys)
  return _internal_left_keys().Get(index);
}
inline ::substrait::Expression_FieldReference* MergeJoinRel::add_left_keys() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::Expression_FieldReference* _add = _internal_mutable_left_keys()->Add();
  // @@protoc_insertion_point(field_add:substrait.MergeJoinRel.left_keys)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression_FieldReference>& MergeJoinRel::left_keys() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.MergeJoinRel.left_keys)
  return _internal_left_keys();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression_FieldReference>&
MergeJoinRel::_internal_left_keys() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.left_keys_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression_FieldReference>*
MergeJoinRel::_internal_mutable_left_keys() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.left_keys_;
}

// repeated .substrait.Expression.FieldReference right_keys = 5 [deprecated = true];
inline int MergeJoinRel::_internal_right_keys_size() const {
  return _internal_right_keys().size();
}
inline int MergeJoinRel::right_keys_size() const {
  return _internal_right_keys_size();
}
inline void MergeJoinRel::clear_right_keys() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.right_keys_.Clear();
}
inline ::substrait::Expression_FieldReference* MergeJoinRel::mutable_right_keys(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.MergeJoinRel.right_keys)
  return _internal_mutable_right_keys()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression_FieldReference>* MergeJoinRel::mutable_right_keys()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.MergeJoinRel.right_keys)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_right_keys();
}
inline const ::substrait::Expression_FieldReference& MergeJoinRel::right_keys(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.MergeJoinRel.right_keys)
  return _internal_right_keys().Get(index);
}
inline ::substrait::Expression_FieldReference* MergeJoinRel::add_right_keys() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::Expression_FieldReference* _add = _internal_mutable_right_keys()->Add();
  // @@protoc_insertion_point(field_add:substrait.MergeJoinRel.right_keys)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression_FieldReference>& MergeJoinRel::right_keys() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.MergeJoinRel.right_keys)
  return _internal_right_keys();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression_FieldReference>&
MergeJoinRel::_internal_right_keys() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.right_keys_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression_FieldReference>*
MergeJoinRel::_internal_mutable_right_keys() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.right_keys_;
}

// repeated .substrait.ComparisonJoinKey keys = 8;
inline int MergeJoinRel::_internal_keys_size() const {
  return _internal_keys().size();
}
inline int MergeJoinRel::keys_size() const {
  return _internal_keys_size();
}
inline void MergeJoinRel::clear_keys() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.keys_.Clear();
}
inline ::substrait::ComparisonJoinKey* MergeJoinRel::mutable_keys(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.MergeJoinRel.keys)
  return _internal_mutable_keys()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::ComparisonJoinKey>* MergeJoinRel::mutable_keys()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.MergeJoinRel.keys)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_keys();
}
inline const ::substrait::ComparisonJoinKey& MergeJoinRel::keys(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.MergeJoinRel.keys)
  return _internal_keys().Get(index);
}
inline ::substrait::ComparisonJoinKey* MergeJoinRel::add_keys() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::ComparisonJoinKey* _add = _internal_mutable_keys()->Add();
  // @@protoc_insertion_point(field_add:substrait.MergeJoinRel.keys)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::ComparisonJoinKey>& MergeJoinRel::keys() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.MergeJoinRel.keys)
  return _internal_keys();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::ComparisonJoinKey>&
MergeJoinRel::_internal_keys() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.keys_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::ComparisonJoinKey>*
MergeJoinRel::_internal_mutable_keys() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.keys_;
}

// .substrait.Expression post_join_filter = 6;
inline bool MergeJoinRel::has_post_join_filter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.post_join_filter_ != nullptr);
  return value;
}
inline void MergeJoinRel::clear_post_join_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.post_join_filter_ != nullptr) _impl_.post_join_filter_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::substrait::Expression& MergeJoinRel::_internal_post_join_filter() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Expression* p = _impl_.post_join_filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression&>(::substrait::_Expression_default_instance_);
}
inline const ::substrait::Expression& MergeJoinRel::post_join_filter() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.MergeJoinRel.post_join_filter)
  return _internal_post_join_filter();
}
inline void MergeJoinRel::unsafe_arena_set_allocated_post_join_filter(::substrait::Expression* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.post_join_filter_);
  }
  _impl_.post_join_filter_ = reinterpret_cast<::substrait::Expression*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.MergeJoinRel.post_join_filter)
}
inline ::substrait::Expression* MergeJoinRel::release_post_join_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::substrait::Expression* released = _impl_.post_join_filter_;
  _impl_.post_join_filter_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Expression* MergeJoinRel::unsafe_arena_release_post_join_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.MergeJoinRel.post_join_filter)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::substrait::Expression* temp = _impl_.post_join_filter_;
  _impl_.post_join_filter_ = nullptr;
  return temp;
}
inline ::substrait::Expression* MergeJoinRel::_internal_mutable_post_join_filter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.post_join_filter_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Expression>(GetArena());
    _impl_.post_join_filter_ = reinterpret_cast<::substrait::Expression*>(p);
  }
  return _impl_.post_join_filter_;
}
inline ::substrait::Expression* MergeJoinRel::mutable_post_join_filter() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::substrait::Expression* _msg = _internal_mutable_post_join_filter();
  // @@protoc_insertion_point(field_mutable:substrait.MergeJoinRel.post_join_filter)
  return _msg;
}
inline void MergeJoinRel::set_allocated_post_join_filter(::substrait::Expression* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.post_join_filter_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.post_join_filter_ = reinterpret_cast<::substrait::Expression*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.MergeJoinRel.post_join_filter)
}

// .substrait.MergeJoinRel.JoinType type = 7;
inline void MergeJoinRel::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::substrait::MergeJoinRel_JoinType MergeJoinRel::type() const {
  // @@protoc_insertion_point(field_get:substrait.MergeJoinRel.type)
  return _internal_type();
}
inline void MergeJoinRel::set_type(::substrait::MergeJoinRel_JoinType value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:substrait.MergeJoinRel.type)
}
inline ::substrait::MergeJoinRel_JoinType MergeJoinRel::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::substrait::MergeJoinRel_JoinType>(_impl_.type_);
}
inline void MergeJoinRel::_internal_set_type(::substrait::MergeJoinRel_JoinType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// .substrait.extensions.AdvancedExtension advanced_extension = 10;
inline bool MergeJoinRel::has_advanced_extension() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.advanced_extension_ != nullptr);
  return value;
}
inline const ::substrait::extensions::AdvancedExtension& MergeJoinRel::_internal_advanced_extension() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::extensions::AdvancedExtension* p = _impl_.advanced_extension_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::extensions::AdvancedExtension&>(::substrait::extensions::_AdvancedExtension_default_instance_);
}
inline const ::substrait::extensions::AdvancedExtension& MergeJoinRel::advanced_extension() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.MergeJoinRel.advanced_extension)
  return _internal_advanced_extension();
}
inline void MergeJoinRel::unsafe_arena_set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.advanced_extension_);
  }
  _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.MergeJoinRel.advanced_extension)
}
inline ::substrait::extensions::AdvancedExtension* MergeJoinRel::release_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::substrait::extensions::AdvancedExtension* released = _impl_.advanced_extension_;
  _impl_.advanced_extension_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::extensions::AdvancedExtension* MergeJoinRel::unsafe_arena_release_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.MergeJoinRel.advanced_extension)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::substrait::extensions::AdvancedExtension* temp = _impl_.advanced_extension_;
  _impl_.advanced_extension_ = nullptr;
  return temp;
}
inline ::substrait::extensions::AdvancedExtension* MergeJoinRel::_internal_mutable_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.advanced_extension_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::extensions::AdvancedExtension>(GetArena());
    _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(p);
  }
  return _impl_.advanced_extension_;
}
inline ::substrait::extensions::AdvancedExtension* MergeJoinRel::mutable_advanced_extension() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::substrait::extensions::AdvancedExtension* _msg = _internal_mutable_advanced_extension();
  // @@protoc_insertion_point(field_mutable:substrait.MergeJoinRel.advanced_extension)
  return _msg;
}
inline void MergeJoinRel::set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.advanced_extension_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.MergeJoinRel.advanced_extension)
}

// -------------------------------------------------------------------

// NestedLoopJoinRel

// .substrait.RelCommon common = 1;
inline bool NestedLoopJoinRel::has_common() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.common_ != nullptr);
  return value;
}
inline void NestedLoopJoinRel::clear_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.common_ != nullptr) _impl_.common_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::RelCommon& NestedLoopJoinRel::_internal_common() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::RelCommon* p = _impl_.common_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::RelCommon&>(::substrait::_RelCommon_default_instance_);
}
inline const ::substrait::RelCommon& NestedLoopJoinRel::common() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.NestedLoopJoinRel.common)
  return _internal_common();
}
inline void NestedLoopJoinRel::unsafe_arena_set_allocated_common(::substrait::RelCommon* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.common_);
  }
  _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.NestedLoopJoinRel.common)
}
inline ::substrait::RelCommon* NestedLoopJoinRel::release_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::RelCommon* released = _impl_.common_;
  _impl_.common_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::RelCommon* NestedLoopJoinRel::unsafe_arena_release_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.NestedLoopJoinRel.common)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::RelCommon* temp = _impl_.common_;
  _impl_.common_ = nullptr;
  return temp;
}
inline ::substrait::RelCommon* NestedLoopJoinRel::_internal_mutable_common() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.common_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::RelCommon>(GetArena());
    _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(p);
  }
  return _impl_.common_;
}
inline ::substrait::RelCommon* NestedLoopJoinRel::mutable_common() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::RelCommon* _msg = _internal_mutable_common();
  // @@protoc_insertion_point(field_mutable:substrait.NestedLoopJoinRel.common)
  return _msg;
}
inline void NestedLoopJoinRel::set_allocated_common(::substrait::RelCommon* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.common_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.common_ = reinterpret_cast<::substrait::RelCommon*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.NestedLoopJoinRel.common)
}

// .substrait.Rel left = 2;
inline bool NestedLoopJoinRel::has_left() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.left_ != nullptr);
  return value;
}
inline void NestedLoopJoinRel::clear_left() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.left_ != nullptr) _impl_.left_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::substrait::Rel& NestedLoopJoinRel::_internal_left() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Rel* p = _impl_.left_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Rel&>(::substrait::_Rel_default_instance_);
}
inline const ::substrait::Rel& NestedLoopJoinRel::left() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.NestedLoopJoinRel.left)
  return _internal_left();
}
inline void NestedLoopJoinRel::unsafe_arena_set_allocated_left(::substrait::Rel* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.left_);
  }
  _impl_.left_ = reinterpret_cast<::substrait::Rel*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.NestedLoopJoinRel.left)
}
inline ::substrait::Rel* NestedLoopJoinRel::release_left() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Rel* released = _impl_.left_;
  _impl_.left_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Rel* NestedLoopJoinRel::unsafe_arena_release_left() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.NestedLoopJoinRel.left)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Rel* temp = _impl_.left_;
  _impl_.left_ = nullptr;
  return temp;
}
inline ::substrait::Rel* NestedLoopJoinRel::_internal_mutable_left() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.left_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Rel>(GetArena());
    _impl_.left_ = reinterpret_cast<::substrait::Rel*>(p);
  }
  return _impl_.left_;
}
inline ::substrait::Rel* NestedLoopJoinRel::mutable_left() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::substrait::Rel* _msg = _internal_mutable_left();
  // @@protoc_insertion_point(field_mutable:substrait.NestedLoopJoinRel.left)
  return _msg;
}
inline void NestedLoopJoinRel::set_allocated_left(::substrait::Rel* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.left_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.left_ = reinterpret_cast<::substrait::Rel*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.NestedLoopJoinRel.left)
}

// .substrait.Rel right = 3;
inline bool NestedLoopJoinRel::has_right() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.right_ != nullptr);
  return value;
}
inline void NestedLoopJoinRel::clear_right() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.right_ != nullptr) _impl_.right_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::substrait::Rel& NestedLoopJoinRel::_internal_right() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Rel* p = _impl_.right_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Rel&>(::substrait::_Rel_default_instance_);
}
inline const ::substrait::Rel& NestedLoopJoinRel::right() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.NestedLoopJoinRel.right)
  return _internal_right();
}
inline void NestedLoopJoinRel::unsafe_arena_set_allocated_right(::substrait::Rel* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.right_);
  }
  _impl_.right_ = reinterpret_cast<::substrait::Rel*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.NestedLoopJoinRel.right)
}
inline ::substrait::Rel* NestedLoopJoinRel::release_right() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::substrait::Rel* released = _impl_.right_;
  _impl_.right_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Rel* NestedLoopJoinRel::unsafe_arena_release_right() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.NestedLoopJoinRel.right)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::substrait::Rel* temp = _impl_.right_;
  _impl_.right_ = nullptr;
  return temp;
}
inline ::substrait::Rel* NestedLoopJoinRel::_internal_mutable_right() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.right_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Rel>(GetArena());
    _impl_.right_ = reinterpret_cast<::substrait::Rel*>(p);
  }
  return _impl_.right_;
}
inline ::substrait::Rel* NestedLoopJoinRel::mutable_right() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::substrait::Rel* _msg = _internal_mutable_right();
  // @@protoc_insertion_point(field_mutable:substrait.NestedLoopJoinRel.right)
  return _msg;
}
inline void NestedLoopJoinRel::set_allocated_right(::substrait::Rel* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.right_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.right_ = reinterpret_cast<::substrait::Rel*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.NestedLoopJoinRel.right)
}

// .substrait.Expression expression = 4;
inline bool NestedLoopJoinRel::has_expression() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.expression_ != nullptr);
  return value;
}
inline void NestedLoopJoinRel::clear_expression() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.expression_ != nullptr) _impl_.expression_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::substrait::Expression& NestedLoopJoinRel::_internal_expression() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Expression* p = _impl_.expression_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression&>(::substrait::_Expression_default_instance_);
}
inline const ::substrait::Expression& NestedLoopJoinRel::expression() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.NestedLoopJoinRel.expression)
  return _internal_expression();
}
inline void NestedLoopJoinRel::unsafe_arena_set_allocated_expression(::substrait::Expression* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.expression_);
  }
  _impl_.expression_ = reinterpret_cast<::substrait::Expression*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.NestedLoopJoinRel.expression)
}
inline ::substrait::Expression* NestedLoopJoinRel::release_expression() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::substrait::Expression* released = _impl_.expression_;
  _impl_.expression_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Expression* NestedLoopJoinRel::unsafe_arena_release_expression() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.NestedLoopJoinRel.expression)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::substrait::Expression* temp = _impl_.expression_;
  _impl_.expression_ = nullptr;
  return temp;
}
inline ::substrait::Expression* NestedLoopJoinRel::_internal_mutable_expression() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.expression_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Expression>(GetArena());
    _impl_.expression_ = reinterpret_cast<::substrait::Expression*>(p);
  }
  return _impl_.expression_;
}
inline ::substrait::Expression* NestedLoopJoinRel::mutable_expression() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::substrait::Expression* _msg = _internal_mutable_expression();
  // @@protoc_insertion_point(field_mutable:substrait.NestedLoopJoinRel.expression)
  return _msg;
}
inline void NestedLoopJoinRel::set_allocated_expression(::substrait::Expression* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.expression_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.expression_ = reinterpret_cast<::substrait::Expression*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.NestedLoopJoinRel.expression)
}

// .substrait.NestedLoopJoinRel.JoinType type = 5;
inline void NestedLoopJoinRel::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::substrait::NestedLoopJoinRel_JoinType NestedLoopJoinRel::type() const {
  // @@protoc_insertion_point(field_get:substrait.NestedLoopJoinRel.type)
  return _internal_type();
}
inline void NestedLoopJoinRel::set_type(::substrait::NestedLoopJoinRel_JoinType value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:substrait.NestedLoopJoinRel.type)
}
inline ::substrait::NestedLoopJoinRel_JoinType NestedLoopJoinRel::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::substrait::NestedLoopJoinRel_JoinType>(_impl_.type_);
}
inline void NestedLoopJoinRel::_internal_set_type(::substrait::NestedLoopJoinRel_JoinType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// .substrait.extensions.AdvancedExtension advanced_extension = 10;
inline bool NestedLoopJoinRel::has_advanced_extension() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.advanced_extension_ != nullptr);
  return value;
}
inline const ::substrait::extensions::AdvancedExtension& NestedLoopJoinRel::_internal_advanced_extension() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::extensions::AdvancedExtension* p = _impl_.advanced_extension_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::extensions::AdvancedExtension&>(::substrait::extensions::_AdvancedExtension_default_instance_);
}
inline const ::substrait::extensions::AdvancedExtension& NestedLoopJoinRel::advanced_extension() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.NestedLoopJoinRel.advanced_extension)
  return _internal_advanced_extension();
}
inline void NestedLoopJoinRel::unsafe_arena_set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.advanced_extension_);
  }
  _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.NestedLoopJoinRel.advanced_extension)
}
inline ::substrait::extensions::AdvancedExtension* NestedLoopJoinRel::release_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::substrait::extensions::AdvancedExtension* released = _impl_.advanced_extension_;
  _impl_.advanced_extension_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::extensions::AdvancedExtension* NestedLoopJoinRel::unsafe_arena_release_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.NestedLoopJoinRel.advanced_extension)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::substrait::extensions::AdvancedExtension* temp = _impl_.advanced_extension_;
  _impl_.advanced_extension_ = nullptr;
  return temp;
}
inline ::substrait::extensions::AdvancedExtension* NestedLoopJoinRel::_internal_mutable_advanced_extension() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.advanced_extension_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::extensions::AdvancedExtension>(GetArena());
    _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(p);
  }
  return _impl_.advanced_extension_;
}
inline ::substrait::extensions::AdvancedExtension* NestedLoopJoinRel::mutable_advanced_extension() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::substrait::extensions::AdvancedExtension* _msg = _internal_mutable_advanced_extension();
  // @@protoc_insertion_point(field_mutable:substrait.NestedLoopJoinRel.advanced_extension)
  return _msg;
}
inline void NestedLoopJoinRel::set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.advanced_extension_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.advanced_extension_ = reinterpret_cast<::substrait::extensions::AdvancedExtension*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.NestedLoopJoinRel.advanced_extension)
}

// -------------------------------------------------------------------

// FunctionArgument

// string enum = 1;
inline bool FunctionArgument::has_enum_() const {
  return arg_type_case() == kEnum;
}
inline void FunctionArgument::set_has_enum_() {
  _impl_._oneof_case_[0] = kEnum;
}
inline void FunctionArgument::clear_enum_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (arg_type_case() == kEnum) {
    _impl_.arg_type_.enum__.Destroy();
    clear_has_arg_type();
  }
}
inline const std::string& FunctionArgument::enum_() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.FunctionArgument.enum)
  return _internal_enum_();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void FunctionArgument::set_enum_(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (arg_type_case() != kEnum) {
    clear_arg_type();

    set_has_enum_();
    _impl_.arg_type_.enum__.InitDefault();
  }
  _impl_.arg_type_.enum__.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:substrait.FunctionArgument.enum)
}
inline std::string* FunctionArgument::mutable_enum_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_enum_();
  // @@protoc_insertion_point(field_mutable:substrait.FunctionArgument.enum)
  return _s;
}
inline const std::string& FunctionArgument::_internal_enum_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (arg_type_case() != kEnum) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.arg_type_.enum__.Get();
}
inline void FunctionArgument::_internal_set_enum_(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (arg_type_case() != kEnum) {
    clear_arg_type();

    set_has_enum_();
    _impl_.arg_type_.enum__.InitDefault();
  }
  _impl_.arg_type_.enum__.Set(value, GetArena());
}
inline std::string* FunctionArgument::_internal_mutable_enum_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (arg_type_case() != kEnum) {
    clear_arg_type();

    set_has_enum_();
    _impl_.arg_type_.enum__.InitDefault();
  }
  return _impl_.arg_type_.enum__.Mutable( GetArena());
}
inline std::string* FunctionArgument::release_enum_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.FunctionArgument.enum)
  if (arg_type_case() != kEnum) {
    return nullptr;
  }
  clear_has_arg_type();
  return _impl_.arg_type_.enum__.Release();
}
inline void FunctionArgument::set_allocated_enum_(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_arg_type()) {
    clear_arg_type();
  }
  if (value != nullptr) {
    set_has_enum_();
    _impl_.arg_type_.enum__.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:substrait.FunctionArgument.enum)
}

// .substrait.Type type = 2;
inline bool FunctionArgument::has_type() const {
  return arg_type_case() == kType;
}
inline bool FunctionArgument::_internal_has_type() const {
  return arg_type_case() == kType;
}
inline void FunctionArgument::set_has_type() {
  _impl_._oneof_case_[0] = kType;
}
inline ::substrait::Type* FunctionArgument::release_type() {
  // @@protoc_insertion_point(field_release:substrait.FunctionArgument.type)
  if (arg_type_case() == kType) {
    clear_has_arg_type();
    auto* temp = _impl_.arg_type_.type_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.arg_type_.type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Type& FunctionArgument::_internal_type() const {
  return arg_type_case() == kType ? *_impl_.arg_type_.type_ : reinterpret_cast<::substrait::Type&>(::substrait::_Type_default_instance_);
}
inline const ::substrait::Type& FunctionArgument::type() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.FunctionArgument.type)
  return _internal_type();
}
inline ::substrait::Type* FunctionArgument::unsafe_arena_release_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.FunctionArgument.type)
  if (arg_type_case() == kType) {
    clear_has_arg_type();
    auto* temp = _impl_.arg_type_.type_;
    _impl_.arg_type_.type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FunctionArgument::unsafe_arena_set_allocated_type(::substrait::Type* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_arg_type();
  if (value) {
    set_has_type();
    _impl_.arg_type_.type_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.FunctionArgument.type)
}
inline ::substrait::Type* FunctionArgument::_internal_mutable_type() {
  if (arg_type_case() != kType) {
    clear_arg_type();
    set_has_type();
    _impl_.arg_type_.type_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Type>(GetArena());
  }
  return _impl_.arg_type_.type_;
}
inline ::substrait::Type* FunctionArgument::mutable_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Type* _msg = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:substrait.FunctionArgument.type)
  return _msg;
}

// .substrait.Expression value = 3;
inline bool FunctionArgument::has_value() const {
  return arg_type_case() == kValue;
}
inline bool FunctionArgument::_internal_has_value() const {
  return arg_type_case() == kValue;
}
inline void FunctionArgument::set_has_value() {
  _impl_._oneof_case_[0] = kValue;
}
inline void FunctionArgument::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (arg_type_case() == kValue) {
    if (GetArena() == nullptr) {
      delete _impl_.arg_type_.value_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.arg_type_.value_);
    }
    clear_has_arg_type();
  }
}
inline ::substrait::Expression* FunctionArgument::release_value() {
  // @@protoc_insertion_point(field_release:substrait.FunctionArgument.value)
  if (arg_type_case() == kValue) {
    clear_has_arg_type();
    auto* temp = _impl_.arg_type_.value_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.arg_type_.value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression& FunctionArgument::_internal_value() const {
  return arg_type_case() == kValue ? *_impl_.arg_type_.value_ : reinterpret_cast<::substrait::Expression&>(::substrait::_Expression_default_instance_);
}
inline const ::substrait::Expression& FunctionArgument::value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.FunctionArgument.value)
  return _internal_value();
}
inline ::substrait::Expression* FunctionArgument::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.FunctionArgument.value)
  if (arg_type_case() == kValue) {
    clear_has_arg_type();
    auto* temp = _impl_.arg_type_.value_;
    _impl_.arg_type_.value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FunctionArgument::unsafe_arena_set_allocated_value(::substrait::Expression* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_arg_type();
  if (value) {
    set_has_value();
    _impl_.arg_type_.value_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.FunctionArgument.value)
}
inline ::substrait::Expression* FunctionArgument::_internal_mutable_value() {
  if (arg_type_case() != kValue) {
    clear_arg_type();
    set_has_value();
    _impl_.arg_type_.value_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression>(GetArena());
  }
  return _impl_.arg_type_.value_;
}
inline ::substrait::Expression* FunctionArgument::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:substrait.FunctionArgument.value)
  return _msg;
}

inline bool FunctionArgument::has_arg_type() const {
  return arg_type_case() != ARG_TYPE_NOT_SET;
}
inline void FunctionArgument::clear_has_arg_type() {
  _impl_._oneof_case_[0] = ARG_TYPE_NOT_SET;
}
inline FunctionArgument::ArgTypeCase FunctionArgument::arg_type_case() const {
  return FunctionArgument::ArgTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// FunctionOption

// string name = 1;
inline void FunctionOption::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FunctionOption::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.FunctionOption.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void FunctionOption::set_name(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:substrait.FunctionOption.name)
}
inline std::string* FunctionOption::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:substrait.FunctionOption.name)
  return _s;
}
inline const std::string& FunctionOption::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void FunctionOption::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* FunctionOption::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* FunctionOption::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.FunctionOption.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void FunctionOption::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:substrait.FunctionOption.name)
}

// repeated string preference = 2;
inline int FunctionOption::_internal_preference_size() const {
  return _internal_preference().size();
}
inline int FunctionOption::preference_size() const {
  return _internal_preference_size();
}
inline void FunctionOption::clear_preference() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.preference_.Clear();
}
inline std::string* FunctionOption::add_preference() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_preference()->Add();
  // @@protoc_insertion_point(field_add_mutable:substrait.FunctionOption.preference)
  return _s;
}
inline const std::string& FunctionOption::preference(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.FunctionOption.preference)
  return _internal_preference().Get(index);
}
inline std::string* FunctionOption::mutable_preference(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.FunctionOption.preference)
  return _internal_mutable_preference()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void FunctionOption::set_preference(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_preference()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:substrait.FunctionOption.preference)
}
template <typename Arg_, typename... Args_>
inline void FunctionOption::add_preference(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_preference(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:substrait.FunctionOption.preference)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
FunctionOption::preference() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.FunctionOption.preference)
  return _internal_preference();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
FunctionOption::mutable_preference() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.FunctionOption.preference)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_preference();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
FunctionOption::_internal_preference() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.preference_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
FunctionOption::_internal_mutable_preference() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.preference_;
}

// -------------------------------------------------------------------

// Expression_Enum_Empty

// -------------------------------------------------------------------

// Expression_Enum

// string specified = 1;
inline bool Expression_Enum::has_specified() const {
  return enum_kind_case() == kSpecified;
}
inline void Expression_Enum::set_has_specified() {
  _impl_._oneof_case_[0] = kSpecified;
}
inline void Expression_Enum::clear_specified() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (enum_kind_case() == kSpecified) {
    _impl_.enum_kind_.specified_.Destroy();
    clear_has_enum_kind();
  }
}
inline const std::string& Expression_Enum::specified() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.Enum.specified)
  return _internal_specified();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Expression_Enum::set_specified(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (enum_kind_case() != kSpecified) {
    clear_enum_kind();

    set_has_specified();
    _impl_.enum_kind_.specified_.InitDefault();
  }
  _impl_.enum_kind_.specified_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:substrait.Expression.Enum.specified)
}
inline std::string* Expression_Enum::mutable_specified() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_specified();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Enum.specified)
  return _s;
}
inline const std::string& Expression_Enum::_internal_specified() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (enum_kind_case() != kSpecified) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.enum_kind_.specified_.Get();
}
inline void Expression_Enum::_internal_set_specified(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (enum_kind_case() != kSpecified) {
    clear_enum_kind();

    set_has_specified();
    _impl_.enum_kind_.specified_.InitDefault();
  }
  _impl_.enum_kind_.specified_.Set(value, GetArena());
}
inline std::string* Expression_Enum::_internal_mutable_specified() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (enum_kind_case() != kSpecified) {
    clear_enum_kind();

    set_has_specified();
    _impl_.enum_kind_.specified_.InitDefault();
  }
  return _impl_.enum_kind_.specified_.Mutable( GetArena());
}
inline std::string* Expression_Enum::release_specified() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.Expression.Enum.specified)
  if (enum_kind_case() != kSpecified) {
    return nullptr;
  }
  clear_has_enum_kind();
  return _impl_.enum_kind_.specified_.Release();
}
inline void Expression_Enum::set_allocated_specified(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_enum_kind()) {
    clear_enum_kind();
  }
  if (value != nullptr) {
    set_has_specified();
    _impl_.enum_kind_.specified_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Enum.specified)
}

// .substrait.Expression.Enum.Empty unspecified = 2;
inline bool Expression_Enum::has_unspecified() const {
  return enum_kind_case() == kUnspecified;
}
inline bool Expression_Enum::_internal_has_unspecified() const {
  return enum_kind_case() == kUnspecified;
}
inline void Expression_Enum::set_has_unspecified() {
  _impl_._oneof_case_[0] = kUnspecified;
}
inline void Expression_Enum::clear_unspecified() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (enum_kind_case() == kUnspecified) {
    if (GetArena() == nullptr) {
      delete _impl_.enum_kind_.unspecified_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.enum_kind_.unspecified_);
    }
    clear_has_enum_kind();
  }
}
inline ::substrait::Expression_Enum_Empty* Expression_Enum::release_unspecified() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Enum.unspecified)
  if (enum_kind_case() == kUnspecified) {
    clear_has_enum_kind();
    auto* temp = _impl_.enum_kind_.unspecified_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.enum_kind_.unspecified_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_Enum_Empty& Expression_Enum::_internal_unspecified() const {
  return enum_kind_case() == kUnspecified ? *_impl_.enum_kind_.unspecified_ : reinterpret_cast<::substrait::Expression_Enum_Empty&>(::substrait::_Expression_Enum_Empty_default_instance_);
}
inline const ::substrait::Expression_Enum_Empty& Expression_Enum::unspecified() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.Enum.unspecified)
  return _internal_unspecified();
}
inline ::substrait::Expression_Enum_Empty* Expression_Enum::unsafe_arena_release_unspecified() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.Enum.unspecified)
  if (enum_kind_case() == kUnspecified) {
    clear_has_enum_kind();
    auto* temp = _impl_.enum_kind_.unspecified_;
    _impl_.enum_kind_.unspecified_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_Enum::unsafe_arena_set_allocated_unspecified(::substrait::Expression_Enum_Empty* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_enum_kind();
  if (value) {
    set_has_unspecified();
    _impl_.enum_kind_.unspecified_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.Enum.unspecified)
}
inline ::substrait::Expression_Enum_Empty* Expression_Enum::_internal_mutable_unspecified() {
  if (enum_kind_case() != kUnspecified) {
    clear_enum_kind();
    set_has_unspecified();
    _impl_.enum_kind_.unspecified_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_Enum_Empty>(GetArena());
  }
  return _impl_.enum_kind_.unspecified_;
}
inline ::substrait::Expression_Enum_Empty* Expression_Enum::mutable_unspecified() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression_Enum_Empty* _msg = _internal_mutable_unspecified();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Enum.unspecified)
  return _msg;
}

inline bool Expression_Enum::has_enum_kind() const {
  return enum_kind_case() != ENUM_KIND_NOT_SET;
}
inline void Expression_Enum::clear_has_enum_kind() {
  _impl_._oneof_case_[0] = ENUM_KIND_NOT_SET;
}
inline Expression_Enum::EnumKindCase Expression_Enum::enum_kind_case() const {
  return Expression_Enum::EnumKindCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Expression_Literal_VarChar

// string value = 1;
inline void Expression_Literal_VarChar::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Expression_Literal_VarChar::value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.VarChar.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Expression_Literal_VarChar::set_value(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.value_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.VarChar.value)
}
inline std::string* Expression_Literal_VarChar::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.VarChar.value)
  return _s;
}
inline const std::string& Expression_Literal_VarChar::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_.Get();
}
inline void Expression_Literal_VarChar::_internal_set_value(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.value_.Set(value, GetArena());
}
inline std::string* Expression_Literal_VarChar::_internal_mutable_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.value_.Mutable( GetArena());
}
inline std::string* Expression_Literal_VarChar::release_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.VarChar.value)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.value_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.value_.Set("", GetArena());
  }
  return released;
}
inline void Expression_Literal_VarChar::set_allocated_value(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.value_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Literal.VarChar.value)
}

// uint32 length = 2;
inline void Expression_Literal_VarChar::clear_length() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.length_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t Expression_Literal_VarChar::length() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.VarChar.length)
  return _internal_length();
}
inline void Expression_Literal_VarChar::set_length(::uint32_t value) {
  _internal_set_length(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.VarChar.length)
}
inline ::uint32_t Expression_Literal_VarChar::_internal_length() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.length_;
}
inline void Expression_Literal_VarChar::_internal_set_length(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.length_ = value;
}

// -------------------------------------------------------------------

// Expression_Literal_Decimal

// bytes value = 1;
inline void Expression_Literal_Decimal::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Expression_Literal_Decimal::value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.Decimal.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Expression_Literal_Decimal::set_value(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.value_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.Decimal.value)
}
inline std::string* Expression_Literal_Decimal::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.Decimal.value)
  return _s;
}
inline const std::string& Expression_Literal_Decimal::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_.Get();
}
inline void Expression_Literal_Decimal::_internal_set_value(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.value_.Set(value, GetArena());
}
inline std::string* Expression_Literal_Decimal::_internal_mutable_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.value_.Mutable( GetArena());
}
inline std::string* Expression_Literal_Decimal::release_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.Decimal.value)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.value_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.value_.Set("", GetArena());
  }
  return released;
}
inline void Expression_Literal_Decimal::set_allocated_value(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.value_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Literal.Decimal.value)
}

// int32 precision = 2;
inline void Expression_Literal_Decimal::clear_precision() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.precision_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t Expression_Literal_Decimal::precision() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.Decimal.precision)
  return _internal_precision();
}
inline void Expression_Literal_Decimal::set_precision(::int32_t value) {
  _internal_set_precision(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.Decimal.precision)
}
inline ::int32_t Expression_Literal_Decimal::_internal_precision() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.precision_;
}
inline void Expression_Literal_Decimal::_internal_set_precision(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.precision_ = value;
}

// int32 scale = 3;
inline void Expression_Literal_Decimal::clear_scale() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.scale_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t Expression_Literal_Decimal::scale() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.Decimal.scale)
  return _internal_scale();
}
inline void Expression_Literal_Decimal::set_scale(::int32_t value) {
  _internal_set_scale(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.Decimal.scale)
}
inline ::int32_t Expression_Literal_Decimal::_internal_scale() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.scale_;
}
inline void Expression_Literal_Decimal::_internal_set_scale(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.scale_ = value;
}

// -------------------------------------------------------------------

// Expression_Literal_Map_KeyValue

// .substrait.Expression.Literal key = 1;
inline bool Expression_Literal_Map_KeyValue::has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.key_ != nullptr);
  return value;
}
inline void Expression_Literal_Map_KeyValue::clear_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.key_ != nullptr) _impl_.key_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::Expression_Literal& Expression_Literal_Map_KeyValue::_internal_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Expression_Literal* p = _impl_.key_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression_Literal&>(::substrait::_Expression_Literal_default_instance_);
}
inline const ::substrait::Expression_Literal& Expression_Literal_Map_KeyValue::key() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.Map.KeyValue.key)
  return _internal_key();
}
inline void Expression_Literal_Map_KeyValue::unsafe_arena_set_allocated_key(::substrait::Expression_Literal* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.key_);
  }
  _impl_.key_ = reinterpret_cast<::substrait::Expression_Literal*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.Literal.Map.KeyValue.key)
}
inline ::substrait::Expression_Literal* Expression_Literal_Map_KeyValue::release_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Expression_Literal* released = _impl_.key_;
  _impl_.key_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Expression_Literal* Expression_Literal_Map_KeyValue::unsafe_arena_release_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.Map.KeyValue.key)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Expression_Literal* temp = _impl_.key_;
  _impl_.key_ = nullptr;
  return temp;
}
inline ::substrait::Expression_Literal* Expression_Literal_Map_KeyValue::_internal_mutable_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.key_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_Literal>(GetArena());
    _impl_.key_ = reinterpret_cast<::substrait::Expression_Literal*>(p);
  }
  return _impl_.key_;
}
inline ::substrait::Expression_Literal* Expression_Literal_Map_KeyValue::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::Expression_Literal* _msg = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.Map.KeyValue.key)
  return _msg;
}
inline void Expression_Literal_Map_KeyValue::set_allocated_key(::substrait::Expression_Literal* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.key_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.key_ = reinterpret_cast<::substrait::Expression_Literal*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Literal.Map.KeyValue.key)
}

// .substrait.Expression.Literal value = 2;
inline bool Expression_Literal_Map_KeyValue::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.value_ != nullptr);
  return value;
}
inline void Expression_Literal_Map_KeyValue::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.value_ != nullptr) _impl_.value_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::substrait::Expression_Literal& Expression_Literal_Map_KeyValue::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Expression_Literal* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression_Literal&>(::substrait::_Expression_Literal_default_instance_);
}
inline const ::substrait::Expression_Literal& Expression_Literal_Map_KeyValue::value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.Map.KeyValue.value)
  return _internal_value();
}
inline void Expression_Literal_Map_KeyValue::unsafe_arena_set_allocated_value(::substrait::Expression_Literal* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = reinterpret_cast<::substrait::Expression_Literal*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.Literal.Map.KeyValue.value)
}
inline ::substrait::Expression_Literal* Expression_Literal_Map_KeyValue::release_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Expression_Literal* released = _impl_.value_;
  _impl_.value_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Expression_Literal* Expression_Literal_Map_KeyValue::unsafe_arena_release_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.Map.KeyValue.value)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Expression_Literal* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::substrait::Expression_Literal* Expression_Literal_Map_KeyValue::_internal_mutable_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.value_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_Literal>(GetArena());
    _impl_.value_ = reinterpret_cast<::substrait::Expression_Literal*>(p);
  }
  return _impl_.value_;
}
inline ::substrait::Expression_Literal* Expression_Literal_Map_KeyValue::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::substrait::Expression_Literal* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.Map.KeyValue.value)
  return _msg;
}
inline void Expression_Literal_Map_KeyValue::set_allocated_value(::substrait::Expression_Literal* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.value_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.value_ = reinterpret_cast<::substrait::Expression_Literal*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Literal.Map.KeyValue.value)
}

// -------------------------------------------------------------------

// Expression_Literal_Map

// repeated .substrait.Expression.Literal.Map.KeyValue key_values = 1;
inline int Expression_Literal_Map::_internal_key_values_size() const {
  return _internal_key_values().size();
}
inline int Expression_Literal_Map::key_values_size() const {
  return _internal_key_values_size();
}
inline void Expression_Literal_Map::clear_key_values() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_values_.Clear();
}
inline ::substrait::Expression_Literal_Map_KeyValue* Expression_Literal_Map::mutable_key_values(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.Map.key_values)
  return _internal_mutable_key_values()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression_Literal_Map_KeyValue>* Expression_Literal_Map::mutable_key_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.Literal.Map.key_values)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_key_values();
}
inline const ::substrait::Expression_Literal_Map_KeyValue& Expression_Literal_Map::key_values(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.Map.key_values)
  return _internal_key_values().Get(index);
}
inline ::substrait::Expression_Literal_Map_KeyValue* Expression_Literal_Map::add_key_values() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::Expression_Literal_Map_KeyValue* _add = _internal_mutable_key_values()->Add();
  // @@protoc_insertion_point(field_add:substrait.Expression.Literal.Map.key_values)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression_Literal_Map_KeyValue>& Expression_Literal_Map::key_values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.Expression.Literal.Map.key_values)
  return _internal_key_values();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression_Literal_Map_KeyValue>&
Expression_Literal_Map::_internal_key_values() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.key_values_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression_Literal_Map_KeyValue>*
Expression_Literal_Map::_internal_mutable_key_values() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.key_values_;
}

// -------------------------------------------------------------------

// Expression_Literal_IntervalYearToMonth

// int32 years = 1;
inline void Expression_Literal_IntervalYearToMonth::clear_years() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.years_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t Expression_Literal_IntervalYearToMonth::years() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.IntervalYearToMonth.years)
  return _internal_years();
}
inline void Expression_Literal_IntervalYearToMonth::set_years(::int32_t value) {
  _internal_set_years(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.IntervalYearToMonth.years)
}
inline ::int32_t Expression_Literal_IntervalYearToMonth::_internal_years() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.years_;
}
inline void Expression_Literal_IntervalYearToMonth::_internal_set_years(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.years_ = value;
}

// int32 months = 2;
inline void Expression_Literal_IntervalYearToMonth::clear_months() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.months_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t Expression_Literal_IntervalYearToMonth::months() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.IntervalYearToMonth.months)
  return _internal_months();
}
inline void Expression_Literal_IntervalYearToMonth::set_months(::int32_t value) {
  _internal_set_months(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.IntervalYearToMonth.months)
}
inline ::int32_t Expression_Literal_IntervalYearToMonth::_internal_months() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.months_;
}
inline void Expression_Literal_IntervalYearToMonth::_internal_set_months(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.months_ = value;
}

// -------------------------------------------------------------------

// Expression_Literal_IntervalDayToSecond

// int32 days = 1;
inline void Expression_Literal_IntervalDayToSecond::clear_days() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.days_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t Expression_Literal_IntervalDayToSecond::days() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.IntervalDayToSecond.days)
  return _internal_days();
}
inline void Expression_Literal_IntervalDayToSecond::set_days(::int32_t value) {
  _internal_set_days(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.IntervalDayToSecond.days)
}
inline ::int32_t Expression_Literal_IntervalDayToSecond::_internal_days() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.days_;
}
inline void Expression_Literal_IntervalDayToSecond::_internal_set_days(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.days_ = value;
}

// int32 seconds = 2;
inline void Expression_Literal_IntervalDayToSecond::clear_seconds() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.seconds_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t Expression_Literal_IntervalDayToSecond::seconds() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.IntervalDayToSecond.seconds)
  return _internal_seconds();
}
inline void Expression_Literal_IntervalDayToSecond::set_seconds(::int32_t value) {
  _internal_set_seconds(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.IntervalDayToSecond.seconds)
}
inline ::int32_t Expression_Literal_IntervalDayToSecond::_internal_seconds() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.seconds_;
}
inline void Expression_Literal_IntervalDayToSecond::_internal_set_seconds(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.seconds_ = value;
}

// int32 microseconds = 3;
inline void Expression_Literal_IntervalDayToSecond::clear_microseconds() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.microseconds_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t Expression_Literal_IntervalDayToSecond::microseconds() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.IntervalDayToSecond.microseconds)
  return _internal_microseconds();
}
inline void Expression_Literal_IntervalDayToSecond::set_microseconds(::int32_t value) {
  _internal_set_microseconds(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.IntervalDayToSecond.microseconds)
}
inline ::int32_t Expression_Literal_IntervalDayToSecond::_internal_microseconds() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.microseconds_;
}
inline void Expression_Literal_IntervalDayToSecond::_internal_set_microseconds(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.microseconds_ = value;
}

// -------------------------------------------------------------------

// Expression_Literal_Struct

// repeated .substrait.Expression.Literal fields = 1;
inline int Expression_Literal_Struct::_internal_fields_size() const {
  return _internal_fields().size();
}
inline int Expression_Literal_Struct::fields_size() const {
  return _internal_fields_size();
}
inline void Expression_Literal_Struct::clear_fields() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fields_.Clear();
}
inline ::substrait::Expression_Literal* Expression_Literal_Struct::mutable_fields(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.Struct.fields)
  return _internal_mutable_fields()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression_Literal>* Expression_Literal_Struct::mutable_fields()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.Literal.Struct.fields)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_fields();
}
inline const ::substrait::Expression_Literal& Expression_Literal_Struct::fields(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.Struct.fields)
  return _internal_fields().Get(index);
}
inline ::substrait::Expression_Literal* Expression_Literal_Struct::add_fields() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::Expression_Literal* _add = _internal_mutable_fields()->Add();
  // @@protoc_insertion_point(field_add:substrait.Expression.Literal.Struct.fields)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression_Literal>& Expression_Literal_Struct::fields() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.Expression.Literal.Struct.fields)
  return _internal_fields();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression_Literal>&
Expression_Literal_Struct::_internal_fields() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fields_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression_Literal>*
Expression_Literal_Struct::_internal_mutable_fields() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.fields_;
}

// -------------------------------------------------------------------

// Expression_Literal_List

// repeated .substrait.Expression.Literal values = 1;
inline int Expression_Literal_List::_internal_values_size() const {
  return _internal_values().size();
}
inline int Expression_Literal_List::values_size() const {
  return _internal_values_size();
}
inline void Expression_Literal_List::clear_values() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.values_.Clear();
}
inline ::substrait::Expression_Literal* Expression_Literal_List::mutable_values(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.List.values)
  return _internal_mutable_values()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression_Literal>* Expression_Literal_List::mutable_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.Literal.List.values)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_values();
}
inline const ::substrait::Expression_Literal& Expression_Literal_List::values(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.List.values)
  return _internal_values().Get(index);
}
inline ::substrait::Expression_Literal* Expression_Literal_List::add_values() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::Expression_Literal* _add = _internal_mutable_values()->Add();
  // @@protoc_insertion_point(field_add:substrait.Expression.Literal.List.values)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression_Literal>& Expression_Literal_List::values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.Expression.Literal.List.values)
  return _internal_values();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression_Literal>&
Expression_Literal_List::_internal_values() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression_Literal>*
Expression_Literal_List::_internal_mutable_values() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// Expression_Literal_UserDefined

// uint32 type_reference = 1;
inline void Expression_Literal_UserDefined::clear_type_reference() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_reference_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t Expression_Literal_UserDefined::type_reference() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.UserDefined.type_reference)
  return _internal_type_reference();
}
inline void Expression_Literal_UserDefined::set_type_reference(::uint32_t value) {
  _internal_set_type_reference(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.UserDefined.type_reference)
}
inline ::uint32_t Expression_Literal_UserDefined::_internal_type_reference() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.type_reference_;
}
inline void Expression_Literal_UserDefined::_internal_set_type_reference(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_reference_ = value;
}

// repeated .substrait.Type.Parameter type_parameters = 3;
inline int Expression_Literal_UserDefined::_internal_type_parameters_size() const {
  return _internal_type_parameters().size();
}
inline int Expression_Literal_UserDefined::type_parameters_size() const {
  return _internal_type_parameters_size();
}
inline ::substrait::Type_Parameter* Expression_Literal_UserDefined::mutable_type_parameters(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.UserDefined.type_parameters)
  return _internal_mutable_type_parameters()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Type_Parameter>* Expression_Literal_UserDefined::mutable_type_parameters()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.Literal.UserDefined.type_parameters)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_type_parameters();
}
inline const ::substrait::Type_Parameter& Expression_Literal_UserDefined::type_parameters(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.UserDefined.type_parameters)
  return _internal_type_parameters().Get(index);
}
inline ::substrait::Type_Parameter* Expression_Literal_UserDefined::add_type_parameters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::Type_Parameter* _add = _internal_mutable_type_parameters()->Add();
  // @@protoc_insertion_point(field_add:substrait.Expression.Literal.UserDefined.type_parameters)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Type_Parameter>& Expression_Literal_UserDefined::type_parameters() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.Expression.Literal.UserDefined.type_parameters)
  return _internal_type_parameters();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Type_Parameter>&
Expression_Literal_UserDefined::_internal_type_parameters() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.type_parameters_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Type_Parameter>*
Expression_Literal_UserDefined::_internal_mutable_type_parameters() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.type_parameters_;
}

// .google.protobuf.Any value = 2;
inline bool Expression_Literal_UserDefined::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.value_ != nullptr);
  return value;
}
inline const ::google::protobuf::Any& Expression_Literal_UserDefined::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Any* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Any&>(::google::protobuf::_Any_default_instance_);
}
inline const ::google::protobuf::Any& Expression_Literal_UserDefined::value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.UserDefined.value)
  return _internal_value();
}
inline void Expression_Literal_UserDefined::unsafe_arena_set_allocated_value(::google::protobuf::Any* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = reinterpret_cast<::google::protobuf::Any*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.Literal.UserDefined.value)
}
inline ::google::protobuf::Any* Expression_Literal_UserDefined::release_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Any* released = _impl_.value_;
  _impl_.value_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Any* Expression_Literal_UserDefined::unsafe_arena_release_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.UserDefined.value)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Any* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::google::protobuf::Any* Expression_Literal_UserDefined::_internal_mutable_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.value_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Any>(GetArena());
    _impl_.value_ = reinterpret_cast<::google::protobuf::Any*>(p);
  }
  return _impl_.value_;
}
inline ::google::protobuf::Any* Expression_Literal_UserDefined::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Any* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.UserDefined.value)
  return _msg;
}
inline void Expression_Literal_UserDefined::set_allocated_value(::google::protobuf::Any* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.value_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.value_ = reinterpret_cast<::google::protobuf::Any*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Literal.UserDefined.value)
}

// -------------------------------------------------------------------

// Expression_Literal

// bool boolean = 1;
inline bool Expression_Literal::has_boolean() const {
  return literal_type_case() == kBoolean;
}
inline void Expression_Literal::set_has_boolean() {
  _impl_._oneof_case_[0] = kBoolean;
}
inline void Expression_Literal::clear_boolean() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (literal_type_case() == kBoolean) {
    _impl_.literal_type_.boolean_ = false;
    clear_has_literal_type();
  }
}
inline bool Expression_Literal::boolean() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.boolean)
  return _internal_boolean();
}
inline void Expression_Literal::set_boolean(bool value) {
  if (literal_type_case() != kBoolean) {
    clear_literal_type();
    set_has_boolean();
  }
  _impl_.literal_type_.boolean_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.boolean)
}
inline bool Expression_Literal::_internal_boolean() const {
  if (literal_type_case() == kBoolean) {
    return _impl_.literal_type_.boolean_;
  }
  return false;
}

// int32 i8 = 2;
inline bool Expression_Literal::has_i8() const {
  return literal_type_case() == kI8;
}
inline void Expression_Literal::set_has_i8() {
  _impl_._oneof_case_[0] = kI8;
}
inline void Expression_Literal::clear_i8() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (literal_type_case() == kI8) {
    _impl_.literal_type_.i8_ = 0;
    clear_has_literal_type();
  }
}
inline ::int32_t Expression_Literal::i8() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.i8)
  return _internal_i8();
}
inline void Expression_Literal::set_i8(::int32_t value) {
  if (literal_type_case() != kI8) {
    clear_literal_type();
    set_has_i8();
  }
  _impl_.literal_type_.i8_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.i8)
}
inline ::int32_t Expression_Literal::_internal_i8() const {
  if (literal_type_case() == kI8) {
    return _impl_.literal_type_.i8_;
  }
  return 0;
}

// int32 i16 = 3;
inline bool Expression_Literal::has_i16() const {
  return literal_type_case() == kI16;
}
inline void Expression_Literal::set_has_i16() {
  _impl_._oneof_case_[0] = kI16;
}
inline void Expression_Literal::clear_i16() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (literal_type_case() == kI16) {
    _impl_.literal_type_.i16_ = 0;
    clear_has_literal_type();
  }
}
inline ::int32_t Expression_Literal::i16() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.i16)
  return _internal_i16();
}
inline void Expression_Literal::set_i16(::int32_t value) {
  if (literal_type_case() != kI16) {
    clear_literal_type();
    set_has_i16();
  }
  _impl_.literal_type_.i16_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.i16)
}
inline ::int32_t Expression_Literal::_internal_i16() const {
  if (literal_type_case() == kI16) {
    return _impl_.literal_type_.i16_;
  }
  return 0;
}

// int32 i32 = 5;
inline bool Expression_Literal::has_i32() const {
  return literal_type_case() == kI32;
}
inline void Expression_Literal::set_has_i32() {
  _impl_._oneof_case_[0] = kI32;
}
inline void Expression_Literal::clear_i32() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (literal_type_case() == kI32) {
    _impl_.literal_type_.i32_ = 0;
    clear_has_literal_type();
  }
}
inline ::int32_t Expression_Literal::i32() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.i32)
  return _internal_i32();
}
inline void Expression_Literal::set_i32(::int32_t value) {
  if (literal_type_case() != kI32) {
    clear_literal_type();
    set_has_i32();
  }
  _impl_.literal_type_.i32_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.i32)
}
inline ::int32_t Expression_Literal::_internal_i32() const {
  if (literal_type_case() == kI32) {
    return _impl_.literal_type_.i32_;
  }
  return 0;
}

// int64 i64 = 7;
inline bool Expression_Literal::has_i64() const {
  return literal_type_case() == kI64;
}
inline void Expression_Literal::set_has_i64() {
  _impl_._oneof_case_[0] = kI64;
}
inline void Expression_Literal::clear_i64() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (literal_type_case() == kI64) {
    _impl_.literal_type_.i64_ = ::int64_t{0};
    clear_has_literal_type();
  }
}
inline ::int64_t Expression_Literal::i64() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.i64)
  return _internal_i64();
}
inline void Expression_Literal::set_i64(::int64_t value) {
  if (literal_type_case() != kI64) {
    clear_literal_type();
    set_has_i64();
  }
  _impl_.literal_type_.i64_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.i64)
}
inline ::int64_t Expression_Literal::_internal_i64() const {
  if (literal_type_case() == kI64) {
    return _impl_.literal_type_.i64_;
  }
  return ::int64_t{0};
}

// float fp32 = 10;
inline bool Expression_Literal::has_fp32() const {
  return literal_type_case() == kFp32;
}
inline void Expression_Literal::set_has_fp32() {
  _impl_._oneof_case_[0] = kFp32;
}
inline void Expression_Literal::clear_fp32() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (literal_type_case() == kFp32) {
    _impl_.literal_type_.fp32_ = 0;
    clear_has_literal_type();
  }
}
inline float Expression_Literal::fp32() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.fp32)
  return _internal_fp32();
}
inline void Expression_Literal::set_fp32(float value) {
  if (literal_type_case() != kFp32) {
    clear_literal_type();
    set_has_fp32();
  }
  _impl_.literal_type_.fp32_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.fp32)
}
inline float Expression_Literal::_internal_fp32() const {
  if (literal_type_case() == kFp32) {
    return _impl_.literal_type_.fp32_;
  }
  return 0;
}

// double fp64 = 11;
inline bool Expression_Literal::has_fp64() const {
  return literal_type_case() == kFp64;
}
inline void Expression_Literal::set_has_fp64() {
  _impl_._oneof_case_[0] = kFp64;
}
inline void Expression_Literal::clear_fp64() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (literal_type_case() == kFp64) {
    _impl_.literal_type_.fp64_ = 0;
    clear_has_literal_type();
  }
}
inline double Expression_Literal::fp64() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.fp64)
  return _internal_fp64();
}
inline void Expression_Literal::set_fp64(double value) {
  if (literal_type_case() != kFp64) {
    clear_literal_type();
    set_has_fp64();
  }
  _impl_.literal_type_.fp64_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.fp64)
}
inline double Expression_Literal::_internal_fp64() const {
  if (literal_type_case() == kFp64) {
    return _impl_.literal_type_.fp64_;
  }
  return 0;
}

// string string = 12;
inline bool Expression_Literal::has_string() const {
  return literal_type_case() == kString;
}
inline void Expression_Literal::set_has_string() {
  _impl_._oneof_case_[0] = kString;
}
inline void Expression_Literal::clear_string() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (literal_type_case() == kString) {
    _impl_.literal_type_.string_.Destroy();
    clear_has_literal_type();
  }
}
inline const std::string& Expression_Literal::string() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.string)
  return _internal_string();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Expression_Literal::set_string(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (literal_type_case() != kString) {
    clear_literal_type();

    set_has_string();
    _impl_.literal_type_.string_.InitDefault();
  }
  _impl_.literal_type_.string_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.string)
}
inline std::string* Expression_Literal::mutable_string() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_string();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.string)
  return _s;
}
inline const std::string& Expression_Literal::_internal_string() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (literal_type_case() != kString) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.literal_type_.string_.Get();
}
inline void Expression_Literal::_internal_set_string(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (literal_type_case() != kString) {
    clear_literal_type();

    set_has_string();
    _impl_.literal_type_.string_.InitDefault();
  }
  _impl_.literal_type_.string_.Set(value, GetArena());
}
inline std::string* Expression_Literal::_internal_mutable_string() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (literal_type_case() != kString) {
    clear_literal_type();

    set_has_string();
    _impl_.literal_type_.string_.InitDefault();
  }
  return _impl_.literal_type_.string_.Mutable( GetArena());
}
inline std::string* Expression_Literal::release_string() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.string)
  if (literal_type_case() != kString) {
    return nullptr;
  }
  clear_has_literal_type();
  return _impl_.literal_type_.string_.Release();
}
inline void Expression_Literal::set_allocated_string(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_literal_type()) {
    clear_literal_type();
  }
  if (value != nullptr) {
    set_has_string();
    _impl_.literal_type_.string_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Literal.string)
}

// bytes binary = 13;
inline bool Expression_Literal::has_binary() const {
  return literal_type_case() == kBinary;
}
inline void Expression_Literal::set_has_binary() {
  _impl_._oneof_case_[0] = kBinary;
}
inline void Expression_Literal::clear_binary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (literal_type_case() == kBinary) {
    _impl_.literal_type_.binary_.Destroy();
    clear_has_literal_type();
  }
}
inline const std::string& Expression_Literal::binary() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.binary)
  return _internal_binary();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Expression_Literal::set_binary(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (literal_type_case() != kBinary) {
    clear_literal_type();

    set_has_binary();
    _impl_.literal_type_.binary_.InitDefault();
  }
  _impl_.literal_type_.binary_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.binary)
}
inline std::string* Expression_Literal::mutable_binary() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_binary();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.binary)
  return _s;
}
inline const std::string& Expression_Literal::_internal_binary() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (literal_type_case() != kBinary) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.literal_type_.binary_.Get();
}
inline void Expression_Literal::_internal_set_binary(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (literal_type_case() != kBinary) {
    clear_literal_type();

    set_has_binary();
    _impl_.literal_type_.binary_.InitDefault();
  }
  _impl_.literal_type_.binary_.Set(value, GetArena());
}
inline std::string* Expression_Literal::_internal_mutable_binary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (literal_type_case() != kBinary) {
    clear_literal_type();

    set_has_binary();
    _impl_.literal_type_.binary_.InitDefault();
  }
  return _impl_.literal_type_.binary_.Mutable( GetArena());
}
inline std::string* Expression_Literal::release_binary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.binary)
  if (literal_type_case() != kBinary) {
    return nullptr;
  }
  clear_has_literal_type();
  return _impl_.literal_type_.binary_.Release();
}
inline void Expression_Literal::set_allocated_binary(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_literal_type()) {
    clear_literal_type();
  }
  if (value != nullptr) {
    set_has_binary();
    _impl_.literal_type_.binary_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Literal.binary)
}

// int64 timestamp = 14 [deprecated = true];
inline bool Expression_Literal::has_timestamp() const {
  return literal_type_case() == kTimestamp;
}
inline void Expression_Literal::set_has_timestamp() {
  _impl_._oneof_case_[0] = kTimestamp;
}
inline void Expression_Literal::clear_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (literal_type_case() == kTimestamp) {
    _impl_.literal_type_.timestamp_ = ::int64_t{0};
    clear_has_literal_type();
  }
}
inline ::int64_t Expression_Literal::timestamp() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.timestamp)
  return _internal_timestamp();
}
inline void Expression_Literal::set_timestamp(::int64_t value) {
  if (literal_type_case() != kTimestamp) {
    clear_literal_type();
    set_has_timestamp();
  }
  _impl_.literal_type_.timestamp_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.timestamp)
}
inline ::int64_t Expression_Literal::_internal_timestamp() const {
  if (literal_type_case() == kTimestamp) {
    return _impl_.literal_type_.timestamp_;
  }
  return ::int64_t{0};
}

// int32 date = 16;
inline bool Expression_Literal::has_date() const {
  return literal_type_case() == kDate;
}
inline void Expression_Literal::set_has_date() {
  _impl_._oneof_case_[0] = kDate;
}
inline void Expression_Literal::clear_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (literal_type_case() == kDate) {
    _impl_.literal_type_.date_ = 0;
    clear_has_literal_type();
  }
}
inline ::int32_t Expression_Literal::date() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.date)
  return _internal_date();
}
inline void Expression_Literal::set_date(::int32_t value) {
  if (literal_type_case() != kDate) {
    clear_literal_type();
    set_has_date();
  }
  _impl_.literal_type_.date_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.date)
}
inline ::int32_t Expression_Literal::_internal_date() const {
  if (literal_type_case() == kDate) {
    return _impl_.literal_type_.date_;
  }
  return 0;
}

// int64 time = 17;
inline bool Expression_Literal::has_time() const {
  return literal_type_case() == kTime;
}
inline void Expression_Literal::set_has_time() {
  _impl_._oneof_case_[0] = kTime;
}
inline void Expression_Literal::clear_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (literal_type_case() == kTime) {
    _impl_.literal_type_.time_ = ::int64_t{0};
    clear_has_literal_type();
  }
}
inline ::int64_t Expression_Literal::time() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.time)
  return _internal_time();
}
inline void Expression_Literal::set_time(::int64_t value) {
  if (literal_type_case() != kTime) {
    clear_literal_type();
    set_has_time();
  }
  _impl_.literal_type_.time_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.time)
}
inline ::int64_t Expression_Literal::_internal_time() const {
  if (literal_type_case() == kTime) {
    return _impl_.literal_type_.time_;
  }
  return ::int64_t{0};
}

// .substrait.Expression.Literal.IntervalYearToMonth interval_year_to_month = 19;
inline bool Expression_Literal::has_interval_year_to_month() const {
  return literal_type_case() == kIntervalYearToMonth;
}
inline bool Expression_Literal::_internal_has_interval_year_to_month() const {
  return literal_type_case() == kIntervalYearToMonth;
}
inline void Expression_Literal::set_has_interval_year_to_month() {
  _impl_._oneof_case_[0] = kIntervalYearToMonth;
}
inline void Expression_Literal::clear_interval_year_to_month() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (literal_type_case() == kIntervalYearToMonth) {
    if (GetArena() == nullptr) {
      delete _impl_.literal_type_.interval_year_to_month_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.literal_type_.interval_year_to_month_);
    }
    clear_has_literal_type();
  }
}
inline ::substrait::Expression_Literal_IntervalYearToMonth* Expression_Literal::release_interval_year_to_month() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.interval_year_to_month)
  if (literal_type_case() == kIntervalYearToMonth) {
    clear_has_literal_type();
    auto* temp = _impl_.literal_type_.interval_year_to_month_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.literal_type_.interval_year_to_month_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_Literal_IntervalYearToMonth& Expression_Literal::_internal_interval_year_to_month() const {
  return literal_type_case() == kIntervalYearToMonth ? *_impl_.literal_type_.interval_year_to_month_ : reinterpret_cast<::substrait::Expression_Literal_IntervalYearToMonth&>(::substrait::_Expression_Literal_IntervalYearToMonth_default_instance_);
}
inline const ::substrait::Expression_Literal_IntervalYearToMonth& Expression_Literal::interval_year_to_month() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.interval_year_to_month)
  return _internal_interval_year_to_month();
}
inline ::substrait::Expression_Literal_IntervalYearToMonth* Expression_Literal::unsafe_arena_release_interval_year_to_month() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.Literal.interval_year_to_month)
  if (literal_type_case() == kIntervalYearToMonth) {
    clear_has_literal_type();
    auto* temp = _impl_.literal_type_.interval_year_to_month_;
    _impl_.literal_type_.interval_year_to_month_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_Literal::unsafe_arena_set_allocated_interval_year_to_month(::substrait::Expression_Literal_IntervalYearToMonth* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_literal_type();
  if (value) {
    set_has_interval_year_to_month();
    _impl_.literal_type_.interval_year_to_month_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.Literal.interval_year_to_month)
}
inline ::substrait::Expression_Literal_IntervalYearToMonth* Expression_Literal::_internal_mutable_interval_year_to_month() {
  if (literal_type_case() != kIntervalYearToMonth) {
    clear_literal_type();
    set_has_interval_year_to_month();
    _impl_.literal_type_.interval_year_to_month_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_Literal_IntervalYearToMonth>(GetArena());
  }
  return _impl_.literal_type_.interval_year_to_month_;
}
inline ::substrait::Expression_Literal_IntervalYearToMonth* Expression_Literal::mutable_interval_year_to_month() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression_Literal_IntervalYearToMonth* _msg = _internal_mutable_interval_year_to_month();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.interval_year_to_month)
  return _msg;
}

// .substrait.Expression.Literal.IntervalDayToSecond interval_day_to_second = 20;
inline bool Expression_Literal::has_interval_day_to_second() const {
  return literal_type_case() == kIntervalDayToSecond;
}
inline bool Expression_Literal::_internal_has_interval_day_to_second() const {
  return literal_type_case() == kIntervalDayToSecond;
}
inline void Expression_Literal::set_has_interval_day_to_second() {
  _impl_._oneof_case_[0] = kIntervalDayToSecond;
}
inline void Expression_Literal::clear_interval_day_to_second() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (literal_type_case() == kIntervalDayToSecond) {
    if (GetArena() == nullptr) {
      delete _impl_.literal_type_.interval_day_to_second_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.literal_type_.interval_day_to_second_);
    }
    clear_has_literal_type();
  }
}
inline ::substrait::Expression_Literal_IntervalDayToSecond* Expression_Literal::release_interval_day_to_second() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.interval_day_to_second)
  if (literal_type_case() == kIntervalDayToSecond) {
    clear_has_literal_type();
    auto* temp = _impl_.literal_type_.interval_day_to_second_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.literal_type_.interval_day_to_second_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_Literal_IntervalDayToSecond& Expression_Literal::_internal_interval_day_to_second() const {
  return literal_type_case() == kIntervalDayToSecond ? *_impl_.literal_type_.interval_day_to_second_ : reinterpret_cast<::substrait::Expression_Literal_IntervalDayToSecond&>(::substrait::_Expression_Literal_IntervalDayToSecond_default_instance_);
}
inline const ::substrait::Expression_Literal_IntervalDayToSecond& Expression_Literal::interval_day_to_second() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.interval_day_to_second)
  return _internal_interval_day_to_second();
}
inline ::substrait::Expression_Literal_IntervalDayToSecond* Expression_Literal::unsafe_arena_release_interval_day_to_second() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.Literal.interval_day_to_second)
  if (literal_type_case() == kIntervalDayToSecond) {
    clear_has_literal_type();
    auto* temp = _impl_.literal_type_.interval_day_to_second_;
    _impl_.literal_type_.interval_day_to_second_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_Literal::unsafe_arena_set_allocated_interval_day_to_second(::substrait::Expression_Literal_IntervalDayToSecond* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_literal_type();
  if (value) {
    set_has_interval_day_to_second();
    _impl_.literal_type_.interval_day_to_second_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.Literal.interval_day_to_second)
}
inline ::substrait::Expression_Literal_IntervalDayToSecond* Expression_Literal::_internal_mutable_interval_day_to_second() {
  if (literal_type_case() != kIntervalDayToSecond) {
    clear_literal_type();
    set_has_interval_day_to_second();
    _impl_.literal_type_.interval_day_to_second_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_Literal_IntervalDayToSecond>(GetArena());
  }
  return _impl_.literal_type_.interval_day_to_second_;
}
inline ::substrait::Expression_Literal_IntervalDayToSecond* Expression_Literal::mutable_interval_day_to_second() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression_Literal_IntervalDayToSecond* _msg = _internal_mutable_interval_day_to_second();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.interval_day_to_second)
  return _msg;
}

// string fixed_char = 21;
inline bool Expression_Literal::has_fixed_char() const {
  return literal_type_case() == kFixedChar;
}
inline void Expression_Literal::set_has_fixed_char() {
  _impl_._oneof_case_[0] = kFixedChar;
}
inline void Expression_Literal::clear_fixed_char() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (literal_type_case() == kFixedChar) {
    _impl_.literal_type_.fixed_char_.Destroy();
    clear_has_literal_type();
  }
}
inline const std::string& Expression_Literal::fixed_char() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.fixed_char)
  return _internal_fixed_char();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Expression_Literal::set_fixed_char(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (literal_type_case() != kFixedChar) {
    clear_literal_type();

    set_has_fixed_char();
    _impl_.literal_type_.fixed_char_.InitDefault();
  }
  _impl_.literal_type_.fixed_char_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.fixed_char)
}
inline std::string* Expression_Literal::mutable_fixed_char() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_fixed_char();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.fixed_char)
  return _s;
}
inline const std::string& Expression_Literal::_internal_fixed_char() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (literal_type_case() != kFixedChar) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.literal_type_.fixed_char_.Get();
}
inline void Expression_Literal::_internal_set_fixed_char(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (literal_type_case() != kFixedChar) {
    clear_literal_type();

    set_has_fixed_char();
    _impl_.literal_type_.fixed_char_.InitDefault();
  }
  _impl_.literal_type_.fixed_char_.Set(value, GetArena());
}
inline std::string* Expression_Literal::_internal_mutable_fixed_char() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (literal_type_case() != kFixedChar) {
    clear_literal_type();

    set_has_fixed_char();
    _impl_.literal_type_.fixed_char_.InitDefault();
  }
  return _impl_.literal_type_.fixed_char_.Mutable( GetArena());
}
inline std::string* Expression_Literal::release_fixed_char() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.fixed_char)
  if (literal_type_case() != kFixedChar) {
    return nullptr;
  }
  clear_has_literal_type();
  return _impl_.literal_type_.fixed_char_.Release();
}
inline void Expression_Literal::set_allocated_fixed_char(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_literal_type()) {
    clear_literal_type();
  }
  if (value != nullptr) {
    set_has_fixed_char();
    _impl_.literal_type_.fixed_char_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Literal.fixed_char)
}

// .substrait.Expression.Literal.VarChar var_char = 22;
inline bool Expression_Literal::has_var_char() const {
  return literal_type_case() == kVarChar;
}
inline bool Expression_Literal::_internal_has_var_char() const {
  return literal_type_case() == kVarChar;
}
inline void Expression_Literal::set_has_var_char() {
  _impl_._oneof_case_[0] = kVarChar;
}
inline void Expression_Literal::clear_var_char() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (literal_type_case() == kVarChar) {
    if (GetArena() == nullptr) {
      delete _impl_.literal_type_.var_char_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.literal_type_.var_char_);
    }
    clear_has_literal_type();
  }
}
inline ::substrait::Expression_Literal_VarChar* Expression_Literal::release_var_char() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.var_char)
  if (literal_type_case() == kVarChar) {
    clear_has_literal_type();
    auto* temp = _impl_.literal_type_.var_char_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.literal_type_.var_char_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_Literal_VarChar& Expression_Literal::_internal_var_char() const {
  return literal_type_case() == kVarChar ? *_impl_.literal_type_.var_char_ : reinterpret_cast<::substrait::Expression_Literal_VarChar&>(::substrait::_Expression_Literal_VarChar_default_instance_);
}
inline const ::substrait::Expression_Literal_VarChar& Expression_Literal::var_char() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.var_char)
  return _internal_var_char();
}
inline ::substrait::Expression_Literal_VarChar* Expression_Literal::unsafe_arena_release_var_char() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.Literal.var_char)
  if (literal_type_case() == kVarChar) {
    clear_has_literal_type();
    auto* temp = _impl_.literal_type_.var_char_;
    _impl_.literal_type_.var_char_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_Literal::unsafe_arena_set_allocated_var_char(::substrait::Expression_Literal_VarChar* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_literal_type();
  if (value) {
    set_has_var_char();
    _impl_.literal_type_.var_char_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.Literal.var_char)
}
inline ::substrait::Expression_Literal_VarChar* Expression_Literal::_internal_mutable_var_char() {
  if (literal_type_case() != kVarChar) {
    clear_literal_type();
    set_has_var_char();
    _impl_.literal_type_.var_char_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_Literal_VarChar>(GetArena());
  }
  return _impl_.literal_type_.var_char_;
}
inline ::substrait::Expression_Literal_VarChar* Expression_Literal::mutable_var_char() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression_Literal_VarChar* _msg = _internal_mutable_var_char();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.var_char)
  return _msg;
}

// bytes fixed_binary = 23;
inline bool Expression_Literal::has_fixed_binary() const {
  return literal_type_case() == kFixedBinary;
}
inline void Expression_Literal::set_has_fixed_binary() {
  _impl_._oneof_case_[0] = kFixedBinary;
}
inline void Expression_Literal::clear_fixed_binary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (literal_type_case() == kFixedBinary) {
    _impl_.literal_type_.fixed_binary_.Destroy();
    clear_has_literal_type();
  }
}
inline const std::string& Expression_Literal::fixed_binary() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.fixed_binary)
  return _internal_fixed_binary();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Expression_Literal::set_fixed_binary(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (literal_type_case() != kFixedBinary) {
    clear_literal_type();

    set_has_fixed_binary();
    _impl_.literal_type_.fixed_binary_.InitDefault();
  }
  _impl_.literal_type_.fixed_binary_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.fixed_binary)
}
inline std::string* Expression_Literal::mutable_fixed_binary() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_fixed_binary();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.fixed_binary)
  return _s;
}
inline const std::string& Expression_Literal::_internal_fixed_binary() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (literal_type_case() != kFixedBinary) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.literal_type_.fixed_binary_.Get();
}
inline void Expression_Literal::_internal_set_fixed_binary(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (literal_type_case() != kFixedBinary) {
    clear_literal_type();

    set_has_fixed_binary();
    _impl_.literal_type_.fixed_binary_.InitDefault();
  }
  _impl_.literal_type_.fixed_binary_.Set(value, GetArena());
}
inline std::string* Expression_Literal::_internal_mutable_fixed_binary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (literal_type_case() != kFixedBinary) {
    clear_literal_type();

    set_has_fixed_binary();
    _impl_.literal_type_.fixed_binary_.InitDefault();
  }
  return _impl_.literal_type_.fixed_binary_.Mutable( GetArena());
}
inline std::string* Expression_Literal::release_fixed_binary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.fixed_binary)
  if (literal_type_case() != kFixedBinary) {
    return nullptr;
  }
  clear_has_literal_type();
  return _impl_.literal_type_.fixed_binary_.Release();
}
inline void Expression_Literal::set_allocated_fixed_binary(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_literal_type()) {
    clear_literal_type();
  }
  if (value != nullptr) {
    set_has_fixed_binary();
    _impl_.literal_type_.fixed_binary_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Literal.fixed_binary)
}

// .substrait.Expression.Literal.Decimal decimal = 24;
inline bool Expression_Literal::has_decimal() const {
  return literal_type_case() == kDecimal;
}
inline bool Expression_Literal::_internal_has_decimal() const {
  return literal_type_case() == kDecimal;
}
inline void Expression_Literal::set_has_decimal() {
  _impl_._oneof_case_[0] = kDecimal;
}
inline void Expression_Literal::clear_decimal() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (literal_type_case() == kDecimal) {
    if (GetArena() == nullptr) {
      delete _impl_.literal_type_.decimal_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.literal_type_.decimal_);
    }
    clear_has_literal_type();
  }
}
inline ::substrait::Expression_Literal_Decimal* Expression_Literal::release_decimal() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.decimal)
  if (literal_type_case() == kDecimal) {
    clear_has_literal_type();
    auto* temp = _impl_.literal_type_.decimal_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.literal_type_.decimal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_Literal_Decimal& Expression_Literal::_internal_decimal() const {
  return literal_type_case() == kDecimal ? *_impl_.literal_type_.decimal_ : reinterpret_cast<::substrait::Expression_Literal_Decimal&>(::substrait::_Expression_Literal_Decimal_default_instance_);
}
inline const ::substrait::Expression_Literal_Decimal& Expression_Literal::decimal() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.decimal)
  return _internal_decimal();
}
inline ::substrait::Expression_Literal_Decimal* Expression_Literal::unsafe_arena_release_decimal() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.Literal.decimal)
  if (literal_type_case() == kDecimal) {
    clear_has_literal_type();
    auto* temp = _impl_.literal_type_.decimal_;
    _impl_.literal_type_.decimal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_Literal::unsafe_arena_set_allocated_decimal(::substrait::Expression_Literal_Decimal* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_literal_type();
  if (value) {
    set_has_decimal();
    _impl_.literal_type_.decimal_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.Literal.decimal)
}
inline ::substrait::Expression_Literal_Decimal* Expression_Literal::_internal_mutable_decimal() {
  if (literal_type_case() != kDecimal) {
    clear_literal_type();
    set_has_decimal();
    _impl_.literal_type_.decimal_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_Literal_Decimal>(GetArena());
  }
  return _impl_.literal_type_.decimal_;
}
inline ::substrait::Expression_Literal_Decimal* Expression_Literal::mutable_decimal() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression_Literal_Decimal* _msg = _internal_mutable_decimal();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.decimal)
  return _msg;
}

// uint64 precision_timestamp = 34;
inline bool Expression_Literal::has_precision_timestamp() const {
  return literal_type_case() == kPrecisionTimestamp;
}
inline void Expression_Literal::set_has_precision_timestamp() {
  _impl_._oneof_case_[0] = kPrecisionTimestamp;
}
inline void Expression_Literal::clear_precision_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (literal_type_case() == kPrecisionTimestamp) {
    _impl_.literal_type_.precision_timestamp_ = ::uint64_t{0u};
    clear_has_literal_type();
  }
}
inline ::uint64_t Expression_Literal::precision_timestamp() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.precision_timestamp)
  return _internal_precision_timestamp();
}
inline void Expression_Literal::set_precision_timestamp(::uint64_t value) {
  if (literal_type_case() != kPrecisionTimestamp) {
    clear_literal_type();
    set_has_precision_timestamp();
  }
  _impl_.literal_type_.precision_timestamp_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.precision_timestamp)
}
inline ::uint64_t Expression_Literal::_internal_precision_timestamp() const {
  if (literal_type_case() == kPrecisionTimestamp) {
    return _impl_.literal_type_.precision_timestamp_;
  }
  return ::uint64_t{0u};
}

// uint64 precision_timestamp_tz = 35;
inline bool Expression_Literal::has_precision_timestamp_tz() const {
  return literal_type_case() == kPrecisionTimestampTz;
}
inline void Expression_Literal::set_has_precision_timestamp_tz() {
  _impl_._oneof_case_[0] = kPrecisionTimestampTz;
}
inline void Expression_Literal::clear_precision_timestamp_tz() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (literal_type_case() == kPrecisionTimestampTz) {
    _impl_.literal_type_.precision_timestamp_tz_ = ::uint64_t{0u};
    clear_has_literal_type();
  }
}
inline ::uint64_t Expression_Literal::precision_timestamp_tz() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.precision_timestamp_tz)
  return _internal_precision_timestamp_tz();
}
inline void Expression_Literal::set_precision_timestamp_tz(::uint64_t value) {
  if (literal_type_case() != kPrecisionTimestampTz) {
    clear_literal_type();
    set_has_precision_timestamp_tz();
  }
  _impl_.literal_type_.precision_timestamp_tz_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.precision_timestamp_tz)
}
inline ::uint64_t Expression_Literal::_internal_precision_timestamp_tz() const {
  if (literal_type_case() == kPrecisionTimestampTz) {
    return _impl_.literal_type_.precision_timestamp_tz_;
  }
  return ::uint64_t{0u};
}

// .substrait.Expression.Literal.Struct struct = 25;
inline bool Expression_Literal::has_struct_() const {
  return literal_type_case() == kStruct;
}
inline bool Expression_Literal::_internal_has_struct_() const {
  return literal_type_case() == kStruct;
}
inline void Expression_Literal::set_has_struct_() {
  _impl_._oneof_case_[0] = kStruct;
}
inline void Expression_Literal::clear_struct_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (literal_type_case() == kStruct) {
    if (GetArena() == nullptr) {
      delete _impl_.literal_type_.struct__;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.literal_type_.struct__);
    }
    clear_has_literal_type();
  }
}
inline ::substrait::Expression_Literal_Struct* Expression_Literal::release_struct_() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.struct)
  if (literal_type_case() == kStruct) {
    clear_has_literal_type();
    auto* temp = _impl_.literal_type_.struct__;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.literal_type_.struct__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_Literal_Struct& Expression_Literal::_internal_struct_() const {
  return literal_type_case() == kStruct ? *_impl_.literal_type_.struct__ : reinterpret_cast<::substrait::Expression_Literal_Struct&>(::substrait::_Expression_Literal_Struct_default_instance_);
}
inline const ::substrait::Expression_Literal_Struct& Expression_Literal::struct_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.struct)
  return _internal_struct_();
}
inline ::substrait::Expression_Literal_Struct* Expression_Literal::unsafe_arena_release_struct_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.Literal.struct)
  if (literal_type_case() == kStruct) {
    clear_has_literal_type();
    auto* temp = _impl_.literal_type_.struct__;
    _impl_.literal_type_.struct__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_Literal::unsafe_arena_set_allocated_struct_(::substrait::Expression_Literal_Struct* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_literal_type();
  if (value) {
    set_has_struct_();
    _impl_.literal_type_.struct__ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.Literal.struct)
}
inline ::substrait::Expression_Literal_Struct* Expression_Literal::_internal_mutable_struct_() {
  if (literal_type_case() != kStruct) {
    clear_literal_type();
    set_has_struct_();
    _impl_.literal_type_.struct__ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_Literal_Struct>(GetArena());
  }
  return _impl_.literal_type_.struct__;
}
inline ::substrait::Expression_Literal_Struct* Expression_Literal::mutable_struct_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression_Literal_Struct* _msg = _internal_mutable_struct_();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.struct)
  return _msg;
}

// .substrait.Expression.Literal.Map map = 26;
inline bool Expression_Literal::has_map() const {
  return literal_type_case() == kMap;
}
inline bool Expression_Literal::_internal_has_map() const {
  return literal_type_case() == kMap;
}
inline void Expression_Literal::set_has_map() {
  _impl_._oneof_case_[0] = kMap;
}
inline void Expression_Literal::clear_map() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (literal_type_case() == kMap) {
    if (GetArena() == nullptr) {
      delete _impl_.literal_type_.map_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.literal_type_.map_);
    }
    clear_has_literal_type();
  }
}
inline ::substrait::Expression_Literal_Map* Expression_Literal::release_map() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.map)
  if (literal_type_case() == kMap) {
    clear_has_literal_type();
    auto* temp = _impl_.literal_type_.map_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.literal_type_.map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_Literal_Map& Expression_Literal::_internal_map() const {
  return literal_type_case() == kMap ? *_impl_.literal_type_.map_ : reinterpret_cast<::substrait::Expression_Literal_Map&>(::substrait::_Expression_Literal_Map_default_instance_);
}
inline const ::substrait::Expression_Literal_Map& Expression_Literal::map() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.map)
  return _internal_map();
}
inline ::substrait::Expression_Literal_Map* Expression_Literal::unsafe_arena_release_map() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.Literal.map)
  if (literal_type_case() == kMap) {
    clear_has_literal_type();
    auto* temp = _impl_.literal_type_.map_;
    _impl_.literal_type_.map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_Literal::unsafe_arena_set_allocated_map(::substrait::Expression_Literal_Map* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_literal_type();
  if (value) {
    set_has_map();
    _impl_.literal_type_.map_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.Literal.map)
}
inline ::substrait::Expression_Literal_Map* Expression_Literal::_internal_mutable_map() {
  if (literal_type_case() != kMap) {
    clear_literal_type();
    set_has_map();
    _impl_.literal_type_.map_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_Literal_Map>(GetArena());
  }
  return _impl_.literal_type_.map_;
}
inline ::substrait::Expression_Literal_Map* Expression_Literal::mutable_map() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression_Literal_Map* _msg = _internal_mutable_map();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.map)
  return _msg;
}

// int64 timestamp_tz = 27 [deprecated = true];
inline bool Expression_Literal::has_timestamp_tz() const {
  return literal_type_case() == kTimestampTz;
}
inline void Expression_Literal::set_has_timestamp_tz() {
  _impl_._oneof_case_[0] = kTimestampTz;
}
inline void Expression_Literal::clear_timestamp_tz() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (literal_type_case() == kTimestampTz) {
    _impl_.literal_type_.timestamp_tz_ = ::int64_t{0};
    clear_has_literal_type();
  }
}
inline ::int64_t Expression_Literal::timestamp_tz() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.timestamp_tz)
  return _internal_timestamp_tz();
}
inline void Expression_Literal::set_timestamp_tz(::int64_t value) {
  if (literal_type_case() != kTimestampTz) {
    clear_literal_type();
    set_has_timestamp_tz();
  }
  _impl_.literal_type_.timestamp_tz_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.timestamp_tz)
}
inline ::int64_t Expression_Literal::_internal_timestamp_tz() const {
  if (literal_type_case() == kTimestampTz) {
    return _impl_.literal_type_.timestamp_tz_;
  }
  return ::int64_t{0};
}

// bytes uuid = 28;
inline bool Expression_Literal::has_uuid() const {
  return literal_type_case() == kUuid;
}
inline void Expression_Literal::set_has_uuid() {
  _impl_._oneof_case_[0] = kUuid;
}
inline void Expression_Literal::clear_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (literal_type_case() == kUuid) {
    _impl_.literal_type_.uuid_.Destroy();
    clear_has_literal_type();
  }
}
inline const std::string& Expression_Literal::uuid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.uuid)
  return _internal_uuid();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Expression_Literal::set_uuid(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (literal_type_case() != kUuid) {
    clear_literal_type();

    set_has_uuid();
    _impl_.literal_type_.uuid_.InitDefault();
  }
  _impl_.literal_type_.uuid_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.uuid)
}
inline std::string* Expression_Literal::mutable_uuid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.uuid)
  return _s;
}
inline const std::string& Expression_Literal::_internal_uuid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (literal_type_case() != kUuid) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.literal_type_.uuid_.Get();
}
inline void Expression_Literal::_internal_set_uuid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (literal_type_case() != kUuid) {
    clear_literal_type();

    set_has_uuid();
    _impl_.literal_type_.uuid_.InitDefault();
  }
  _impl_.literal_type_.uuid_.Set(value, GetArena());
}
inline std::string* Expression_Literal::_internal_mutable_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (literal_type_case() != kUuid) {
    clear_literal_type();

    set_has_uuid();
    _impl_.literal_type_.uuid_.InitDefault();
  }
  return _impl_.literal_type_.uuid_.Mutable( GetArena());
}
inline std::string* Expression_Literal::release_uuid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.uuid)
  if (literal_type_case() != kUuid) {
    return nullptr;
  }
  clear_has_literal_type();
  return _impl_.literal_type_.uuid_.Release();
}
inline void Expression_Literal::set_allocated_uuid(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_literal_type()) {
    clear_literal_type();
  }
  if (value != nullptr) {
    set_has_uuid();
    _impl_.literal_type_.uuid_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Literal.uuid)
}

// .substrait.Type null = 29;
inline bool Expression_Literal::has_null() const {
  return literal_type_case() == kNull;
}
inline bool Expression_Literal::_internal_has_null() const {
  return literal_type_case() == kNull;
}
inline void Expression_Literal::set_has_null() {
  _impl_._oneof_case_[0] = kNull;
}
inline ::substrait::Type* Expression_Literal::release_null() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.null)
  if (literal_type_case() == kNull) {
    clear_has_literal_type();
    auto* temp = _impl_.literal_type_.null_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.literal_type_.null_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Type& Expression_Literal::_internal_null() const {
  return literal_type_case() == kNull ? *_impl_.literal_type_.null_ : reinterpret_cast<::substrait::Type&>(::substrait::_Type_default_instance_);
}
inline const ::substrait::Type& Expression_Literal::null() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.null)
  return _internal_null();
}
inline ::substrait::Type* Expression_Literal::unsafe_arena_release_null() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.Literal.null)
  if (literal_type_case() == kNull) {
    clear_has_literal_type();
    auto* temp = _impl_.literal_type_.null_;
    _impl_.literal_type_.null_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_Literal::unsafe_arena_set_allocated_null(::substrait::Type* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_literal_type();
  if (value) {
    set_has_null();
    _impl_.literal_type_.null_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.Literal.null)
}
inline ::substrait::Type* Expression_Literal::_internal_mutable_null() {
  if (literal_type_case() != kNull) {
    clear_literal_type();
    set_has_null();
    _impl_.literal_type_.null_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Type>(GetArena());
  }
  return _impl_.literal_type_.null_;
}
inline ::substrait::Type* Expression_Literal::mutable_null() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Type* _msg = _internal_mutable_null();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.null)
  return _msg;
}

// .substrait.Expression.Literal.List list = 30;
inline bool Expression_Literal::has_list() const {
  return literal_type_case() == kList;
}
inline bool Expression_Literal::_internal_has_list() const {
  return literal_type_case() == kList;
}
inline void Expression_Literal::set_has_list() {
  _impl_._oneof_case_[0] = kList;
}
inline void Expression_Literal::clear_list() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (literal_type_case() == kList) {
    if (GetArena() == nullptr) {
      delete _impl_.literal_type_.list_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.literal_type_.list_);
    }
    clear_has_literal_type();
  }
}
inline ::substrait::Expression_Literal_List* Expression_Literal::release_list() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.list)
  if (literal_type_case() == kList) {
    clear_has_literal_type();
    auto* temp = _impl_.literal_type_.list_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.literal_type_.list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_Literal_List& Expression_Literal::_internal_list() const {
  return literal_type_case() == kList ? *_impl_.literal_type_.list_ : reinterpret_cast<::substrait::Expression_Literal_List&>(::substrait::_Expression_Literal_List_default_instance_);
}
inline const ::substrait::Expression_Literal_List& Expression_Literal::list() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.list)
  return _internal_list();
}
inline ::substrait::Expression_Literal_List* Expression_Literal::unsafe_arena_release_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.Literal.list)
  if (literal_type_case() == kList) {
    clear_has_literal_type();
    auto* temp = _impl_.literal_type_.list_;
    _impl_.literal_type_.list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_Literal::unsafe_arena_set_allocated_list(::substrait::Expression_Literal_List* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_literal_type();
  if (value) {
    set_has_list();
    _impl_.literal_type_.list_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.Literal.list)
}
inline ::substrait::Expression_Literal_List* Expression_Literal::_internal_mutable_list() {
  if (literal_type_case() != kList) {
    clear_literal_type();
    set_has_list();
    _impl_.literal_type_.list_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_Literal_List>(GetArena());
  }
  return _impl_.literal_type_.list_;
}
inline ::substrait::Expression_Literal_List* Expression_Literal::mutable_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression_Literal_List* _msg = _internal_mutable_list();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.list)
  return _msg;
}

// .substrait.Type.List empty_list = 31;
inline bool Expression_Literal::has_empty_list() const {
  return literal_type_case() == kEmptyList;
}
inline bool Expression_Literal::_internal_has_empty_list() const {
  return literal_type_case() == kEmptyList;
}
inline void Expression_Literal::set_has_empty_list() {
  _impl_._oneof_case_[0] = kEmptyList;
}
inline ::substrait::Type_List* Expression_Literal::release_empty_list() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.empty_list)
  if (literal_type_case() == kEmptyList) {
    clear_has_literal_type();
    auto* temp = _impl_.literal_type_.empty_list_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.literal_type_.empty_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Type_List& Expression_Literal::_internal_empty_list() const {
  return literal_type_case() == kEmptyList ? *_impl_.literal_type_.empty_list_ : reinterpret_cast<::substrait::Type_List&>(::substrait::_Type_List_default_instance_);
}
inline const ::substrait::Type_List& Expression_Literal::empty_list() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.empty_list)
  return _internal_empty_list();
}
inline ::substrait::Type_List* Expression_Literal::unsafe_arena_release_empty_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.Literal.empty_list)
  if (literal_type_case() == kEmptyList) {
    clear_has_literal_type();
    auto* temp = _impl_.literal_type_.empty_list_;
    _impl_.literal_type_.empty_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_Literal::unsafe_arena_set_allocated_empty_list(::substrait::Type_List* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_literal_type();
  if (value) {
    set_has_empty_list();
    _impl_.literal_type_.empty_list_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.Literal.empty_list)
}
inline ::substrait::Type_List* Expression_Literal::_internal_mutable_empty_list() {
  if (literal_type_case() != kEmptyList) {
    clear_literal_type();
    set_has_empty_list();
    _impl_.literal_type_.empty_list_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Type_List>(GetArena());
  }
  return _impl_.literal_type_.empty_list_;
}
inline ::substrait::Type_List* Expression_Literal::mutable_empty_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Type_List* _msg = _internal_mutable_empty_list();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.empty_list)
  return _msg;
}

// .substrait.Type.Map empty_map = 32;
inline bool Expression_Literal::has_empty_map() const {
  return literal_type_case() == kEmptyMap;
}
inline bool Expression_Literal::_internal_has_empty_map() const {
  return literal_type_case() == kEmptyMap;
}
inline void Expression_Literal::set_has_empty_map() {
  _impl_._oneof_case_[0] = kEmptyMap;
}
inline ::substrait::Type_Map* Expression_Literal::release_empty_map() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.empty_map)
  if (literal_type_case() == kEmptyMap) {
    clear_has_literal_type();
    auto* temp = _impl_.literal_type_.empty_map_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.literal_type_.empty_map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Type_Map& Expression_Literal::_internal_empty_map() const {
  return literal_type_case() == kEmptyMap ? *_impl_.literal_type_.empty_map_ : reinterpret_cast<::substrait::Type_Map&>(::substrait::_Type_Map_default_instance_);
}
inline const ::substrait::Type_Map& Expression_Literal::empty_map() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.empty_map)
  return _internal_empty_map();
}
inline ::substrait::Type_Map* Expression_Literal::unsafe_arena_release_empty_map() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.Literal.empty_map)
  if (literal_type_case() == kEmptyMap) {
    clear_has_literal_type();
    auto* temp = _impl_.literal_type_.empty_map_;
    _impl_.literal_type_.empty_map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_Literal::unsafe_arena_set_allocated_empty_map(::substrait::Type_Map* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_literal_type();
  if (value) {
    set_has_empty_map();
    _impl_.literal_type_.empty_map_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.Literal.empty_map)
}
inline ::substrait::Type_Map* Expression_Literal::_internal_mutable_empty_map() {
  if (literal_type_case() != kEmptyMap) {
    clear_literal_type();
    set_has_empty_map();
    _impl_.literal_type_.empty_map_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Type_Map>(GetArena());
  }
  return _impl_.literal_type_.empty_map_;
}
inline ::substrait::Type_Map* Expression_Literal::mutable_empty_map() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Type_Map* _msg = _internal_mutable_empty_map();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.empty_map)
  return _msg;
}

// .substrait.Expression.Literal.UserDefined user_defined = 33;
inline bool Expression_Literal::has_user_defined() const {
  return literal_type_case() == kUserDefined;
}
inline bool Expression_Literal::_internal_has_user_defined() const {
  return literal_type_case() == kUserDefined;
}
inline void Expression_Literal::set_has_user_defined() {
  _impl_._oneof_case_[0] = kUserDefined;
}
inline void Expression_Literal::clear_user_defined() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (literal_type_case() == kUserDefined) {
    if (GetArena() == nullptr) {
      delete _impl_.literal_type_.user_defined_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.literal_type_.user_defined_);
    }
    clear_has_literal_type();
  }
}
inline ::substrait::Expression_Literal_UserDefined* Expression_Literal::release_user_defined() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.user_defined)
  if (literal_type_case() == kUserDefined) {
    clear_has_literal_type();
    auto* temp = _impl_.literal_type_.user_defined_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.literal_type_.user_defined_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_Literal_UserDefined& Expression_Literal::_internal_user_defined() const {
  return literal_type_case() == kUserDefined ? *_impl_.literal_type_.user_defined_ : reinterpret_cast<::substrait::Expression_Literal_UserDefined&>(::substrait::_Expression_Literal_UserDefined_default_instance_);
}
inline const ::substrait::Expression_Literal_UserDefined& Expression_Literal::user_defined() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.user_defined)
  return _internal_user_defined();
}
inline ::substrait::Expression_Literal_UserDefined* Expression_Literal::unsafe_arena_release_user_defined() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.Literal.user_defined)
  if (literal_type_case() == kUserDefined) {
    clear_has_literal_type();
    auto* temp = _impl_.literal_type_.user_defined_;
    _impl_.literal_type_.user_defined_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_Literal::unsafe_arena_set_allocated_user_defined(::substrait::Expression_Literal_UserDefined* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_literal_type();
  if (value) {
    set_has_user_defined();
    _impl_.literal_type_.user_defined_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.Literal.user_defined)
}
inline ::substrait::Expression_Literal_UserDefined* Expression_Literal::_internal_mutable_user_defined() {
  if (literal_type_case() != kUserDefined) {
    clear_literal_type();
    set_has_user_defined();
    _impl_.literal_type_.user_defined_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_Literal_UserDefined>(GetArena());
  }
  return _impl_.literal_type_.user_defined_;
}
inline ::substrait::Expression_Literal_UserDefined* Expression_Literal::mutable_user_defined() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression_Literal_UserDefined* _msg = _internal_mutable_user_defined();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.user_defined)
  return _msg;
}

// bool nullable = 50;
inline void Expression_Literal::clear_nullable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nullable_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool Expression_Literal::nullable() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.nullable)
  return _internal_nullable();
}
inline void Expression_Literal::set_nullable(bool value) {
  _internal_set_nullable(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.nullable)
}
inline bool Expression_Literal::_internal_nullable() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.nullable_;
}
inline void Expression_Literal::_internal_set_nullable(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nullable_ = value;
}

// uint32 type_variation_reference = 51;
inline void Expression_Literal::clear_type_variation_reference() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_variation_reference_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t Expression_Literal::type_variation_reference() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.type_variation_reference)
  return _internal_type_variation_reference();
}
inline void Expression_Literal::set_type_variation_reference(::uint32_t value) {
  _internal_set_type_variation_reference(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.type_variation_reference)
}
inline ::uint32_t Expression_Literal::_internal_type_variation_reference() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.type_variation_reference_;
}
inline void Expression_Literal::_internal_set_type_variation_reference(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_variation_reference_ = value;
}

inline bool Expression_Literal::has_literal_type() const {
  return literal_type_case() != LITERAL_TYPE_NOT_SET;
}
inline void Expression_Literal::clear_has_literal_type() {
  _impl_._oneof_case_[0] = LITERAL_TYPE_NOT_SET;
}
inline Expression_Literal::LiteralTypeCase Expression_Literal::literal_type_case() const {
  return Expression_Literal::LiteralTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Expression_Nested_Map_KeyValue

// .substrait.Expression key = 1;
inline bool Expression_Nested_Map_KeyValue::has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.key_ != nullptr);
  return value;
}
inline void Expression_Nested_Map_KeyValue::clear_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.key_ != nullptr) _impl_.key_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::Expression& Expression_Nested_Map_KeyValue::_internal_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Expression* p = _impl_.key_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression&>(::substrait::_Expression_default_instance_);
}
inline const ::substrait::Expression& Expression_Nested_Map_KeyValue::key() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.Nested.Map.KeyValue.key)
  return _internal_key();
}
inline void Expression_Nested_Map_KeyValue::unsafe_arena_set_allocated_key(::substrait::Expression* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.key_);
  }
  _impl_.key_ = reinterpret_cast<::substrait::Expression*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.Nested.Map.KeyValue.key)
}
inline ::substrait::Expression* Expression_Nested_Map_KeyValue::release_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Expression* released = _impl_.key_;
  _impl_.key_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Expression* Expression_Nested_Map_KeyValue::unsafe_arena_release_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.Expression.Nested.Map.KeyValue.key)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Expression* temp = _impl_.key_;
  _impl_.key_ = nullptr;
  return temp;
}
inline ::substrait::Expression* Expression_Nested_Map_KeyValue::_internal_mutable_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.key_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Expression>(GetArena());
    _impl_.key_ = reinterpret_cast<::substrait::Expression*>(p);
  }
  return _impl_.key_;
}
inline ::substrait::Expression* Expression_Nested_Map_KeyValue::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::Expression* _msg = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Nested.Map.KeyValue.key)
  return _msg;
}
inline void Expression_Nested_Map_KeyValue::set_allocated_key(::substrait::Expression* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.key_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.key_ = reinterpret_cast<::substrait::Expression*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Nested.Map.KeyValue.key)
}

// .substrait.Expression value = 2;
inline bool Expression_Nested_Map_KeyValue::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.value_ != nullptr);
  return value;
}
inline void Expression_Nested_Map_KeyValue::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.value_ != nullptr) _impl_.value_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::substrait::Expression& Expression_Nested_Map_KeyValue::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Expression* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression&>(::substrait::_Expression_default_instance_);
}
inline const ::substrait::Expression& Expression_Nested_Map_KeyValue::value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.Nested.Map.KeyValue.value)
  return _internal_value();
}
inline void Expression_Nested_Map_KeyValue::unsafe_arena_set_allocated_value(::substrait::Expression* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = reinterpret_cast<::substrait::Expression*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.Nested.Map.KeyValue.value)
}
inline ::substrait::Expression* Expression_Nested_Map_KeyValue::release_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Expression* released = _impl_.value_;
  _impl_.value_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Expression* Expression_Nested_Map_KeyValue::unsafe_arena_release_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.Expression.Nested.Map.KeyValue.value)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Expression* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::substrait::Expression* Expression_Nested_Map_KeyValue::_internal_mutable_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.value_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Expression>(GetArena());
    _impl_.value_ = reinterpret_cast<::substrait::Expression*>(p);
  }
  return _impl_.value_;
}
inline ::substrait::Expression* Expression_Nested_Map_KeyValue::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::substrait::Expression* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Nested.Map.KeyValue.value)
  return _msg;
}
inline void Expression_Nested_Map_KeyValue::set_allocated_value(::substrait::Expression* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.value_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.value_ = reinterpret_cast<::substrait::Expression*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Nested.Map.KeyValue.value)
}

// -------------------------------------------------------------------

// Expression_Nested_Map

// repeated .substrait.Expression.Nested.Map.KeyValue key_values = 1;
inline int Expression_Nested_Map::_internal_key_values_size() const {
  return _internal_key_values().size();
}
inline int Expression_Nested_Map::key_values_size() const {
  return _internal_key_values_size();
}
inline void Expression_Nested_Map::clear_key_values() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_values_.Clear();
}
inline ::substrait::Expression_Nested_Map_KeyValue* Expression_Nested_Map::mutable_key_values(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Nested.Map.key_values)
  return _internal_mutable_key_values()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression_Nested_Map_KeyValue>* Expression_Nested_Map::mutable_key_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.Nested.Map.key_values)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_key_values();
}
inline const ::substrait::Expression_Nested_Map_KeyValue& Expression_Nested_Map::key_values(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.Nested.Map.key_values)
  return _internal_key_values().Get(index);
}
inline ::substrait::Expression_Nested_Map_KeyValue* Expression_Nested_Map::add_key_values() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::Expression_Nested_Map_KeyValue* _add = _internal_mutable_key_values()->Add();
  // @@protoc_insertion_point(field_add:substrait.Expression.Nested.Map.key_values)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression_Nested_Map_KeyValue>& Expression_Nested_Map::key_values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.Expression.Nested.Map.key_values)
  return _internal_key_values();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression_Nested_Map_KeyValue>&
Expression_Nested_Map::_internal_key_values() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.key_values_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression_Nested_Map_KeyValue>*
Expression_Nested_Map::_internal_mutable_key_values() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.key_values_;
}

// -------------------------------------------------------------------

// Expression_Nested_Struct

// repeated .substrait.Expression fields = 1;
inline int Expression_Nested_Struct::_internal_fields_size() const {
  return _internal_fields().size();
}
inline int Expression_Nested_Struct::fields_size() const {
  return _internal_fields_size();
}
inline void Expression_Nested_Struct::clear_fields() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fields_.Clear();
}
inline ::substrait::Expression* Expression_Nested_Struct::mutable_fields(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Nested.Struct.fields)
  return _internal_mutable_fields()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression>* Expression_Nested_Struct::mutable_fields()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.Nested.Struct.fields)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_fields();
}
inline const ::substrait::Expression& Expression_Nested_Struct::fields(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.Nested.Struct.fields)
  return _internal_fields().Get(index);
}
inline ::substrait::Expression* Expression_Nested_Struct::add_fields() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::Expression* _add = _internal_mutable_fields()->Add();
  // @@protoc_insertion_point(field_add:substrait.Expression.Nested.Struct.fields)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression>& Expression_Nested_Struct::fields() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.Expression.Nested.Struct.fields)
  return _internal_fields();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression>&
Expression_Nested_Struct::_internal_fields() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fields_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression>*
Expression_Nested_Struct::_internal_mutable_fields() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.fields_;
}

// -------------------------------------------------------------------

// Expression_Nested_List

// repeated .substrait.Expression values = 1;
inline int Expression_Nested_List::_internal_values_size() const {
  return _internal_values().size();
}
inline int Expression_Nested_List::values_size() const {
  return _internal_values_size();
}
inline void Expression_Nested_List::clear_values() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.values_.Clear();
}
inline ::substrait::Expression* Expression_Nested_List::mutable_values(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Nested.List.values)
  return _internal_mutable_values()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression>* Expression_Nested_List::mutable_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.Nested.List.values)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_values();
}
inline const ::substrait::Expression& Expression_Nested_List::values(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.Nested.List.values)
  return _internal_values().Get(index);
}
inline ::substrait::Expression* Expression_Nested_List::add_values() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::Expression* _add = _internal_mutable_values()->Add();
  // @@protoc_insertion_point(field_add:substrait.Expression.Nested.List.values)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression>& Expression_Nested_List::values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.Expression.Nested.List.values)
  return _internal_values();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression>&
Expression_Nested_List::_internal_values() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression>*
Expression_Nested_List::_internal_mutable_values() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// Expression_Nested

// bool nullable = 1;
inline void Expression_Nested::clear_nullable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nullable_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool Expression_Nested::nullable() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Nested.nullable)
  return _internal_nullable();
}
inline void Expression_Nested::set_nullable(bool value) {
  _internal_set_nullable(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:substrait.Expression.Nested.nullable)
}
inline bool Expression_Nested::_internal_nullable() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.nullable_;
}
inline void Expression_Nested::_internal_set_nullable(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nullable_ = value;
}

// uint32 type_variation_reference = 2;
inline void Expression_Nested::clear_type_variation_reference() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_variation_reference_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t Expression_Nested::type_variation_reference() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Nested.type_variation_reference)
  return _internal_type_variation_reference();
}
inline void Expression_Nested::set_type_variation_reference(::uint32_t value) {
  _internal_set_type_variation_reference(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:substrait.Expression.Nested.type_variation_reference)
}
inline ::uint32_t Expression_Nested::_internal_type_variation_reference() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.type_variation_reference_;
}
inline void Expression_Nested::_internal_set_type_variation_reference(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_variation_reference_ = value;
}

// .substrait.Expression.Nested.Struct struct = 3;
inline bool Expression_Nested::has_struct_() const {
  return nested_type_case() == kStruct;
}
inline bool Expression_Nested::_internal_has_struct_() const {
  return nested_type_case() == kStruct;
}
inline void Expression_Nested::set_has_struct_() {
  _impl_._oneof_case_[0] = kStruct;
}
inline void Expression_Nested::clear_struct_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (nested_type_case() == kStruct) {
    if (GetArena() == nullptr) {
      delete _impl_.nested_type_.struct__;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.nested_type_.struct__);
    }
    clear_has_nested_type();
  }
}
inline ::substrait::Expression_Nested_Struct* Expression_Nested::release_struct_() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Nested.struct)
  if (nested_type_case() == kStruct) {
    clear_has_nested_type();
    auto* temp = _impl_.nested_type_.struct__;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.nested_type_.struct__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_Nested_Struct& Expression_Nested::_internal_struct_() const {
  return nested_type_case() == kStruct ? *_impl_.nested_type_.struct__ : reinterpret_cast<::substrait::Expression_Nested_Struct&>(::substrait::_Expression_Nested_Struct_default_instance_);
}
inline const ::substrait::Expression_Nested_Struct& Expression_Nested::struct_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.Nested.struct)
  return _internal_struct_();
}
inline ::substrait::Expression_Nested_Struct* Expression_Nested::unsafe_arena_release_struct_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.Nested.struct)
  if (nested_type_case() == kStruct) {
    clear_has_nested_type();
    auto* temp = _impl_.nested_type_.struct__;
    _impl_.nested_type_.struct__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_Nested::unsafe_arena_set_allocated_struct_(::substrait::Expression_Nested_Struct* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_nested_type();
  if (value) {
    set_has_struct_();
    _impl_.nested_type_.struct__ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.Nested.struct)
}
inline ::substrait::Expression_Nested_Struct* Expression_Nested::_internal_mutable_struct_() {
  if (nested_type_case() != kStruct) {
    clear_nested_type();
    set_has_struct_();
    _impl_.nested_type_.struct__ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_Nested_Struct>(GetArena());
  }
  return _impl_.nested_type_.struct__;
}
inline ::substrait::Expression_Nested_Struct* Expression_Nested::mutable_struct_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression_Nested_Struct* _msg = _internal_mutable_struct_();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Nested.struct)
  return _msg;
}

// .substrait.Expression.Nested.List list = 4;
inline bool Expression_Nested::has_list() const {
  return nested_type_case() == kList;
}
inline bool Expression_Nested::_internal_has_list() const {
  return nested_type_case() == kList;
}
inline void Expression_Nested::set_has_list() {
  _impl_._oneof_case_[0] = kList;
}
inline void Expression_Nested::clear_list() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (nested_type_case() == kList) {
    if (GetArena() == nullptr) {
      delete _impl_.nested_type_.list_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.nested_type_.list_);
    }
    clear_has_nested_type();
  }
}
inline ::substrait::Expression_Nested_List* Expression_Nested::release_list() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Nested.list)
  if (nested_type_case() == kList) {
    clear_has_nested_type();
    auto* temp = _impl_.nested_type_.list_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.nested_type_.list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_Nested_List& Expression_Nested::_internal_list() const {
  return nested_type_case() == kList ? *_impl_.nested_type_.list_ : reinterpret_cast<::substrait::Expression_Nested_List&>(::substrait::_Expression_Nested_List_default_instance_);
}
inline const ::substrait::Expression_Nested_List& Expression_Nested::list() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.Nested.list)
  return _internal_list();
}
inline ::substrait::Expression_Nested_List* Expression_Nested::unsafe_arena_release_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.Nested.list)
  if (nested_type_case() == kList) {
    clear_has_nested_type();
    auto* temp = _impl_.nested_type_.list_;
    _impl_.nested_type_.list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_Nested::unsafe_arena_set_allocated_list(::substrait::Expression_Nested_List* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_nested_type();
  if (value) {
    set_has_list();
    _impl_.nested_type_.list_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.Nested.list)
}
inline ::substrait::Expression_Nested_List* Expression_Nested::_internal_mutable_list() {
  if (nested_type_case() != kList) {
    clear_nested_type();
    set_has_list();
    _impl_.nested_type_.list_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_Nested_List>(GetArena());
  }
  return _impl_.nested_type_.list_;
}
inline ::substrait::Expression_Nested_List* Expression_Nested::mutable_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression_Nested_List* _msg = _internal_mutable_list();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Nested.list)
  return _msg;
}

// .substrait.Expression.Nested.Map map = 5;
inline bool Expression_Nested::has_map() const {
  return nested_type_case() == kMap;
}
inline bool Expression_Nested::_internal_has_map() const {
  return nested_type_case() == kMap;
}
inline void Expression_Nested::set_has_map() {
  _impl_._oneof_case_[0] = kMap;
}
inline void Expression_Nested::clear_map() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (nested_type_case() == kMap) {
    if (GetArena() == nullptr) {
      delete _impl_.nested_type_.map_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.nested_type_.map_);
    }
    clear_has_nested_type();
  }
}
inline ::substrait::Expression_Nested_Map* Expression_Nested::release_map() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Nested.map)
  if (nested_type_case() == kMap) {
    clear_has_nested_type();
    auto* temp = _impl_.nested_type_.map_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.nested_type_.map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_Nested_Map& Expression_Nested::_internal_map() const {
  return nested_type_case() == kMap ? *_impl_.nested_type_.map_ : reinterpret_cast<::substrait::Expression_Nested_Map&>(::substrait::_Expression_Nested_Map_default_instance_);
}
inline const ::substrait::Expression_Nested_Map& Expression_Nested::map() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.Nested.map)
  return _internal_map();
}
inline ::substrait::Expression_Nested_Map* Expression_Nested::unsafe_arena_release_map() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.Nested.map)
  if (nested_type_case() == kMap) {
    clear_has_nested_type();
    auto* temp = _impl_.nested_type_.map_;
    _impl_.nested_type_.map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_Nested::unsafe_arena_set_allocated_map(::substrait::Expression_Nested_Map* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_nested_type();
  if (value) {
    set_has_map();
    _impl_.nested_type_.map_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.Nested.map)
}
inline ::substrait::Expression_Nested_Map* Expression_Nested::_internal_mutable_map() {
  if (nested_type_case() != kMap) {
    clear_nested_type();
    set_has_map();
    _impl_.nested_type_.map_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_Nested_Map>(GetArena());
  }
  return _impl_.nested_type_.map_;
}
inline ::substrait::Expression_Nested_Map* Expression_Nested::mutable_map() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression_Nested_Map* _msg = _internal_mutable_map();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Nested.map)
  return _msg;
}

inline bool Expression_Nested::has_nested_type() const {
  return nested_type_case() != NESTED_TYPE_NOT_SET;
}
inline void Expression_Nested::clear_has_nested_type() {
  _impl_._oneof_case_[0] = NESTED_TYPE_NOT_SET;
}
inline Expression_Nested::NestedTypeCase Expression_Nested::nested_type_case() const {
  return Expression_Nested::NestedTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Expression_ScalarFunction

// uint32 function_reference = 1;
inline void Expression_ScalarFunction::clear_function_reference() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.function_reference_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t Expression_ScalarFunction::function_reference() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.ScalarFunction.function_reference)
  return _internal_function_reference();
}
inline void Expression_ScalarFunction::set_function_reference(::uint32_t value) {
  _internal_set_function_reference(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:substrait.Expression.ScalarFunction.function_reference)
}
inline ::uint32_t Expression_ScalarFunction::_internal_function_reference() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.function_reference_;
}
inline void Expression_ScalarFunction::_internal_set_function_reference(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.function_reference_ = value;
}

// repeated .substrait.FunctionArgument arguments = 4;
inline int Expression_ScalarFunction::_internal_arguments_size() const {
  return _internal_arguments().size();
}
inline int Expression_ScalarFunction::arguments_size() const {
  return _internal_arguments_size();
}
inline void Expression_ScalarFunction::clear_arguments() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.arguments_.Clear();
}
inline ::substrait::FunctionArgument* Expression_ScalarFunction::mutable_arguments(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.ScalarFunction.arguments)
  return _internal_mutable_arguments()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::FunctionArgument>* Expression_ScalarFunction::mutable_arguments()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.ScalarFunction.arguments)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_arguments();
}
inline const ::substrait::FunctionArgument& Expression_ScalarFunction::arguments(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.ScalarFunction.arguments)
  return _internal_arguments().Get(index);
}
inline ::substrait::FunctionArgument* Expression_ScalarFunction::add_arguments() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::FunctionArgument* _add = _internal_mutable_arguments()->Add();
  // @@protoc_insertion_point(field_add:substrait.Expression.ScalarFunction.arguments)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::FunctionArgument>& Expression_ScalarFunction::arguments() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.Expression.ScalarFunction.arguments)
  return _internal_arguments();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::FunctionArgument>&
Expression_ScalarFunction::_internal_arguments() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.arguments_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::FunctionArgument>*
Expression_ScalarFunction::_internal_mutable_arguments() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.arguments_;
}

// repeated .substrait.FunctionOption options = 5;
inline int Expression_ScalarFunction::_internal_options_size() const {
  return _internal_options().size();
}
inline int Expression_ScalarFunction::options_size() const {
  return _internal_options_size();
}
inline void Expression_ScalarFunction::clear_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.options_.Clear();
}
inline ::substrait::FunctionOption* Expression_ScalarFunction::mutable_options(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.ScalarFunction.options)
  return _internal_mutable_options()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::FunctionOption>* Expression_ScalarFunction::mutable_options()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.ScalarFunction.options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_options();
}
inline const ::substrait::FunctionOption& Expression_ScalarFunction::options(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.ScalarFunction.options)
  return _internal_options().Get(index);
}
inline ::substrait::FunctionOption* Expression_ScalarFunction::add_options() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::FunctionOption* _add = _internal_mutable_options()->Add();
  // @@protoc_insertion_point(field_add:substrait.Expression.ScalarFunction.options)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::FunctionOption>& Expression_ScalarFunction::options() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.Expression.ScalarFunction.options)
  return _internal_options();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::FunctionOption>&
Expression_ScalarFunction::_internal_options() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.options_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::FunctionOption>*
Expression_ScalarFunction::_internal_mutable_options() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.options_;
}

// .substrait.Type output_type = 3;
inline bool Expression_ScalarFunction::has_output_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.output_type_ != nullptr);
  return value;
}
inline const ::substrait::Type& Expression_ScalarFunction::_internal_output_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Type* p = _impl_.output_type_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Type&>(::substrait::_Type_default_instance_);
}
inline const ::substrait::Type& Expression_ScalarFunction::output_type() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.ScalarFunction.output_type)
  return _internal_output_type();
}
inline void Expression_ScalarFunction::unsafe_arena_set_allocated_output_type(::substrait::Type* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.output_type_);
  }
  _impl_.output_type_ = reinterpret_cast<::substrait::Type*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.ScalarFunction.output_type)
}
inline ::substrait::Type* Expression_ScalarFunction::release_output_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Type* released = _impl_.output_type_;
  _impl_.output_type_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Type* Expression_ScalarFunction::unsafe_arena_release_output_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.Expression.ScalarFunction.output_type)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Type* temp = _impl_.output_type_;
  _impl_.output_type_ = nullptr;
  return temp;
}
inline ::substrait::Type* Expression_ScalarFunction::_internal_mutable_output_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.output_type_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Type>(GetArena());
    _impl_.output_type_ = reinterpret_cast<::substrait::Type*>(p);
  }
  return _impl_.output_type_;
}
inline ::substrait::Type* Expression_ScalarFunction::mutable_output_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::Type* _msg = _internal_mutable_output_type();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.ScalarFunction.output_type)
  return _msg;
}
inline void Expression_ScalarFunction::set_allocated_output_type(::substrait::Type* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.output_type_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.output_type_ = reinterpret_cast<::substrait::Type*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.ScalarFunction.output_type)
}

// repeated .substrait.Expression args = 2 [deprecated = true];
inline int Expression_ScalarFunction::_internal_args_size() const {
  return _internal_args().size();
}
inline int Expression_ScalarFunction::args_size() const {
  return _internal_args_size();
}
inline void Expression_ScalarFunction::clear_args() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.args_.Clear();
}
inline ::substrait::Expression* Expression_ScalarFunction::mutable_args(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.ScalarFunction.args)
  return _internal_mutable_args()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression>* Expression_ScalarFunction::mutable_args()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.ScalarFunction.args)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_args();
}
inline const ::substrait::Expression& Expression_ScalarFunction::args(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.ScalarFunction.args)
  return _internal_args().Get(index);
}
inline ::substrait::Expression* Expression_ScalarFunction::add_args() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::Expression* _add = _internal_mutable_args()->Add();
  // @@protoc_insertion_point(field_add:substrait.Expression.ScalarFunction.args)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression>& Expression_ScalarFunction::args() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.Expression.ScalarFunction.args)
  return _internal_args();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression>&
Expression_ScalarFunction::_internal_args() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.args_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression>*
Expression_ScalarFunction::_internal_mutable_args() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.args_;
}

// -------------------------------------------------------------------

// Expression_WindowFunction_Bound_Preceding

// int64 offset = 1;
inline void Expression_WindowFunction_Bound_Preceding::clear_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.offset_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t Expression_WindowFunction_Bound_Preceding::offset() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.WindowFunction.Bound.Preceding.offset)
  return _internal_offset();
}
inline void Expression_WindowFunction_Bound_Preceding::set_offset(::int64_t value) {
  _internal_set_offset(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:substrait.Expression.WindowFunction.Bound.Preceding.offset)
}
inline ::int64_t Expression_WindowFunction_Bound_Preceding::_internal_offset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.offset_;
}
inline void Expression_WindowFunction_Bound_Preceding::_internal_set_offset(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.offset_ = value;
}

// -------------------------------------------------------------------

// Expression_WindowFunction_Bound_Following

// int64 offset = 1;
inline void Expression_WindowFunction_Bound_Following::clear_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.offset_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t Expression_WindowFunction_Bound_Following::offset() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.WindowFunction.Bound.Following.offset)
  return _internal_offset();
}
inline void Expression_WindowFunction_Bound_Following::set_offset(::int64_t value) {
  _internal_set_offset(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:substrait.Expression.WindowFunction.Bound.Following.offset)
}
inline ::int64_t Expression_WindowFunction_Bound_Following::_internal_offset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.offset_;
}
inline void Expression_WindowFunction_Bound_Following::_internal_set_offset(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.offset_ = value;
}

// -------------------------------------------------------------------

// Expression_WindowFunction_Bound_CurrentRow

// -------------------------------------------------------------------

// Expression_WindowFunction_Bound_Unbounded

// -------------------------------------------------------------------

// Expression_WindowFunction_Bound

// .substrait.Expression.WindowFunction.Bound.Preceding preceding = 1;
inline bool Expression_WindowFunction_Bound::has_preceding() const {
  return kind_case() == kPreceding;
}
inline bool Expression_WindowFunction_Bound::_internal_has_preceding() const {
  return kind_case() == kPreceding;
}
inline void Expression_WindowFunction_Bound::set_has_preceding() {
  _impl_._oneof_case_[0] = kPreceding;
}
inline void Expression_WindowFunction_Bound::clear_preceding() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kPreceding) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.preceding_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.preceding_);
    }
    clear_has_kind();
  }
}
inline ::substrait::Expression_WindowFunction_Bound_Preceding* Expression_WindowFunction_Bound::release_preceding() {
  // @@protoc_insertion_point(field_release:substrait.Expression.WindowFunction.Bound.preceding)
  if (kind_case() == kPreceding) {
    clear_has_kind();
    auto* temp = _impl_.kind_.preceding_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.preceding_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_WindowFunction_Bound_Preceding& Expression_WindowFunction_Bound::_internal_preceding() const {
  return kind_case() == kPreceding ? *_impl_.kind_.preceding_ : reinterpret_cast<::substrait::Expression_WindowFunction_Bound_Preceding&>(::substrait::_Expression_WindowFunction_Bound_Preceding_default_instance_);
}
inline const ::substrait::Expression_WindowFunction_Bound_Preceding& Expression_WindowFunction_Bound::preceding() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.WindowFunction.Bound.preceding)
  return _internal_preceding();
}
inline ::substrait::Expression_WindowFunction_Bound_Preceding* Expression_WindowFunction_Bound::unsafe_arena_release_preceding() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.WindowFunction.Bound.preceding)
  if (kind_case() == kPreceding) {
    clear_has_kind();
    auto* temp = _impl_.kind_.preceding_;
    _impl_.kind_.preceding_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_WindowFunction_Bound::unsafe_arena_set_allocated_preceding(::substrait::Expression_WindowFunction_Bound_Preceding* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_preceding();
    _impl_.kind_.preceding_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.WindowFunction.Bound.preceding)
}
inline ::substrait::Expression_WindowFunction_Bound_Preceding* Expression_WindowFunction_Bound::_internal_mutable_preceding() {
  if (kind_case() != kPreceding) {
    clear_kind();
    set_has_preceding();
    _impl_.kind_.preceding_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_WindowFunction_Bound_Preceding>(GetArena());
  }
  return _impl_.kind_.preceding_;
}
inline ::substrait::Expression_WindowFunction_Bound_Preceding* Expression_WindowFunction_Bound::mutable_preceding() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression_WindowFunction_Bound_Preceding* _msg = _internal_mutable_preceding();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.WindowFunction.Bound.preceding)
  return _msg;
}

// .substrait.Expression.WindowFunction.Bound.Following following = 2;
inline bool Expression_WindowFunction_Bound::has_following() const {
  return kind_case() == kFollowing;
}
inline bool Expression_WindowFunction_Bound::_internal_has_following() const {
  return kind_case() == kFollowing;
}
inline void Expression_WindowFunction_Bound::set_has_following() {
  _impl_._oneof_case_[0] = kFollowing;
}
inline void Expression_WindowFunction_Bound::clear_following() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kFollowing) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.following_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.following_);
    }
    clear_has_kind();
  }
}
inline ::substrait::Expression_WindowFunction_Bound_Following* Expression_WindowFunction_Bound::release_following() {
  // @@protoc_insertion_point(field_release:substrait.Expression.WindowFunction.Bound.following)
  if (kind_case() == kFollowing) {
    clear_has_kind();
    auto* temp = _impl_.kind_.following_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.following_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_WindowFunction_Bound_Following& Expression_WindowFunction_Bound::_internal_following() const {
  return kind_case() == kFollowing ? *_impl_.kind_.following_ : reinterpret_cast<::substrait::Expression_WindowFunction_Bound_Following&>(::substrait::_Expression_WindowFunction_Bound_Following_default_instance_);
}
inline const ::substrait::Expression_WindowFunction_Bound_Following& Expression_WindowFunction_Bound::following() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.WindowFunction.Bound.following)
  return _internal_following();
}
inline ::substrait::Expression_WindowFunction_Bound_Following* Expression_WindowFunction_Bound::unsafe_arena_release_following() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.WindowFunction.Bound.following)
  if (kind_case() == kFollowing) {
    clear_has_kind();
    auto* temp = _impl_.kind_.following_;
    _impl_.kind_.following_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_WindowFunction_Bound::unsafe_arena_set_allocated_following(::substrait::Expression_WindowFunction_Bound_Following* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_following();
    _impl_.kind_.following_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.WindowFunction.Bound.following)
}
inline ::substrait::Expression_WindowFunction_Bound_Following* Expression_WindowFunction_Bound::_internal_mutable_following() {
  if (kind_case() != kFollowing) {
    clear_kind();
    set_has_following();
    _impl_.kind_.following_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_WindowFunction_Bound_Following>(GetArena());
  }
  return _impl_.kind_.following_;
}
inline ::substrait::Expression_WindowFunction_Bound_Following* Expression_WindowFunction_Bound::mutable_following() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression_WindowFunction_Bound_Following* _msg = _internal_mutable_following();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.WindowFunction.Bound.following)
  return _msg;
}

// .substrait.Expression.WindowFunction.Bound.CurrentRow current_row = 3;
inline bool Expression_WindowFunction_Bound::has_current_row() const {
  return kind_case() == kCurrentRow;
}
inline bool Expression_WindowFunction_Bound::_internal_has_current_row() const {
  return kind_case() == kCurrentRow;
}
inline void Expression_WindowFunction_Bound::set_has_current_row() {
  _impl_._oneof_case_[0] = kCurrentRow;
}
inline void Expression_WindowFunction_Bound::clear_current_row() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kCurrentRow) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.current_row_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.current_row_);
    }
    clear_has_kind();
  }
}
inline ::substrait::Expression_WindowFunction_Bound_CurrentRow* Expression_WindowFunction_Bound::release_current_row() {
  // @@protoc_insertion_point(field_release:substrait.Expression.WindowFunction.Bound.current_row)
  if (kind_case() == kCurrentRow) {
    clear_has_kind();
    auto* temp = _impl_.kind_.current_row_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.current_row_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_WindowFunction_Bound_CurrentRow& Expression_WindowFunction_Bound::_internal_current_row() const {
  return kind_case() == kCurrentRow ? *_impl_.kind_.current_row_ : reinterpret_cast<::substrait::Expression_WindowFunction_Bound_CurrentRow&>(::substrait::_Expression_WindowFunction_Bound_CurrentRow_default_instance_);
}
inline const ::substrait::Expression_WindowFunction_Bound_CurrentRow& Expression_WindowFunction_Bound::current_row() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.WindowFunction.Bound.current_row)
  return _internal_current_row();
}
inline ::substrait::Expression_WindowFunction_Bound_CurrentRow* Expression_WindowFunction_Bound::unsafe_arena_release_current_row() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.WindowFunction.Bound.current_row)
  if (kind_case() == kCurrentRow) {
    clear_has_kind();
    auto* temp = _impl_.kind_.current_row_;
    _impl_.kind_.current_row_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_WindowFunction_Bound::unsafe_arena_set_allocated_current_row(::substrait::Expression_WindowFunction_Bound_CurrentRow* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_current_row();
    _impl_.kind_.current_row_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.WindowFunction.Bound.current_row)
}
inline ::substrait::Expression_WindowFunction_Bound_CurrentRow* Expression_WindowFunction_Bound::_internal_mutable_current_row() {
  if (kind_case() != kCurrentRow) {
    clear_kind();
    set_has_current_row();
    _impl_.kind_.current_row_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_WindowFunction_Bound_CurrentRow>(GetArena());
  }
  return _impl_.kind_.current_row_;
}
inline ::substrait::Expression_WindowFunction_Bound_CurrentRow* Expression_WindowFunction_Bound::mutable_current_row() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression_WindowFunction_Bound_CurrentRow* _msg = _internal_mutable_current_row();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.WindowFunction.Bound.current_row)
  return _msg;
}

// .substrait.Expression.WindowFunction.Bound.Unbounded unbounded = 4;
inline bool Expression_WindowFunction_Bound::has_unbounded() const {
  return kind_case() == kUnbounded;
}
inline bool Expression_WindowFunction_Bound::_internal_has_unbounded() const {
  return kind_case() == kUnbounded;
}
inline void Expression_WindowFunction_Bound::set_has_unbounded() {
  _impl_._oneof_case_[0] = kUnbounded;
}
inline void Expression_WindowFunction_Bound::clear_unbounded() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kUnbounded) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.unbounded_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.unbounded_);
    }
    clear_has_kind();
  }
}
inline ::substrait::Expression_WindowFunction_Bound_Unbounded* Expression_WindowFunction_Bound::release_unbounded() {
  // @@protoc_insertion_point(field_release:substrait.Expression.WindowFunction.Bound.unbounded)
  if (kind_case() == kUnbounded) {
    clear_has_kind();
    auto* temp = _impl_.kind_.unbounded_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.unbounded_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_WindowFunction_Bound_Unbounded& Expression_WindowFunction_Bound::_internal_unbounded() const {
  return kind_case() == kUnbounded ? *_impl_.kind_.unbounded_ : reinterpret_cast<::substrait::Expression_WindowFunction_Bound_Unbounded&>(::substrait::_Expression_WindowFunction_Bound_Unbounded_default_instance_);
}
inline const ::substrait::Expression_WindowFunction_Bound_Unbounded& Expression_WindowFunction_Bound::unbounded() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.WindowFunction.Bound.unbounded)
  return _internal_unbounded();
}
inline ::substrait::Expression_WindowFunction_Bound_Unbounded* Expression_WindowFunction_Bound::unsafe_arena_release_unbounded() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.WindowFunction.Bound.unbounded)
  if (kind_case() == kUnbounded) {
    clear_has_kind();
    auto* temp = _impl_.kind_.unbounded_;
    _impl_.kind_.unbounded_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_WindowFunction_Bound::unsafe_arena_set_allocated_unbounded(::substrait::Expression_WindowFunction_Bound_Unbounded* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_unbounded();
    _impl_.kind_.unbounded_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.WindowFunction.Bound.unbounded)
}
inline ::substrait::Expression_WindowFunction_Bound_Unbounded* Expression_WindowFunction_Bound::_internal_mutable_unbounded() {
  if (kind_case() != kUnbounded) {
    clear_kind();
    set_has_unbounded();
    _impl_.kind_.unbounded_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_WindowFunction_Bound_Unbounded>(GetArena());
  }
  return _impl_.kind_.unbounded_;
}
inline ::substrait::Expression_WindowFunction_Bound_Unbounded* Expression_WindowFunction_Bound::mutable_unbounded() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression_WindowFunction_Bound_Unbounded* _msg = _internal_mutable_unbounded();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.WindowFunction.Bound.unbounded)
  return _msg;
}

inline bool Expression_WindowFunction_Bound::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void Expression_WindowFunction_Bound::clear_has_kind() {
  _impl_._oneof_case_[0] = KIND_NOT_SET;
}
inline Expression_WindowFunction_Bound::KindCase Expression_WindowFunction_Bound::kind_case() const {
  return Expression_WindowFunction_Bound::KindCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Expression_WindowFunction

// uint32 function_reference = 1;
inline void Expression_WindowFunction::clear_function_reference() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.function_reference_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t Expression_WindowFunction::function_reference() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.WindowFunction.function_reference)
  return _internal_function_reference();
}
inline void Expression_WindowFunction::set_function_reference(::uint32_t value) {
  _internal_set_function_reference(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:substrait.Expression.WindowFunction.function_reference)
}
inline ::uint32_t Expression_WindowFunction::_internal_function_reference() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.function_reference_;
}
inline void Expression_WindowFunction::_internal_set_function_reference(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.function_reference_ = value;
}

// repeated .substrait.FunctionArgument arguments = 9;
inline int Expression_WindowFunction::_internal_arguments_size() const {
  return _internal_arguments().size();
}
inline int Expression_WindowFunction::arguments_size() const {
  return _internal_arguments_size();
}
inline void Expression_WindowFunction::clear_arguments() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.arguments_.Clear();
}
inline ::substrait::FunctionArgument* Expression_WindowFunction::mutable_arguments(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.WindowFunction.arguments)
  return _internal_mutable_arguments()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::FunctionArgument>* Expression_WindowFunction::mutable_arguments()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.WindowFunction.arguments)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_arguments();
}
inline const ::substrait::FunctionArgument& Expression_WindowFunction::arguments(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.WindowFunction.arguments)
  return _internal_arguments().Get(index);
}
inline ::substrait::FunctionArgument* Expression_WindowFunction::add_arguments() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::FunctionArgument* _add = _internal_mutable_arguments()->Add();
  // @@protoc_insertion_point(field_add:substrait.Expression.WindowFunction.arguments)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::FunctionArgument>& Expression_WindowFunction::arguments() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.Expression.WindowFunction.arguments)
  return _internal_arguments();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::FunctionArgument>&
Expression_WindowFunction::_internal_arguments() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.arguments_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::FunctionArgument>*
Expression_WindowFunction::_internal_mutable_arguments() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.arguments_;
}

// repeated .substrait.FunctionOption options = 11;
inline int Expression_WindowFunction::_internal_options_size() const {
  return _internal_options().size();
}
inline int Expression_WindowFunction::options_size() const {
  return _internal_options_size();
}
inline void Expression_WindowFunction::clear_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.options_.Clear();
}
inline ::substrait::FunctionOption* Expression_WindowFunction::mutable_options(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.WindowFunction.options)
  return _internal_mutable_options()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::FunctionOption>* Expression_WindowFunction::mutable_options()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.WindowFunction.options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_options();
}
inline const ::substrait::FunctionOption& Expression_WindowFunction::options(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.WindowFunction.options)
  return _internal_options().Get(index);
}
inline ::substrait::FunctionOption* Expression_WindowFunction::add_options() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::FunctionOption* _add = _internal_mutable_options()->Add();
  // @@protoc_insertion_point(field_add:substrait.Expression.WindowFunction.options)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::FunctionOption>& Expression_WindowFunction::options() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.Expression.WindowFunction.options)
  return _internal_options();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::FunctionOption>&
Expression_WindowFunction::_internal_options() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.options_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::FunctionOption>*
Expression_WindowFunction::_internal_mutable_options() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.options_;
}

// .substrait.Type output_type = 7;
inline bool Expression_WindowFunction::has_output_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.output_type_ != nullptr);
  return value;
}
inline const ::substrait::Type& Expression_WindowFunction::_internal_output_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Type* p = _impl_.output_type_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Type&>(::substrait::_Type_default_instance_);
}
inline const ::substrait::Type& Expression_WindowFunction::output_type() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.WindowFunction.output_type)
  return _internal_output_type();
}
inline void Expression_WindowFunction::unsafe_arena_set_allocated_output_type(::substrait::Type* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.output_type_);
  }
  _impl_.output_type_ = reinterpret_cast<::substrait::Type*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.WindowFunction.output_type)
}
inline ::substrait::Type* Expression_WindowFunction::release_output_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::substrait::Type* released = _impl_.output_type_;
  _impl_.output_type_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Type* Expression_WindowFunction::unsafe_arena_release_output_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.Expression.WindowFunction.output_type)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::substrait::Type* temp = _impl_.output_type_;
  _impl_.output_type_ = nullptr;
  return temp;
}
inline ::substrait::Type* Expression_WindowFunction::_internal_mutable_output_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.output_type_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Type>(GetArena());
    _impl_.output_type_ = reinterpret_cast<::substrait::Type*>(p);
  }
  return _impl_.output_type_;
}
inline ::substrait::Type* Expression_WindowFunction::mutable_output_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::substrait::Type* _msg = _internal_mutable_output_type();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.WindowFunction.output_type)
  return _msg;
}
inline void Expression_WindowFunction::set_allocated_output_type(::substrait::Type* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.output_type_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.output_type_ = reinterpret_cast<::substrait::Type*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.WindowFunction.output_type)
}

// .substrait.AggregationPhase phase = 6;
inline void Expression_WindowFunction::clear_phase() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.phase_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::substrait::AggregationPhase Expression_WindowFunction::phase() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.WindowFunction.phase)
  return _internal_phase();
}
inline void Expression_WindowFunction::set_phase(::substrait::AggregationPhase value) {
  _internal_set_phase(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:substrait.Expression.WindowFunction.phase)
}
inline ::substrait::AggregationPhase Expression_WindowFunction::_internal_phase() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::substrait::AggregationPhase>(_impl_.phase_);
}
inline void Expression_WindowFunction::_internal_set_phase(::substrait::AggregationPhase value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.phase_ = value;
}

// repeated .substrait.SortField sorts = 3;
inline int Expression_WindowFunction::_internal_sorts_size() const {
  return _internal_sorts().size();
}
inline int Expression_WindowFunction::sorts_size() const {
  return _internal_sorts_size();
}
inline void Expression_WindowFunction::clear_sorts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sorts_.Clear();
}
inline ::substrait::SortField* Expression_WindowFunction::mutable_sorts(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.WindowFunction.sorts)
  return _internal_mutable_sorts()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::SortField>* Expression_WindowFunction::mutable_sorts()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.WindowFunction.sorts)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_sorts();
}
inline const ::substrait::SortField& Expression_WindowFunction::sorts(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.WindowFunction.sorts)
  return _internal_sorts().Get(index);
}
inline ::substrait::SortField* Expression_WindowFunction::add_sorts() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::SortField* _add = _internal_mutable_sorts()->Add();
  // @@protoc_insertion_point(field_add:substrait.Expression.WindowFunction.sorts)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::SortField>& Expression_WindowFunction::sorts() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.Expression.WindowFunction.sorts)
  return _internal_sorts();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::SortField>&
Expression_WindowFunction::_internal_sorts() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sorts_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::SortField>*
Expression_WindowFunction::_internal_mutable_sorts() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.sorts_;
}

// .substrait.AggregateFunction.AggregationInvocation invocation = 10;
inline void Expression_WindowFunction::clear_invocation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.invocation_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::substrait::AggregateFunction_AggregationInvocation Expression_WindowFunction::invocation() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.WindowFunction.invocation)
  return _internal_invocation();
}
inline void Expression_WindowFunction::set_invocation(::substrait::AggregateFunction_AggregationInvocation value) {
  _internal_set_invocation(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:substrait.Expression.WindowFunction.invocation)
}
inline ::substrait::AggregateFunction_AggregationInvocation Expression_WindowFunction::_internal_invocation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::substrait::AggregateFunction_AggregationInvocation>(_impl_.invocation_);
}
inline void Expression_WindowFunction::_internal_set_invocation(::substrait::AggregateFunction_AggregationInvocation value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.invocation_ = value;
}

// repeated .substrait.Expression partitions = 2;
inline int Expression_WindowFunction::_internal_partitions_size() const {
  return _internal_partitions().size();
}
inline int Expression_WindowFunction::partitions_size() const {
  return _internal_partitions_size();
}
inline void Expression_WindowFunction::clear_partitions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.partitions_.Clear();
}
inline ::substrait::Expression* Expression_WindowFunction::mutable_partitions(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.WindowFunction.partitions)
  return _internal_mutable_partitions()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression>* Expression_WindowFunction::mutable_partitions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.WindowFunction.partitions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_partitions();
}
inline const ::substrait::Expression& Expression_WindowFunction::partitions(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.WindowFunction.partitions)
  return _internal_partitions().Get(index);
}
inline ::substrait::Expression* Expression_WindowFunction::add_partitions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::Expression* _add = _internal_mutable_partitions()->Add();
  // @@protoc_insertion_point(field_add:substrait.Expression.WindowFunction.partitions)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression>& Expression_WindowFunction::partitions() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.Expression.WindowFunction.partitions)
  return _internal_partitions();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression>&
Expression_WindowFunction::_internal_partitions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.partitions_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression>*
Expression_WindowFunction::_internal_mutable_partitions() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.partitions_;
}

// .substrait.Expression.WindowFunction.BoundsType bounds_type = 12;
inline void Expression_WindowFunction::clear_bounds_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bounds_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::substrait::Expression_WindowFunction_BoundsType Expression_WindowFunction::bounds_type() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.WindowFunction.bounds_type)
  return _internal_bounds_type();
}
inline void Expression_WindowFunction::set_bounds_type(::substrait::Expression_WindowFunction_BoundsType value) {
  _internal_set_bounds_type(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:substrait.Expression.WindowFunction.bounds_type)
}
inline ::substrait::Expression_WindowFunction_BoundsType Expression_WindowFunction::_internal_bounds_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::substrait::Expression_WindowFunction_BoundsType>(_impl_.bounds_type_);
}
inline void Expression_WindowFunction::_internal_set_bounds_type(::substrait::Expression_WindowFunction_BoundsType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bounds_type_ = value;
}

// .substrait.Expression.WindowFunction.Bound lower_bound = 5;
inline bool Expression_WindowFunction::has_lower_bound() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lower_bound_ != nullptr);
  return value;
}
inline void Expression_WindowFunction::clear_lower_bound() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lower_bound_ != nullptr) _impl_.lower_bound_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::substrait::Expression_WindowFunction_Bound& Expression_WindowFunction::_internal_lower_bound() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Expression_WindowFunction_Bound* p = _impl_.lower_bound_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression_WindowFunction_Bound&>(::substrait::_Expression_WindowFunction_Bound_default_instance_);
}
inline const ::substrait::Expression_WindowFunction_Bound& Expression_WindowFunction::lower_bound() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.WindowFunction.lower_bound)
  return _internal_lower_bound();
}
inline void Expression_WindowFunction::unsafe_arena_set_allocated_lower_bound(::substrait::Expression_WindowFunction_Bound* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lower_bound_);
  }
  _impl_.lower_bound_ = reinterpret_cast<::substrait::Expression_WindowFunction_Bound*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.WindowFunction.lower_bound)
}
inline ::substrait::Expression_WindowFunction_Bound* Expression_WindowFunction::release_lower_bound() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Expression_WindowFunction_Bound* released = _impl_.lower_bound_;
  _impl_.lower_bound_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Expression_WindowFunction_Bound* Expression_WindowFunction::unsafe_arena_release_lower_bound() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.Expression.WindowFunction.lower_bound)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Expression_WindowFunction_Bound* temp = _impl_.lower_bound_;
  _impl_.lower_bound_ = nullptr;
  return temp;
}
inline ::substrait::Expression_WindowFunction_Bound* Expression_WindowFunction::_internal_mutable_lower_bound() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.lower_bound_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_WindowFunction_Bound>(GetArena());
    _impl_.lower_bound_ = reinterpret_cast<::substrait::Expression_WindowFunction_Bound*>(p);
  }
  return _impl_.lower_bound_;
}
inline ::substrait::Expression_WindowFunction_Bound* Expression_WindowFunction::mutable_lower_bound() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::substrait::Expression_WindowFunction_Bound* _msg = _internal_mutable_lower_bound();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.WindowFunction.lower_bound)
  return _msg;
}
inline void Expression_WindowFunction::set_allocated_lower_bound(::substrait::Expression_WindowFunction_Bound* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.lower_bound_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.lower_bound_ = reinterpret_cast<::substrait::Expression_WindowFunction_Bound*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.WindowFunction.lower_bound)
}

// .substrait.Expression.WindowFunction.Bound upper_bound = 4;
inline bool Expression_WindowFunction::has_upper_bound() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.upper_bound_ != nullptr);
  return value;
}
inline void Expression_WindowFunction::clear_upper_bound() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.upper_bound_ != nullptr) _impl_.upper_bound_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::Expression_WindowFunction_Bound& Expression_WindowFunction::_internal_upper_bound() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Expression_WindowFunction_Bound* p = _impl_.upper_bound_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression_WindowFunction_Bound&>(::substrait::_Expression_WindowFunction_Bound_default_instance_);
}
inline const ::substrait::Expression_WindowFunction_Bound& Expression_WindowFunction::upper_bound() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.WindowFunction.upper_bound)
  return _internal_upper_bound();
}
inline void Expression_WindowFunction::unsafe_arena_set_allocated_upper_bound(::substrait::Expression_WindowFunction_Bound* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.upper_bound_);
  }
  _impl_.upper_bound_ = reinterpret_cast<::substrait::Expression_WindowFunction_Bound*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.WindowFunction.upper_bound)
}
inline ::substrait::Expression_WindowFunction_Bound* Expression_WindowFunction::release_upper_bound() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Expression_WindowFunction_Bound* released = _impl_.upper_bound_;
  _impl_.upper_bound_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Expression_WindowFunction_Bound* Expression_WindowFunction::unsafe_arena_release_upper_bound() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.Expression.WindowFunction.upper_bound)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Expression_WindowFunction_Bound* temp = _impl_.upper_bound_;
  _impl_.upper_bound_ = nullptr;
  return temp;
}
inline ::substrait::Expression_WindowFunction_Bound* Expression_WindowFunction::_internal_mutable_upper_bound() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.upper_bound_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_WindowFunction_Bound>(GetArena());
    _impl_.upper_bound_ = reinterpret_cast<::substrait::Expression_WindowFunction_Bound*>(p);
  }
  return _impl_.upper_bound_;
}
inline ::substrait::Expression_WindowFunction_Bound* Expression_WindowFunction::mutable_upper_bound() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::Expression_WindowFunction_Bound* _msg = _internal_mutable_upper_bound();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.WindowFunction.upper_bound)
  return _msg;
}
inline void Expression_WindowFunction::set_allocated_upper_bound(::substrait::Expression_WindowFunction_Bound* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.upper_bound_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.upper_bound_ = reinterpret_cast<::substrait::Expression_WindowFunction_Bound*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.WindowFunction.upper_bound)
}

// repeated .substrait.Expression args = 8 [deprecated = true];
inline int Expression_WindowFunction::_internal_args_size() const {
  return _internal_args().size();
}
inline int Expression_WindowFunction::args_size() const {
  return _internal_args_size();
}
inline void Expression_WindowFunction::clear_args() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.args_.Clear();
}
inline ::substrait::Expression* Expression_WindowFunction::mutable_args(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.WindowFunction.args)
  return _internal_mutable_args()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression>* Expression_WindowFunction::mutable_args()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.WindowFunction.args)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_args();
}
inline const ::substrait::Expression& Expression_WindowFunction::args(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.WindowFunction.args)
  return _internal_args().Get(index);
}
inline ::substrait::Expression* Expression_WindowFunction::add_args() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::Expression* _add = _internal_mutable_args()->Add();
  // @@protoc_insertion_point(field_add:substrait.Expression.WindowFunction.args)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression>& Expression_WindowFunction::args() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.Expression.WindowFunction.args)
  return _internal_args();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression>&
Expression_WindowFunction::_internal_args() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.args_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression>*
Expression_WindowFunction::_internal_mutable_args() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.args_;
}

// -------------------------------------------------------------------

// Expression_IfThen_IfClause

// .substrait.Expression if = 1;
inline bool Expression_IfThen_IfClause::has_if_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.if__ != nullptr);
  return value;
}
inline void Expression_IfThen_IfClause::clear_if_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.if__ != nullptr) _impl_.if__->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::Expression& Expression_IfThen_IfClause::_internal_if_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Expression* p = _impl_.if__;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression&>(::substrait::_Expression_default_instance_);
}
inline const ::substrait::Expression& Expression_IfThen_IfClause::if_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.IfThen.IfClause.if)
  return _internal_if_();
}
inline void Expression_IfThen_IfClause::unsafe_arena_set_allocated_if_(::substrait::Expression* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.if__);
  }
  _impl_.if__ = reinterpret_cast<::substrait::Expression*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.IfThen.IfClause.if)
}
inline ::substrait::Expression* Expression_IfThen_IfClause::release_if_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Expression* released = _impl_.if__;
  _impl_.if__ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Expression* Expression_IfThen_IfClause::unsafe_arena_release_if_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.Expression.IfThen.IfClause.if)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Expression* temp = _impl_.if__;
  _impl_.if__ = nullptr;
  return temp;
}
inline ::substrait::Expression* Expression_IfThen_IfClause::_internal_mutable_if_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.if__ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Expression>(GetArena());
    _impl_.if__ = reinterpret_cast<::substrait::Expression*>(p);
  }
  return _impl_.if__;
}
inline ::substrait::Expression* Expression_IfThen_IfClause::mutable_if_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::Expression* _msg = _internal_mutable_if_();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.IfThen.IfClause.if)
  return _msg;
}
inline void Expression_IfThen_IfClause::set_allocated_if_(::substrait::Expression* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.if__);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.if__ = reinterpret_cast<::substrait::Expression*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.IfThen.IfClause.if)
}

// .substrait.Expression then = 2;
inline bool Expression_IfThen_IfClause::has_then() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.then_ != nullptr);
  return value;
}
inline void Expression_IfThen_IfClause::clear_then() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.then_ != nullptr) _impl_.then_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::substrait::Expression& Expression_IfThen_IfClause::_internal_then() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Expression* p = _impl_.then_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression&>(::substrait::_Expression_default_instance_);
}
inline const ::substrait::Expression& Expression_IfThen_IfClause::then() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.IfThen.IfClause.then)
  return _internal_then();
}
inline void Expression_IfThen_IfClause::unsafe_arena_set_allocated_then(::substrait::Expression* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.then_);
  }
  _impl_.then_ = reinterpret_cast<::substrait::Expression*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.IfThen.IfClause.then)
}
inline ::substrait::Expression* Expression_IfThen_IfClause::release_then() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Expression* released = _impl_.then_;
  _impl_.then_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Expression* Expression_IfThen_IfClause::unsafe_arena_release_then() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.Expression.IfThen.IfClause.then)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Expression* temp = _impl_.then_;
  _impl_.then_ = nullptr;
  return temp;
}
inline ::substrait::Expression* Expression_IfThen_IfClause::_internal_mutable_then() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.then_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Expression>(GetArena());
    _impl_.then_ = reinterpret_cast<::substrait::Expression*>(p);
  }
  return _impl_.then_;
}
inline ::substrait::Expression* Expression_IfThen_IfClause::mutable_then() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::substrait::Expression* _msg = _internal_mutable_then();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.IfThen.IfClause.then)
  return _msg;
}
inline void Expression_IfThen_IfClause::set_allocated_then(::substrait::Expression* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.then_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.then_ = reinterpret_cast<::substrait::Expression*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.IfThen.IfClause.then)
}

// -------------------------------------------------------------------

// Expression_IfThen

// repeated .substrait.Expression.IfThen.IfClause ifs = 1;
inline int Expression_IfThen::_internal_ifs_size() const {
  return _internal_ifs().size();
}
inline int Expression_IfThen::ifs_size() const {
  return _internal_ifs_size();
}
inline void Expression_IfThen::clear_ifs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ifs_.Clear();
}
inline ::substrait::Expression_IfThen_IfClause* Expression_IfThen::mutable_ifs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.IfThen.ifs)
  return _internal_mutable_ifs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression_IfThen_IfClause>* Expression_IfThen::mutable_ifs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.IfThen.ifs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_ifs();
}
inline const ::substrait::Expression_IfThen_IfClause& Expression_IfThen::ifs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.IfThen.ifs)
  return _internal_ifs().Get(index);
}
inline ::substrait::Expression_IfThen_IfClause* Expression_IfThen::add_ifs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::Expression_IfThen_IfClause* _add = _internal_mutable_ifs()->Add();
  // @@protoc_insertion_point(field_add:substrait.Expression.IfThen.ifs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression_IfThen_IfClause>& Expression_IfThen::ifs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.Expression.IfThen.ifs)
  return _internal_ifs();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression_IfThen_IfClause>&
Expression_IfThen::_internal_ifs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ifs_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression_IfThen_IfClause>*
Expression_IfThen::_internal_mutable_ifs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.ifs_;
}

// .substrait.Expression else = 2;
inline bool Expression_IfThen::has_else_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.else__ != nullptr);
  return value;
}
inline void Expression_IfThen::clear_else_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.else__ != nullptr) _impl_.else__->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::Expression& Expression_IfThen::_internal_else_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Expression* p = _impl_.else__;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression&>(::substrait::_Expression_default_instance_);
}
inline const ::substrait::Expression& Expression_IfThen::else_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.IfThen.else)
  return _internal_else_();
}
inline void Expression_IfThen::unsafe_arena_set_allocated_else_(::substrait::Expression* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.else__);
  }
  _impl_.else__ = reinterpret_cast<::substrait::Expression*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.IfThen.else)
}
inline ::substrait::Expression* Expression_IfThen::release_else_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Expression* released = _impl_.else__;
  _impl_.else__ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Expression* Expression_IfThen::unsafe_arena_release_else_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.Expression.IfThen.else)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Expression* temp = _impl_.else__;
  _impl_.else__ = nullptr;
  return temp;
}
inline ::substrait::Expression* Expression_IfThen::_internal_mutable_else_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.else__ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Expression>(GetArena());
    _impl_.else__ = reinterpret_cast<::substrait::Expression*>(p);
  }
  return _impl_.else__;
}
inline ::substrait::Expression* Expression_IfThen::mutable_else_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::Expression* _msg = _internal_mutable_else_();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.IfThen.else)
  return _msg;
}
inline void Expression_IfThen::set_allocated_else_(::substrait::Expression* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.else__);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.else__ = reinterpret_cast<::substrait::Expression*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.IfThen.else)
}

// -------------------------------------------------------------------

// Expression_Cast

// .substrait.Type type = 1;
inline bool Expression_Cast::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.type_ != nullptr);
  return value;
}
inline const ::substrait::Type& Expression_Cast::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Type* p = _impl_.type_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Type&>(::substrait::_Type_default_instance_);
}
inline const ::substrait::Type& Expression_Cast::type() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.Cast.type)
  return _internal_type();
}
inline void Expression_Cast::unsafe_arena_set_allocated_type(::substrait::Type* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.type_);
  }
  _impl_.type_ = reinterpret_cast<::substrait::Type*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.Cast.type)
}
inline ::substrait::Type* Expression_Cast::release_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Type* released = _impl_.type_;
  _impl_.type_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Type* Expression_Cast::unsafe_arena_release_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.Expression.Cast.type)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Type* temp = _impl_.type_;
  _impl_.type_ = nullptr;
  return temp;
}
inline ::substrait::Type* Expression_Cast::_internal_mutable_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.type_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Type>(GetArena());
    _impl_.type_ = reinterpret_cast<::substrait::Type*>(p);
  }
  return _impl_.type_;
}
inline ::substrait::Type* Expression_Cast::mutable_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::Type* _msg = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Cast.type)
  return _msg;
}
inline void Expression_Cast::set_allocated_type(::substrait::Type* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.type_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.type_ = reinterpret_cast<::substrait::Type*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Cast.type)
}

// .substrait.Expression input = 2;
inline bool Expression_Cast::has_input() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.input_ != nullptr);
  return value;
}
inline void Expression_Cast::clear_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.input_ != nullptr) _impl_.input_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::substrait::Expression& Expression_Cast::_internal_input() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Expression* p = _impl_.input_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression&>(::substrait::_Expression_default_instance_);
}
inline const ::substrait::Expression& Expression_Cast::input() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.Cast.input)
  return _internal_input();
}
inline void Expression_Cast::unsafe_arena_set_allocated_input(::substrait::Expression* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.input_);
  }
  _impl_.input_ = reinterpret_cast<::substrait::Expression*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.Cast.input)
}
inline ::substrait::Expression* Expression_Cast::release_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Expression* released = _impl_.input_;
  _impl_.input_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Expression* Expression_Cast::unsafe_arena_release_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.Expression.Cast.input)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Expression* temp = _impl_.input_;
  _impl_.input_ = nullptr;
  return temp;
}
inline ::substrait::Expression* Expression_Cast::_internal_mutable_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.input_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Expression>(GetArena());
    _impl_.input_ = reinterpret_cast<::substrait::Expression*>(p);
  }
  return _impl_.input_;
}
inline ::substrait::Expression* Expression_Cast::mutable_input() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::substrait::Expression* _msg = _internal_mutable_input();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Cast.input)
  return _msg;
}
inline void Expression_Cast::set_allocated_input(::substrait::Expression* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.input_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.input_ = reinterpret_cast<::substrait::Expression*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Cast.input)
}

// .substrait.Expression.Cast.FailureBehavior failure_behavior = 3;
inline void Expression_Cast::clear_failure_behavior() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.failure_behavior_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::substrait::Expression_Cast_FailureBehavior Expression_Cast::failure_behavior() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Cast.failure_behavior)
  return _internal_failure_behavior();
}
inline void Expression_Cast::set_failure_behavior(::substrait::Expression_Cast_FailureBehavior value) {
  _internal_set_failure_behavior(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:substrait.Expression.Cast.failure_behavior)
}
inline ::substrait::Expression_Cast_FailureBehavior Expression_Cast::_internal_failure_behavior() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::substrait::Expression_Cast_FailureBehavior>(_impl_.failure_behavior_);
}
inline void Expression_Cast::_internal_set_failure_behavior(::substrait::Expression_Cast_FailureBehavior value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.failure_behavior_ = value;
}

// -------------------------------------------------------------------

// Expression_SwitchExpression_IfValue

// .substrait.Expression.Literal if = 1;
inline bool Expression_SwitchExpression_IfValue::has_if_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.if__ != nullptr);
  return value;
}
inline void Expression_SwitchExpression_IfValue::clear_if_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.if__ != nullptr) _impl_.if__->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::Expression_Literal& Expression_SwitchExpression_IfValue::_internal_if_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Expression_Literal* p = _impl_.if__;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression_Literal&>(::substrait::_Expression_Literal_default_instance_);
}
inline const ::substrait::Expression_Literal& Expression_SwitchExpression_IfValue::if_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.SwitchExpression.IfValue.if)
  return _internal_if_();
}
inline void Expression_SwitchExpression_IfValue::unsafe_arena_set_allocated_if_(::substrait::Expression_Literal* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.if__);
  }
  _impl_.if__ = reinterpret_cast<::substrait::Expression_Literal*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.SwitchExpression.IfValue.if)
}
inline ::substrait::Expression_Literal* Expression_SwitchExpression_IfValue::release_if_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Expression_Literal* released = _impl_.if__;
  _impl_.if__ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Expression_Literal* Expression_SwitchExpression_IfValue::unsafe_arena_release_if_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.Expression.SwitchExpression.IfValue.if)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Expression_Literal* temp = _impl_.if__;
  _impl_.if__ = nullptr;
  return temp;
}
inline ::substrait::Expression_Literal* Expression_SwitchExpression_IfValue::_internal_mutable_if_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.if__ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_Literal>(GetArena());
    _impl_.if__ = reinterpret_cast<::substrait::Expression_Literal*>(p);
  }
  return _impl_.if__;
}
inline ::substrait::Expression_Literal* Expression_SwitchExpression_IfValue::mutable_if_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::Expression_Literal* _msg = _internal_mutable_if_();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.SwitchExpression.IfValue.if)
  return _msg;
}
inline void Expression_SwitchExpression_IfValue::set_allocated_if_(::substrait::Expression_Literal* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.if__);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.if__ = reinterpret_cast<::substrait::Expression_Literal*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.SwitchExpression.IfValue.if)
}

// .substrait.Expression then = 2;
inline bool Expression_SwitchExpression_IfValue::has_then() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.then_ != nullptr);
  return value;
}
inline void Expression_SwitchExpression_IfValue::clear_then() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.then_ != nullptr) _impl_.then_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::substrait::Expression& Expression_SwitchExpression_IfValue::_internal_then() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Expression* p = _impl_.then_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression&>(::substrait::_Expression_default_instance_);
}
inline const ::substrait::Expression& Expression_SwitchExpression_IfValue::then() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.SwitchExpression.IfValue.then)
  return _internal_then();
}
inline void Expression_SwitchExpression_IfValue::unsafe_arena_set_allocated_then(::substrait::Expression* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.then_);
  }
  _impl_.then_ = reinterpret_cast<::substrait::Expression*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.SwitchExpression.IfValue.then)
}
inline ::substrait::Expression* Expression_SwitchExpression_IfValue::release_then() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Expression* released = _impl_.then_;
  _impl_.then_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Expression* Expression_SwitchExpression_IfValue::unsafe_arena_release_then() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.Expression.SwitchExpression.IfValue.then)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Expression* temp = _impl_.then_;
  _impl_.then_ = nullptr;
  return temp;
}
inline ::substrait::Expression* Expression_SwitchExpression_IfValue::_internal_mutable_then() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.then_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Expression>(GetArena());
    _impl_.then_ = reinterpret_cast<::substrait::Expression*>(p);
  }
  return _impl_.then_;
}
inline ::substrait::Expression* Expression_SwitchExpression_IfValue::mutable_then() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::substrait::Expression* _msg = _internal_mutable_then();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.SwitchExpression.IfValue.then)
  return _msg;
}
inline void Expression_SwitchExpression_IfValue::set_allocated_then(::substrait::Expression* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.then_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.then_ = reinterpret_cast<::substrait::Expression*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.SwitchExpression.IfValue.then)
}

// -------------------------------------------------------------------

// Expression_SwitchExpression

// .substrait.Expression match = 3;
inline bool Expression_SwitchExpression::has_match() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.match_ != nullptr);
  return value;
}
inline void Expression_SwitchExpression::clear_match() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.match_ != nullptr) _impl_.match_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::substrait::Expression& Expression_SwitchExpression::_internal_match() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Expression* p = _impl_.match_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression&>(::substrait::_Expression_default_instance_);
}
inline const ::substrait::Expression& Expression_SwitchExpression::match() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.SwitchExpression.match)
  return _internal_match();
}
inline void Expression_SwitchExpression::unsafe_arena_set_allocated_match(::substrait::Expression* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.match_);
  }
  _impl_.match_ = reinterpret_cast<::substrait::Expression*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.SwitchExpression.match)
}
inline ::substrait::Expression* Expression_SwitchExpression::release_match() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Expression* released = _impl_.match_;
  _impl_.match_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Expression* Expression_SwitchExpression::unsafe_arena_release_match() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.Expression.SwitchExpression.match)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Expression* temp = _impl_.match_;
  _impl_.match_ = nullptr;
  return temp;
}
inline ::substrait::Expression* Expression_SwitchExpression::_internal_mutable_match() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.match_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Expression>(GetArena());
    _impl_.match_ = reinterpret_cast<::substrait::Expression*>(p);
  }
  return _impl_.match_;
}
inline ::substrait::Expression* Expression_SwitchExpression::mutable_match() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::substrait::Expression* _msg = _internal_mutable_match();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.SwitchExpression.match)
  return _msg;
}
inline void Expression_SwitchExpression::set_allocated_match(::substrait::Expression* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.match_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.match_ = reinterpret_cast<::substrait::Expression*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.SwitchExpression.match)
}

// repeated .substrait.Expression.SwitchExpression.IfValue ifs = 1;
inline int Expression_SwitchExpression::_internal_ifs_size() const {
  return _internal_ifs().size();
}
inline int Expression_SwitchExpression::ifs_size() const {
  return _internal_ifs_size();
}
inline void Expression_SwitchExpression::clear_ifs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ifs_.Clear();
}
inline ::substrait::Expression_SwitchExpression_IfValue* Expression_SwitchExpression::mutable_ifs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.SwitchExpression.ifs)
  return _internal_mutable_ifs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression_SwitchExpression_IfValue>* Expression_SwitchExpression::mutable_ifs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.SwitchExpression.ifs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_ifs();
}
inline const ::substrait::Expression_SwitchExpression_IfValue& Expression_SwitchExpression::ifs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.SwitchExpression.ifs)
  return _internal_ifs().Get(index);
}
inline ::substrait::Expression_SwitchExpression_IfValue* Expression_SwitchExpression::add_ifs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::Expression_SwitchExpression_IfValue* _add = _internal_mutable_ifs()->Add();
  // @@protoc_insertion_point(field_add:substrait.Expression.SwitchExpression.ifs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression_SwitchExpression_IfValue>& Expression_SwitchExpression::ifs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.Expression.SwitchExpression.ifs)
  return _internal_ifs();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression_SwitchExpression_IfValue>&
Expression_SwitchExpression::_internal_ifs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ifs_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression_SwitchExpression_IfValue>*
Expression_SwitchExpression::_internal_mutable_ifs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.ifs_;
}

// .substrait.Expression else = 2;
inline bool Expression_SwitchExpression::has_else_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.else__ != nullptr);
  return value;
}
inline void Expression_SwitchExpression::clear_else_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.else__ != nullptr) _impl_.else__->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::Expression& Expression_SwitchExpression::_internal_else_() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Expression* p = _impl_.else__;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression&>(::substrait::_Expression_default_instance_);
}
inline const ::substrait::Expression& Expression_SwitchExpression::else_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.SwitchExpression.else)
  return _internal_else_();
}
inline void Expression_SwitchExpression::unsafe_arena_set_allocated_else_(::substrait::Expression* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.else__);
  }
  _impl_.else__ = reinterpret_cast<::substrait::Expression*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.SwitchExpression.else)
}
inline ::substrait::Expression* Expression_SwitchExpression::release_else_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Expression* released = _impl_.else__;
  _impl_.else__ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Expression* Expression_SwitchExpression::unsafe_arena_release_else_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.Expression.SwitchExpression.else)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Expression* temp = _impl_.else__;
  _impl_.else__ = nullptr;
  return temp;
}
inline ::substrait::Expression* Expression_SwitchExpression::_internal_mutable_else_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.else__ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Expression>(GetArena());
    _impl_.else__ = reinterpret_cast<::substrait::Expression*>(p);
  }
  return _impl_.else__;
}
inline ::substrait::Expression* Expression_SwitchExpression::mutable_else_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::Expression* _msg = _internal_mutable_else_();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.SwitchExpression.else)
  return _msg;
}
inline void Expression_SwitchExpression::set_allocated_else_(::substrait::Expression* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.else__);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.else__ = reinterpret_cast<::substrait::Expression*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.SwitchExpression.else)
}

// -------------------------------------------------------------------

// Expression_SingularOrList

// .substrait.Expression value = 1;
inline bool Expression_SingularOrList::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.value_ != nullptr);
  return value;
}
inline void Expression_SingularOrList::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.value_ != nullptr) _impl_.value_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::Expression& Expression_SingularOrList::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Expression* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression&>(::substrait::_Expression_default_instance_);
}
inline const ::substrait::Expression& Expression_SingularOrList::value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.SingularOrList.value)
  return _internal_value();
}
inline void Expression_SingularOrList::unsafe_arena_set_allocated_value(::substrait::Expression* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = reinterpret_cast<::substrait::Expression*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.SingularOrList.value)
}
inline ::substrait::Expression* Expression_SingularOrList::release_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Expression* released = _impl_.value_;
  _impl_.value_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Expression* Expression_SingularOrList::unsafe_arena_release_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.Expression.SingularOrList.value)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Expression* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::substrait::Expression* Expression_SingularOrList::_internal_mutable_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.value_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Expression>(GetArena());
    _impl_.value_ = reinterpret_cast<::substrait::Expression*>(p);
  }
  return _impl_.value_;
}
inline ::substrait::Expression* Expression_SingularOrList::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::Expression* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.SingularOrList.value)
  return _msg;
}
inline void Expression_SingularOrList::set_allocated_value(::substrait::Expression* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.value_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.value_ = reinterpret_cast<::substrait::Expression*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.SingularOrList.value)
}

// repeated .substrait.Expression options = 2;
inline int Expression_SingularOrList::_internal_options_size() const {
  return _internal_options().size();
}
inline int Expression_SingularOrList::options_size() const {
  return _internal_options_size();
}
inline void Expression_SingularOrList::clear_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.options_.Clear();
}
inline ::substrait::Expression* Expression_SingularOrList::mutable_options(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.SingularOrList.options)
  return _internal_mutable_options()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression>* Expression_SingularOrList::mutable_options()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.SingularOrList.options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_options();
}
inline const ::substrait::Expression& Expression_SingularOrList::options(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.SingularOrList.options)
  return _internal_options().Get(index);
}
inline ::substrait::Expression* Expression_SingularOrList::add_options() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::Expression* _add = _internal_mutable_options()->Add();
  // @@protoc_insertion_point(field_add:substrait.Expression.SingularOrList.options)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression>& Expression_SingularOrList::options() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.Expression.SingularOrList.options)
  return _internal_options();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression>&
Expression_SingularOrList::_internal_options() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.options_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression>*
Expression_SingularOrList::_internal_mutable_options() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.options_;
}

// -------------------------------------------------------------------

// Expression_MultiOrList_Record

// repeated .substrait.Expression fields = 1;
inline int Expression_MultiOrList_Record::_internal_fields_size() const {
  return _internal_fields().size();
}
inline int Expression_MultiOrList_Record::fields_size() const {
  return _internal_fields_size();
}
inline void Expression_MultiOrList_Record::clear_fields() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fields_.Clear();
}
inline ::substrait::Expression* Expression_MultiOrList_Record::mutable_fields(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MultiOrList.Record.fields)
  return _internal_mutable_fields()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression>* Expression_MultiOrList_Record::mutable_fields()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.MultiOrList.Record.fields)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_fields();
}
inline const ::substrait::Expression& Expression_MultiOrList_Record::fields(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.MultiOrList.Record.fields)
  return _internal_fields().Get(index);
}
inline ::substrait::Expression* Expression_MultiOrList_Record::add_fields() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::Expression* _add = _internal_mutable_fields()->Add();
  // @@protoc_insertion_point(field_add:substrait.Expression.MultiOrList.Record.fields)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression>& Expression_MultiOrList_Record::fields() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.Expression.MultiOrList.Record.fields)
  return _internal_fields();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression>&
Expression_MultiOrList_Record::_internal_fields() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fields_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression>*
Expression_MultiOrList_Record::_internal_mutable_fields() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.fields_;
}

// -------------------------------------------------------------------

// Expression_MultiOrList

// repeated .substrait.Expression value = 1;
inline int Expression_MultiOrList::_internal_value_size() const {
  return _internal_value().size();
}
inline int Expression_MultiOrList::value_size() const {
  return _internal_value_size();
}
inline void Expression_MultiOrList::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.Clear();
}
inline ::substrait::Expression* Expression_MultiOrList::mutable_value(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MultiOrList.value)
  return _internal_mutable_value()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression>* Expression_MultiOrList::mutable_value()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.MultiOrList.value)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_value();
}
inline const ::substrait::Expression& Expression_MultiOrList::value(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.MultiOrList.value)
  return _internal_value().Get(index);
}
inline ::substrait::Expression* Expression_MultiOrList::add_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::Expression* _add = _internal_mutable_value()->Add();
  // @@protoc_insertion_point(field_add:substrait.Expression.MultiOrList.value)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression>& Expression_MultiOrList::value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.Expression.MultiOrList.value)
  return _internal_value();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression>&
Expression_MultiOrList::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression>*
Expression_MultiOrList::_internal_mutable_value() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.value_;
}

// repeated .substrait.Expression.MultiOrList.Record options = 2;
inline int Expression_MultiOrList::_internal_options_size() const {
  return _internal_options().size();
}
inline int Expression_MultiOrList::options_size() const {
  return _internal_options_size();
}
inline void Expression_MultiOrList::clear_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.options_.Clear();
}
inline ::substrait::Expression_MultiOrList_Record* Expression_MultiOrList::mutable_options(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MultiOrList.options)
  return _internal_mutable_options()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression_MultiOrList_Record>* Expression_MultiOrList::mutable_options()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.MultiOrList.options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_options();
}
inline const ::substrait::Expression_MultiOrList_Record& Expression_MultiOrList::options(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.MultiOrList.options)
  return _internal_options().Get(index);
}
inline ::substrait::Expression_MultiOrList_Record* Expression_MultiOrList::add_options() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::Expression_MultiOrList_Record* _add = _internal_mutable_options()->Add();
  // @@protoc_insertion_point(field_add:substrait.Expression.MultiOrList.options)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression_MultiOrList_Record>& Expression_MultiOrList::options() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.Expression.MultiOrList.options)
  return _internal_options();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression_MultiOrList_Record>&
Expression_MultiOrList::_internal_options() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.options_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression_MultiOrList_Record>*
Expression_MultiOrList::_internal_mutable_options() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.options_;
}

// -------------------------------------------------------------------

// Expression_EmbeddedFunction_PythonPickleFunction

// bytes function = 1;
inline void Expression_EmbeddedFunction_PythonPickleFunction::clear_function() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.function_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Expression_EmbeddedFunction_PythonPickleFunction::function() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.EmbeddedFunction.PythonPickleFunction.function)
  return _internal_function();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Expression_EmbeddedFunction_PythonPickleFunction::set_function(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.function_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:substrait.Expression.EmbeddedFunction.PythonPickleFunction.function)
}
inline std::string* Expression_EmbeddedFunction_PythonPickleFunction::mutable_function() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_function();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.EmbeddedFunction.PythonPickleFunction.function)
  return _s;
}
inline const std::string& Expression_EmbeddedFunction_PythonPickleFunction::_internal_function() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.function_.Get();
}
inline void Expression_EmbeddedFunction_PythonPickleFunction::_internal_set_function(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.function_.Set(value, GetArena());
}
inline std::string* Expression_EmbeddedFunction_PythonPickleFunction::_internal_mutable_function() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.function_.Mutable( GetArena());
}
inline std::string* Expression_EmbeddedFunction_PythonPickleFunction::release_function() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.Expression.EmbeddedFunction.PythonPickleFunction.function)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.function_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.function_.Set("", GetArena());
  }
  return released;
}
inline void Expression_EmbeddedFunction_PythonPickleFunction::set_allocated_function(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.function_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.function_.IsDefault()) {
    _impl_.function_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.EmbeddedFunction.PythonPickleFunction.function)
}

// repeated string prerequisite = 2;
inline int Expression_EmbeddedFunction_PythonPickleFunction::_internal_prerequisite_size() const {
  return _internal_prerequisite().size();
}
inline int Expression_EmbeddedFunction_PythonPickleFunction::prerequisite_size() const {
  return _internal_prerequisite_size();
}
inline void Expression_EmbeddedFunction_PythonPickleFunction::clear_prerequisite() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prerequisite_.Clear();
}
inline std::string* Expression_EmbeddedFunction_PythonPickleFunction::add_prerequisite() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_prerequisite()->Add();
  // @@protoc_insertion_point(field_add_mutable:substrait.Expression.EmbeddedFunction.PythonPickleFunction.prerequisite)
  return _s;
}
inline const std::string& Expression_EmbeddedFunction_PythonPickleFunction::prerequisite(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.EmbeddedFunction.PythonPickleFunction.prerequisite)
  return _internal_prerequisite().Get(index);
}
inline std::string* Expression_EmbeddedFunction_PythonPickleFunction::mutable_prerequisite(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.EmbeddedFunction.PythonPickleFunction.prerequisite)
  return _internal_mutable_prerequisite()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void Expression_EmbeddedFunction_PythonPickleFunction::set_prerequisite(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_prerequisite()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:substrait.Expression.EmbeddedFunction.PythonPickleFunction.prerequisite)
}
template <typename Arg_, typename... Args_>
inline void Expression_EmbeddedFunction_PythonPickleFunction::add_prerequisite(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_prerequisite(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:substrait.Expression.EmbeddedFunction.PythonPickleFunction.prerequisite)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Expression_EmbeddedFunction_PythonPickleFunction::prerequisite() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.Expression.EmbeddedFunction.PythonPickleFunction.prerequisite)
  return _internal_prerequisite();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Expression_EmbeddedFunction_PythonPickleFunction::mutable_prerequisite() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.EmbeddedFunction.PythonPickleFunction.prerequisite)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_prerequisite();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Expression_EmbeddedFunction_PythonPickleFunction::_internal_prerequisite() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.prerequisite_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Expression_EmbeddedFunction_PythonPickleFunction::_internal_mutable_prerequisite() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.prerequisite_;
}

// -------------------------------------------------------------------

// Expression_EmbeddedFunction_WebAssemblyFunction

// bytes script = 1;
inline void Expression_EmbeddedFunction_WebAssemblyFunction::clear_script() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.script_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Expression_EmbeddedFunction_WebAssemblyFunction::script() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.script)
  return _internal_script();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Expression_EmbeddedFunction_WebAssemblyFunction::set_script(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.script_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.script)
}
inline std::string* Expression_EmbeddedFunction_WebAssemblyFunction::mutable_script() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_script();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.script)
  return _s;
}
inline const std::string& Expression_EmbeddedFunction_WebAssemblyFunction::_internal_script() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.script_.Get();
}
inline void Expression_EmbeddedFunction_WebAssemblyFunction::_internal_set_script(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.script_.Set(value, GetArena());
}
inline std::string* Expression_EmbeddedFunction_WebAssemblyFunction::_internal_mutable_script() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.script_.Mutable( GetArena());
}
inline std::string* Expression_EmbeddedFunction_WebAssemblyFunction::release_script() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.script)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.script_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.script_.Set("", GetArena());
  }
  return released;
}
inline void Expression_EmbeddedFunction_WebAssemblyFunction::set_allocated_script(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.script_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.script_.IsDefault()) {
    _impl_.script_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.script)
}

// repeated string prerequisite = 2;
inline int Expression_EmbeddedFunction_WebAssemblyFunction::_internal_prerequisite_size() const {
  return _internal_prerequisite().size();
}
inline int Expression_EmbeddedFunction_WebAssemblyFunction::prerequisite_size() const {
  return _internal_prerequisite_size();
}
inline void Expression_EmbeddedFunction_WebAssemblyFunction::clear_prerequisite() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prerequisite_.Clear();
}
inline std::string* Expression_EmbeddedFunction_WebAssemblyFunction::add_prerequisite() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_prerequisite()->Add();
  // @@protoc_insertion_point(field_add_mutable:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.prerequisite)
  return _s;
}
inline const std::string& Expression_EmbeddedFunction_WebAssemblyFunction::prerequisite(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.prerequisite)
  return _internal_prerequisite().Get(index);
}
inline std::string* Expression_EmbeddedFunction_WebAssemblyFunction::mutable_prerequisite(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.prerequisite)
  return _internal_mutable_prerequisite()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void Expression_EmbeddedFunction_WebAssemblyFunction::set_prerequisite(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_prerequisite()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.prerequisite)
}
template <typename Arg_, typename... Args_>
inline void Expression_EmbeddedFunction_WebAssemblyFunction::add_prerequisite(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_prerequisite(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.prerequisite)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Expression_EmbeddedFunction_WebAssemblyFunction::prerequisite() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.prerequisite)
  return _internal_prerequisite();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Expression_EmbeddedFunction_WebAssemblyFunction::mutable_prerequisite() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.prerequisite)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_prerequisite();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Expression_EmbeddedFunction_WebAssemblyFunction::_internal_prerequisite() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.prerequisite_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Expression_EmbeddedFunction_WebAssemblyFunction::_internal_mutable_prerequisite() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.prerequisite_;
}

// -------------------------------------------------------------------

// Expression_EmbeddedFunction

// repeated .substrait.Expression arguments = 1;
inline int Expression_EmbeddedFunction::_internal_arguments_size() const {
  return _internal_arguments().size();
}
inline int Expression_EmbeddedFunction::arguments_size() const {
  return _internal_arguments_size();
}
inline void Expression_EmbeddedFunction::clear_arguments() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.arguments_.Clear();
}
inline ::substrait::Expression* Expression_EmbeddedFunction::mutable_arguments(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.EmbeddedFunction.arguments)
  return _internal_mutable_arguments()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression>* Expression_EmbeddedFunction::mutable_arguments()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.EmbeddedFunction.arguments)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_arguments();
}
inline const ::substrait::Expression& Expression_EmbeddedFunction::arguments(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.EmbeddedFunction.arguments)
  return _internal_arguments().Get(index);
}
inline ::substrait::Expression* Expression_EmbeddedFunction::add_arguments() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::Expression* _add = _internal_mutable_arguments()->Add();
  // @@protoc_insertion_point(field_add:substrait.Expression.EmbeddedFunction.arguments)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression>& Expression_EmbeddedFunction::arguments() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.Expression.EmbeddedFunction.arguments)
  return _internal_arguments();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression>&
Expression_EmbeddedFunction::_internal_arguments() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.arguments_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression>*
Expression_EmbeddedFunction::_internal_mutable_arguments() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.arguments_;
}

// .substrait.Type output_type = 2;
inline bool Expression_EmbeddedFunction::has_output_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.output_type_ != nullptr);
  return value;
}
inline const ::substrait::Type& Expression_EmbeddedFunction::_internal_output_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Type* p = _impl_.output_type_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Type&>(::substrait::_Type_default_instance_);
}
inline const ::substrait::Type& Expression_EmbeddedFunction::output_type() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.EmbeddedFunction.output_type)
  return _internal_output_type();
}
inline void Expression_EmbeddedFunction::unsafe_arena_set_allocated_output_type(::substrait::Type* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.output_type_);
  }
  _impl_.output_type_ = reinterpret_cast<::substrait::Type*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.EmbeddedFunction.output_type)
}
inline ::substrait::Type* Expression_EmbeddedFunction::release_output_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Type* released = _impl_.output_type_;
  _impl_.output_type_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Type* Expression_EmbeddedFunction::unsafe_arena_release_output_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.Expression.EmbeddedFunction.output_type)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Type* temp = _impl_.output_type_;
  _impl_.output_type_ = nullptr;
  return temp;
}
inline ::substrait::Type* Expression_EmbeddedFunction::_internal_mutable_output_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.output_type_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Type>(GetArena());
    _impl_.output_type_ = reinterpret_cast<::substrait::Type*>(p);
  }
  return _impl_.output_type_;
}
inline ::substrait::Type* Expression_EmbeddedFunction::mutable_output_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::Type* _msg = _internal_mutable_output_type();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.EmbeddedFunction.output_type)
  return _msg;
}
inline void Expression_EmbeddedFunction::set_allocated_output_type(::substrait::Type* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.output_type_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.output_type_ = reinterpret_cast<::substrait::Type*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.EmbeddedFunction.output_type)
}

// .substrait.Expression.EmbeddedFunction.PythonPickleFunction python_pickle_function = 3;
inline bool Expression_EmbeddedFunction::has_python_pickle_function() const {
  return kind_case() == kPythonPickleFunction;
}
inline bool Expression_EmbeddedFunction::_internal_has_python_pickle_function() const {
  return kind_case() == kPythonPickleFunction;
}
inline void Expression_EmbeddedFunction::set_has_python_pickle_function() {
  _impl_._oneof_case_[0] = kPythonPickleFunction;
}
inline void Expression_EmbeddedFunction::clear_python_pickle_function() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kPythonPickleFunction) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.python_pickle_function_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.python_pickle_function_);
    }
    clear_has_kind();
  }
}
inline ::substrait::Expression_EmbeddedFunction_PythonPickleFunction* Expression_EmbeddedFunction::release_python_pickle_function() {
  // @@protoc_insertion_point(field_release:substrait.Expression.EmbeddedFunction.python_pickle_function)
  if (kind_case() == kPythonPickleFunction) {
    clear_has_kind();
    auto* temp = _impl_.kind_.python_pickle_function_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.python_pickle_function_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_EmbeddedFunction_PythonPickleFunction& Expression_EmbeddedFunction::_internal_python_pickle_function() const {
  return kind_case() == kPythonPickleFunction ? *_impl_.kind_.python_pickle_function_ : reinterpret_cast<::substrait::Expression_EmbeddedFunction_PythonPickleFunction&>(::substrait::_Expression_EmbeddedFunction_PythonPickleFunction_default_instance_);
}
inline const ::substrait::Expression_EmbeddedFunction_PythonPickleFunction& Expression_EmbeddedFunction::python_pickle_function() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.EmbeddedFunction.python_pickle_function)
  return _internal_python_pickle_function();
}
inline ::substrait::Expression_EmbeddedFunction_PythonPickleFunction* Expression_EmbeddedFunction::unsafe_arena_release_python_pickle_function() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.EmbeddedFunction.python_pickle_function)
  if (kind_case() == kPythonPickleFunction) {
    clear_has_kind();
    auto* temp = _impl_.kind_.python_pickle_function_;
    _impl_.kind_.python_pickle_function_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_EmbeddedFunction::unsafe_arena_set_allocated_python_pickle_function(::substrait::Expression_EmbeddedFunction_PythonPickleFunction* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_python_pickle_function();
    _impl_.kind_.python_pickle_function_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.EmbeddedFunction.python_pickle_function)
}
inline ::substrait::Expression_EmbeddedFunction_PythonPickleFunction* Expression_EmbeddedFunction::_internal_mutable_python_pickle_function() {
  if (kind_case() != kPythonPickleFunction) {
    clear_kind();
    set_has_python_pickle_function();
    _impl_.kind_.python_pickle_function_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_EmbeddedFunction_PythonPickleFunction>(GetArena());
  }
  return _impl_.kind_.python_pickle_function_;
}
inline ::substrait::Expression_EmbeddedFunction_PythonPickleFunction* Expression_EmbeddedFunction::mutable_python_pickle_function() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression_EmbeddedFunction_PythonPickleFunction* _msg = _internal_mutable_python_pickle_function();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.EmbeddedFunction.python_pickle_function)
  return _msg;
}

// .substrait.Expression.EmbeddedFunction.WebAssemblyFunction web_assembly_function = 4;
inline bool Expression_EmbeddedFunction::has_web_assembly_function() const {
  return kind_case() == kWebAssemblyFunction;
}
inline bool Expression_EmbeddedFunction::_internal_has_web_assembly_function() const {
  return kind_case() == kWebAssemblyFunction;
}
inline void Expression_EmbeddedFunction::set_has_web_assembly_function() {
  _impl_._oneof_case_[0] = kWebAssemblyFunction;
}
inline void Expression_EmbeddedFunction::clear_web_assembly_function() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kWebAssemblyFunction) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.web_assembly_function_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.web_assembly_function_);
    }
    clear_has_kind();
  }
}
inline ::substrait::Expression_EmbeddedFunction_WebAssemblyFunction* Expression_EmbeddedFunction::release_web_assembly_function() {
  // @@protoc_insertion_point(field_release:substrait.Expression.EmbeddedFunction.web_assembly_function)
  if (kind_case() == kWebAssemblyFunction) {
    clear_has_kind();
    auto* temp = _impl_.kind_.web_assembly_function_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.web_assembly_function_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_EmbeddedFunction_WebAssemblyFunction& Expression_EmbeddedFunction::_internal_web_assembly_function() const {
  return kind_case() == kWebAssemblyFunction ? *_impl_.kind_.web_assembly_function_ : reinterpret_cast<::substrait::Expression_EmbeddedFunction_WebAssemblyFunction&>(::substrait::_Expression_EmbeddedFunction_WebAssemblyFunction_default_instance_);
}
inline const ::substrait::Expression_EmbeddedFunction_WebAssemblyFunction& Expression_EmbeddedFunction::web_assembly_function() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.EmbeddedFunction.web_assembly_function)
  return _internal_web_assembly_function();
}
inline ::substrait::Expression_EmbeddedFunction_WebAssemblyFunction* Expression_EmbeddedFunction::unsafe_arena_release_web_assembly_function() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.EmbeddedFunction.web_assembly_function)
  if (kind_case() == kWebAssemblyFunction) {
    clear_has_kind();
    auto* temp = _impl_.kind_.web_assembly_function_;
    _impl_.kind_.web_assembly_function_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_EmbeddedFunction::unsafe_arena_set_allocated_web_assembly_function(::substrait::Expression_EmbeddedFunction_WebAssemblyFunction* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_web_assembly_function();
    _impl_.kind_.web_assembly_function_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.EmbeddedFunction.web_assembly_function)
}
inline ::substrait::Expression_EmbeddedFunction_WebAssemblyFunction* Expression_EmbeddedFunction::_internal_mutable_web_assembly_function() {
  if (kind_case() != kWebAssemblyFunction) {
    clear_kind();
    set_has_web_assembly_function();
    _impl_.kind_.web_assembly_function_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_EmbeddedFunction_WebAssemblyFunction>(GetArena());
  }
  return _impl_.kind_.web_assembly_function_;
}
inline ::substrait::Expression_EmbeddedFunction_WebAssemblyFunction* Expression_EmbeddedFunction::mutable_web_assembly_function() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression_EmbeddedFunction_WebAssemblyFunction* _msg = _internal_mutable_web_assembly_function();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.EmbeddedFunction.web_assembly_function)
  return _msg;
}

inline bool Expression_EmbeddedFunction::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void Expression_EmbeddedFunction::clear_has_kind() {
  _impl_._oneof_case_[0] = KIND_NOT_SET;
}
inline Expression_EmbeddedFunction::KindCase Expression_EmbeddedFunction::kind_case() const {
  return Expression_EmbeddedFunction::KindCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Expression_ReferenceSegment_MapKey

// .substrait.Expression.Literal map_key = 1;
inline bool Expression_ReferenceSegment_MapKey::has_map_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.map_key_ != nullptr);
  return value;
}
inline void Expression_ReferenceSegment_MapKey::clear_map_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.map_key_ != nullptr) _impl_.map_key_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::Expression_Literal& Expression_ReferenceSegment_MapKey::_internal_map_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Expression_Literal* p = _impl_.map_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression_Literal&>(::substrait::_Expression_Literal_default_instance_);
}
inline const ::substrait::Expression_Literal& Expression_ReferenceSegment_MapKey::map_key() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.ReferenceSegment.MapKey.map_key)
  return _internal_map_key();
}
inline void Expression_ReferenceSegment_MapKey::unsafe_arena_set_allocated_map_key(::substrait::Expression_Literal* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.map_key_);
  }
  _impl_.map_key_ = reinterpret_cast<::substrait::Expression_Literal*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.ReferenceSegment.MapKey.map_key)
}
inline ::substrait::Expression_Literal* Expression_ReferenceSegment_MapKey::release_map_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Expression_Literal* released = _impl_.map_key_;
  _impl_.map_key_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Expression_Literal* Expression_ReferenceSegment_MapKey::unsafe_arena_release_map_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.Expression.ReferenceSegment.MapKey.map_key)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Expression_Literal* temp = _impl_.map_key_;
  _impl_.map_key_ = nullptr;
  return temp;
}
inline ::substrait::Expression_Literal* Expression_ReferenceSegment_MapKey::_internal_mutable_map_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.map_key_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_Literal>(GetArena());
    _impl_.map_key_ = reinterpret_cast<::substrait::Expression_Literal*>(p);
  }
  return _impl_.map_key_;
}
inline ::substrait::Expression_Literal* Expression_ReferenceSegment_MapKey::mutable_map_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::Expression_Literal* _msg = _internal_mutable_map_key();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.ReferenceSegment.MapKey.map_key)
  return _msg;
}
inline void Expression_ReferenceSegment_MapKey::set_allocated_map_key(::substrait::Expression_Literal* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.map_key_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.map_key_ = reinterpret_cast<::substrait::Expression_Literal*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.ReferenceSegment.MapKey.map_key)
}

// .substrait.Expression.ReferenceSegment child = 2;
inline bool Expression_ReferenceSegment_MapKey::has_child() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.child_ != nullptr);
  return value;
}
inline void Expression_ReferenceSegment_MapKey::clear_child() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.child_ != nullptr) _impl_.child_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::substrait::Expression_ReferenceSegment& Expression_ReferenceSegment_MapKey::_internal_child() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Expression_ReferenceSegment* p = _impl_.child_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression_ReferenceSegment&>(::substrait::_Expression_ReferenceSegment_default_instance_);
}
inline const ::substrait::Expression_ReferenceSegment& Expression_ReferenceSegment_MapKey::child() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.ReferenceSegment.MapKey.child)
  return _internal_child();
}
inline void Expression_ReferenceSegment_MapKey::unsafe_arena_set_allocated_child(::substrait::Expression_ReferenceSegment* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.child_);
  }
  _impl_.child_ = reinterpret_cast<::substrait::Expression_ReferenceSegment*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.ReferenceSegment.MapKey.child)
}
inline ::substrait::Expression_ReferenceSegment* Expression_ReferenceSegment_MapKey::release_child() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Expression_ReferenceSegment* released = _impl_.child_;
  _impl_.child_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Expression_ReferenceSegment* Expression_ReferenceSegment_MapKey::unsafe_arena_release_child() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.Expression.ReferenceSegment.MapKey.child)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Expression_ReferenceSegment* temp = _impl_.child_;
  _impl_.child_ = nullptr;
  return temp;
}
inline ::substrait::Expression_ReferenceSegment* Expression_ReferenceSegment_MapKey::_internal_mutable_child() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.child_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_ReferenceSegment>(GetArena());
    _impl_.child_ = reinterpret_cast<::substrait::Expression_ReferenceSegment*>(p);
  }
  return _impl_.child_;
}
inline ::substrait::Expression_ReferenceSegment* Expression_ReferenceSegment_MapKey::mutable_child() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::substrait::Expression_ReferenceSegment* _msg = _internal_mutable_child();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.ReferenceSegment.MapKey.child)
  return _msg;
}
inline void Expression_ReferenceSegment_MapKey::set_allocated_child(::substrait::Expression_ReferenceSegment* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.child_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.child_ = reinterpret_cast<::substrait::Expression_ReferenceSegment*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.ReferenceSegment.MapKey.child)
}

// -------------------------------------------------------------------

// Expression_ReferenceSegment_StructField

// int32 field = 1;
inline void Expression_ReferenceSegment_StructField::clear_field() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.field_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t Expression_ReferenceSegment_StructField::field() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.ReferenceSegment.StructField.field)
  return _internal_field();
}
inline void Expression_ReferenceSegment_StructField::set_field(::int32_t value) {
  _internal_set_field(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:substrait.Expression.ReferenceSegment.StructField.field)
}
inline ::int32_t Expression_ReferenceSegment_StructField::_internal_field() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.field_;
}
inline void Expression_ReferenceSegment_StructField::_internal_set_field(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.field_ = value;
}

// .substrait.Expression.ReferenceSegment child = 2;
inline bool Expression_ReferenceSegment_StructField::has_child() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.child_ != nullptr);
  return value;
}
inline void Expression_ReferenceSegment_StructField::clear_child() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.child_ != nullptr) _impl_.child_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::Expression_ReferenceSegment& Expression_ReferenceSegment_StructField::_internal_child() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Expression_ReferenceSegment* p = _impl_.child_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression_ReferenceSegment&>(::substrait::_Expression_ReferenceSegment_default_instance_);
}
inline const ::substrait::Expression_ReferenceSegment& Expression_ReferenceSegment_StructField::child() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.ReferenceSegment.StructField.child)
  return _internal_child();
}
inline void Expression_ReferenceSegment_StructField::unsafe_arena_set_allocated_child(::substrait::Expression_ReferenceSegment* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.child_);
  }
  _impl_.child_ = reinterpret_cast<::substrait::Expression_ReferenceSegment*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.ReferenceSegment.StructField.child)
}
inline ::substrait::Expression_ReferenceSegment* Expression_ReferenceSegment_StructField::release_child() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Expression_ReferenceSegment* released = _impl_.child_;
  _impl_.child_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Expression_ReferenceSegment* Expression_ReferenceSegment_StructField::unsafe_arena_release_child() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.Expression.ReferenceSegment.StructField.child)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Expression_ReferenceSegment* temp = _impl_.child_;
  _impl_.child_ = nullptr;
  return temp;
}
inline ::substrait::Expression_ReferenceSegment* Expression_ReferenceSegment_StructField::_internal_mutable_child() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.child_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_ReferenceSegment>(GetArena());
    _impl_.child_ = reinterpret_cast<::substrait::Expression_ReferenceSegment*>(p);
  }
  return _impl_.child_;
}
inline ::substrait::Expression_ReferenceSegment* Expression_ReferenceSegment_StructField::mutable_child() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::Expression_ReferenceSegment* _msg = _internal_mutable_child();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.ReferenceSegment.StructField.child)
  return _msg;
}
inline void Expression_ReferenceSegment_StructField::set_allocated_child(::substrait::Expression_ReferenceSegment* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.child_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.child_ = reinterpret_cast<::substrait::Expression_ReferenceSegment*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.ReferenceSegment.StructField.child)
}

// -------------------------------------------------------------------

// Expression_ReferenceSegment_ListElement

// int32 offset = 1;
inline void Expression_ReferenceSegment_ListElement::clear_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.offset_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t Expression_ReferenceSegment_ListElement::offset() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.ReferenceSegment.ListElement.offset)
  return _internal_offset();
}
inline void Expression_ReferenceSegment_ListElement::set_offset(::int32_t value) {
  _internal_set_offset(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:substrait.Expression.ReferenceSegment.ListElement.offset)
}
inline ::int32_t Expression_ReferenceSegment_ListElement::_internal_offset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.offset_;
}
inline void Expression_ReferenceSegment_ListElement::_internal_set_offset(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.offset_ = value;
}

// .substrait.Expression.ReferenceSegment child = 2;
inline bool Expression_ReferenceSegment_ListElement::has_child() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.child_ != nullptr);
  return value;
}
inline void Expression_ReferenceSegment_ListElement::clear_child() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.child_ != nullptr) _impl_.child_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::Expression_ReferenceSegment& Expression_ReferenceSegment_ListElement::_internal_child() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Expression_ReferenceSegment* p = _impl_.child_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression_ReferenceSegment&>(::substrait::_Expression_ReferenceSegment_default_instance_);
}
inline const ::substrait::Expression_ReferenceSegment& Expression_ReferenceSegment_ListElement::child() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.ReferenceSegment.ListElement.child)
  return _internal_child();
}
inline void Expression_ReferenceSegment_ListElement::unsafe_arena_set_allocated_child(::substrait::Expression_ReferenceSegment* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.child_);
  }
  _impl_.child_ = reinterpret_cast<::substrait::Expression_ReferenceSegment*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.ReferenceSegment.ListElement.child)
}
inline ::substrait::Expression_ReferenceSegment* Expression_ReferenceSegment_ListElement::release_child() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Expression_ReferenceSegment* released = _impl_.child_;
  _impl_.child_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Expression_ReferenceSegment* Expression_ReferenceSegment_ListElement::unsafe_arena_release_child() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.Expression.ReferenceSegment.ListElement.child)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Expression_ReferenceSegment* temp = _impl_.child_;
  _impl_.child_ = nullptr;
  return temp;
}
inline ::substrait::Expression_ReferenceSegment* Expression_ReferenceSegment_ListElement::_internal_mutable_child() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.child_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_ReferenceSegment>(GetArena());
    _impl_.child_ = reinterpret_cast<::substrait::Expression_ReferenceSegment*>(p);
  }
  return _impl_.child_;
}
inline ::substrait::Expression_ReferenceSegment* Expression_ReferenceSegment_ListElement::mutable_child() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::Expression_ReferenceSegment* _msg = _internal_mutable_child();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.ReferenceSegment.ListElement.child)
  return _msg;
}
inline void Expression_ReferenceSegment_ListElement::set_allocated_child(::substrait::Expression_ReferenceSegment* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.child_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.child_ = reinterpret_cast<::substrait::Expression_ReferenceSegment*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.ReferenceSegment.ListElement.child)
}

// -------------------------------------------------------------------

// Expression_ReferenceSegment

// .substrait.Expression.ReferenceSegment.MapKey map_key = 1;
inline bool Expression_ReferenceSegment::has_map_key() const {
  return reference_type_case() == kMapKey;
}
inline bool Expression_ReferenceSegment::_internal_has_map_key() const {
  return reference_type_case() == kMapKey;
}
inline void Expression_ReferenceSegment::set_has_map_key() {
  _impl_._oneof_case_[0] = kMapKey;
}
inline void Expression_ReferenceSegment::clear_map_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (reference_type_case() == kMapKey) {
    if (GetArena() == nullptr) {
      delete _impl_.reference_type_.map_key_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.reference_type_.map_key_);
    }
    clear_has_reference_type();
  }
}
inline ::substrait::Expression_ReferenceSegment_MapKey* Expression_ReferenceSegment::release_map_key() {
  // @@protoc_insertion_point(field_release:substrait.Expression.ReferenceSegment.map_key)
  if (reference_type_case() == kMapKey) {
    clear_has_reference_type();
    auto* temp = _impl_.reference_type_.map_key_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.reference_type_.map_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_ReferenceSegment_MapKey& Expression_ReferenceSegment::_internal_map_key() const {
  return reference_type_case() == kMapKey ? *_impl_.reference_type_.map_key_ : reinterpret_cast<::substrait::Expression_ReferenceSegment_MapKey&>(::substrait::_Expression_ReferenceSegment_MapKey_default_instance_);
}
inline const ::substrait::Expression_ReferenceSegment_MapKey& Expression_ReferenceSegment::map_key() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.ReferenceSegment.map_key)
  return _internal_map_key();
}
inline ::substrait::Expression_ReferenceSegment_MapKey* Expression_ReferenceSegment::unsafe_arena_release_map_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.ReferenceSegment.map_key)
  if (reference_type_case() == kMapKey) {
    clear_has_reference_type();
    auto* temp = _impl_.reference_type_.map_key_;
    _impl_.reference_type_.map_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_ReferenceSegment::unsafe_arena_set_allocated_map_key(::substrait::Expression_ReferenceSegment_MapKey* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_reference_type();
  if (value) {
    set_has_map_key();
    _impl_.reference_type_.map_key_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.ReferenceSegment.map_key)
}
inline ::substrait::Expression_ReferenceSegment_MapKey* Expression_ReferenceSegment::_internal_mutable_map_key() {
  if (reference_type_case() != kMapKey) {
    clear_reference_type();
    set_has_map_key();
    _impl_.reference_type_.map_key_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_ReferenceSegment_MapKey>(GetArena());
  }
  return _impl_.reference_type_.map_key_;
}
inline ::substrait::Expression_ReferenceSegment_MapKey* Expression_ReferenceSegment::mutable_map_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression_ReferenceSegment_MapKey* _msg = _internal_mutable_map_key();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.ReferenceSegment.map_key)
  return _msg;
}

// .substrait.Expression.ReferenceSegment.StructField struct_field = 2;
inline bool Expression_ReferenceSegment::has_struct_field() const {
  return reference_type_case() == kStructField;
}
inline bool Expression_ReferenceSegment::_internal_has_struct_field() const {
  return reference_type_case() == kStructField;
}
inline void Expression_ReferenceSegment::set_has_struct_field() {
  _impl_._oneof_case_[0] = kStructField;
}
inline void Expression_ReferenceSegment::clear_struct_field() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (reference_type_case() == kStructField) {
    if (GetArena() == nullptr) {
      delete _impl_.reference_type_.struct_field_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.reference_type_.struct_field_);
    }
    clear_has_reference_type();
  }
}
inline ::substrait::Expression_ReferenceSegment_StructField* Expression_ReferenceSegment::release_struct_field() {
  // @@protoc_insertion_point(field_release:substrait.Expression.ReferenceSegment.struct_field)
  if (reference_type_case() == kStructField) {
    clear_has_reference_type();
    auto* temp = _impl_.reference_type_.struct_field_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.reference_type_.struct_field_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_ReferenceSegment_StructField& Expression_ReferenceSegment::_internal_struct_field() const {
  return reference_type_case() == kStructField ? *_impl_.reference_type_.struct_field_ : reinterpret_cast<::substrait::Expression_ReferenceSegment_StructField&>(::substrait::_Expression_ReferenceSegment_StructField_default_instance_);
}
inline const ::substrait::Expression_ReferenceSegment_StructField& Expression_ReferenceSegment::struct_field() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.ReferenceSegment.struct_field)
  return _internal_struct_field();
}
inline ::substrait::Expression_ReferenceSegment_StructField* Expression_ReferenceSegment::unsafe_arena_release_struct_field() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.ReferenceSegment.struct_field)
  if (reference_type_case() == kStructField) {
    clear_has_reference_type();
    auto* temp = _impl_.reference_type_.struct_field_;
    _impl_.reference_type_.struct_field_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_ReferenceSegment::unsafe_arena_set_allocated_struct_field(::substrait::Expression_ReferenceSegment_StructField* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_reference_type();
  if (value) {
    set_has_struct_field();
    _impl_.reference_type_.struct_field_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.ReferenceSegment.struct_field)
}
inline ::substrait::Expression_ReferenceSegment_StructField* Expression_ReferenceSegment::_internal_mutable_struct_field() {
  if (reference_type_case() != kStructField) {
    clear_reference_type();
    set_has_struct_field();
    _impl_.reference_type_.struct_field_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_ReferenceSegment_StructField>(GetArena());
  }
  return _impl_.reference_type_.struct_field_;
}
inline ::substrait::Expression_ReferenceSegment_StructField* Expression_ReferenceSegment::mutable_struct_field() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression_ReferenceSegment_StructField* _msg = _internal_mutable_struct_field();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.ReferenceSegment.struct_field)
  return _msg;
}

// .substrait.Expression.ReferenceSegment.ListElement list_element = 3;
inline bool Expression_ReferenceSegment::has_list_element() const {
  return reference_type_case() == kListElement;
}
inline bool Expression_ReferenceSegment::_internal_has_list_element() const {
  return reference_type_case() == kListElement;
}
inline void Expression_ReferenceSegment::set_has_list_element() {
  _impl_._oneof_case_[0] = kListElement;
}
inline void Expression_ReferenceSegment::clear_list_element() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (reference_type_case() == kListElement) {
    if (GetArena() == nullptr) {
      delete _impl_.reference_type_.list_element_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.reference_type_.list_element_);
    }
    clear_has_reference_type();
  }
}
inline ::substrait::Expression_ReferenceSegment_ListElement* Expression_ReferenceSegment::release_list_element() {
  // @@protoc_insertion_point(field_release:substrait.Expression.ReferenceSegment.list_element)
  if (reference_type_case() == kListElement) {
    clear_has_reference_type();
    auto* temp = _impl_.reference_type_.list_element_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.reference_type_.list_element_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_ReferenceSegment_ListElement& Expression_ReferenceSegment::_internal_list_element() const {
  return reference_type_case() == kListElement ? *_impl_.reference_type_.list_element_ : reinterpret_cast<::substrait::Expression_ReferenceSegment_ListElement&>(::substrait::_Expression_ReferenceSegment_ListElement_default_instance_);
}
inline const ::substrait::Expression_ReferenceSegment_ListElement& Expression_ReferenceSegment::list_element() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.ReferenceSegment.list_element)
  return _internal_list_element();
}
inline ::substrait::Expression_ReferenceSegment_ListElement* Expression_ReferenceSegment::unsafe_arena_release_list_element() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.ReferenceSegment.list_element)
  if (reference_type_case() == kListElement) {
    clear_has_reference_type();
    auto* temp = _impl_.reference_type_.list_element_;
    _impl_.reference_type_.list_element_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_ReferenceSegment::unsafe_arena_set_allocated_list_element(::substrait::Expression_ReferenceSegment_ListElement* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_reference_type();
  if (value) {
    set_has_list_element();
    _impl_.reference_type_.list_element_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.ReferenceSegment.list_element)
}
inline ::substrait::Expression_ReferenceSegment_ListElement* Expression_ReferenceSegment::_internal_mutable_list_element() {
  if (reference_type_case() != kListElement) {
    clear_reference_type();
    set_has_list_element();
    _impl_.reference_type_.list_element_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_ReferenceSegment_ListElement>(GetArena());
  }
  return _impl_.reference_type_.list_element_;
}
inline ::substrait::Expression_ReferenceSegment_ListElement* Expression_ReferenceSegment::mutable_list_element() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression_ReferenceSegment_ListElement* _msg = _internal_mutable_list_element();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.ReferenceSegment.list_element)
  return _msg;
}

inline bool Expression_ReferenceSegment::has_reference_type() const {
  return reference_type_case() != REFERENCE_TYPE_NOT_SET;
}
inline void Expression_ReferenceSegment::clear_has_reference_type() {
  _impl_._oneof_case_[0] = REFERENCE_TYPE_NOT_SET;
}
inline Expression_ReferenceSegment::ReferenceTypeCase Expression_ReferenceSegment::reference_type_case() const {
  return Expression_ReferenceSegment::ReferenceTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Expression_MaskExpression_Select

// .substrait.Expression.MaskExpression.StructSelect struct = 1;
inline bool Expression_MaskExpression_Select::has_struct_() const {
  return type_case() == kStruct;
}
inline bool Expression_MaskExpression_Select::_internal_has_struct_() const {
  return type_case() == kStruct;
}
inline void Expression_MaskExpression_Select::set_has_struct_() {
  _impl_._oneof_case_[0] = kStruct;
}
inline void Expression_MaskExpression_Select::clear_struct_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kStruct) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.struct__;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.struct__);
    }
    clear_has_type();
  }
}
inline ::substrait::Expression_MaskExpression_StructSelect* Expression_MaskExpression_Select::release_struct_() {
  // @@protoc_insertion_point(field_release:substrait.Expression.MaskExpression.Select.struct)
  if (type_case() == kStruct) {
    clear_has_type();
    auto* temp = _impl_.type_.struct__;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.struct__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_MaskExpression_StructSelect& Expression_MaskExpression_Select::_internal_struct_() const {
  return type_case() == kStruct ? *_impl_.type_.struct__ : reinterpret_cast<::substrait::Expression_MaskExpression_StructSelect&>(::substrait::_Expression_MaskExpression_StructSelect_default_instance_);
}
inline const ::substrait::Expression_MaskExpression_StructSelect& Expression_MaskExpression_Select::struct_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.Select.struct)
  return _internal_struct_();
}
inline ::substrait::Expression_MaskExpression_StructSelect* Expression_MaskExpression_Select::unsafe_arena_release_struct_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.MaskExpression.Select.struct)
  if (type_case() == kStruct) {
    clear_has_type();
    auto* temp = _impl_.type_.struct__;
    _impl_.type_.struct__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_MaskExpression_Select::unsafe_arena_set_allocated_struct_(::substrait::Expression_MaskExpression_StructSelect* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_struct_();
    _impl_.type_.struct__ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.MaskExpression.Select.struct)
}
inline ::substrait::Expression_MaskExpression_StructSelect* Expression_MaskExpression_Select::_internal_mutable_struct_() {
  if (type_case() != kStruct) {
    clear_type();
    set_has_struct_();
    _impl_.type_.struct__ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_MaskExpression_StructSelect>(GetArena());
  }
  return _impl_.type_.struct__;
}
inline ::substrait::Expression_MaskExpression_StructSelect* Expression_MaskExpression_Select::mutable_struct_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression_MaskExpression_StructSelect* _msg = _internal_mutable_struct_();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MaskExpression.Select.struct)
  return _msg;
}

// .substrait.Expression.MaskExpression.ListSelect list = 2;
inline bool Expression_MaskExpression_Select::has_list() const {
  return type_case() == kList;
}
inline bool Expression_MaskExpression_Select::_internal_has_list() const {
  return type_case() == kList;
}
inline void Expression_MaskExpression_Select::set_has_list() {
  _impl_._oneof_case_[0] = kList;
}
inline void Expression_MaskExpression_Select::clear_list() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kList) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.list_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.list_);
    }
    clear_has_type();
  }
}
inline ::substrait::Expression_MaskExpression_ListSelect* Expression_MaskExpression_Select::release_list() {
  // @@protoc_insertion_point(field_release:substrait.Expression.MaskExpression.Select.list)
  if (type_case() == kList) {
    clear_has_type();
    auto* temp = _impl_.type_.list_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_MaskExpression_ListSelect& Expression_MaskExpression_Select::_internal_list() const {
  return type_case() == kList ? *_impl_.type_.list_ : reinterpret_cast<::substrait::Expression_MaskExpression_ListSelect&>(::substrait::_Expression_MaskExpression_ListSelect_default_instance_);
}
inline const ::substrait::Expression_MaskExpression_ListSelect& Expression_MaskExpression_Select::list() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.Select.list)
  return _internal_list();
}
inline ::substrait::Expression_MaskExpression_ListSelect* Expression_MaskExpression_Select::unsafe_arena_release_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.MaskExpression.Select.list)
  if (type_case() == kList) {
    clear_has_type();
    auto* temp = _impl_.type_.list_;
    _impl_.type_.list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_MaskExpression_Select::unsafe_arena_set_allocated_list(::substrait::Expression_MaskExpression_ListSelect* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_list();
    _impl_.type_.list_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.MaskExpression.Select.list)
}
inline ::substrait::Expression_MaskExpression_ListSelect* Expression_MaskExpression_Select::_internal_mutable_list() {
  if (type_case() != kList) {
    clear_type();
    set_has_list();
    _impl_.type_.list_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_MaskExpression_ListSelect>(GetArena());
  }
  return _impl_.type_.list_;
}
inline ::substrait::Expression_MaskExpression_ListSelect* Expression_MaskExpression_Select::mutable_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression_MaskExpression_ListSelect* _msg = _internal_mutable_list();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MaskExpression.Select.list)
  return _msg;
}

// .substrait.Expression.MaskExpression.MapSelect map = 3;
inline bool Expression_MaskExpression_Select::has_map() const {
  return type_case() == kMap;
}
inline bool Expression_MaskExpression_Select::_internal_has_map() const {
  return type_case() == kMap;
}
inline void Expression_MaskExpression_Select::set_has_map() {
  _impl_._oneof_case_[0] = kMap;
}
inline void Expression_MaskExpression_Select::clear_map() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kMap) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.map_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.map_);
    }
    clear_has_type();
  }
}
inline ::substrait::Expression_MaskExpression_MapSelect* Expression_MaskExpression_Select::release_map() {
  // @@protoc_insertion_point(field_release:substrait.Expression.MaskExpression.Select.map)
  if (type_case() == kMap) {
    clear_has_type();
    auto* temp = _impl_.type_.map_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_MaskExpression_MapSelect& Expression_MaskExpression_Select::_internal_map() const {
  return type_case() == kMap ? *_impl_.type_.map_ : reinterpret_cast<::substrait::Expression_MaskExpression_MapSelect&>(::substrait::_Expression_MaskExpression_MapSelect_default_instance_);
}
inline const ::substrait::Expression_MaskExpression_MapSelect& Expression_MaskExpression_Select::map() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.Select.map)
  return _internal_map();
}
inline ::substrait::Expression_MaskExpression_MapSelect* Expression_MaskExpression_Select::unsafe_arena_release_map() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.MaskExpression.Select.map)
  if (type_case() == kMap) {
    clear_has_type();
    auto* temp = _impl_.type_.map_;
    _impl_.type_.map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_MaskExpression_Select::unsafe_arena_set_allocated_map(::substrait::Expression_MaskExpression_MapSelect* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_map();
    _impl_.type_.map_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.MaskExpression.Select.map)
}
inline ::substrait::Expression_MaskExpression_MapSelect* Expression_MaskExpression_Select::_internal_mutable_map() {
  if (type_case() != kMap) {
    clear_type();
    set_has_map();
    _impl_.type_.map_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_MaskExpression_MapSelect>(GetArena());
  }
  return _impl_.type_.map_;
}
inline ::substrait::Expression_MaskExpression_MapSelect* Expression_MaskExpression_Select::mutable_map() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression_MaskExpression_MapSelect* _msg = _internal_mutable_map();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MaskExpression.Select.map)
  return _msg;
}

inline bool Expression_MaskExpression_Select::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Expression_MaskExpression_Select::clear_has_type() {
  _impl_._oneof_case_[0] = TYPE_NOT_SET;
}
inline Expression_MaskExpression_Select::TypeCase Expression_MaskExpression_Select::type_case() const {
  return Expression_MaskExpression_Select::TypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Expression_MaskExpression_StructSelect

// repeated .substrait.Expression.MaskExpression.StructItem struct_items = 1;
inline int Expression_MaskExpression_StructSelect::_internal_struct_items_size() const {
  return _internal_struct_items().size();
}
inline int Expression_MaskExpression_StructSelect::struct_items_size() const {
  return _internal_struct_items_size();
}
inline void Expression_MaskExpression_StructSelect::clear_struct_items() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.struct_items_.Clear();
}
inline ::substrait::Expression_MaskExpression_StructItem* Expression_MaskExpression_StructSelect::mutable_struct_items(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MaskExpression.StructSelect.struct_items)
  return _internal_mutable_struct_items()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression_MaskExpression_StructItem>* Expression_MaskExpression_StructSelect::mutable_struct_items()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.MaskExpression.StructSelect.struct_items)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_struct_items();
}
inline const ::substrait::Expression_MaskExpression_StructItem& Expression_MaskExpression_StructSelect::struct_items(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.StructSelect.struct_items)
  return _internal_struct_items().Get(index);
}
inline ::substrait::Expression_MaskExpression_StructItem* Expression_MaskExpression_StructSelect::add_struct_items() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::Expression_MaskExpression_StructItem* _add = _internal_mutable_struct_items()->Add();
  // @@protoc_insertion_point(field_add:substrait.Expression.MaskExpression.StructSelect.struct_items)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression_MaskExpression_StructItem>& Expression_MaskExpression_StructSelect::struct_items() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.Expression.MaskExpression.StructSelect.struct_items)
  return _internal_struct_items();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression_MaskExpression_StructItem>&
Expression_MaskExpression_StructSelect::_internal_struct_items() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.struct_items_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression_MaskExpression_StructItem>*
Expression_MaskExpression_StructSelect::_internal_mutable_struct_items() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.struct_items_;
}

// -------------------------------------------------------------------

// Expression_MaskExpression_StructItem

// int32 field = 1;
inline void Expression_MaskExpression_StructItem::clear_field() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.field_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t Expression_MaskExpression_StructItem::field() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.StructItem.field)
  return _internal_field();
}
inline void Expression_MaskExpression_StructItem::set_field(::int32_t value) {
  _internal_set_field(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:substrait.Expression.MaskExpression.StructItem.field)
}
inline ::int32_t Expression_MaskExpression_StructItem::_internal_field() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.field_;
}
inline void Expression_MaskExpression_StructItem::_internal_set_field(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.field_ = value;
}

// .substrait.Expression.MaskExpression.Select child = 2;
inline bool Expression_MaskExpression_StructItem::has_child() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.child_ != nullptr);
  return value;
}
inline void Expression_MaskExpression_StructItem::clear_child() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.child_ != nullptr) _impl_.child_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::Expression_MaskExpression_Select& Expression_MaskExpression_StructItem::_internal_child() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Expression_MaskExpression_Select* p = _impl_.child_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression_MaskExpression_Select&>(::substrait::_Expression_MaskExpression_Select_default_instance_);
}
inline const ::substrait::Expression_MaskExpression_Select& Expression_MaskExpression_StructItem::child() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.StructItem.child)
  return _internal_child();
}
inline void Expression_MaskExpression_StructItem::unsafe_arena_set_allocated_child(::substrait::Expression_MaskExpression_Select* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.child_);
  }
  _impl_.child_ = reinterpret_cast<::substrait::Expression_MaskExpression_Select*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.MaskExpression.StructItem.child)
}
inline ::substrait::Expression_MaskExpression_Select* Expression_MaskExpression_StructItem::release_child() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Expression_MaskExpression_Select* released = _impl_.child_;
  _impl_.child_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Expression_MaskExpression_Select* Expression_MaskExpression_StructItem::unsafe_arena_release_child() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.Expression.MaskExpression.StructItem.child)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Expression_MaskExpression_Select* temp = _impl_.child_;
  _impl_.child_ = nullptr;
  return temp;
}
inline ::substrait::Expression_MaskExpression_Select* Expression_MaskExpression_StructItem::_internal_mutable_child() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.child_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_MaskExpression_Select>(GetArena());
    _impl_.child_ = reinterpret_cast<::substrait::Expression_MaskExpression_Select*>(p);
  }
  return _impl_.child_;
}
inline ::substrait::Expression_MaskExpression_Select* Expression_MaskExpression_StructItem::mutable_child() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::Expression_MaskExpression_Select* _msg = _internal_mutable_child();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MaskExpression.StructItem.child)
  return _msg;
}
inline void Expression_MaskExpression_StructItem::set_allocated_child(::substrait::Expression_MaskExpression_Select* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.child_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.child_ = reinterpret_cast<::substrait::Expression_MaskExpression_Select*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.MaskExpression.StructItem.child)
}

// -------------------------------------------------------------------

// Expression_MaskExpression_ListSelect_ListSelectItem_ListElement

// int32 field = 1;
inline void Expression_MaskExpression_ListSelect_ListSelectItem_ListElement::clear_field() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.field_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t Expression_MaskExpression_ListSelect_ListSelectItem_ListElement::field() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListElement.field)
  return _internal_field();
}
inline void Expression_MaskExpression_ListSelect_ListSelectItem_ListElement::set_field(::int32_t value) {
  _internal_set_field(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListElement.field)
}
inline ::int32_t Expression_MaskExpression_ListSelect_ListSelectItem_ListElement::_internal_field() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.field_;
}
inline void Expression_MaskExpression_ListSelect_ListSelectItem_ListElement::_internal_set_field(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.field_ = value;
}

// -------------------------------------------------------------------

// Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice

// int32 start = 1;
inline void Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice::clear_start() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.start_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice::start() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListSlice.start)
  return _internal_start();
}
inline void Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice::set_start(::int32_t value) {
  _internal_set_start(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListSlice.start)
}
inline ::int32_t Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice::_internal_start() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.start_;
}
inline void Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice::_internal_set_start(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.start_ = value;
}

// int32 end = 2;
inline void Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice::clear_end() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.end_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice::end() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListSlice.end)
  return _internal_end();
}
inline void Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice::set_end(::int32_t value) {
  _internal_set_end(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListSlice.end)
}
inline ::int32_t Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice::_internal_end() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.end_;
}
inline void Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice::_internal_set_end(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.end_ = value;
}

// -------------------------------------------------------------------

// Expression_MaskExpression_ListSelect_ListSelectItem

// .substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListElement item = 1;
inline bool Expression_MaskExpression_ListSelect_ListSelectItem::has_item() const {
  return type_case() == kItem;
}
inline bool Expression_MaskExpression_ListSelect_ListSelectItem::_internal_has_item() const {
  return type_case() == kItem;
}
inline void Expression_MaskExpression_ListSelect_ListSelectItem::set_has_item() {
  _impl_._oneof_case_[0] = kItem;
}
inline void Expression_MaskExpression_ListSelect_ListSelectItem::clear_item() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kItem) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.item_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.item_);
    }
    clear_has_type();
  }
}
inline ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* Expression_MaskExpression_ListSelect_ListSelectItem::release_item() {
  // @@protoc_insertion_point(field_release:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.item)
  if (type_case() == kItem) {
    clear_has_type();
    auto* temp = _impl_.type_.item_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.item_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement& Expression_MaskExpression_ListSelect_ListSelectItem::_internal_item() const {
  return type_case() == kItem ? *_impl_.type_.item_ : reinterpret_cast<::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement&>(::substrait::_Expression_MaskExpression_ListSelect_ListSelectItem_ListElement_default_instance_);
}
inline const ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement& Expression_MaskExpression_ListSelect_ListSelectItem::item() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.item)
  return _internal_item();
}
inline ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* Expression_MaskExpression_ListSelect_ListSelectItem::unsafe_arena_release_item() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.item)
  if (type_case() == kItem) {
    clear_has_type();
    auto* temp = _impl_.type_.item_;
    _impl_.type_.item_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_MaskExpression_ListSelect_ListSelectItem::unsafe_arena_set_allocated_item(::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_item();
    _impl_.type_.item_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.item)
}
inline ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* Expression_MaskExpression_ListSelect_ListSelectItem::_internal_mutable_item() {
  if (type_case() != kItem) {
    clear_type();
    set_has_item();
    _impl_.type_.item_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement>(GetArena());
  }
  return _impl_.type_.item_;
}
inline ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* Expression_MaskExpression_ListSelect_ListSelectItem::mutable_item() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* _msg = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.item)
  return _msg;
}

// .substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListSlice slice = 2;
inline bool Expression_MaskExpression_ListSelect_ListSelectItem::has_slice() const {
  return type_case() == kSlice;
}
inline bool Expression_MaskExpression_ListSelect_ListSelectItem::_internal_has_slice() const {
  return type_case() == kSlice;
}
inline void Expression_MaskExpression_ListSelect_ListSelectItem::set_has_slice() {
  _impl_._oneof_case_[0] = kSlice;
}
inline void Expression_MaskExpression_ListSelect_ListSelectItem::clear_slice() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kSlice) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.slice_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.slice_);
    }
    clear_has_type();
  }
}
inline ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* Expression_MaskExpression_ListSelect_ListSelectItem::release_slice() {
  // @@protoc_insertion_point(field_release:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.slice)
  if (type_case() == kSlice) {
    clear_has_type();
    auto* temp = _impl_.type_.slice_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.slice_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice& Expression_MaskExpression_ListSelect_ListSelectItem::_internal_slice() const {
  return type_case() == kSlice ? *_impl_.type_.slice_ : reinterpret_cast<::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice&>(::substrait::_Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice_default_instance_);
}
inline const ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice& Expression_MaskExpression_ListSelect_ListSelectItem::slice() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.slice)
  return _internal_slice();
}
inline ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* Expression_MaskExpression_ListSelect_ListSelectItem::unsafe_arena_release_slice() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.slice)
  if (type_case() == kSlice) {
    clear_has_type();
    auto* temp = _impl_.type_.slice_;
    _impl_.type_.slice_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_MaskExpression_ListSelect_ListSelectItem::unsafe_arena_set_allocated_slice(::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_slice();
    _impl_.type_.slice_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.slice)
}
inline ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* Expression_MaskExpression_ListSelect_ListSelectItem::_internal_mutable_slice() {
  if (type_case() != kSlice) {
    clear_type();
    set_has_slice();
    _impl_.type_.slice_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice>(GetArena());
  }
  return _impl_.type_.slice_;
}
inline ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* Expression_MaskExpression_ListSelect_ListSelectItem::mutable_slice() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* _msg = _internal_mutable_slice();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.slice)
  return _msg;
}

inline bool Expression_MaskExpression_ListSelect_ListSelectItem::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Expression_MaskExpression_ListSelect_ListSelectItem::clear_has_type() {
  _impl_._oneof_case_[0] = TYPE_NOT_SET;
}
inline Expression_MaskExpression_ListSelect_ListSelectItem::TypeCase Expression_MaskExpression_ListSelect_ListSelectItem::type_case() const {
  return Expression_MaskExpression_ListSelect_ListSelectItem::TypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Expression_MaskExpression_ListSelect

// repeated .substrait.Expression.MaskExpression.ListSelect.ListSelectItem selection = 1;
inline int Expression_MaskExpression_ListSelect::_internal_selection_size() const {
  return _internal_selection().size();
}
inline int Expression_MaskExpression_ListSelect::selection_size() const {
  return _internal_selection_size();
}
inline void Expression_MaskExpression_ListSelect::clear_selection() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.selection_.Clear();
}
inline ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem* Expression_MaskExpression_ListSelect::mutable_selection(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MaskExpression.ListSelect.selection)
  return _internal_mutable_selection()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression_MaskExpression_ListSelect_ListSelectItem>* Expression_MaskExpression_ListSelect::mutable_selection()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.MaskExpression.ListSelect.selection)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_selection();
}
inline const ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem& Expression_MaskExpression_ListSelect::selection(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.ListSelect.selection)
  return _internal_selection().Get(index);
}
inline ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem* Expression_MaskExpression_ListSelect::add_selection() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem* _add = _internal_mutable_selection()->Add();
  // @@protoc_insertion_point(field_add:substrait.Expression.MaskExpression.ListSelect.selection)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression_MaskExpression_ListSelect_ListSelectItem>& Expression_MaskExpression_ListSelect::selection() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.Expression.MaskExpression.ListSelect.selection)
  return _internal_selection();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression_MaskExpression_ListSelect_ListSelectItem>&
Expression_MaskExpression_ListSelect::_internal_selection() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.selection_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression_MaskExpression_ListSelect_ListSelectItem>*
Expression_MaskExpression_ListSelect::_internal_mutable_selection() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.selection_;
}

// .substrait.Expression.MaskExpression.Select child = 2;
inline bool Expression_MaskExpression_ListSelect::has_child() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.child_ != nullptr);
  return value;
}
inline void Expression_MaskExpression_ListSelect::clear_child() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.child_ != nullptr) _impl_.child_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::Expression_MaskExpression_Select& Expression_MaskExpression_ListSelect::_internal_child() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Expression_MaskExpression_Select* p = _impl_.child_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression_MaskExpression_Select&>(::substrait::_Expression_MaskExpression_Select_default_instance_);
}
inline const ::substrait::Expression_MaskExpression_Select& Expression_MaskExpression_ListSelect::child() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.ListSelect.child)
  return _internal_child();
}
inline void Expression_MaskExpression_ListSelect::unsafe_arena_set_allocated_child(::substrait::Expression_MaskExpression_Select* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.child_);
  }
  _impl_.child_ = reinterpret_cast<::substrait::Expression_MaskExpression_Select*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.MaskExpression.ListSelect.child)
}
inline ::substrait::Expression_MaskExpression_Select* Expression_MaskExpression_ListSelect::release_child() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Expression_MaskExpression_Select* released = _impl_.child_;
  _impl_.child_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Expression_MaskExpression_Select* Expression_MaskExpression_ListSelect::unsafe_arena_release_child() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.Expression.MaskExpression.ListSelect.child)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Expression_MaskExpression_Select* temp = _impl_.child_;
  _impl_.child_ = nullptr;
  return temp;
}
inline ::substrait::Expression_MaskExpression_Select* Expression_MaskExpression_ListSelect::_internal_mutable_child() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.child_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_MaskExpression_Select>(GetArena());
    _impl_.child_ = reinterpret_cast<::substrait::Expression_MaskExpression_Select*>(p);
  }
  return _impl_.child_;
}
inline ::substrait::Expression_MaskExpression_Select* Expression_MaskExpression_ListSelect::mutable_child() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::Expression_MaskExpression_Select* _msg = _internal_mutable_child();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MaskExpression.ListSelect.child)
  return _msg;
}
inline void Expression_MaskExpression_ListSelect::set_allocated_child(::substrait::Expression_MaskExpression_Select* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.child_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.child_ = reinterpret_cast<::substrait::Expression_MaskExpression_Select*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.MaskExpression.ListSelect.child)
}

// -------------------------------------------------------------------

// Expression_MaskExpression_MapSelect_MapKey

// string map_key = 1;
inline void Expression_MaskExpression_MapSelect_MapKey::clear_map_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.map_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Expression_MaskExpression_MapSelect_MapKey::map_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.MapSelect.MapKey.map_key)
  return _internal_map_key();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Expression_MaskExpression_MapSelect_MapKey::set_map_key(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.map_key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:substrait.Expression.MaskExpression.MapSelect.MapKey.map_key)
}
inline std::string* Expression_MaskExpression_MapSelect_MapKey::mutable_map_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_map_key();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MaskExpression.MapSelect.MapKey.map_key)
  return _s;
}
inline const std::string& Expression_MaskExpression_MapSelect_MapKey::_internal_map_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.map_key_.Get();
}
inline void Expression_MaskExpression_MapSelect_MapKey::_internal_set_map_key(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.map_key_.Set(value, GetArena());
}
inline std::string* Expression_MaskExpression_MapSelect_MapKey::_internal_mutable_map_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.map_key_.Mutable( GetArena());
}
inline std::string* Expression_MaskExpression_MapSelect_MapKey::release_map_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.Expression.MaskExpression.MapSelect.MapKey.map_key)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.map_key_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.map_key_.Set("", GetArena());
  }
  return released;
}
inline void Expression_MaskExpression_MapSelect_MapKey::set_allocated_map_key(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.map_key_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.map_key_.IsDefault()) {
    _impl_.map_key_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.MaskExpression.MapSelect.MapKey.map_key)
}

// -------------------------------------------------------------------

// Expression_MaskExpression_MapSelect_MapKeyExpression

// string map_key_expression = 1;
inline void Expression_MaskExpression_MapSelect_MapKeyExpression::clear_map_key_expression() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.map_key_expression_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Expression_MaskExpression_MapSelect_MapKeyExpression::map_key_expression() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.MapSelect.MapKeyExpression.map_key_expression)
  return _internal_map_key_expression();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Expression_MaskExpression_MapSelect_MapKeyExpression::set_map_key_expression(Arg_&& arg,
                                              Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.map_key_expression_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:substrait.Expression.MaskExpression.MapSelect.MapKeyExpression.map_key_expression)
}
inline std::string* Expression_MaskExpression_MapSelect_MapKeyExpression::mutable_map_key_expression() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_map_key_expression();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MaskExpression.MapSelect.MapKeyExpression.map_key_expression)
  return _s;
}
inline const std::string& Expression_MaskExpression_MapSelect_MapKeyExpression::_internal_map_key_expression() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.map_key_expression_.Get();
}
inline void Expression_MaskExpression_MapSelect_MapKeyExpression::_internal_set_map_key_expression(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.map_key_expression_.Set(value, GetArena());
}
inline std::string* Expression_MaskExpression_MapSelect_MapKeyExpression::_internal_mutable_map_key_expression() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.map_key_expression_.Mutable( GetArena());
}
inline std::string* Expression_MaskExpression_MapSelect_MapKeyExpression::release_map_key_expression() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.Expression.MaskExpression.MapSelect.MapKeyExpression.map_key_expression)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.map_key_expression_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.map_key_expression_.Set("", GetArena());
  }
  return released;
}
inline void Expression_MaskExpression_MapSelect_MapKeyExpression::set_allocated_map_key_expression(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.map_key_expression_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.map_key_expression_.IsDefault()) {
    _impl_.map_key_expression_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.MaskExpression.MapSelect.MapKeyExpression.map_key_expression)
}

// -------------------------------------------------------------------

// Expression_MaskExpression_MapSelect

// .substrait.Expression.MaskExpression.MapSelect.MapKey key = 1;
inline bool Expression_MaskExpression_MapSelect::has_key() const {
  return select_case() == kKey;
}
inline bool Expression_MaskExpression_MapSelect::_internal_has_key() const {
  return select_case() == kKey;
}
inline void Expression_MaskExpression_MapSelect::set_has_key() {
  _impl_._oneof_case_[0] = kKey;
}
inline void Expression_MaskExpression_MapSelect::clear_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (select_case() == kKey) {
    if (GetArena() == nullptr) {
      delete _impl_.select_.key_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.select_.key_);
    }
    clear_has_select();
  }
}
inline ::substrait::Expression_MaskExpression_MapSelect_MapKey* Expression_MaskExpression_MapSelect::release_key() {
  // @@protoc_insertion_point(field_release:substrait.Expression.MaskExpression.MapSelect.key)
  if (select_case() == kKey) {
    clear_has_select();
    auto* temp = _impl_.select_.key_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.select_.key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_MaskExpression_MapSelect_MapKey& Expression_MaskExpression_MapSelect::_internal_key() const {
  return select_case() == kKey ? *_impl_.select_.key_ : reinterpret_cast<::substrait::Expression_MaskExpression_MapSelect_MapKey&>(::substrait::_Expression_MaskExpression_MapSelect_MapKey_default_instance_);
}
inline const ::substrait::Expression_MaskExpression_MapSelect_MapKey& Expression_MaskExpression_MapSelect::key() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.MapSelect.key)
  return _internal_key();
}
inline ::substrait::Expression_MaskExpression_MapSelect_MapKey* Expression_MaskExpression_MapSelect::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.MaskExpression.MapSelect.key)
  if (select_case() == kKey) {
    clear_has_select();
    auto* temp = _impl_.select_.key_;
    _impl_.select_.key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_MaskExpression_MapSelect::unsafe_arena_set_allocated_key(::substrait::Expression_MaskExpression_MapSelect_MapKey* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_select();
  if (value) {
    set_has_key();
    _impl_.select_.key_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.MaskExpression.MapSelect.key)
}
inline ::substrait::Expression_MaskExpression_MapSelect_MapKey* Expression_MaskExpression_MapSelect::_internal_mutable_key() {
  if (select_case() != kKey) {
    clear_select();
    set_has_key();
    _impl_.select_.key_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_MaskExpression_MapSelect_MapKey>(GetArena());
  }
  return _impl_.select_.key_;
}
inline ::substrait::Expression_MaskExpression_MapSelect_MapKey* Expression_MaskExpression_MapSelect::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression_MaskExpression_MapSelect_MapKey* _msg = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MaskExpression.MapSelect.key)
  return _msg;
}

// .substrait.Expression.MaskExpression.MapSelect.MapKeyExpression expression = 2;
inline bool Expression_MaskExpression_MapSelect::has_expression() const {
  return select_case() == kExpression;
}
inline bool Expression_MaskExpression_MapSelect::_internal_has_expression() const {
  return select_case() == kExpression;
}
inline void Expression_MaskExpression_MapSelect::set_has_expression() {
  _impl_._oneof_case_[0] = kExpression;
}
inline void Expression_MaskExpression_MapSelect::clear_expression() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (select_case() == kExpression) {
    if (GetArena() == nullptr) {
      delete _impl_.select_.expression_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.select_.expression_);
    }
    clear_has_select();
  }
}
inline ::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression* Expression_MaskExpression_MapSelect::release_expression() {
  // @@protoc_insertion_point(field_release:substrait.Expression.MaskExpression.MapSelect.expression)
  if (select_case() == kExpression) {
    clear_has_select();
    auto* temp = _impl_.select_.expression_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.select_.expression_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression& Expression_MaskExpression_MapSelect::_internal_expression() const {
  return select_case() == kExpression ? *_impl_.select_.expression_ : reinterpret_cast<::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression&>(::substrait::_Expression_MaskExpression_MapSelect_MapKeyExpression_default_instance_);
}
inline const ::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression& Expression_MaskExpression_MapSelect::expression() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.MapSelect.expression)
  return _internal_expression();
}
inline ::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression* Expression_MaskExpression_MapSelect::unsafe_arena_release_expression() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.MaskExpression.MapSelect.expression)
  if (select_case() == kExpression) {
    clear_has_select();
    auto* temp = _impl_.select_.expression_;
    _impl_.select_.expression_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_MaskExpression_MapSelect::unsafe_arena_set_allocated_expression(::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_select();
  if (value) {
    set_has_expression();
    _impl_.select_.expression_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.MaskExpression.MapSelect.expression)
}
inline ::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression* Expression_MaskExpression_MapSelect::_internal_mutable_expression() {
  if (select_case() != kExpression) {
    clear_select();
    set_has_expression();
    _impl_.select_.expression_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression>(GetArena());
  }
  return _impl_.select_.expression_;
}
inline ::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression* Expression_MaskExpression_MapSelect::mutable_expression() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression* _msg = _internal_mutable_expression();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MaskExpression.MapSelect.expression)
  return _msg;
}

// .substrait.Expression.MaskExpression.Select child = 3;
inline bool Expression_MaskExpression_MapSelect::has_child() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.child_ != nullptr);
  return value;
}
inline void Expression_MaskExpression_MapSelect::clear_child() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.child_ != nullptr) _impl_.child_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::Expression_MaskExpression_Select& Expression_MaskExpression_MapSelect::_internal_child() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Expression_MaskExpression_Select* p = _impl_.child_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression_MaskExpression_Select&>(::substrait::_Expression_MaskExpression_Select_default_instance_);
}
inline const ::substrait::Expression_MaskExpression_Select& Expression_MaskExpression_MapSelect::child() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.MapSelect.child)
  return _internal_child();
}
inline void Expression_MaskExpression_MapSelect::unsafe_arena_set_allocated_child(::substrait::Expression_MaskExpression_Select* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.child_);
  }
  _impl_.child_ = reinterpret_cast<::substrait::Expression_MaskExpression_Select*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.MaskExpression.MapSelect.child)
}
inline ::substrait::Expression_MaskExpression_Select* Expression_MaskExpression_MapSelect::release_child() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Expression_MaskExpression_Select* released = _impl_.child_;
  _impl_.child_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Expression_MaskExpression_Select* Expression_MaskExpression_MapSelect::unsafe_arena_release_child() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.Expression.MaskExpression.MapSelect.child)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Expression_MaskExpression_Select* temp = _impl_.child_;
  _impl_.child_ = nullptr;
  return temp;
}
inline ::substrait::Expression_MaskExpression_Select* Expression_MaskExpression_MapSelect::_internal_mutable_child() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.child_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_MaskExpression_Select>(GetArena());
    _impl_.child_ = reinterpret_cast<::substrait::Expression_MaskExpression_Select*>(p);
  }
  return _impl_.child_;
}
inline ::substrait::Expression_MaskExpression_Select* Expression_MaskExpression_MapSelect::mutable_child() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::Expression_MaskExpression_Select* _msg = _internal_mutable_child();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MaskExpression.MapSelect.child)
  return _msg;
}
inline void Expression_MaskExpression_MapSelect::set_allocated_child(::substrait::Expression_MaskExpression_Select* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.child_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.child_ = reinterpret_cast<::substrait::Expression_MaskExpression_Select*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.MaskExpression.MapSelect.child)
}

inline bool Expression_MaskExpression_MapSelect::has_select() const {
  return select_case() != SELECT_NOT_SET;
}
inline void Expression_MaskExpression_MapSelect::clear_has_select() {
  _impl_._oneof_case_[0] = SELECT_NOT_SET;
}
inline Expression_MaskExpression_MapSelect::SelectCase Expression_MaskExpression_MapSelect::select_case() const {
  return Expression_MaskExpression_MapSelect::SelectCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Expression_MaskExpression

// .substrait.Expression.MaskExpression.StructSelect select = 1;
inline bool Expression_MaskExpression::has_select() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.select_ != nullptr);
  return value;
}
inline void Expression_MaskExpression::clear_select() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.select_ != nullptr) _impl_.select_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::Expression_MaskExpression_StructSelect& Expression_MaskExpression::_internal_select() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Expression_MaskExpression_StructSelect* p = _impl_.select_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression_MaskExpression_StructSelect&>(::substrait::_Expression_MaskExpression_StructSelect_default_instance_);
}
inline const ::substrait::Expression_MaskExpression_StructSelect& Expression_MaskExpression::select() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.select)
  return _internal_select();
}
inline void Expression_MaskExpression::unsafe_arena_set_allocated_select(::substrait::Expression_MaskExpression_StructSelect* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.select_);
  }
  _impl_.select_ = reinterpret_cast<::substrait::Expression_MaskExpression_StructSelect*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.MaskExpression.select)
}
inline ::substrait::Expression_MaskExpression_StructSelect* Expression_MaskExpression::release_select() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Expression_MaskExpression_StructSelect* released = _impl_.select_;
  _impl_.select_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Expression_MaskExpression_StructSelect* Expression_MaskExpression::unsafe_arena_release_select() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.Expression.MaskExpression.select)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Expression_MaskExpression_StructSelect* temp = _impl_.select_;
  _impl_.select_ = nullptr;
  return temp;
}
inline ::substrait::Expression_MaskExpression_StructSelect* Expression_MaskExpression::_internal_mutable_select() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.select_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_MaskExpression_StructSelect>(GetArena());
    _impl_.select_ = reinterpret_cast<::substrait::Expression_MaskExpression_StructSelect*>(p);
  }
  return _impl_.select_;
}
inline ::substrait::Expression_MaskExpression_StructSelect* Expression_MaskExpression::mutable_select() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::Expression_MaskExpression_StructSelect* _msg = _internal_mutable_select();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MaskExpression.select)
  return _msg;
}
inline void Expression_MaskExpression::set_allocated_select(::substrait::Expression_MaskExpression_StructSelect* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.select_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.select_ = reinterpret_cast<::substrait::Expression_MaskExpression_StructSelect*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.MaskExpression.select)
}

// bool maintain_singular_struct = 2;
inline void Expression_MaskExpression::clear_maintain_singular_struct() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.maintain_singular_struct_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool Expression_MaskExpression::maintain_singular_struct() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.maintain_singular_struct)
  return _internal_maintain_singular_struct();
}
inline void Expression_MaskExpression::set_maintain_singular_struct(bool value) {
  _internal_set_maintain_singular_struct(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:substrait.Expression.MaskExpression.maintain_singular_struct)
}
inline bool Expression_MaskExpression::_internal_maintain_singular_struct() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.maintain_singular_struct_;
}
inline void Expression_MaskExpression::_internal_set_maintain_singular_struct(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.maintain_singular_struct_ = value;
}

// -------------------------------------------------------------------

// Expression_FieldReference_RootReference

// -------------------------------------------------------------------

// Expression_FieldReference_OuterReference

// uint32 steps_out = 1;
inline void Expression_FieldReference_OuterReference::clear_steps_out() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.steps_out_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t Expression_FieldReference_OuterReference::steps_out() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.FieldReference.OuterReference.steps_out)
  return _internal_steps_out();
}
inline void Expression_FieldReference_OuterReference::set_steps_out(::uint32_t value) {
  _internal_set_steps_out(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:substrait.Expression.FieldReference.OuterReference.steps_out)
}
inline ::uint32_t Expression_FieldReference_OuterReference::_internal_steps_out() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.steps_out_;
}
inline void Expression_FieldReference_OuterReference::_internal_set_steps_out(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.steps_out_ = value;
}

// -------------------------------------------------------------------

// Expression_FieldReference

// .substrait.Expression.ReferenceSegment direct_reference = 1;
inline bool Expression_FieldReference::has_direct_reference() const {
  return reference_type_case() == kDirectReference;
}
inline bool Expression_FieldReference::_internal_has_direct_reference() const {
  return reference_type_case() == kDirectReference;
}
inline void Expression_FieldReference::set_has_direct_reference() {
  _impl_._oneof_case_[0] = kDirectReference;
}
inline void Expression_FieldReference::clear_direct_reference() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (reference_type_case() == kDirectReference) {
    if (GetArena() == nullptr) {
      delete _impl_.reference_type_.direct_reference_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.reference_type_.direct_reference_);
    }
    clear_has_reference_type();
  }
}
inline ::substrait::Expression_ReferenceSegment* Expression_FieldReference::release_direct_reference() {
  // @@protoc_insertion_point(field_release:substrait.Expression.FieldReference.direct_reference)
  if (reference_type_case() == kDirectReference) {
    clear_has_reference_type();
    auto* temp = _impl_.reference_type_.direct_reference_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.reference_type_.direct_reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_ReferenceSegment& Expression_FieldReference::_internal_direct_reference() const {
  return reference_type_case() == kDirectReference ? *_impl_.reference_type_.direct_reference_ : reinterpret_cast<::substrait::Expression_ReferenceSegment&>(::substrait::_Expression_ReferenceSegment_default_instance_);
}
inline const ::substrait::Expression_ReferenceSegment& Expression_FieldReference::direct_reference() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.FieldReference.direct_reference)
  return _internal_direct_reference();
}
inline ::substrait::Expression_ReferenceSegment* Expression_FieldReference::unsafe_arena_release_direct_reference() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.FieldReference.direct_reference)
  if (reference_type_case() == kDirectReference) {
    clear_has_reference_type();
    auto* temp = _impl_.reference_type_.direct_reference_;
    _impl_.reference_type_.direct_reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_FieldReference::unsafe_arena_set_allocated_direct_reference(::substrait::Expression_ReferenceSegment* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_reference_type();
  if (value) {
    set_has_direct_reference();
    _impl_.reference_type_.direct_reference_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.FieldReference.direct_reference)
}
inline ::substrait::Expression_ReferenceSegment* Expression_FieldReference::_internal_mutable_direct_reference() {
  if (reference_type_case() != kDirectReference) {
    clear_reference_type();
    set_has_direct_reference();
    _impl_.reference_type_.direct_reference_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_ReferenceSegment>(GetArena());
  }
  return _impl_.reference_type_.direct_reference_;
}
inline ::substrait::Expression_ReferenceSegment* Expression_FieldReference::mutable_direct_reference() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression_ReferenceSegment* _msg = _internal_mutable_direct_reference();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.FieldReference.direct_reference)
  return _msg;
}

// .substrait.Expression.MaskExpression masked_reference = 2;
inline bool Expression_FieldReference::has_masked_reference() const {
  return reference_type_case() == kMaskedReference;
}
inline bool Expression_FieldReference::_internal_has_masked_reference() const {
  return reference_type_case() == kMaskedReference;
}
inline void Expression_FieldReference::set_has_masked_reference() {
  _impl_._oneof_case_[0] = kMaskedReference;
}
inline void Expression_FieldReference::clear_masked_reference() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (reference_type_case() == kMaskedReference) {
    if (GetArena() == nullptr) {
      delete _impl_.reference_type_.masked_reference_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.reference_type_.masked_reference_);
    }
    clear_has_reference_type();
  }
}
inline ::substrait::Expression_MaskExpression* Expression_FieldReference::release_masked_reference() {
  // @@protoc_insertion_point(field_release:substrait.Expression.FieldReference.masked_reference)
  if (reference_type_case() == kMaskedReference) {
    clear_has_reference_type();
    auto* temp = _impl_.reference_type_.masked_reference_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.reference_type_.masked_reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_MaskExpression& Expression_FieldReference::_internal_masked_reference() const {
  return reference_type_case() == kMaskedReference ? *_impl_.reference_type_.masked_reference_ : reinterpret_cast<::substrait::Expression_MaskExpression&>(::substrait::_Expression_MaskExpression_default_instance_);
}
inline const ::substrait::Expression_MaskExpression& Expression_FieldReference::masked_reference() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.FieldReference.masked_reference)
  return _internal_masked_reference();
}
inline ::substrait::Expression_MaskExpression* Expression_FieldReference::unsafe_arena_release_masked_reference() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.FieldReference.masked_reference)
  if (reference_type_case() == kMaskedReference) {
    clear_has_reference_type();
    auto* temp = _impl_.reference_type_.masked_reference_;
    _impl_.reference_type_.masked_reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_FieldReference::unsafe_arena_set_allocated_masked_reference(::substrait::Expression_MaskExpression* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_reference_type();
  if (value) {
    set_has_masked_reference();
    _impl_.reference_type_.masked_reference_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.FieldReference.masked_reference)
}
inline ::substrait::Expression_MaskExpression* Expression_FieldReference::_internal_mutable_masked_reference() {
  if (reference_type_case() != kMaskedReference) {
    clear_reference_type();
    set_has_masked_reference();
    _impl_.reference_type_.masked_reference_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_MaskExpression>(GetArena());
  }
  return _impl_.reference_type_.masked_reference_;
}
inline ::substrait::Expression_MaskExpression* Expression_FieldReference::mutable_masked_reference() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression_MaskExpression* _msg = _internal_mutable_masked_reference();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.FieldReference.masked_reference)
  return _msg;
}

// .substrait.Expression expression = 3;
inline bool Expression_FieldReference::has_expression() const {
  return root_type_case() == kExpression;
}
inline bool Expression_FieldReference::_internal_has_expression() const {
  return root_type_case() == kExpression;
}
inline void Expression_FieldReference::set_has_expression() {
  _impl_._oneof_case_[1] = kExpression;
}
inline void Expression_FieldReference::clear_expression() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (root_type_case() == kExpression) {
    if (GetArena() == nullptr) {
      delete _impl_.root_type_.expression_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.root_type_.expression_);
    }
    clear_has_root_type();
  }
}
inline ::substrait::Expression* Expression_FieldReference::release_expression() {
  // @@protoc_insertion_point(field_release:substrait.Expression.FieldReference.expression)
  if (root_type_case() == kExpression) {
    clear_has_root_type();
    auto* temp = _impl_.root_type_.expression_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.root_type_.expression_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression& Expression_FieldReference::_internal_expression() const {
  return root_type_case() == kExpression ? *_impl_.root_type_.expression_ : reinterpret_cast<::substrait::Expression&>(::substrait::_Expression_default_instance_);
}
inline const ::substrait::Expression& Expression_FieldReference::expression() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.FieldReference.expression)
  return _internal_expression();
}
inline ::substrait::Expression* Expression_FieldReference::unsafe_arena_release_expression() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.FieldReference.expression)
  if (root_type_case() == kExpression) {
    clear_has_root_type();
    auto* temp = _impl_.root_type_.expression_;
    _impl_.root_type_.expression_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_FieldReference::unsafe_arena_set_allocated_expression(::substrait::Expression* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_root_type();
  if (value) {
    set_has_expression();
    _impl_.root_type_.expression_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.FieldReference.expression)
}
inline ::substrait::Expression* Expression_FieldReference::_internal_mutable_expression() {
  if (root_type_case() != kExpression) {
    clear_root_type();
    set_has_expression();
    _impl_.root_type_.expression_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression>(GetArena());
  }
  return _impl_.root_type_.expression_;
}
inline ::substrait::Expression* Expression_FieldReference::mutable_expression() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression* _msg = _internal_mutable_expression();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.FieldReference.expression)
  return _msg;
}

// .substrait.Expression.FieldReference.RootReference root_reference = 4;
inline bool Expression_FieldReference::has_root_reference() const {
  return root_type_case() == kRootReference;
}
inline bool Expression_FieldReference::_internal_has_root_reference() const {
  return root_type_case() == kRootReference;
}
inline void Expression_FieldReference::set_has_root_reference() {
  _impl_._oneof_case_[1] = kRootReference;
}
inline void Expression_FieldReference::clear_root_reference() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (root_type_case() == kRootReference) {
    if (GetArena() == nullptr) {
      delete _impl_.root_type_.root_reference_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.root_type_.root_reference_);
    }
    clear_has_root_type();
  }
}
inline ::substrait::Expression_FieldReference_RootReference* Expression_FieldReference::release_root_reference() {
  // @@protoc_insertion_point(field_release:substrait.Expression.FieldReference.root_reference)
  if (root_type_case() == kRootReference) {
    clear_has_root_type();
    auto* temp = _impl_.root_type_.root_reference_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.root_type_.root_reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_FieldReference_RootReference& Expression_FieldReference::_internal_root_reference() const {
  return root_type_case() == kRootReference ? *_impl_.root_type_.root_reference_ : reinterpret_cast<::substrait::Expression_FieldReference_RootReference&>(::substrait::_Expression_FieldReference_RootReference_default_instance_);
}
inline const ::substrait::Expression_FieldReference_RootReference& Expression_FieldReference::root_reference() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.FieldReference.root_reference)
  return _internal_root_reference();
}
inline ::substrait::Expression_FieldReference_RootReference* Expression_FieldReference::unsafe_arena_release_root_reference() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.FieldReference.root_reference)
  if (root_type_case() == kRootReference) {
    clear_has_root_type();
    auto* temp = _impl_.root_type_.root_reference_;
    _impl_.root_type_.root_reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_FieldReference::unsafe_arena_set_allocated_root_reference(::substrait::Expression_FieldReference_RootReference* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_root_type();
  if (value) {
    set_has_root_reference();
    _impl_.root_type_.root_reference_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.FieldReference.root_reference)
}
inline ::substrait::Expression_FieldReference_RootReference* Expression_FieldReference::_internal_mutable_root_reference() {
  if (root_type_case() != kRootReference) {
    clear_root_type();
    set_has_root_reference();
    _impl_.root_type_.root_reference_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_FieldReference_RootReference>(GetArena());
  }
  return _impl_.root_type_.root_reference_;
}
inline ::substrait::Expression_FieldReference_RootReference* Expression_FieldReference::mutable_root_reference() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression_FieldReference_RootReference* _msg = _internal_mutable_root_reference();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.FieldReference.root_reference)
  return _msg;
}

// .substrait.Expression.FieldReference.OuterReference outer_reference = 5;
inline bool Expression_FieldReference::has_outer_reference() const {
  return root_type_case() == kOuterReference;
}
inline bool Expression_FieldReference::_internal_has_outer_reference() const {
  return root_type_case() == kOuterReference;
}
inline void Expression_FieldReference::set_has_outer_reference() {
  _impl_._oneof_case_[1] = kOuterReference;
}
inline void Expression_FieldReference::clear_outer_reference() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (root_type_case() == kOuterReference) {
    if (GetArena() == nullptr) {
      delete _impl_.root_type_.outer_reference_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.root_type_.outer_reference_);
    }
    clear_has_root_type();
  }
}
inline ::substrait::Expression_FieldReference_OuterReference* Expression_FieldReference::release_outer_reference() {
  // @@protoc_insertion_point(field_release:substrait.Expression.FieldReference.outer_reference)
  if (root_type_case() == kOuterReference) {
    clear_has_root_type();
    auto* temp = _impl_.root_type_.outer_reference_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.root_type_.outer_reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_FieldReference_OuterReference& Expression_FieldReference::_internal_outer_reference() const {
  return root_type_case() == kOuterReference ? *_impl_.root_type_.outer_reference_ : reinterpret_cast<::substrait::Expression_FieldReference_OuterReference&>(::substrait::_Expression_FieldReference_OuterReference_default_instance_);
}
inline const ::substrait::Expression_FieldReference_OuterReference& Expression_FieldReference::outer_reference() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.FieldReference.outer_reference)
  return _internal_outer_reference();
}
inline ::substrait::Expression_FieldReference_OuterReference* Expression_FieldReference::unsafe_arena_release_outer_reference() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.FieldReference.outer_reference)
  if (root_type_case() == kOuterReference) {
    clear_has_root_type();
    auto* temp = _impl_.root_type_.outer_reference_;
    _impl_.root_type_.outer_reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_FieldReference::unsafe_arena_set_allocated_outer_reference(::substrait::Expression_FieldReference_OuterReference* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_root_type();
  if (value) {
    set_has_outer_reference();
    _impl_.root_type_.outer_reference_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.FieldReference.outer_reference)
}
inline ::substrait::Expression_FieldReference_OuterReference* Expression_FieldReference::_internal_mutable_outer_reference() {
  if (root_type_case() != kOuterReference) {
    clear_root_type();
    set_has_outer_reference();
    _impl_.root_type_.outer_reference_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_FieldReference_OuterReference>(GetArena());
  }
  return _impl_.root_type_.outer_reference_;
}
inline ::substrait::Expression_FieldReference_OuterReference* Expression_FieldReference::mutable_outer_reference() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression_FieldReference_OuterReference* _msg = _internal_mutable_outer_reference();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.FieldReference.outer_reference)
  return _msg;
}

inline bool Expression_FieldReference::has_reference_type() const {
  return reference_type_case() != REFERENCE_TYPE_NOT_SET;
}
inline void Expression_FieldReference::clear_has_reference_type() {
  _impl_._oneof_case_[0] = REFERENCE_TYPE_NOT_SET;
}
inline bool Expression_FieldReference::has_root_type() const {
  return root_type_case() != ROOT_TYPE_NOT_SET;
}
inline void Expression_FieldReference::clear_has_root_type() {
  _impl_._oneof_case_[1] = ROOT_TYPE_NOT_SET;
}
inline Expression_FieldReference::ReferenceTypeCase Expression_FieldReference::reference_type_case() const {
  return Expression_FieldReference::ReferenceTypeCase(_impl_._oneof_case_[0]);
}
inline Expression_FieldReference::RootTypeCase Expression_FieldReference::root_type_case() const {
  return Expression_FieldReference::RootTypeCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// Expression_Subquery_Scalar

// .substrait.Rel input = 1;
inline bool Expression_Subquery_Scalar::has_input() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.input_ != nullptr);
  return value;
}
inline void Expression_Subquery_Scalar::clear_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.input_ != nullptr) _impl_.input_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::Rel& Expression_Subquery_Scalar::_internal_input() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Rel* p = _impl_.input_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Rel&>(::substrait::_Rel_default_instance_);
}
inline const ::substrait::Rel& Expression_Subquery_Scalar::input() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.Subquery.Scalar.input)
  return _internal_input();
}
inline void Expression_Subquery_Scalar::unsafe_arena_set_allocated_input(::substrait::Rel* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.input_);
  }
  _impl_.input_ = reinterpret_cast<::substrait::Rel*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.Subquery.Scalar.input)
}
inline ::substrait::Rel* Expression_Subquery_Scalar::release_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Rel* released = _impl_.input_;
  _impl_.input_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Rel* Expression_Subquery_Scalar::unsafe_arena_release_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.Expression.Subquery.Scalar.input)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Rel* temp = _impl_.input_;
  _impl_.input_ = nullptr;
  return temp;
}
inline ::substrait::Rel* Expression_Subquery_Scalar::_internal_mutable_input() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.input_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Rel>(GetArena());
    _impl_.input_ = reinterpret_cast<::substrait::Rel*>(p);
  }
  return _impl_.input_;
}
inline ::substrait::Rel* Expression_Subquery_Scalar::mutable_input() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::Rel* _msg = _internal_mutable_input();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Subquery.Scalar.input)
  return _msg;
}
inline void Expression_Subquery_Scalar::set_allocated_input(::substrait::Rel* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.input_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.input_ = reinterpret_cast<::substrait::Rel*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Subquery.Scalar.input)
}

// -------------------------------------------------------------------

// Expression_Subquery_InPredicate

// repeated .substrait.Expression needles = 1;
inline int Expression_Subquery_InPredicate::_internal_needles_size() const {
  return _internal_needles().size();
}
inline int Expression_Subquery_InPredicate::needles_size() const {
  return _internal_needles_size();
}
inline void Expression_Subquery_InPredicate::clear_needles() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.needles_.Clear();
}
inline ::substrait::Expression* Expression_Subquery_InPredicate::mutable_needles(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Subquery.InPredicate.needles)
  return _internal_mutable_needles()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression>* Expression_Subquery_InPredicate::mutable_needles()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.Subquery.InPredicate.needles)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_needles();
}
inline const ::substrait::Expression& Expression_Subquery_InPredicate::needles(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.Subquery.InPredicate.needles)
  return _internal_needles().Get(index);
}
inline ::substrait::Expression* Expression_Subquery_InPredicate::add_needles() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::Expression* _add = _internal_mutable_needles()->Add();
  // @@protoc_insertion_point(field_add:substrait.Expression.Subquery.InPredicate.needles)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression>& Expression_Subquery_InPredicate::needles() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.Expression.Subquery.InPredicate.needles)
  return _internal_needles();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression>&
Expression_Subquery_InPredicate::_internal_needles() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.needles_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression>*
Expression_Subquery_InPredicate::_internal_mutable_needles() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.needles_;
}

// .substrait.Rel haystack = 2;
inline bool Expression_Subquery_InPredicate::has_haystack() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.haystack_ != nullptr);
  return value;
}
inline void Expression_Subquery_InPredicate::clear_haystack() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.haystack_ != nullptr) _impl_.haystack_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::Rel& Expression_Subquery_InPredicate::_internal_haystack() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Rel* p = _impl_.haystack_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Rel&>(::substrait::_Rel_default_instance_);
}
inline const ::substrait::Rel& Expression_Subquery_InPredicate::haystack() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.Subquery.InPredicate.haystack)
  return _internal_haystack();
}
inline void Expression_Subquery_InPredicate::unsafe_arena_set_allocated_haystack(::substrait::Rel* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.haystack_);
  }
  _impl_.haystack_ = reinterpret_cast<::substrait::Rel*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.Subquery.InPredicate.haystack)
}
inline ::substrait::Rel* Expression_Subquery_InPredicate::release_haystack() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Rel* released = _impl_.haystack_;
  _impl_.haystack_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Rel* Expression_Subquery_InPredicate::unsafe_arena_release_haystack() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.Expression.Subquery.InPredicate.haystack)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Rel* temp = _impl_.haystack_;
  _impl_.haystack_ = nullptr;
  return temp;
}
inline ::substrait::Rel* Expression_Subquery_InPredicate::_internal_mutable_haystack() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.haystack_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Rel>(GetArena());
    _impl_.haystack_ = reinterpret_cast<::substrait::Rel*>(p);
  }
  return _impl_.haystack_;
}
inline ::substrait::Rel* Expression_Subquery_InPredicate::mutable_haystack() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::Rel* _msg = _internal_mutable_haystack();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Subquery.InPredicate.haystack)
  return _msg;
}
inline void Expression_Subquery_InPredicate::set_allocated_haystack(::substrait::Rel* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.haystack_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.haystack_ = reinterpret_cast<::substrait::Rel*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Subquery.InPredicate.haystack)
}

// -------------------------------------------------------------------

// Expression_Subquery_SetPredicate

// .substrait.Expression.Subquery.SetPredicate.PredicateOp predicate_op = 1;
inline void Expression_Subquery_SetPredicate::clear_predicate_op() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.predicate_op_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::substrait::Expression_Subquery_SetPredicate_PredicateOp Expression_Subquery_SetPredicate::predicate_op() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Subquery.SetPredicate.predicate_op)
  return _internal_predicate_op();
}
inline void Expression_Subquery_SetPredicate::set_predicate_op(::substrait::Expression_Subquery_SetPredicate_PredicateOp value) {
  _internal_set_predicate_op(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:substrait.Expression.Subquery.SetPredicate.predicate_op)
}
inline ::substrait::Expression_Subquery_SetPredicate_PredicateOp Expression_Subquery_SetPredicate::_internal_predicate_op() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::substrait::Expression_Subquery_SetPredicate_PredicateOp>(_impl_.predicate_op_);
}
inline void Expression_Subquery_SetPredicate::_internal_set_predicate_op(::substrait::Expression_Subquery_SetPredicate_PredicateOp value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.predicate_op_ = value;
}

// .substrait.Rel tuples = 2;
inline bool Expression_Subquery_SetPredicate::has_tuples() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tuples_ != nullptr);
  return value;
}
inline void Expression_Subquery_SetPredicate::clear_tuples() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tuples_ != nullptr) _impl_.tuples_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::Rel& Expression_Subquery_SetPredicate::_internal_tuples() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Rel* p = _impl_.tuples_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Rel&>(::substrait::_Rel_default_instance_);
}
inline const ::substrait::Rel& Expression_Subquery_SetPredicate::tuples() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.Subquery.SetPredicate.tuples)
  return _internal_tuples();
}
inline void Expression_Subquery_SetPredicate::unsafe_arena_set_allocated_tuples(::substrait::Rel* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tuples_);
  }
  _impl_.tuples_ = reinterpret_cast<::substrait::Rel*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.Subquery.SetPredicate.tuples)
}
inline ::substrait::Rel* Expression_Subquery_SetPredicate::release_tuples() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Rel* released = _impl_.tuples_;
  _impl_.tuples_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Rel* Expression_Subquery_SetPredicate::unsafe_arena_release_tuples() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.Expression.Subquery.SetPredicate.tuples)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Rel* temp = _impl_.tuples_;
  _impl_.tuples_ = nullptr;
  return temp;
}
inline ::substrait::Rel* Expression_Subquery_SetPredicate::_internal_mutable_tuples() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tuples_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Rel>(GetArena());
    _impl_.tuples_ = reinterpret_cast<::substrait::Rel*>(p);
  }
  return _impl_.tuples_;
}
inline ::substrait::Rel* Expression_Subquery_SetPredicate::mutable_tuples() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::Rel* _msg = _internal_mutable_tuples();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Subquery.SetPredicate.tuples)
  return _msg;
}
inline void Expression_Subquery_SetPredicate::set_allocated_tuples(::substrait::Rel* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.tuples_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.tuples_ = reinterpret_cast<::substrait::Rel*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Subquery.SetPredicate.tuples)
}

// -------------------------------------------------------------------

// Expression_Subquery_SetComparison

// .substrait.Expression.Subquery.SetComparison.ReductionOp reduction_op = 1;
inline void Expression_Subquery_SetComparison::clear_reduction_op() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reduction_op_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::substrait::Expression_Subquery_SetComparison_ReductionOp Expression_Subquery_SetComparison::reduction_op() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Subquery.SetComparison.reduction_op)
  return _internal_reduction_op();
}
inline void Expression_Subquery_SetComparison::set_reduction_op(::substrait::Expression_Subquery_SetComparison_ReductionOp value) {
  _internal_set_reduction_op(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:substrait.Expression.Subquery.SetComparison.reduction_op)
}
inline ::substrait::Expression_Subquery_SetComparison_ReductionOp Expression_Subquery_SetComparison::_internal_reduction_op() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::substrait::Expression_Subquery_SetComparison_ReductionOp>(_impl_.reduction_op_);
}
inline void Expression_Subquery_SetComparison::_internal_set_reduction_op(::substrait::Expression_Subquery_SetComparison_ReductionOp value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reduction_op_ = value;
}

// .substrait.Expression.Subquery.SetComparison.ComparisonOp comparison_op = 2;
inline void Expression_Subquery_SetComparison::clear_comparison_op() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.comparison_op_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::substrait::Expression_Subquery_SetComparison_ComparisonOp Expression_Subquery_SetComparison::comparison_op() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Subquery.SetComparison.comparison_op)
  return _internal_comparison_op();
}
inline void Expression_Subquery_SetComparison::set_comparison_op(::substrait::Expression_Subquery_SetComparison_ComparisonOp value) {
  _internal_set_comparison_op(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:substrait.Expression.Subquery.SetComparison.comparison_op)
}
inline ::substrait::Expression_Subquery_SetComparison_ComparisonOp Expression_Subquery_SetComparison::_internal_comparison_op() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::substrait::Expression_Subquery_SetComparison_ComparisonOp>(_impl_.comparison_op_);
}
inline void Expression_Subquery_SetComparison::_internal_set_comparison_op(::substrait::Expression_Subquery_SetComparison_ComparisonOp value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.comparison_op_ = value;
}

// .substrait.Expression left = 3;
inline bool Expression_Subquery_SetComparison::has_left() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.left_ != nullptr);
  return value;
}
inline void Expression_Subquery_SetComparison::clear_left() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.left_ != nullptr) _impl_.left_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::Expression& Expression_Subquery_SetComparison::_internal_left() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Expression* p = _impl_.left_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression&>(::substrait::_Expression_default_instance_);
}
inline const ::substrait::Expression& Expression_Subquery_SetComparison::left() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.Subquery.SetComparison.left)
  return _internal_left();
}
inline void Expression_Subquery_SetComparison::unsafe_arena_set_allocated_left(::substrait::Expression* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.left_);
  }
  _impl_.left_ = reinterpret_cast<::substrait::Expression*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.Subquery.SetComparison.left)
}
inline ::substrait::Expression* Expression_Subquery_SetComparison::release_left() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Expression* released = _impl_.left_;
  _impl_.left_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Expression* Expression_Subquery_SetComparison::unsafe_arena_release_left() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.Expression.Subquery.SetComparison.left)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Expression* temp = _impl_.left_;
  _impl_.left_ = nullptr;
  return temp;
}
inline ::substrait::Expression* Expression_Subquery_SetComparison::_internal_mutable_left() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.left_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Expression>(GetArena());
    _impl_.left_ = reinterpret_cast<::substrait::Expression*>(p);
  }
  return _impl_.left_;
}
inline ::substrait::Expression* Expression_Subquery_SetComparison::mutable_left() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::Expression* _msg = _internal_mutable_left();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Subquery.SetComparison.left)
  return _msg;
}
inline void Expression_Subquery_SetComparison::set_allocated_left(::substrait::Expression* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.left_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.left_ = reinterpret_cast<::substrait::Expression*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Subquery.SetComparison.left)
}

// .substrait.Rel right = 4;
inline bool Expression_Subquery_SetComparison::has_right() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.right_ != nullptr);
  return value;
}
inline void Expression_Subquery_SetComparison::clear_right() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.right_ != nullptr) _impl_.right_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::substrait::Rel& Expression_Subquery_SetComparison::_internal_right() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Rel* p = _impl_.right_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Rel&>(::substrait::_Rel_default_instance_);
}
inline const ::substrait::Rel& Expression_Subquery_SetComparison::right() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.Subquery.SetComparison.right)
  return _internal_right();
}
inline void Expression_Subquery_SetComparison::unsafe_arena_set_allocated_right(::substrait::Rel* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.right_);
  }
  _impl_.right_ = reinterpret_cast<::substrait::Rel*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.Subquery.SetComparison.right)
}
inline ::substrait::Rel* Expression_Subquery_SetComparison::release_right() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Rel* released = _impl_.right_;
  _impl_.right_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Rel* Expression_Subquery_SetComparison::unsafe_arena_release_right() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.Expression.Subquery.SetComparison.right)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::Rel* temp = _impl_.right_;
  _impl_.right_ = nullptr;
  return temp;
}
inline ::substrait::Rel* Expression_Subquery_SetComparison::_internal_mutable_right() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.right_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Rel>(GetArena());
    _impl_.right_ = reinterpret_cast<::substrait::Rel*>(p);
  }
  return _impl_.right_;
}
inline ::substrait::Rel* Expression_Subquery_SetComparison::mutable_right() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::substrait::Rel* _msg = _internal_mutable_right();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Subquery.SetComparison.right)
  return _msg;
}
inline void Expression_Subquery_SetComparison::set_allocated_right(::substrait::Rel* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.right_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.right_ = reinterpret_cast<::substrait::Rel*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Subquery.SetComparison.right)
}

// -------------------------------------------------------------------

// Expression_Subquery

// .substrait.Expression.Subquery.Scalar scalar = 1;
inline bool Expression_Subquery::has_scalar() const {
  return subquery_type_case() == kScalar;
}
inline bool Expression_Subquery::_internal_has_scalar() const {
  return subquery_type_case() == kScalar;
}
inline void Expression_Subquery::set_has_scalar() {
  _impl_._oneof_case_[0] = kScalar;
}
inline void Expression_Subquery::clear_scalar() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (subquery_type_case() == kScalar) {
    if (GetArena() == nullptr) {
      delete _impl_.subquery_type_.scalar_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.subquery_type_.scalar_);
    }
    clear_has_subquery_type();
  }
}
inline ::substrait::Expression_Subquery_Scalar* Expression_Subquery::release_scalar() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Subquery.scalar)
  if (subquery_type_case() == kScalar) {
    clear_has_subquery_type();
    auto* temp = _impl_.subquery_type_.scalar_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.subquery_type_.scalar_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_Subquery_Scalar& Expression_Subquery::_internal_scalar() const {
  return subquery_type_case() == kScalar ? *_impl_.subquery_type_.scalar_ : reinterpret_cast<::substrait::Expression_Subquery_Scalar&>(::substrait::_Expression_Subquery_Scalar_default_instance_);
}
inline const ::substrait::Expression_Subquery_Scalar& Expression_Subquery::scalar() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.Subquery.scalar)
  return _internal_scalar();
}
inline ::substrait::Expression_Subquery_Scalar* Expression_Subquery::unsafe_arena_release_scalar() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.Subquery.scalar)
  if (subquery_type_case() == kScalar) {
    clear_has_subquery_type();
    auto* temp = _impl_.subquery_type_.scalar_;
    _impl_.subquery_type_.scalar_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_Subquery::unsafe_arena_set_allocated_scalar(::substrait::Expression_Subquery_Scalar* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_subquery_type();
  if (value) {
    set_has_scalar();
    _impl_.subquery_type_.scalar_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.Subquery.scalar)
}
inline ::substrait::Expression_Subquery_Scalar* Expression_Subquery::_internal_mutable_scalar() {
  if (subquery_type_case() != kScalar) {
    clear_subquery_type();
    set_has_scalar();
    _impl_.subquery_type_.scalar_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_Subquery_Scalar>(GetArena());
  }
  return _impl_.subquery_type_.scalar_;
}
inline ::substrait::Expression_Subquery_Scalar* Expression_Subquery::mutable_scalar() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression_Subquery_Scalar* _msg = _internal_mutable_scalar();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Subquery.scalar)
  return _msg;
}

// .substrait.Expression.Subquery.InPredicate in_predicate = 2;
inline bool Expression_Subquery::has_in_predicate() const {
  return subquery_type_case() == kInPredicate;
}
inline bool Expression_Subquery::_internal_has_in_predicate() const {
  return subquery_type_case() == kInPredicate;
}
inline void Expression_Subquery::set_has_in_predicate() {
  _impl_._oneof_case_[0] = kInPredicate;
}
inline void Expression_Subquery::clear_in_predicate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (subquery_type_case() == kInPredicate) {
    if (GetArena() == nullptr) {
      delete _impl_.subquery_type_.in_predicate_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.subquery_type_.in_predicate_);
    }
    clear_has_subquery_type();
  }
}
inline ::substrait::Expression_Subquery_InPredicate* Expression_Subquery::release_in_predicate() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Subquery.in_predicate)
  if (subquery_type_case() == kInPredicate) {
    clear_has_subquery_type();
    auto* temp = _impl_.subquery_type_.in_predicate_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.subquery_type_.in_predicate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_Subquery_InPredicate& Expression_Subquery::_internal_in_predicate() const {
  return subquery_type_case() == kInPredicate ? *_impl_.subquery_type_.in_predicate_ : reinterpret_cast<::substrait::Expression_Subquery_InPredicate&>(::substrait::_Expression_Subquery_InPredicate_default_instance_);
}
inline const ::substrait::Expression_Subquery_InPredicate& Expression_Subquery::in_predicate() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.Subquery.in_predicate)
  return _internal_in_predicate();
}
inline ::substrait::Expression_Subquery_InPredicate* Expression_Subquery::unsafe_arena_release_in_predicate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.Subquery.in_predicate)
  if (subquery_type_case() == kInPredicate) {
    clear_has_subquery_type();
    auto* temp = _impl_.subquery_type_.in_predicate_;
    _impl_.subquery_type_.in_predicate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_Subquery::unsafe_arena_set_allocated_in_predicate(::substrait::Expression_Subquery_InPredicate* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_subquery_type();
  if (value) {
    set_has_in_predicate();
    _impl_.subquery_type_.in_predicate_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.Subquery.in_predicate)
}
inline ::substrait::Expression_Subquery_InPredicate* Expression_Subquery::_internal_mutable_in_predicate() {
  if (subquery_type_case() != kInPredicate) {
    clear_subquery_type();
    set_has_in_predicate();
    _impl_.subquery_type_.in_predicate_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_Subquery_InPredicate>(GetArena());
  }
  return _impl_.subquery_type_.in_predicate_;
}
inline ::substrait::Expression_Subquery_InPredicate* Expression_Subquery::mutable_in_predicate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression_Subquery_InPredicate* _msg = _internal_mutable_in_predicate();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Subquery.in_predicate)
  return _msg;
}

// .substrait.Expression.Subquery.SetPredicate set_predicate = 3;
inline bool Expression_Subquery::has_set_predicate() const {
  return subquery_type_case() == kSetPredicate;
}
inline bool Expression_Subquery::_internal_has_set_predicate() const {
  return subquery_type_case() == kSetPredicate;
}
inline void Expression_Subquery::set_has_set_predicate() {
  _impl_._oneof_case_[0] = kSetPredicate;
}
inline void Expression_Subquery::clear_set_predicate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (subquery_type_case() == kSetPredicate) {
    if (GetArena() == nullptr) {
      delete _impl_.subquery_type_.set_predicate_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.subquery_type_.set_predicate_);
    }
    clear_has_subquery_type();
  }
}
inline ::substrait::Expression_Subquery_SetPredicate* Expression_Subquery::release_set_predicate() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Subquery.set_predicate)
  if (subquery_type_case() == kSetPredicate) {
    clear_has_subquery_type();
    auto* temp = _impl_.subquery_type_.set_predicate_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.subquery_type_.set_predicate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_Subquery_SetPredicate& Expression_Subquery::_internal_set_predicate() const {
  return subquery_type_case() == kSetPredicate ? *_impl_.subquery_type_.set_predicate_ : reinterpret_cast<::substrait::Expression_Subquery_SetPredicate&>(::substrait::_Expression_Subquery_SetPredicate_default_instance_);
}
inline const ::substrait::Expression_Subquery_SetPredicate& Expression_Subquery::set_predicate() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.Subquery.set_predicate)
  return _internal_set_predicate();
}
inline ::substrait::Expression_Subquery_SetPredicate* Expression_Subquery::unsafe_arena_release_set_predicate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.Subquery.set_predicate)
  if (subquery_type_case() == kSetPredicate) {
    clear_has_subquery_type();
    auto* temp = _impl_.subquery_type_.set_predicate_;
    _impl_.subquery_type_.set_predicate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_Subquery::unsafe_arena_set_allocated_set_predicate(::substrait::Expression_Subquery_SetPredicate* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_subquery_type();
  if (value) {
    set_has_set_predicate();
    _impl_.subquery_type_.set_predicate_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.Subquery.set_predicate)
}
inline ::substrait::Expression_Subquery_SetPredicate* Expression_Subquery::_internal_mutable_set_predicate() {
  if (subquery_type_case() != kSetPredicate) {
    clear_subquery_type();
    set_has_set_predicate();
    _impl_.subquery_type_.set_predicate_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_Subquery_SetPredicate>(GetArena());
  }
  return _impl_.subquery_type_.set_predicate_;
}
inline ::substrait::Expression_Subquery_SetPredicate* Expression_Subquery::mutable_set_predicate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression_Subquery_SetPredicate* _msg = _internal_mutable_set_predicate();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Subquery.set_predicate)
  return _msg;
}

// .substrait.Expression.Subquery.SetComparison set_comparison = 4;
inline bool Expression_Subquery::has_set_comparison() const {
  return subquery_type_case() == kSetComparison;
}
inline bool Expression_Subquery::_internal_has_set_comparison() const {
  return subquery_type_case() == kSetComparison;
}
inline void Expression_Subquery::set_has_set_comparison() {
  _impl_._oneof_case_[0] = kSetComparison;
}
inline void Expression_Subquery::clear_set_comparison() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (subquery_type_case() == kSetComparison) {
    if (GetArena() == nullptr) {
      delete _impl_.subquery_type_.set_comparison_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.subquery_type_.set_comparison_);
    }
    clear_has_subquery_type();
  }
}
inline ::substrait::Expression_Subquery_SetComparison* Expression_Subquery::release_set_comparison() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Subquery.set_comparison)
  if (subquery_type_case() == kSetComparison) {
    clear_has_subquery_type();
    auto* temp = _impl_.subquery_type_.set_comparison_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.subquery_type_.set_comparison_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_Subquery_SetComparison& Expression_Subquery::_internal_set_comparison() const {
  return subquery_type_case() == kSetComparison ? *_impl_.subquery_type_.set_comparison_ : reinterpret_cast<::substrait::Expression_Subquery_SetComparison&>(::substrait::_Expression_Subquery_SetComparison_default_instance_);
}
inline const ::substrait::Expression_Subquery_SetComparison& Expression_Subquery::set_comparison() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.Subquery.set_comparison)
  return _internal_set_comparison();
}
inline ::substrait::Expression_Subquery_SetComparison* Expression_Subquery::unsafe_arena_release_set_comparison() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.Subquery.set_comparison)
  if (subquery_type_case() == kSetComparison) {
    clear_has_subquery_type();
    auto* temp = _impl_.subquery_type_.set_comparison_;
    _impl_.subquery_type_.set_comparison_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression_Subquery::unsafe_arena_set_allocated_set_comparison(::substrait::Expression_Subquery_SetComparison* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_subquery_type();
  if (value) {
    set_has_set_comparison();
    _impl_.subquery_type_.set_comparison_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.Subquery.set_comparison)
}
inline ::substrait::Expression_Subquery_SetComparison* Expression_Subquery::_internal_mutable_set_comparison() {
  if (subquery_type_case() != kSetComparison) {
    clear_subquery_type();
    set_has_set_comparison();
    _impl_.subquery_type_.set_comparison_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_Subquery_SetComparison>(GetArena());
  }
  return _impl_.subquery_type_.set_comparison_;
}
inline ::substrait::Expression_Subquery_SetComparison* Expression_Subquery::mutable_set_comparison() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression_Subquery_SetComparison* _msg = _internal_mutable_set_comparison();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Subquery.set_comparison)
  return _msg;
}

inline bool Expression_Subquery::has_subquery_type() const {
  return subquery_type_case() != SUBQUERY_TYPE_NOT_SET;
}
inline void Expression_Subquery::clear_has_subquery_type() {
  _impl_._oneof_case_[0] = SUBQUERY_TYPE_NOT_SET;
}
inline Expression_Subquery::SubqueryTypeCase Expression_Subquery::subquery_type_case() const {
  return Expression_Subquery::SubqueryTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Expression

// .substrait.Expression.Literal literal = 1;
inline bool Expression::has_literal() const {
  return rex_type_case() == kLiteral;
}
inline bool Expression::_internal_has_literal() const {
  return rex_type_case() == kLiteral;
}
inline void Expression::set_has_literal() {
  _impl_._oneof_case_[0] = kLiteral;
}
inline void Expression::clear_literal() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (rex_type_case() == kLiteral) {
    if (GetArena() == nullptr) {
      delete _impl_.rex_type_.literal_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.rex_type_.literal_);
    }
    clear_has_rex_type();
  }
}
inline ::substrait::Expression_Literal* Expression::release_literal() {
  // @@protoc_insertion_point(field_release:substrait.Expression.literal)
  if (rex_type_case() == kLiteral) {
    clear_has_rex_type();
    auto* temp = _impl_.rex_type_.literal_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.rex_type_.literal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_Literal& Expression::_internal_literal() const {
  return rex_type_case() == kLiteral ? *_impl_.rex_type_.literal_ : reinterpret_cast<::substrait::Expression_Literal&>(::substrait::_Expression_Literal_default_instance_);
}
inline const ::substrait::Expression_Literal& Expression::literal() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.literal)
  return _internal_literal();
}
inline ::substrait::Expression_Literal* Expression::unsafe_arena_release_literal() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.literal)
  if (rex_type_case() == kLiteral) {
    clear_has_rex_type();
    auto* temp = _impl_.rex_type_.literal_;
    _impl_.rex_type_.literal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression::unsafe_arena_set_allocated_literal(::substrait::Expression_Literal* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_rex_type();
  if (value) {
    set_has_literal();
    _impl_.rex_type_.literal_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.literal)
}
inline ::substrait::Expression_Literal* Expression::_internal_mutable_literal() {
  if (rex_type_case() != kLiteral) {
    clear_rex_type();
    set_has_literal();
    _impl_.rex_type_.literal_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_Literal>(GetArena());
  }
  return _impl_.rex_type_.literal_;
}
inline ::substrait::Expression_Literal* Expression::mutable_literal() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression_Literal* _msg = _internal_mutable_literal();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.literal)
  return _msg;
}

// .substrait.Expression.FieldReference selection = 2;
inline bool Expression::has_selection() const {
  return rex_type_case() == kSelection;
}
inline bool Expression::_internal_has_selection() const {
  return rex_type_case() == kSelection;
}
inline void Expression::set_has_selection() {
  _impl_._oneof_case_[0] = kSelection;
}
inline void Expression::clear_selection() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (rex_type_case() == kSelection) {
    if (GetArena() == nullptr) {
      delete _impl_.rex_type_.selection_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.rex_type_.selection_);
    }
    clear_has_rex_type();
  }
}
inline ::substrait::Expression_FieldReference* Expression::release_selection() {
  // @@protoc_insertion_point(field_release:substrait.Expression.selection)
  if (rex_type_case() == kSelection) {
    clear_has_rex_type();
    auto* temp = _impl_.rex_type_.selection_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.rex_type_.selection_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_FieldReference& Expression::_internal_selection() const {
  return rex_type_case() == kSelection ? *_impl_.rex_type_.selection_ : reinterpret_cast<::substrait::Expression_FieldReference&>(::substrait::_Expression_FieldReference_default_instance_);
}
inline const ::substrait::Expression_FieldReference& Expression::selection() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.selection)
  return _internal_selection();
}
inline ::substrait::Expression_FieldReference* Expression::unsafe_arena_release_selection() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.selection)
  if (rex_type_case() == kSelection) {
    clear_has_rex_type();
    auto* temp = _impl_.rex_type_.selection_;
    _impl_.rex_type_.selection_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression::unsafe_arena_set_allocated_selection(::substrait::Expression_FieldReference* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_rex_type();
  if (value) {
    set_has_selection();
    _impl_.rex_type_.selection_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.selection)
}
inline ::substrait::Expression_FieldReference* Expression::_internal_mutable_selection() {
  if (rex_type_case() != kSelection) {
    clear_rex_type();
    set_has_selection();
    _impl_.rex_type_.selection_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_FieldReference>(GetArena());
  }
  return _impl_.rex_type_.selection_;
}
inline ::substrait::Expression_FieldReference* Expression::mutable_selection() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression_FieldReference* _msg = _internal_mutable_selection();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.selection)
  return _msg;
}

// .substrait.Expression.ScalarFunction scalar_function = 3;
inline bool Expression::has_scalar_function() const {
  return rex_type_case() == kScalarFunction;
}
inline bool Expression::_internal_has_scalar_function() const {
  return rex_type_case() == kScalarFunction;
}
inline void Expression::set_has_scalar_function() {
  _impl_._oneof_case_[0] = kScalarFunction;
}
inline void Expression::clear_scalar_function() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (rex_type_case() == kScalarFunction) {
    if (GetArena() == nullptr) {
      delete _impl_.rex_type_.scalar_function_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.rex_type_.scalar_function_);
    }
    clear_has_rex_type();
  }
}
inline ::substrait::Expression_ScalarFunction* Expression::release_scalar_function() {
  // @@protoc_insertion_point(field_release:substrait.Expression.scalar_function)
  if (rex_type_case() == kScalarFunction) {
    clear_has_rex_type();
    auto* temp = _impl_.rex_type_.scalar_function_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.rex_type_.scalar_function_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_ScalarFunction& Expression::_internal_scalar_function() const {
  return rex_type_case() == kScalarFunction ? *_impl_.rex_type_.scalar_function_ : reinterpret_cast<::substrait::Expression_ScalarFunction&>(::substrait::_Expression_ScalarFunction_default_instance_);
}
inline const ::substrait::Expression_ScalarFunction& Expression::scalar_function() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.scalar_function)
  return _internal_scalar_function();
}
inline ::substrait::Expression_ScalarFunction* Expression::unsafe_arena_release_scalar_function() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.scalar_function)
  if (rex_type_case() == kScalarFunction) {
    clear_has_rex_type();
    auto* temp = _impl_.rex_type_.scalar_function_;
    _impl_.rex_type_.scalar_function_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression::unsafe_arena_set_allocated_scalar_function(::substrait::Expression_ScalarFunction* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_rex_type();
  if (value) {
    set_has_scalar_function();
    _impl_.rex_type_.scalar_function_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.scalar_function)
}
inline ::substrait::Expression_ScalarFunction* Expression::_internal_mutable_scalar_function() {
  if (rex_type_case() != kScalarFunction) {
    clear_rex_type();
    set_has_scalar_function();
    _impl_.rex_type_.scalar_function_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_ScalarFunction>(GetArena());
  }
  return _impl_.rex_type_.scalar_function_;
}
inline ::substrait::Expression_ScalarFunction* Expression::mutable_scalar_function() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression_ScalarFunction* _msg = _internal_mutable_scalar_function();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.scalar_function)
  return _msg;
}

// .substrait.Expression.WindowFunction window_function = 5;
inline bool Expression::has_window_function() const {
  return rex_type_case() == kWindowFunction;
}
inline bool Expression::_internal_has_window_function() const {
  return rex_type_case() == kWindowFunction;
}
inline void Expression::set_has_window_function() {
  _impl_._oneof_case_[0] = kWindowFunction;
}
inline void Expression::clear_window_function() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (rex_type_case() == kWindowFunction) {
    if (GetArena() == nullptr) {
      delete _impl_.rex_type_.window_function_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.rex_type_.window_function_);
    }
    clear_has_rex_type();
  }
}
inline ::substrait::Expression_WindowFunction* Expression::release_window_function() {
  // @@protoc_insertion_point(field_release:substrait.Expression.window_function)
  if (rex_type_case() == kWindowFunction) {
    clear_has_rex_type();
    auto* temp = _impl_.rex_type_.window_function_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.rex_type_.window_function_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_WindowFunction& Expression::_internal_window_function() const {
  return rex_type_case() == kWindowFunction ? *_impl_.rex_type_.window_function_ : reinterpret_cast<::substrait::Expression_WindowFunction&>(::substrait::_Expression_WindowFunction_default_instance_);
}
inline const ::substrait::Expression_WindowFunction& Expression::window_function() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.window_function)
  return _internal_window_function();
}
inline ::substrait::Expression_WindowFunction* Expression::unsafe_arena_release_window_function() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.window_function)
  if (rex_type_case() == kWindowFunction) {
    clear_has_rex_type();
    auto* temp = _impl_.rex_type_.window_function_;
    _impl_.rex_type_.window_function_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression::unsafe_arena_set_allocated_window_function(::substrait::Expression_WindowFunction* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_rex_type();
  if (value) {
    set_has_window_function();
    _impl_.rex_type_.window_function_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.window_function)
}
inline ::substrait::Expression_WindowFunction* Expression::_internal_mutable_window_function() {
  if (rex_type_case() != kWindowFunction) {
    clear_rex_type();
    set_has_window_function();
    _impl_.rex_type_.window_function_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_WindowFunction>(GetArena());
  }
  return _impl_.rex_type_.window_function_;
}
inline ::substrait::Expression_WindowFunction* Expression::mutable_window_function() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression_WindowFunction* _msg = _internal_mutable_window_function();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.window_function)
  return _msg;
}

// .substrait.Expression.IfThen if_then = 6;
inline bool Expression::has_if_then() const {
  return rex_type_case() == kIfThen;
}
inline bool Expression::_internal_has_if_then() const {
  return rex_type_case() == kIfThen;
}
inline void Expression::set_has_if_then() {
  _impl_._oneof_case_[0] = kIfThen;
}
inline void Expression::clear_if_then() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (rex_type_case() == kIfThen) {
    if (GetArena() == nullptr) {
      delete _impl_.rex_type_.if_then_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.rex_type_.if_then_);
    }
    clear_has_rex_type();
  }
}
inline ::substrait::Expression_IfThen* Expression::release_if_then() {
  // @@protoc_insertion_point(field_release:substrait.Expression.if_then)
  if (rex_type_case() == kIfThen) {
    clear_has_rex_type();
    auto* temp = _impl_.rex_type_.if_then_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.rex_type_.if_then_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_IfThen& Expression::_internal_if_then() const {
  return rex_type_case() == kIfThen ? *_impl_.rex_type_.if_then_ : reinterpret_cast<::substrait::Expression_IfThen&>(::substrait::_Expression_IfThen_default_instance_);
}
inline const ::substrait::Expression_IfThen& Expression::if_then() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.if_then)
  return _internal_if_then();
}
inline ::substrait::Expression_IfThen* Expression::unsafe_arena_release_if_then() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.if_then)
  if (rex_type_case() == kIfThen) {
    clear_has_rex_type();
    auto* temp = _impl_.rex_type_.if_then_;
    _impl_.rex_type_.if_then_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression::unsafe_arena_set_allocated_if_then(::substrait::Expression_IfThen* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_rex_type();
  if (value) {
    set_has_if_then();
    _impl_.rex_type_.if_then_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.if_then)
}
inline ::substrait::Expression_IfThen* Expression::_internal_mutable_if_then() {
  if (rex_type_case() != kIfThen) {
    clear_rex_type();
    set_has_if_then();
    _impl_.rex_type_.if_then_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_IfThen>(GetArena());
  }
  return _impl_.rex_type_.if_then_;
}
inline ::substrait::Expression_IfThen* Expression::mutable_if_then() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression_IfThen* _msg = _internal_mutable_if_then();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.if_then)
  return _msg;
}

// .substrait.Expression.SwitchExpression switch_expression = 7;
inline bool Expression::has_switch_expression() const {
  return rex_type_case() == kSwitchExpression;
}
inline bool Expression::_internal_has_switch_expression() const {
  return rex_type_case() == kSwitchExpression;
}
inline void Expression::set_has_switch_expression() {
  _impl_._oneof_case_[0] = kSwitchExpression;
}
inline void Expression::clear_switch_expression() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (rex_type_case() == kSwitchExpression) {
    if (GetArena() == nullptr) {
      delete _impl_.rex_type_.switch_expression_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.rex_type_.switch_expression_);
    }
    clear_has_rex_type();
  }
}
inline ::substrait::Expression_SwitchExpression* Expression::release_switch_expression() {
  // @@protoc_insertion_point(field_release:substrait.Expression.switch_expression)
  if (rex_type_case() == kSwitchExpression) {
    clear_has_rex_type();
    auto* temp = _impl_.rex_type_.switch_expression_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.rex_type_.switch_expression_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_SwitchExpression& Expression::_internal_switch_expression() const {
  return rex_type_case() == kSwitchExpression ? *_impl_.rex_type_.switch_expression_ : reinterpret_cast<::substrait::Expression_SwitchExpression&>(::substrait::_Expression_SwitchExpression_default_instance_);
}
inline const ::substrait::Expression_SwitchExpression& Expression::switch_expression() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.switch_expression)
  return _internal_switch_expression();
}
inline ::substrait::Expression_SwitchExpression* Expression::unsafe_arena_release_switch_expression() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.switch_expression)
  if (rex_type_case() == kSwitchExpression) {
    clear_has_rex_type();
    auto* temp = _impl_.rex_type_.switch_expression_;
    _impl_.rex_type_.switch_expression_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression::unsafe_arena_set_allocated_switch_expression(::substrait::Expression_SwitchExpression* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_rex_type();
  if (value) {
    set_has_switch_expression();
    _impl_.rex_type_.switch_expression_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.switch_expression)
}
inline ::substrait::Expression_SwitchExpression* Expression::_internal_mutable_switch_expression() {
  if (rex_type_case() != kSwitchExpression) {
    clear_rex_type();
    set_has_switch_expression();
    _impl_.rex_type_.switch_expression_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_SwitchExpression>(GetArena());
  }
  return _impl_.rex_type_.switch_expression_;
}
inline ::substrait::Expression_SwitchExpression* Expression::mutable_switch_expression() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression_SwitchExpression* _msg = _internal_mutable_switch_expression();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.switch_expression)
  return _msg;
}

// .substrait.Expression.SingularOrList singular_or_list = 8;
inline bool Expression::has_singular_or_list() const {
  return rex_type_case() == kSingularOrList;
}
inline bool Expression::_internal_has_singular_or_list() const {
  return rex_type_case() == kSingularOrList;
}
inline void Expression::set_has_singular_or_list() {
  _impl_._oneof_case_[0] = kSingularOrList;
}
inline void Expression::clear_singular_or_list() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (rex_type_case() == kSingularOrList) {
    if (GetArena() == nullptr) {
      delete _impl_.rex_type_.singular_or_list_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.rex_type_.singular_or_list_);
    }
    clear_has_rex_type();
  }
}
inline ::substrait::Expression_SingularOrList* Expression::release_singular_or_list() {
  // @@protoc_insertion_point(field_release:substrait.Expression.singular_or_list)
  if (rex_type_case() == kSingularOrList) {
    clear_has_rex_type();
    auto* temp = _impl_.rex_type_.singular_or_list_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.rex_type_.singular_or_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_SingularOrList& Expression::_internal_singular_or_list() const {
  return rex_type_case() == kSingularOrList ? *_impl_.rex_type_.singular_or_list_ : reinterpret_cast<::substrait::Expression_SingularOrList&>(::substrait::_Expression_SingularOrList_default_instance_);
}
inline const ::substrait::Expression_SingularOrList& Expression::singular_or_list() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.singular_or_list)
  return _internal_singular_or_list();
}
inline ::substrait::Expression_SingularOrList* Expression::unsafe_arena_release_singular_or_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.singular_or_list)
  if (rex_type_case() == kSingularOrList) {
    clear_has_rex_type();
    auto* temp = _impl_.rex_type_.singular_or_list_;
    _impl_.rex_type_.singular_or_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression::unsafe_arena_set_allocated_singular_or_list(::substrait::Expression_SingularOrList* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_rex_type();
  if (value) {
    set_has_singular_or_list();
    _impl_.rex_type_.singular_or_list_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.singular_or_list)
}
inline ::substrait::Expression_SingularOrList* Expression::_internal_mutable_singular_or_list() {
  if (rex_type_case() != kSingularOrList) {
    clear_rex_type();
    set_has_singular_or_list();
    _impl_.rex_type_.singular_or_list_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_SingularOrList>(GetArena());
  }
  return _impl_.rex_type_.singular_or_list_;
}
inline ::substrait::Expression_SingularOrList* Expression::mutable_singular_or_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression_SingularOrList* _msg = _internal_mutable_singular_or_list();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.singular_or_list)
  return _msg;
}

// .substrait.Expression.MultiOrList multi_or_list = 9;
inline bool Expression::has_multi_or_list() const {
  return rex_type_case() == kMultiOrList;
}
inline bool Expression::_internal_has_multi_or_list() const {
  return rex_type_case() == kMultiOrList;
}
inline void Expression::set_has_multi_or_list() {
  _impl_._oneof_case_[0] = kMultiOrList;
}
inline void Expression::clear_multi_or_list() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (rex_type_case() == kMultiOrList) {
    if (GetArena() == nullptr) {
      delete _impl_.rex_type_.multi_or_list_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.rex_type_.multi_or_list_);
    }
    clear_has_rex_type();
  }
}
inline ::substrait::Expression_MultiOrList* Expression::release_multi_or_list() {
  // @@protoc_insertion_point(field_release:substrait.Expression.multi_or_list)
  if (rex_type_case() == kMultiOrList) {
    clear_has_rex_type();
    auto* temp = _impl_.rex_type_.multi_or_list_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.rex_type_.multi_or_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_MultiOrList& Expression::_internal_multi_or_list() const {
  return rex_type_case() == kMultiOrList ? *_impl_.rex_type_.multi_or_list_ : reinterpret_cast<::substrait::Expression_MultiOrList&>(::substrait::_Expression_MultiOrList_default_instance_);
}
inline const ::substrait::Expression_MultiOrList& Expression::multi_or_list() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.multi_or_list)
  return _internal_multi_or_list();
}
inline ::substrait::Expression_MultiOrList* Expression::unsafe_arena_release_multi_or_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.multi_or_list)
  if (rex_type_case() == kMultiOrList) {
    clear_has_rex_type();
    auto* temp = _impl_.rex_type_.multi_or_list_;
    _impl_.rex_type_.multi_or_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression::unsafe_arena_set_allocated_multi_or_list(::substrait::Expression_MultiOrList* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_rex_type();
  if (value) {
    set_has_multi_or_list();
    _impl_.rex_type_.multi_or_list_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.multi_or_list)
}
inline ::substrait::Expression_MultiOrList* Expression::_internal_mutable_multi_or_list() {
  if (rex_type_case() != kMultiOrList) {
    clear_rex_type();
    set_has_multi_or_list();
    _impl_.rex_type_.multi_or_list_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_MultiOrList>(GetArena());
  }
  return _impl_.rex_type_.multi_or_list_;
}
inline ::substrait::Expression_MultiOrList* Expression::mutable_multi_or_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression_MultiOrList* _msg = _internal_mutable_multi_or_list();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.multi_or_list)
  return _msg;
}

// .substrait.Expression.Cast cast = 11;
inline bool Expression::has_cast() const {
  return rex_type_case() == kCast;
}
inline bool Expression::_internal_has_cast() const {
  return rex_type_case() == kCast;
}
inline void Expression::set_has_cast() {
  _impl_._oneof_case_[0] = kCast;
}
inline void Expression::clear_cast() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (rex_type_case() == kCast) {
    if (GetArena() == nullptr) {
      delete _impl_.rex_type_.cast_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.rex_type_.cast_);
    }
    clear_has_rex_type();
  }
}
inline ::substrait::Expression_Cast* Expression::release_cast() {
  // @@protoc_insertion_point(field_release:substrait.Expression.cast)
  if (rex_type_case() == kCast) {
    clear_has_rex_type();
    auto* temp = _impl_.rex_type_.cast_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.rex_type_.cast_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_Cast& Expression::_internal_cast() const {
  return rex_type_case() == kCast ? *_impl_.rex_type_.cast_ : reinterpret_cast<::substrait::Expression_Cast&>(::substrait::_Expression_Cast_default_instance_);
}
inline const ::substrait::Expression_Cast& Expression::cast() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.cast)
  return _internal_cast();
}
inline ::substrait::Expression_Cast* Expression::unsafe_arena_release_cast() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.cast)
  if (rex_type_case() == kCast) {
    clear_has_rex_type();
    auto* temp = _impl_.rex_type_.cast_;
    _impl_.rex_type_.cast_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression::unsafe_arena_set_allocated_cast(::substrait::Expression_Cast* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_rex_type();
  if (value) {
    set_has_cast();
    _impl_.rex_type_.cast_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.cast)
}
inline ::substrait::Expression_Cast* Expression::_internal_mutable_cast() {
  if (rex_type_case() != kCast) {
    clear_rex_type();
    set_has_cast();
    _impl_.rex_type_.cast_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_Cast>(GetArena());
  }
  return _impl_.rex_type_.cast_;
}
inline ::substrait::Expression_Cast* Expression::mutable_cast() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression_Cast* _msg = _internal_mutable_cast();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.cast)
  return _msg;
}

// .substrait.Expression.Subquery subquery = 12;
inline bool Expression::has_subquery() const {
  return rex_type_case() == kSubquery;
}
inline bool Expression::_internal_has_subquery() const {
  return rex_type_case() == kSubquery;
}
inline void Expression::set_has_subquery() {
  _impl_._oneof_case_[0] = kSubquery;
}
inline void Expression::clear_subquery() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (rex_type_case() == kSubquery) {
    if (GetArena() == nullptr) {
      delete _impl_.rex_type_.subquery_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.rex_type_.subquery_);
    }
    clear_has_rex_type();
  }
}
inline ::substrait::Expression_Subquery* Expression::release_subquery() {
  // @@protoc_insertion_point(field_release:substrait.Expression.subquery)
  if (rex_type_case() == kSubquery) {
    clear_has_rex_type();
    auto* temp = _impl_.rex_type_.subquery_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.rex_type_.subquery_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_Subquery& Expression::_internal_subquery() const {
  return rex_type_case() == kSubquery ? *_impl_.rex_type_.subquery_ : reinterpret_cast<::substrait::Expression_Subquery&>(::substrait::_Expression_Subquery_default_instance_);
}
inline const ::substrait::Expression_Subquery& Expression::subquery() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.subquery)
  return _internal_subquery();
}
inline ::substrait::Expression_Subquery* Expression::unsafe_arena_release_subquery() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.subquery)
  if (rex_type_case() == kSubquery) {
    clear_has_rex_type();
    auto* temp = _impl_.rex_type_.subquery_;
    _impl_.rex_type_.subquery_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression::unsafe_arena_set_allocated_subquery(::substrait::Expression_Subquery* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_rex_type();
  if (value) {
    set_has_subquery();
    _impl_.rex_type_.subquery_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.subquery)
}
inline ::substrait::Expression_Subquery* Expression::_internal_mutable_subquery() {
  if (rex_type_case() != kSubquery) {
    clear_rex_type();
    set_has_subquery();
    _impl_.rex_type_.subquery_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_Subquery>(GetArena());
  }
  return _impl_.rex_type_.subquery_;
}
inline ::substrait::Expression_Subquery* Expression::mutable_subquery() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression_Subquery* _msg = _internal_mutable_subquery();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.subquery)
  return _msg;
}

// .substrait.Expression.Nested nested = 13;
inline bool Expression::has_nested() const {
  return rex_type_case() == kNested;
}
inline bool Expression::_internal_has_nested() const {
  return rex_type_case() == kNested;
}
inline void Expression::set_has_nested() {
  _impl_._oneof_case_[0] = kNested;
}
inline void Expression::clear_nested() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (rex_type_case() == kNested) {
    if (GetArena() == nullptr) {
      delete _impl_.rex_type_.nested_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.rex_type_.nested_);
    }
    clear_has_rex_type();
  }
}
inline ::substrait::Expression_Nested* Expression::release_nested() {
  // @@protoc_insertion_point(field_release:substrait.Expression.nested)
  if (rex_type_case() == kNested) {
    clear_has_rex_type();
    auto* temp = _impl_.rex_type_.nested_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.rex_type_.nested_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_Nested& Expression::_internal_nested() const {
  return rex_type_case() == kNested ? *_impl_.rex_type_.nested_ : reinterpret_cast<::substrait::Expression_Nested&>(::substrait::_Expression_Nested_default_instance_);
}
inline const ::substrait::Expression_Nested& Expression::nested() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.nested)
  return _internal_nested();
}
inline ::substrait::Expression_Nested* Expression::unsafe_arena_release_nested() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.nested)
  if (rex_type_case() == kNested) {
    clear_has_rex_type();
    auto* temp = _impl_.rex_type_.nested_;
    _impl_.rex_type_.nested_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression::unsafe_arena_set_allocated_nested(::substrait::Expression_Nested* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_rex_type();
  if (value) {
    set_has_nested();
    _impl_.rex_type_.nested_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.nested)
}
inline ::substrait::Expression_Nested* Expression::_internal_mutable_nested() {
  if (rex_type_case() != kNested) {
    clear_rex_type();
    set_has_nested();
    _impl_.rex_type_.nested_ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_Nested>(GetArena());
  }
  return _impl_.rex_type_.nested_;
}
inline ::substrait::Expression_Nested* Expression::mutable_nested() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression_Nested* _msg = _internal_mutable_nested();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.nested)
  return _msg;
}

// .substrait.Expression.Enum enum = 10 [deprecated = true];
inline bool Expression::has_enum_() const {
  return rex_type_case() == kEnum;
}
inline bool Expression::_internal_has_enum_() const {
  return rex_type_case() == kEnum;
}
inline void Expression::set_has_enum_() {
  _impl_._oneof_case_[0] = kEnum;
}
inline void Expression::clear_enum_() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (rex_type_case() == kEnum) {
    if (GetArena() == nullptr) {
      delete _impl_.rex_type_.enum__;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.rex_type_.enum__);
    }
    clear_has_rex_type();
  }
}
inline ::substrait::Expression_Enum* Expression::release_enum_() {
  // @@protoc_insertion_point(field_release:substrait.Expression.enum)
  if (rex_type_case() == kEnum) {
    clear_has_rex_type();
    auto* temp = _impl_.rex_type_.enum__;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.rex_type_.enum__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Expression_Enum& Expression::_internal_enum_() const {
  return rex_type_case() == kEnum ? *_impl_.rex_type_.enum__ : reinterpret_cast<::substrait::Expression_Enum&>(::substrait::_Expression_Enum_default_instance_);
}
inline const ::substrait::Expression_Enum& Expression::enum_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.Expression.enum)
  return _internal_enum_();
}
inline ::substrait::Expression_Enum* Expression::unsafe_arena_release_enum_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.Expression.enum)
  if (rex_type_case() == kEnum) {
    clear_has_rex_type();
    auto* temp = _impl_.rex_type_.enum__;
    _impl_.rex_type_.enum__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expression::unsafe_arena_set_allocated_enum_(::substrait::Expression_Enum* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_rex_type();
  if (value) {
    set_has_enum_();
    _impl_.rex_type_.enum__ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.Expression.enum)
}
inline ::substrait::Expression_Enum* Expression::_internal_mutable_enum_() {
  if (rex_type_case() != kEnum) {
    clear_rex_type();
    set_has_enum_();
    _impl_.rex_type_.enum__ =
        ::google::protobuf::Message::DefaultConstruct<::substrait::Expression_Enum>(GetArena());
  }
  return _impl_.rex_type_.enum__;
}
inline ::substrait::Expression_Enum* Expression::mutable_enum_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Expression_Enum* _msg = _internal_mutable_enum_();
  // @@protoc_insertion_point(field_mutable:substrait.Expression.enum)
  return _msg;
}

inline bool Expression::has_rex_type() const {
  return rex_type_case() != REX_TYPE_NOT_SET;
}
inline void Expression::clear_has_rex_type() {
  _impl_._oneof_case_[0] = REX_TYPE_NOT_SET;
}
inline Expression::RexTypeCase Expression::rex_type_case() const {
  return Expression::RexTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SortField

// .substrait.Expression expr = 1;
inline bool SortField::has_expr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.expr_ != nullptr);
  return value;
}
inline void SortField::clear_expr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.expr_ != nullptr) _impl_.expr_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::Expression& SortField::_internal_expr() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Expression* p = _impl_.expr_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Expression&>(::substrait::_Expression_default_instance_);
}
inline const ::substrait::Expression& SortField::expr() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.SortField.expr)
  return _internal_expr();
}
inline void SortField::unsafe_arena_set_allocated_expr(::substrait::Expression* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.expr_);
  }
  _impl_.expr_ = reinterpret_cast<::substrait::Expression*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.SortField.expr)
}
inline ::substrait::Expression* SortField::release_expr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Expression* released = _impl_.expr_;
  _impl_.expr_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Expression* SortField::unsafe_arena_release_expr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.SortField.expr)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Expression* temp = _impl_.expr_;
  _impl_.expr_ = nullptr;
  return temp;
}
inline ::substrait::Expression* SortField::_internal_mutable_expr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.expr_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Expression>(GetArena());
    _impl_.expr_ = reinterpret_cast<::substrait::Expression*>(p);
  }
  return _impl_.expr_;
}
inline ::substrait::Expression* SortField::mutable_expr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::Expression* _msg = _internal_mutable_expr();
  // @@protoc_insertion_point(field_mutable:substrait.SortField.expr)
  return _msg;
}
inline void SortField::set_allocated_expr(::substrait::Expression* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.expr_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.expr_ = reinterpret_cast<::substrait::Expression*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.SortField.expr)
}

// .substrait.SortField.SortDirection direction = 2;
inline bool SortField::has_direction() const {
  return sort_kind_case() == kDirection;
}
inline void SortField::set_has_direction() {
  _impl_._oneof_case_[0] = kDirection;
}
inline void SortField::clear_direction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (sort_kind_case() == kDirection) {
    _impl_.sort_kind_.direction_ = 0;
    clear_has_sort_kind();
  }
}
inline ::substrait::SortField_SortDirection SortField::direction() const {
  // @@protoc_insertion_point(field_get:substrait.SortField.direction)
  return _internal_direction();
}
inline void SortField::set_direction(::substrait::SortField_SortDirection value) {
  if (sort_kind_case() != kDirection) {
    clear_sort_kind();
    set_has_direction();
  }
  _impl_.sort_kind_.direction_ = value;
  // @@protoc_insertion_point(field_set:substrait.SortField.direction)
}
inline ::substrait::SortField_SortDirection SortField::_internal_direction() const {
  if (sort_kind_case() == kDirection) {
    return static_cast<::substrait::SortField_SortDirection>(_impl_.sort_kind_.direction_);
  }
  return static_cast<::substrait::SortField_SortDirection>(0);
}

// uint32 comparison_function_reference = 3;
inline bool SortField::has_comparison_function_reference() const {
  return sort_kind_case() == kComparisonFunctionReference;
}
inline void SortField::set_has_comparison_function_reference() {
  _impl_._oneof_case_[0] = kComparisonFunctionReference;
}
inline void SortField::clear_comparison_function_reference() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (sort_kind_case() == kComparisonFunctionReference) {
    _impl_.sort_kind_.comparison_function_reference_ = 0u;
    clear_has_sort_kind();
  }
}
inline ::uint32_t SortField::comparison_function_reference() const {
  // @@protoc_insertion_point(field_get:substrait.SortField.comparison_function_reference)
  return _internal_comparison_function_reference();
}
inline void SortField::set_comparison_function_reference(::uint32_t value) {
  if (sort_kind_case() != kComparisonFunctionReference) {
    clear_sort_kind();
    set_has_comparison_function_reference();
  }
  _impl_.sort_kind_.comparison_function_reference_ = value;
  // @@protoc_insertion_point(field_set:substrait.SortField.comparison_function_reference)
}
inline ::uint32_t SortField::_internal_comparison_function_reference() const {
  if (sort_kind_case() == kComparisonFunctionReference) {
    return _impl_.sort_kind_.comparison_function_reference_;
  }
  return 0u;
}

inline bool SortField::has_sort_kind() const {
  return sort_kind_case() != SORT_KIND_NOT_SET;
}
inline void SortField::clear_has_sort_kind() {
  _impl_._oneof_case_[0] = SORT_KIND_NOT_SET;
}
inline SortField::SortKindCase SortField::sort_kind_case() const {
  return SortField::SortKindCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AggregateFunction

// uint32 function_reference = 1;
inline void AggregateFunction::clear_function_reference() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.function_reference_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t AggregateFunction::function_reference() const {
  // @@protoc_insertion_point(field_get:substrait.AggregateFunction.function_reference)
  return _internal_function_reference();
}
inline void AggregateFunction::set_function_reference(::uint32_t value) {
  _internal_set_function_reference(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:substrait.AggregateFunction.function_reference)
}
inline ::uint32_t AggregateFunction::_internal_function_reference() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.function_reference_;
}
inline void AggregateFunction::_internal_set_function_reference(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.function_reference_ = value;
}

// repeated .substrait.FunctionArgument arguments = 7;
inline int AggregateFunction::_internal_arguments_size() const {
  return _internal_arguments().size();
}
inline int AggregateFunction::arguments_size() const {
  return _internal_arguments_size();
}
inline void AggregateFunction::clear_arguments() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.arguments_.Clear();
}
inline ::substrait::FunctionArgument* AggregateFunction::mutable_arguments(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.AggregateFunction.arguments)
  return _internal_mutable_arguments()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::FunctionArgument>* AggregateFunction::mutable_arguments()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.AggregateFunction.arguments)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_arguments();
}
inline const ::substrait::FunctionArgument& AggregateFunction::arguments(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.AggregateFunction.arguments)
  return _internal_arguments().Get(index);
}
inline ::substrait::FunctionArgument* AggregateFunction::add_arguments() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::FunctionArgument* _add = _internal_mutable_arguments()->Add();
  // @@protoc_insertion_point(field_add:substrait.AggregateFunction.arguments)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::FunctionArgument>& AggregateFunction::arguments() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.AggregateFunction.arguments)
  return _internal_arguments();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::FunctionArgument>&
AggregateFunction::_internal_arguments() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.arguments_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::FunctionArgument>*
AggregateFunction::_internal_mutable_arguments() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.arguments_;
}

// repeated .substrait.FunctionOption options = 8;
inline int AggregateFunction::_internal_options_size() const {
  return _internal_options().size();
}
inline int AggregateFunction::options_size() const {
  return _internal_options_size();
}
inline void AggregateFunction::clear_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.options_.Clear();
}
inline ::substrait::FunctionOption* AggregateFunction::mutable_options(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.AggregateFunction.options)
  return _internal_mutable_options()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::FunctionOption>* AggregateFunction::mutable_options()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.AggregateFunction.options)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_options();
}
inline const ::substrait::FunctionOption& AggregateFunction::options(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.AggregateFunction.options)
  return _internal_options().Get(index);
}
inline ::substrait::FunctionOption* AggregateFunction::add_options() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::FunctionOption* _add = _internal_mutable_options()->Add();
  // @@protoc_insertion_point(field_add:substrait.AggregateFunction.options)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::FunctionOption>& AggregateFunction::options() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.AggregateFunction.options)
  return _internal_options();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::FunctionOption>&
AggregateFunction::_internal_options() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.options_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::FunctionOption>*
AggregateFunction::_internal_mutable_options() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.options_;
}

// .substrait.Type output_type = 5;
inline bool AggregateFunction::has_output_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.output_type_ != nullptr);
  return value;
}
inline const ::substrait::Type& AggregateFunction::_internal_output_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::substrait::Type* p = _impl_.output_type_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::Type&>(::substrait::_Type_default_instance_);
}
inline const ::substrait::Type& AggregateFunction::output_type() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.AggregateFunction.output_type)
  return _internal_output_type();
}
inline void AggregateFunction::unsafe_arena_set_allocated_output_type(::substrait::Type* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.output_type_);
  }
  _impl_.output_type_ = reinterpret_cast<::substrait::Type*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.AggregateFunction.output_type)
}
inline ::substrait::Type* AggregateFunction::release_output_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Type* released = _impl_.output_type_;
  _impl_.output_type_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::substrait::Type* AggregateFunction::unsafe_arena_release_output_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:substrait.AggregateFunction.output_type)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::Type* temp = _impl_.output_type_;
  _impl_.output_type_ = nullptr;
  return temp;
}
inline ::substrait::Type* AggregateFunction::_internal_mutable_output_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.output_type_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::substrait::Type>(GetArena());
    _impl_.output_type_ = reinterpret_cast<::substrait::Type*>(p);
  }
  return _impl_.output_type_;
}
inline ::substrait::Type* AggregateFunction::mutable_output_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::substrait::Type* _msg = _internal_mutable_output_type();
  // @@protoc_insertion_point(field_mutable:substrait.AggregateFunction.output_type)
  return _msg;
}
inline void AggregateFunction::set_allocated_output_type(::substrait::Type* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.output_type_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.output_type_ = reinterpret_cast<::substrait::Type*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.AggregateFunction.output_type)
}

// .substrait.AggregationPhase phase = 4;
inline void AggregateFunction::clear_phase() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.phase_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::substrait::AggregationPhase AggregateFunction::phase() const {
  // @@protoc_insertion_point(field_get:substrait.AggregateFunction.phase)
  return _internal_phase();
}
inline void AggregateFunction::set_phase(::substrait::AggregationPhase value) {
  _internal_set_phase(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:substrait.AggregateFunction.phase)
}
inline ::substrait::AggregationPhase AggregateFunction::_internal_phase() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::substrait::AggregationPhase>(_impl_.phase_);
}
inline void AggregateFunction::_internal_set_phase(::substrait::AggregationPhase value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.phase_ = value;
}

// repeated .substrait.SortField sorts = 3;
inline int AggregateFunction::_internal_sorts_size() const {
  return _internal_sorts().size();
}
inline int AggregateFunction::sorts_size() const {
  return _internal_sorts_size();
}
inline void AggregateFunction::clear_sorts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sorts_.Clear();
}
inline ::substrait::SortField* AggregateFunction::mutable_sorts(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.AggregateFunction.sorts)
  return _internal_mutable_sorts()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::SortField>* AggregateFunction::mutable_sorts()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.AggregateFunction.sorts)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_sorts();
}
inline const ::substrait::SortField& AggregateFunction::sorts(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.AggregateFunction.sorts)
  return _internal_sorts().Get(index);
}
inline ::substrait::SortField* AggregateFunction::add_sorts() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::SortField* _add = _internal_mutable_sorts()->Add();
  // @@protoc_insertion_point(field_add:substrait.AggregateFunction.sorts)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::SortField>& AggregateFunction::sorts() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.AggregateFunction.sorts)
  return _internal_sorts();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::SortField>&
AggregateFunction::_internal_sorts() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sorts_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::SortField>*
AggregateFunction::_internal_mutable_sorts() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.sorts_;
}

// .substrait.AggregateFunction.AggregationInvocation invocation = 6;
inline void AggregateFunction::clear_invocation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.invocation_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::substrait::AggregateFunction_AggregationInvocation AggregateFunction::invocation() const {
  // @@protoc_insertion_point(field_get:substrait.AggregateFunction.invocation)
  return _internal_invocation();
}
inline void AggregateFunction::set_invocation(::substrait::AggregateFunction_AggregationInvocation value) {
  _internal_set_invocation(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:substrait.AggregateFunction.invocation)
}
inline ::substrait::AggregateFunction_AggregationInvocation AggregateFunction::_internal_invocation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::substrait::AggregateFunction_AggregationInvocation>(_impl_.invocation_);
}
inline void AggregateFunction::_internal_set_invocation(::substrait::AggregateFunction_AggregationInvocation value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.invocation_ = value;
}

// repeated .substrait.Expression args = 2 [deprecated = true];
inline int AggregateFunction::_internal_args_size() const {
  return _internal_args().size();
}
inline int AggregateFunction::args_size() const {
  return _internal_args_size();
}
inline void AggregateFunction::clear_args() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.args_.Clear();
}
inline ::substrait::Expression* AggregateFunction::mutable_args(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.AggregateFunction.args)
  return _internal_mutable_args()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression>* AggregateFunction::mutable_args()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.AggregateFunction.args)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_args();
}
inline const ::substrait::Expression& AggregateFunction::args(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.AggregateFunction.args)
  return _internal_args().Get(index);
}
inline ::substrait::Expression* AggregateFunction::add_args() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::substrait::Expression* _add = _internal_mutable_args()->Add();
  // @@protoc_insertion_point(field_add:substrait.AggregateFunction.args)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression>& AggregateFunction::args() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.AggregateFunction.args)
  return _internal_args();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::Expression>&
AggregateFunction::_internal_args() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.args_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::Expression>*
AggregateFunction::_internal_mutable_args() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.args_;
}

// -------------------------------------------------------------------

// ReferenceRel

// int32 subtree_ordinal = 1;
inline void ReferenceRel::clear_subtree_ordinal() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.subtree_ordinal_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t ReferenceRel::subtree_ordinal() const {
  // @@protoc_insertion_point(field_get:substrait.ReferenceRel.subtree_ordinal)
  return _internal_subtree_ordinal();
}
inline void ReferenceRel::set_subtree_ordinal(::int32_t value) {
  _internal_set_subtree_ordinal(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:substrait.ReferenceRel.subtree_ordinal)
}
inline ::int32_t ReferenceRel::_internal_subtree_ordinal() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.subtree_ordinal_;
}
inline void ReferenceRel::_internal_set_subtree_ordinal(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.subtree_ordinal_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace substrait


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::substrait::JoinRel_JoinType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::substrait::JoinRel_JoinType>() {
  return ::substrait::JoinRel_JoinType_descriptor();
}
template <>
struct is_proto_enum<::substrait::SetRel_SetOp> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::substrait::SetRel_SetOp>() {
  return ::substrait::SetRel_SetOp_descriptor();
}
template <>
struct is_proto_enum<::substrait::DdlRel_DdlObject> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::substrait::DdlRel_DdlObject>() {
  return ::substrait::DdlRel_DdlObject_descriptor();
}
template <>
struct is_proto_enum<::substrait::DdlRel_DdlOp> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::substrait::DdlRel_DdlOp>() {
  return ::substrait::DdlRel_DdlOp_descriptor();
}
template <>
struct is_proto_enum<::substrait::WriteRel_WriteOp> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::substrait::WriteRel_WriteOp>() {
  return ::substrait::WriteRel_WriteOp_descriptor();
}
template <>
struct is_proto_enum<::substrait::WriteRel_OutputMode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::substrait::WriteRel_OutputMode>() {
  return ::substrait::WriteRel_OutputMode_descriptor();
}
template <>
struct is_proto_enum<::substrait::ComparisonJoinKey_SimpleComparisonType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::substrait::ComparisonJoinKey_SimpleComparisonType>() {
  return ::substrait::ComparisonJoinKey_SimpleComparisonType_descriptor();
}
template <>
struct is_proto_enum<::substrait::HashJoinRel_JoinType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::substrait::HashJoinRel_JoinType>() {
  return ::substrait::HashJoinRel_JoinType_descriptor();
}
template <>
struct is_proto_enum<::substrait::MergeJoinRel_JoinType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::substrait::MergeJoinRel_JoinType>() {
  return ::substrait::MergeJoinRel_JoinType_descriptor();
}
template <>
struct is_proto_enum<::substrait::NestedLoopJoinRel_JoinType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::substrait::NestedLoopJoinRel_JoinType>() {
  return ::substrait::NestedLoopJoinRel_JoinType_descriptor();
}
template <>
struct is_proto_enum<::substrait::Expression_WindowFunction_BoundsType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::substrait::Expression_WindowFunction_BoundsType>() {
  return ::substrait::Expression_WindowFunction_BoundsType_descriptor();
}
template <>
struct is_proto_enum<::substrait::Expression_Cast_FailureBehavior> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::substrait::Expression_Cast_FailureBehavior>() {
  return ::substrait::Expression_Cast_FailureBehavior_descriptor();
}
template <>
struct is_proto_enum<::substrait::Expression_Subquery_SetPredicate_PredicateOp> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::substrait::Expression_Subquery_SetPredicate_PredicateOp>() {
  return ::substrait::Expression_Subquery_SetPredicate_PredicateOp_descriptor();
}
template <>
struct is_proto_enum<::substrait::Expression_Subquery_SetComparison_ComparisonOp> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::substrait::Expression_Subquery_SetComparison_ComparisonOp>() {
  return ::substrait::Expression_Subquery_SetComparison_ComparisonOp_descriptor();
}
template <>
struct is_proto_enum<::substrait::Expression_Subquery_SetComparison_ReductionOp> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::substrait::Expression_Subquery_SetComparison_ReductionOp>() {
  return ::substrait::Expression_Subquery_SetComparison_ReductionOp_descriptor();
}
template <>
struct is_proto_enum<::substrait::SortField_SortDirection> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::substrait::SortField_SortDirection>() {
  return ::substrait::SortField_SortDirection_descriptor();
}
template <>
struct is_proto_enum<::substrait::AggregateFunction_AggregationInvocation> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::substrait::AggregateFunction_AggregationInvocation>() {
  return ::substrait::AggregateFunction_AggregationInvocation_descriptor();
}
template <>
struct is_proto_enum<::substrait::AggregationPhase> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::substrait::AggregationPhase>() {
  return ::substrait::AggregationPhase_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // substrait_2falgebra_2eproto_2epb_2eh
