<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Using the Arrow C++ Library in R</title>

<script>// Hide empty <a> tag within highlighted CodeBlock for screen reader accessibility (see https://github.com/jgm/pandoc/issues/6352#issuecomment-626106786) -->
// v0.0.1
// Written by JooYoung Seo (jooyoung@psu.edu) and Atsushi Yasumoto on June 1st, 2020.

document.addEventListener('DOMContentLoaded', function() {
  const codeList = document.getElementsByClassName("sourceCode");
  for (var i = 0; i < codeList.length; i++) {
    var linkList = codeList[i].getElementsByTagName('a');
    for (var j = 0; j < linkList.length; j++) {
      if (linkList[j].innerHTML === "") {
        linkList[j].setAttribute('aria-hidden', 'true');
      }
    }
  }
});
</script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>


<style type="text/css">
  code {
    white-space: pre;
  }
  .sourceCode {
    overflow: visible;
  }
</style>
<style type="text/css" data-origin="pandoc">
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Using the Arrow C++ Library in R</h1>



<p>The Apache Arrow C++ library provides rich, powerful features for working with columnar data. The <code>arrow</code> R package provides both a low-level interface to the C++ library and some higher-level, R-flavored tools for working with it. This vignette provides an overview of how the pieces fit together, and it describes the conventions that the classes and methods follow in R.</p>
<div id="features" class="section level1">
<h1>Features</h1>
<div id="multi-file-datasets" class="section level2">
<h2>Multi-file datasets</h2>
<p>The <code>arrow</code> package lets you work efficiently with large, multi-file datasets using <code>dplyr</code> methods. See <code>vignette(&quot;dataset&quot;, package = &quot;arrow&quot;)</code> for an overview.</p>
</div>
<div id="reading-and-writing-files" class="section level2">
<h2>Reading and writing files</h2>
<p><code>arrow</code> provides some simple functions for using the Arrow C++ library to read and write files. These functions are designed to drop into your normal R workflow without requiring any knowledge of the Arrow C++ library and use naming conventions and arguments that follow popular R packages, particularly <code>readr</code>. The readers return <code>data.frame</code>s (or if you use the <code>tibble</code> package, they will act like <code>tbl_df</code>s), and the writers take <code>data.frame</code>s.</p>
<p>Importantly, <code>arrow</code> provides basic read and write support for the <a href="https://parquet.apache.org/">Apache Parquet</a> columnar data file format.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">library</span>(arrow)</span>
<span id="cb1-2"><a href="#cb1-2"></a>df &lt;-<span class="st"> </span><span class="kw">read_parquet</span>(<span class="st">&quot;path/to/file.parquet&quot;</span>)</span></code></pre></div>
<p>Just as you can read, you can write Parquet files:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">write_parquet</span>(df, <span class="st">&quot;path/to/different_file.parquet&quot;</span>)</span></code></pre></div>
<p>The <code>arrow</code> package also includes a faster and more robust implementation of the <a href="https://github.com/wesm/feather">Feather</a> file format, providing <code>read_feather()</code> and <code>write_feather()</code>. This implementation depends on the same underlying C++ library as the Python version does, resulting in more reliable and consistent behavior across the two languages, as well as <a href="https://wesmckinney.com/blog/feather-arrow-future/">improved performance</a>. <code>arrow</code> also by default writes the Feather V2 format, which supports a wider range of data types, as well as compression.</p>
<p>For CSV and line-delimited JSON, there are <code>read_csv_arrow()</code> and <code>read_json_arrow()</code>, respectively. While <code>read_csv_arrow()</code> currently has fewer parsing options for dealing with every CSV format variation in the wild, for the files it can read, it is often significantly faster than other R CSV readers, such as <code>base::read.csv</code>, <code>readr::read_csv</code>, and <code>data.table::fread</code>.</p>
</div>
<div id="working-with-arrow-data-in-python" class="section level2">
<h2>Working with Arrow data in Python</h2>
<p>Using <a href="https://rstudio.github.io/reticulate/"><code>reticulate</code></a>, <code>arrow</code> lets you share data between R and Python (<code>pyarrow</code>) efficiently, enabling you to take advantage of the vibrant ecosystem of Python packages that build on top of Apache Arrow. See <code>vignette(&quot;python&quot;, package = &quot;arrow&quot;)</code> for details.</p>
</div>
<div id="access-to-arrow-messages-buffers-and-streams" class="section level2">
<h2>Access to Arrow messages, buffers, and streams</h2>
<p>The <code>arrow</code> package also provides many lower-level bindings to the C++ library, which enable you to access and manipulate Arrow objects. You can use these to build connectors to other applications and services that use Arrow. One example is Spark: the <a href="https://spark.rstudio.com/"><code>sparklyr</code></a> package has support for using Arrow to move data to and from Spark, yielding <a href="http://arrow.apache.org/blog/2019/01/25/r-spark-improvements/">significant performance gains</a>.</p>
</div>
</div>
<div id="internals" class="section level1">
<h1>Internals</h1>
<div id="mapping-of-r-arrow-types" class="section level2">
<h2>Mapping of R &lt;–&gt; Arrow types</h2>
<p>Arrow has a rich data type system that includes direct parallels with R’s data types and much more.</p>
<p>In the tables, entries with a <code>-</code> are not currently implemented.</p>
<div id="r-to-arrow" class="section level3">
<h3>R to Arrow</h3>
<table>
<thead>
<tr class="header">
<th>R type</th>
<th>Arrow type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>logical</td>
<td>boolean</td>
</tr>
<tr class="even">
<td>integer</td>
<td>int32</td>
</tr>
<tr class="odd">
<td>double (“numeric”)</td>
<td>float64</td>
</tr>
<tr class="even">
<td>character</td>
<td>utf8<sup>1</sup></td>
</tr>
<tr class="odd">
<td>factor</td>
<td>dictionary</td>
</tr>
<tr class="even">
<td>raw</td>
<td>uint8</td>
</tr>
<tr class="odd">
<td>Date</td>
<td>date32</td>
</tr>
<tr class="even">
<td>POSIXct</td>
<td>timestamp</td>
</tr>
<tr class="odd">
<td>POSIXlt</td>
<td>struct</td>
</tr>
<tr class="even">
<td>data.frame</td>
<td>struct</td>
</tr>
<tr class="odd">
<td>list<sup>2</sup></td>
<td>list</td>
</tr>
<tr class="even">
<td>bit64::integer64</td>
<td>int64</td>
</tr>
<tr class="odd">
<td>difftime</td>
<td>time32</td>
</tr>
<tr class="even">
<td>vctrs::vctrs_unspecified</td>
<td>null</td>
</tr>
</tbody>
</table>
<p><sup>1</sup>: If the character vector exceeds 2GB of strings, it will be converted to a <code>large_utf8</code> Arrow type</p>
<p><sup>2</sup>: Only lists where all elements are the same type are able to be translated to Arrow list type (which is a “list of” some type).</p>
</div>
<div id="arrow-to-r" class="section level3">
<h3>Arrow to R</h3>
<table>
<thead>
<tr class="header">
<th>Arrow type</th>
<th>R type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>boolean</td>
<td>logical</td>
</tr>
<tr class="even">
<td>int8</td>
<td>integer</td>
</tr>
<tr class="odd">
<td>int16</td>
<td>integer</td>
</tr>
<tr class="even">
<td>int32</td>
<td>integer</td>
</tr>
<tr class="odd">
<td>int64</td>
<td>integer<sup>3</sup></td>
</tr>
<tr class="even">
<td>uint8</td>
<td>integer</td>
</tr>
<tr class="odd">
<td>uint16</td>
<td>integer</td>
</tr>
<tr class="even">
<td>uint32</td>
<td>integer<sup>3</sup></td>
</tr>
<tr class="odd">
<td>uint64</td>
<td>integer<sup>3</sup></td>
</tr>
<tr class="even">
<td>float16</td>
<td>-</td>
</tr>
<tr class="odd">
<td>float32</td>
<td>double</td>
</tr>
<tr class="even">
<td>float64</td>
<td>double</td>
</tr>
<tr class="odd">
<td>utf8</td>
<td>character</td>
</tr>
<tr class="even">
<td>binary</td>
<td>arrow_binary <sup>5</sup></td>
</tr>
<tr class="odd">
<td>fixed_size_binary</td>
<td>arrow_fixed_size_binary <sup>5</sup></td>
</tr>
<tr class="even">
<td>date32</td>
<td>Date</td>
</tr>
<tr class="odd">
<td>date64</td>
<td>POSIXct</td>
</tr>
<tr class="even">
<td>time32</td>
<td>hms::difftime</td>
</tr>
<tr class="odd">
<td>time64</td>
<td>hms::difftime</td>
</tr>
<tr class="even">
<td>timestamp</td>
<td>POSIXct</td>
</tr>
<tr class="odd">
<td>duration</td>
<td>-</td>
</tr>
<tr class="even">
<td>decimal</td>
<td>double</td>
</tr>
<tr class="odd">
<td>dictionary</td>
<td>factor<sup>4</sup></td>
</tr>
<tr class="even">
<td>list</td>
<td>arrow_list <sup>6</sup></td>
</tr>
<tr class="odd">
<td>fixed_size_list</td>
<td>arrow_fixed_size_list <sup>6</sup></td>
</tr>
<tr class="even">
<td>struct</td>
<td>data.frame</td>
</tr>
<tr class="odd">
<td>null</td>
<td>vctrs::vctrs_unspecified</td>
</tr>
<tr class="even">
<td>map</td>
<td>-</td>
</tr>
<tr class="odd">
<td>union</td>
<td>-</td>
</tr>
<tr class="even">
<td>large_utf8</td>
<td>character</td>
</tr>
<tr class="odd">
<td>large_binary</td>
<td>arrow_large_binary <sup>5</sup></td>
</tr>
<tr class="even">
<td>large_list</td>
<td>arrow_large_list <sup>6</sup></td>
</tr>
</tbody>
</table>
<p><sup>3</sup>: These integer types may contain values that exceed the range of R’s <code>integer</code> type (32-bit signed integer). When they do, <code>uint32</code> and <code>uint64</code> are converted to <code>double</code> (“numeric”) and <code>int64</code> is converted to <code>bit64::integer64</code>.</p>
<p><sup>4</sup>: Due to the limitation of R <code>factor</code>s, Arrow <code>dictionary</code> values are coerced to string when translated to R if they are not already strings.</p>
<p><sup>5</sup>: <code>arrow*_binary</code> classes are implemented as lists of raw vectors.</p>
<p><sup>6</sup>: <code>arrow*_list</code> classes are implemented as subclasses of <code>vctrs_list_of</code> with a <code>ptype</code> attribute set to what an empty Array of the value type converts to.</p>
</div>
<div id="r-object-attributes" class="section level3">
<h3>R object attributes</h3>
<p>Arrow supports custom key-value metadata attached to Schemas. When we convert a <code>data.frame</code> to an Arrow Table or RecordBatch, the package stores any <code>attributes()</code> attached to the columns of the <code>data.frame</code> in the Arrow object’s Schema. These attributes are stored under the “r” key; you can assign additional string metadata under any other key you wish, like <code>x$metadata$new_key &lt;- &quot;new value&quot;</code>.</p>
<p>This metadata is preserved when writing the table to Feather or Parquet, and when reading those files into R, or when calling <code>as.data.frame()</code> on a Table/RecordBatch, the column attributes are restored to the columns of the resulting <code>data.frame</code>. This means that custom data types, including <code>haven::labelled</code>, <code>vctrs</code> annotations, and others, are preserved when doing a round-trip through Arrow.</p>
<p>Note that the <code>attributes()</code> stored in <code>$metadata$r</code> are only understood by R. If you write a <code>data.frame</code> with <code>haven</code> columns to a Feather file and read that in Pandas, the <code>haven</code> metadata won’t be recognized there. (Similarly, Pandas writes its own custom metadata, which the R package does not consume.) You are free, however, to define custom metadata conventions for your application and assign any (string) values you want to other metadata keys. For more details, see the documentation for <code>schema()</code>.</p>
</div>
</div>
<div id="class-structure-and-package-conventions" class="section level2">
<h2>Class structure and package conventions</h2>
<p>C++ is an object-oriented language, so the core logic of the Arrow library is encapsulated in classes and methods. In the R package, these classes are implemented as <code>R6</code> reference classes, most of which are exported from the namespace.</p>
<p>In order to match the C++ naming conventions, the <code>R6</code> classes are in TitleCase, e.g. <code>RecordBatch</code>. This makes it easy to look up the relevant C++ implementations in the <a href="https://github.com/apache/arrow/tree/master/cpp">code</a> or <a href="https://arrow.apache.org/docs/cpp/">documentation</a>. To simplify things in R, the C++ library namespaces are generally dropped or flattened; that is, where the C++ library has <code>arrow::io::FileOutputStream</code>, it is just <code>FileOutputStream</code> in the R package. One exception is for the file readers, where the namespace is necessary to disambiguate. So <code>arrow::csv::TableReader</code> becomes <code>CsvTableReader</code>, and <code>arrow::json::TableReader</code> becomes <code>JsonTableReader</code>.</p>
<p>Some of these classes are not meant to be instantiated directly; they may be base classes or other kinds of helpers. For those that you should be able to create, use the <code>$create()</code> method to instantiate an object. For example, <code>rb &lt;- RecordBatch$create(int = 1:10, dbl = as.numeric(1:10))</code> will create a <code>RecordBatch</code>. Many of these factory methods that an R user might most often encounter also have a <code>snake_case</code> alias, in order to be more familiar for contemporary R users. So <code>record_batch(int = 1:10, dbl = as.numeric(1:10))</code> would do the same as <code>RecordBatch$create()</code> above.</p>
<p>The typical user of the <code>arrow</code> R package may never deal directly with the <code>R6</code> objects. We provide more R-friendly wrapper functions as a higher-level interface to the C++ library. An R user can call <code>read_parquet()</code> without knowing or caring that they’re instantiating a <code>ParquetFileReader</code> object and calling the <code>$ReadFile()</code> method on it. The classes are there and available to the advanced programmer who wants fine-grained control over how the C++ library is used.</p>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
