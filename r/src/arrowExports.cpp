// Generated by using data-raw/codegen.R -> do not edit by hand
#include <cpp11.hpp>
#include <cpp11/declarations.hpp>

#include "./arrow_types.h"

// altrep.cpp
bool is_arrow_altrep(cpp11::sexp x);
extern "C" SEXP _arrow_is_arrow_altrep(SEXP x_sexp){
BEGIN_CPP11
	arrow::r::Input<cpp11::sexp>::type x(x_sexp);
	return cpp11::as_sexp(is_arrow_altrep(x));
END_CPP11
}
// altrep.cpp
void test_arrow_altrep_set_string_elt(sexp x, int i, std::string value);
extern "C" SEXP _arrow_test_arrow_altrep_set_string_elt(SEXP x_sexp, SEXP i_sexp, SEXP value_sexp){
BEGIN_CPP11
	arrow::r::Input<sexp>::type x(x_sexp);
	arrow::r::Input<int>::type i(i_sexp);
	arrow::r::Input<std::string>::type value(value_sexp);
	test_arrow_altrep_set_string_elt(x, i, value);
	return R_NilValue;
END_CPP11
}
// altrep.cpp
sexp test_arrow_altrep_is_materialized(sexp x);
extern "C" SEXP _arrow_test_arrow_altrep_is_materialized(SEXP x_sexp){
BEGIN_CPP11
	arrow::r::Input<sexp>::type x(x_sexp);
	return cpp11::as_sexp(test_arrow_altrep_is_materialized(x));
END_CPP11
}
// altrep.cpp
bool test_arrow_altrep_force_materialize(sexp x);
extern "C" SEXP _arrow_test_arrow_altrep_force_materialize(SEXP x_sexp){
BEGIN_CPP11
	arrow::r::Input<sexp>::type x(x_sexp);
	return cpp11::as_sexp(test_arrow_altrep_force_materialize(x));
END_CPP11
}
// altrep.cpp
sexp test_arrow_altrep_copy_by_element(sexp x);
extern "C" SEXP _arrow_test_arrow_altrep_copy_by_element(SEXP x_sexp){
BEGIN_CPP11
	arrow::r::Input<sexp>::type x(x_sexp);
	return cpp11::as_sexp(test_arrow_altrep_copy_by_element(x));
END_CPP11
}
// altrep.cpp
sexp test_arrow_altrep_copy_by_region(sexp x, R_xlen_t region_size);
extern "C" SEXP _arrow_test_arrow_altrep_copy_by_region(SEXP x_sexp, SEXP region_size_sexp){
BEGIN_CPP11
	arrow::r::Input<sexp>::type x(x_sexp);
	arrow::r::Input<R_xlen_t>::type region_size(region_size_sexp);
	return cpp11::as_sexp(test_arrow_altrep_copy_by_region(x, region_size));
END_CPP11
}
// altrep.cpp
sexp test_arrow_altrep_copy_by_dataptr(sexp x);
extern "C" SEXP _arrow_test_arrow_altrep_copy_by_dataptr(SEXP x_sexp){
BEGIN_CPP11
	arrow::r::Input<sexp>::type x(x_sexp);
	return cpp11::as_sexp(test_arrow_altrep_copy_by_dataptr(x));
END_CPP11
}
// array.cpp
std::shared_ptr<arrow::Array> Array__Slice1(const std::shared_ptr<arrow::Array>& array, R_xlen_t offset);
extern "C" SEXP _arrow_Array__Slice1(SEXP array_sexp, SEXP offset_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Array>&>::type array(array_sexp);
	arrow::r::Input<R_xlen_t>::type offset(offset_sexp);
	return cpp11::as_sexp(Array__Slice1(array, offset));
END_CPP11
}
// array.cpp
std::shared_ptr<arrow::Array> Array__Slice2(const std::shared_ptr<arrow::Array>& array, R_xlen_t offset, R_xlen_t length);
extern "C" SEXP _arrow_Array__Slice2(SEXP array_sexp, SEXP offset_sexp, SEXP length_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Array>&>::type array(array_sexp);
	arrow::r::Input<R_xlen_t>::type offset(offset_sexp);
	arrow::r::Input<R_xlen_t>::type length(length_sexp);
	return cpp11::as_sexp(Array__Slice2(array, offset, length));
END_CPP11
}
// array.cpp
bool Array__IsNull(const std::shared_ptr<arrow::Array>& x, R_xlen_t i);
extern "C" SEXP _arrow_Array__IsNull(SEXP x_sexp, SEXP i_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Array>&>::type x(x_sexp);
	arrow::r::Input<R_xlen_t>::type i(i_sexp);
	return cpp11::as_sexp(Array__IsNull(x, i));
END_CPP11
}
// array.cpp
bool Array__IsValid(const std::shared_ptr<arrow::Array>& x, R_xlen_t i);
extern "C" SEXP _arrow_Array__IsValid(SEXP x_sexp, SEXP i_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Array>&>::type x(x_sexp);
	arrow::r::Input<R_xlen_t>::type i(i_sexp);
	return cpp11::as_sexp(Array__IsValid(x, i));
END_CPP11
}
// array.cpp
r_vec_size Array__length(const std::shared_ptr<arrow::Array>& x);
extern "C" SEXP _arrow_Array__length(SEXP x_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Array>&>::type x(x_sexp);
	return cpp11::as_sexp(Array__length(x));
END_CPP11
}
// array.cpp
int Array__offset(const std::shared_ptr<arrow::Array>& x);
extern "C" SEXP _arrow_Array__offset(SEXP x_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Array>&>::type x(x_sexp);
	return cpp11::as_sexp(Array__offset(x));
END_CPP11
}
// array.cpp
int Array__null_count(const std::shared_ptr<arrow::Array>& x);
extern "C" SEXP _arrow_Array__null_count(SEXP x_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Array>&>::type x(x_sexp);
	return cpp11::as_sexp(Array__null_count(x));
END_CPP11
}
// array.cpp
std::shared_ptr<arrow::DataType> Array__type(const std::shared_ptr<arrow::Array>& x);
extern "C" SEXP _arrow_Array__type(SEXP x_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Array>&>::type x(x_sexp);
	return cpp11::as_sexp(Array__type(x));
END_CPP11
}
// array.cpp
std::string Array__ToString(const std::shared_ptr<arrow::Array>& x);
extern "C" SEXP _arrow_Array__ToString(SEXP x_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Array>&>::type x(x_sexp);
	return cpp11::as_sexp(Array__ToString(x));
END_CPP11
}
// array.cpp
arrow::Type::type Array__type_id(const std::shared_ptr<arrow::Array>& x);
extern "C" SEXP _arrow_Array__type_id(SEXP x_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Array>&>::type x(x_sexp);
	return cpp11::as_sexp(Array__type_id(x));
END_CPP11
}
// array.cpp
bool Array__Equals(const std::shared_ptr<arrow::Array>& lhs, const std::shared_ptr<arrow::Array>& rhs);
extern "C" SEXP _arrow_Array__Equals(SEXP lhs_sexp, SEXP rhs_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Array>&>::type lhs(lhs_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::Array>&>::type rhs(rhs_sexp);
	return cpp11::as_sexp(Array__Equals(lhs, rhs));
END_CPP11
}
// array.cpp
bool Array__ApproxEquals(const std::shared_ptr<arrow::Array>& lhs, const std::shared_ptr<arrow::Array>& rhs);
extern "C" SEXP _arrow_Array__ApproxEquals(SEXP lhs_sexp, SEXP rhs_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Array>&>::type lhs(lhs_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::Array>&>::type rhs(rhs_sexp);
	return cpp11::as_sexp(Array__ApproxEquals(lhs, rhs));
END_CPP11
}
// array.cpp
std::string Array__Diff(const std::shared_ptr<arrow::Array>& lhs, const std::shared_ptr<arrow::Array>& rhs);
extern "C" SEXP _arrow_Array__Diff(SEXP lhs_sexp, SEXP rhs_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Array>&>::type lhs(lhs_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::Array>&>::type rhs(rhs_sexp);
	return cpp11::as_sexp(Array__Diff(lhs, rhs));
END_CPP11
}
// array.cpp
std::shared_ptr<arrow::ArrayData> Array__data(const std::shared_ptr<arrow::Array>& array);
extern "C" SEXP _arrow_Array__data(SEXP array_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Array>&>::type array(array_sexp);
	return cpp11::as_sexp(Array__data(array));
END_CPP11
}
// array.cpp
bool Array__RangeEquals(const std::shared_ptr<arrow::Array>& self, const std::shared_ptr<arrow::Array>& other, R_xlen_t start_idx, R_xlen_t end_idx, R_xlen_t other_start_idx);
extern "C" SEXP _arrow_Array__RangeEquals(SEXP self_sexp, SEXP other_sexp, SEXP start_idx_sexp, SEXP end_idx_sexp, SEXP other_start_idx_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Array>&>::type self(self_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::Array>&>::type other(other_sexp);
	arrow::r::Input<R_xlen_t>::type start_idx(start_idx_sexp);
	arrow::r::Input<R_xlen_t>::type end_idx(end_idx_sexp);
	arrow::r::Input<R_xlen_t>::type other_start_idx(other_start_idx_sexp);
	return cpp11::as_sexp(Array__RangeEquals(self, other, start_idx, end_idx, other_start_idx));
END_CPP11
}
// array.cpp
std::shared_ptr<arrow::Array> Array__View(const std::shared_ptr<arrow::Array>& array, const std::shared_ptr<arrow::DataType>& type);
extern "C" SEXP _arrow_Array__View(SEXP array_sexp, SEXP type_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Array>&>::type array(array_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::DataType>&>::type type(type_sexp);
	return cpp11::as_sexp(Array__View(array, type));
END_CPP11
}
// array.cpp
void Array__Validate(const std::shared_ptr<arrow::Array>& array);
extern "C" SEXP _arrow_Array__Validate(SEXP array_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Array>&>::type array(array_sexp);
	Array__Validate(array);
	return R_NilValue;
END_CPP11
}
// array.cpp
std::shared_ptr<arrow::Array> DictionaryArray__indices(const std::shared_ptr<arrow::DictionaryArray>& array);
extern "C" SEXP _arrow_DictionaryArray__indices(SEXP array_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::DictionaryArray>&>::type array(array_sexp);
	return cpp11::as_sexp(DictionaryArray__indices(array));
END_CPP11
}
// array.cpp
std::shared_ptr<arrow::Array> DictionaryArray__dictionary(const std::shared_ptr<arrow::DictionaryArray>& array);
extern "C" SEXP _arrow_DictionaryArray__dictionary(SEXP array_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::DictionaryArray>&>::type array(array_sexp);
	return cpp11::as_sexp(DictionaryArray__dictionary(array));
END_CPP11
}
// array.cpp
std::shared_ptr<arrow::Array> StructArray__field(const std::shared_ptr<arrow::StructArray>& array, int i);
extern "C" SEXP _arrow_StructArray__field(SEXP array_sexp, SEXP i_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::StructArray>&>::type array(array_sexp);
	arrow::r::Input<int>::type i(i_sexp);
	return cpp11::as_sexp(StructArray__field(array, i));
END_CPP11
}
// array.cpp
std::shared_ptr<arrow::Array> StructArray__GetFieldByName(const std::shared_ptr<arrow::StructArray>& array, const std::string& name);
extern "C" SEXP _arrow_StructArray__GetFieldByName(SEXP array_sexp, SEXP name_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::StructArray>&>::type array(array_sexp);
	arrow::r::Input<const std::string&>::type name(name_sexp);
	return cpp11::as_sexp(StructArray__GetFieldByName(array, name));
END_CPP11
}
// array.cpp
std::shared_ptr<arrow::StructArray> StructArray__from_RecordBatch(const std::shared_ptr<arrow::RecordBatch>& batch);
extern "C" SEXP _arrow_StructArray__from_RecordBatch(SEXP batch_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::RecordBatch>&>::type batch(batch_sexp);
	return cpp11::as_sexp(StructArray__from_RecordBatch(batch));
END_CPP11
}
// array.cpp
cpp11::list StructArray__Flatten(const std::shared_ptr<arrow::StructArray>& array);
extern "C" SEXP _arrow_StructArray__Flatten(SEXP array_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::StructArray>&>::type array(array_sexp);
	return cpp11::as_sexp(StructArray__Flatten(array));
END_CPP11
}
// array.cpp
std::shared_ptr<arrow::DataType> ListArray__value_type(const std::shared_ptr<arrow::ListArray>& array);
extern "C" SEXP _arrow_ListArray__value_type(SEXP array_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::ListArray>&>::type array(array_sexp);
	return cpp11::as_sexp(ListArray__value_type(array));
END_CPP11
}
// array.cpp
std::shared_ptr<arrow::DataType> LargeListArray__value_type(const std::shared_ptr<arrow::LargeListArray>& array);
extern "C" SEXP _arrow_LargeListArray__value_type(SEXP array_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::LargeListArray>&>::type array(array_sexp);
	return cpp11::as_sexp(LargeListArray__value_type(array));
END_CPP11
}
// array.cpp
std::shared_ptr<arrow::Array> ListArray__values(const std::shared_ptr<arrow::ListArray>& array);
extern "C" SEXP _arrow_ListArray__values(SEXP array_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::ListArray>&>::type array(array_sexp);
	return cpp11::as_sexp(ListArray__values(array));
END_CPP11
}
// array.cpp
std::shared_ptr<arrow::Array> LargeListArray__values(const std::shared_ptr<arrow::LargeListArray>& array);
extern "C" SEXP _arrow_LargeListArray__values(SEXP array_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::LargeListArray>&>::type array(array_sexp);
	return cpp11::as_sexp(LargeListArray__values(array));
END_CPP11
}
// array.cpp
int32_t ListArray__value_length(const std::shared_ptr<arrow::ListArray>& array, int64_t i);
extern "C" SEXP _arrow_ListArray__value_length(SEXP array_sexp, SEXP i_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::ListArray>&>::type array(array_sexp);
	arrow::r::Input<int64_t>::type i(i_sexp);
	return cpp11::as_sexp(ListArray__value_length(array, i));
END_CPP11
}
// array.cpp
r_vec_size LargeListArray__value_length(const std::shared_ptr<arrow::LargeListArray>& array, int64_t i);
extern "C" SEXP _arrow_LargeListArray__value_length(SEXP array_sexp, SEXP i_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::LargeListArray>&>::type array(array_sexp);
	arrow::r::Input<int64_t>::type i(i_sexp);
	return cpp11::as_sexp(LargeListArray__value_length(array, i));
END_CPP11
}
// array.cpp
r_vec_size FixedSizeListArray__value_length(const std::shared_ptr<arrow::FixedSizeListArray>& array, int64_t i);
extern "C" SEXP _arrow_FixedSizeListArray__value_length(SEXP array_sexp, SEXP i_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::FixedSizeListArray>&>::type array(array_sexp);
	arrow::r::Input<int64_t>::type i(i_sexp);
	return cpp11::as_sexp(FixedSizeListArray__value_length(array, i));
END_CPP11
}
// array.cpp
int32_t ListArray__value_offset(const std::shared_ptr<arrow::ListArray>& array, int64_t i);
extern "C" SEXP _arrow_ListArray__value_offset(SEXP array_sexp, SEXP i_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::ListArray>&>::type array(array_sexp);
	arrow::r::Input<int64_t>::type i(i_sexp);
	return cpp11::as_sexp(ListArray__value_offset(array, i));
END_CPP11
}
// array.cpp
r_vec_size LargeListArray__value_offset(const std::shared_ptr<arrow::LargeListArray>& array, int64_t i);
extern "C" SEXP _arrow_LargeListArray__value_offset(SEXP array_sexp, SEXP i_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::LargeListArray>&>::type array(array_sexp);
	arrow::r::Input<int64_t>::type i(i_sexp);
	return cpp11::as_sexp(LargeListArray__value_offset(array, i));
END_CPP11
}
// array.cpp
r_vec_size FixedSizeListArray__value_offset(const std::shared_ptr<arrow::FixedSizeListArray>& array, int64_t i);
extern "C" SEXP _arrow_FixedSizeListArray__value_offset(SEXP array_sexp, SEXP i_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::FixedSizeListArray>&>::type array(array_sexp);
	arrow::r::Input<int64_t>::type i(i_sexp);
	return cpp11::as_sexp(FixedSizeListArray__value_offset(array, i));
END_CPP11
}
// array.cpp
cpp11::writable::integers ListArray__raw_value_offsets(const std::shared_ptr<arrow::ListArray>& array);
extern "C" SEXP _arrow_ListArray__raw_value_offsets(SEXP array_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::ListArray>&>::type array(array_sexp);
	return cpp11::as_sexp(ListArray__raw_value_offsets(array));
END_CPP11
}
// array.cpp
cpp11::writable::integers LargeListArray__raw_value_offsets(const std::shared_ptr<arrow::LargeListArray>& array);
extern "C" SEXP _arrow_LargeListArray__raw_value_offsets(SEXP array_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::LargeListArray>&>::type array(array_sexp);
	return cpp11::as_sexp(LargeListArray__raw_value_offsets(array));
END_CPP11
}
// array.cpp
std::shared_ptr<arrow::Array> MapArray__keys(const std::shared_ptr<arrow::MapArray>& array);
extern "C" SEXP _arrow_MapArray__keys(SEXP array_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::MapArray>&>::type array(array_sexp);
	return cpp11::as_sexp(MapArray__keys(array));
END_CPP11
}
// array.cpp
std::shared_ptr<arrow::Array> MapArray__items(const std::shared_ptr<arrow::MapArray>& array);
extern "C" SEXP _arrow_MapArray__items(SEXP array_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::MapArray>&>::type array(array_sexp);
	return cpp11::as_sexp(MapArray__items(array));
END_CPP11
}
// array.cpp
std::shared_ptr<arrow::Array> MapArray__keys_nested(const std::shared_ptr<arrow::MapArray>& array);
extern "C" SEXP _arrow_MapArray__keys_nested(SEXP array_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::MapArray>&>::type array(array_sexp);
	return cpp11::as_sexp(MapArray__keys_nested(array));
END_CPP11
}
// array.cpp
std::shared_ptr<arrow::Array> MapArray__items_nested(const std::shared_ptr<arrow::MapArray>& array);
extern "C" SEXP _arrow_MapArray__items_nested(SEXP array_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::MapArray>&>::type array(array_sexp);
	return cpp11::as_sexp(MapArray__items_nested(array));
END_CPP11
}
// array.cpp
bool Array__Same(const std::shared_ptr<arrow::Array>& x, const std::shared_ptr<arrow::Array>& y);
extern "C" SEXP _arrow_Array__Same(SEXP x_sexp, SEXP y_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Array>&>::type x(x_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::Array>&>::type y(y_sexp);
	return cpp11::as_sexp(Array__Same(x, y));
END_CPP11
}
// array.cpp
r_vec_size Array__ReferencedBufferSize(const std::shared_ptr<arrow::Array>& x);
extern "C" SEXP _arrow_Array__ReferencedBufferSize(SEXP x_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Array>&>::type x(x_sexp);
	return cpp11::as_sexp(Array__ReferencedBufferSize(x));
END_CPP11
}
// array.cpp
std::shared_ptr<arrow::Array> arrow__Concatenate(cpp11::list dots);
extern "C" SEXP _arrow_arrow__Concatenate(SEXP dots_sexp){
BEGIN_CPP11
	arrow::r::Input<cpp11::list>::type dots(dots_sexp);
	return cpp11::as_sexp(arrow__Concatenate(dots));
END_CPP11
}
// array_to_vector.cpp
SEXP Array__as_vector(const std::shared_ptr<arrow::Array>& array);
extern "C" SEXP _arrow_Array__as_vector(SEXP array_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Array>&>::type array(array_sexp);
	return cpp11::as_sexp(Array__as_vector(array));
END_CPP11
}
// array_to_vector.cpp
SEXP ChunkedArray__as_vector(const std::shared_ptr<arrow::ChunkedArray>& chunked_array, bool use_threads);
extern "C" SEXP _arrow_ChunkedArray__as_vector(SEXP chunked_array_sexp, SEXP use_threads_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::ChunkedArray>&>::type chunked_array(chunked_array_sexp);
	arrow::r::Input<bool>::type use_threads(use_threads_sexp);
	return cpp11::as_sexp(ChunkedArray__as_vector(chunked_array, use_threads));
END_CPP11
}
// array_to_vector.cpp
cpp11::writable::list RecordBatch__to_dataframe(const std::shared_ptr<arrow::RecordBatch>& batch, bool use_threads);
extern "C" SEXP _arrow_RecordBatch__to_dataframe(SEXP batch_sexp, SEXP use_threads_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::RecordBatch>&>::type batch(batch_sexp);
	arrow::r::Input<bool>::type use_threads(use_threads_sexp);
	return cpp11::as_sexp(RecordBatch__to_dataframe(batch, use_threads));
END_CPP11
}
// array_to_vector.cpp
cpp11::writable::list Table__to_dataframe(const std::shared_ptr<arrow::Table>& table, bool use_threads);
extern "C" SEXP _arrow_Table__to_dataframe(SEXP table_sexp, SEXP use_threads_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Table>&>::type table(table_sexp);
	arrow::r::Input<bool>::type use_threads(use_threads_sexp);
	return cpp11::as_sexp(Table__to_dataframe(table, use_threads));
END_CPP11
}
// arraydata.cpp
std::shared_ptr<arrow::DataType> ArrayData__get_type(const std::shared_ptr<arrow::ArrayData>& x);
extern "C" SEXP _arrow_ArrayData__get_type(SEXP x_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::ArrayData>&>::type x(x_sexp);
	return cpp11::as_sexp(ArrayData__get_type(x));
END_CPP11
}
// arraydata.cpp
int ArrayData__get_length(const std::shared_ptr<arrow::ArrayData>& x);
extern "C" SEXP _arrow_ArrayData__get_length(SEXP x_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::ArrayData>&>::type x(x_sexp);
	return cpp11::as_sexp(ArrayData__get_length(x));
END_CPP11
}
// arraydata.cpp
int ArrayData__get_null_count(const std::shared_ptr<arrow::ArrayData>& x);
extern "C" SEXP _arrow_ArrayData__get_null_count(SEXP x_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::ArrayData>&>::type x(x_sexp);
	return cpp11::as_sexp(ArrayData__get_null_count(x));
END_CPP11
}
// arraydata.cpp
int ArrayData__get_offset(const std::shared_ptr<arrow::ArrayData>& x);
extern "C" SEXP _arrow_ArrayData__get_offset(SEXP x_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::ArrayData>&>::type x(x_sexp);
	return cpp11::as_sexp(ArrayData__get_offset(x));
END_CPP11
}
// arraydata.cpp
cpp11::list ArrayData__buffers(const std::shared_ptr<arrow::ArrayData>& x);
extern "C" SEXP _arrow_ArrayData__buffers(SEXP x_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::ArrayData>&>::type x(x_sexp);
	return cpp11::as_sexp(ArrayData__buffers(x));
END_CPP11
}
// bridge.cpp
double external_pointer_addr_double(SEXP external_pointer);
extern "C" SEXP _arrow_external_pointer_addr_double(SEXP external_pointer_sexp){
BEGIN_CPP11
	arrow::r::Input<SEXP>::type external_pointer(external_pointer_sexp);
	return cpp11::as_sexp(external_pointer_addr_double(external_pointer));
END_CPP11
}
// bridge.cpp
std::string external_pointer_addr_character(SEXP external_pointer);
extern "C" SEXP _arrow_external_pointer_addr_character(SEXP external_pointer_sexp){
BEGIN_CPP11
	arrow::r::Input<SEXP>::type external_pointer(external_pointer_sexp);
	return cpp11::as_sexp(external_pointer_addr_character(external_pointer));
END_CPP11
}
// bridge.cpp
cpp11::doubles external_pointer_addr_integer64(SEXP external_pointer);
extern "C" SEXP _arrow_external_pointer_addr_integer64(SEXP external_pointer_sexp){
BEGIN_CPP11
	arrow::r::Input<SEXP>::type external_pointer(external_pointer_sexp);
	return cpp11::as_sexp(external_pointer_addr_integer64(external_pointer));
END_CPP11
}
// bridge.cpp
cpp11::raws external_pointer_addr_raw(SEXP external_pointer);
extern "C" SEXP _arrow_external_pointer_addr_raw(SEXP external_pointer_sexp){
BEGIN_CPP11
	arrow::r::Input<SEXP>::type external_pointer(external_pointer_sexp);
	return cpp11::as_sexp(external_pointer_addr_raw(external_pointer));
END_CPP11
}
// bridge.cpp
arrow::r::Pointer<struct ArrowSchema> allocate_arrow_schema();
extern "C" SEXP _arrow_allocate_arrow_schema(){
BEGIN_CPP11
	return cpp11::as_sexp(allocate_arrow_schema());
END_CPP11
}
// bridge.cpp
void delete_arrow_schema(arrow::r::Pointer<struct ArrowSchema> ptr);
extern "C" SEXP _arrow_delete_arrow_schema(SEXP ptr_sexp){
BEGIN_CPP11
	arrow::r::Input<arrow::r::Pointer<struct ArrowSchema>>::type ptr(ptr_sexp);
	delete_arrow_schema(ptr);
	return R_NilValue;
END_CPP11
}
// bridge.cpp
arrow::r::Pointer<struct ArrowArray> allocate_arrow_array();
extern "C" SEXP _arrow_allocate_arrow_array(){
BEGIN_CPP11
	return cpp11::as_sexp(allocate_arrow_array());
END_CPP11
}
// bridge.cpp
void delete_arrow_array(arrow::r::Pointer<struct ArrowArray> ptr);
extern "C" SEXP _arrow_delete_arrow_array(SEXP ptr_sexp){
BEGIN_CPP11
	arrow::r::Input<arrow::r::Pointer<struct ArrowArray>>::type ptr(ptr_sexp);
	delete_arrow_array(ptr);
	return R_NilValue;
END_CPP11
}
// bridge.cpp
arrow::r::Pointer<struct ArrowArrayStream> allocate_arrow_array_stream();
extern "C" SEXP _arrow_allocate_arrow_array_stream(){
BEGIN_CPP11
	return cpp11::as_sexp(allocate_arrow_array_stream());
END_CPP11
}
// bridge.cpp
void delete_arrow_array_stream(arrow::r::Pointer<struct ArrowArrayStream> ptr);
extern "C" SEXP _arrow_delete_arrow_array_stream(SEXP ptr_sexp){
BEGIN_CPP11
	arrow::r::Input<arrow::r::Pointer<struct ArrowArrayStream>>::type ptr(ptr_sexp);
	delete_arrow_array_stream(ptr);
	return R_NilValue;
END_CPP11
}
// bridge.cpp
std::shared_ptr<arrow::Array> ImportArray(arrow::r::Pointer<struct ArrowArray> array, arrow::r::Pointer<struct ArrowSchema> schema);
extern "C" SEXP _arrow_ImportArray(SEXP array_sexp, SEXP schema_sexp){
BEGIN_CPP11
	arrow::r::Input<arrow::r::Pointer<struct ArrowArray>>::type array(array_sexp);
	arrow::r::Input<arrow::r::Pointer<struct ArrowSchema>>::type schema(schema_sexp);
	return cpp11::as_sexp(ImportArray(array, schema));
END_CPP11
}
// bridge.cpp
std::shared_ptr<arrow::RecordBatch> ImportRecordBatch(arrow::r::Pointer<struct ArrowArray> array, arrow::r::Pointer<struct ArrowSchema> schema);
extern "C" SEXP _arrow_ImportRecordBatch(SEXP array_sexp, SEXP schema_sexp){
BEGIN_CPP11
	arrow::r::Input<arrow::r::Pointer<struct ArrowArray>>::type array(array_sexp);
	arrow::r::Input<arrow::r::Pointer<struct ArrowSchema>>::type schema(schema_sexp);
	return cpp11::as_sexp(ImportRecordBatch(array, schema));
END_CPP11
}
// bridge.cpp
std::shared_ptr<arrow::Schema> ImportSchema(arrow::r::Pointer<struct ArrowSchema> schema);
extern "C" SEXP _arrow_ImportSchema(SEXP schema_sexp){
BEGIN_CPP11
	arrow::r::Input<arrow::r::Pointer<struct ArrowSchema>>::type schema(schema_sexp);
	return cpp11::as_sexp(ImportSchema(schema));
END_CPP11
}
// bridge.cpp
std::shared_ptr<arrow::Field> ImportField(arrow::r::Pointer<struct ArrowSchema> field);
extern "C" SEXP _arrow_ImportField(SEXP field_sexp){
BEGIN_CPP11
	arrow::r::Input<arrow::r::Pointer<struct ArrowSchema>>::type field(field_sexp);
	return cpp11::as_sexp(ImportField(field));
END_CPP11
}
// bridge.cpp
std::shared_ptr<arrow::DataType> ImportType(arrow::r::Pointer<struct ArrowSchema> type);
extern "C" SEXP _arrow_ImportType(SEXP type_sexp){
BEGIN_CPP11
	arrow::r::Input<arrow::r::Pointer<struct ArrowSchema>>::type type(type_sexp);
	return cpp11::as_sexp(ImportType(type));
END_CPP11
}
// bridge.cpp
std::shared_ptr<arrow::RecordBatchReader> ImportRecordBatchReader(arrow::r::Pointer<struct ArrowArrayStream> stream);
extern "C" SEXP _arrow_ImportRecordBatchReader(SEXP stream_sexp){
BEGIN_CPP11
	arrow::r::Input<arrow::r::Pointer<struct ArrowArrayStream>>::type stream(stream_sexp);
	return cpp11::as_sexp(ImportRecordBatchReader(stream));
END_CPP11
}
// bridge.cpp
void ExportType(const std::shared_ptr<arrow::DataType>& type, arrow::r::Pointer<struct ArrowSchema> ptr);
extern "C" SEXP _arrow_ExportType(SEXP type_sexp, SEXP ptr_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::DataType>&>::type type(type_sexp);
	arrow::r::Input<arrow::r::Pointer<struct ArrowSchema>>::type ptr(ptr_sexp);
	ExportType(type, ptr);
	return R_NilValue;
END_CPP11
}
// bridge.cpp
void ExportField(const std::shared_ptr<arrow::Field>& field, arrow::r::Pointer<struct ArrowSchema> ptr);
extern "C" SEXP _arrow_ExportField(SEXP field_sexp, SEXP ptr_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Field>&>::type field(field_sexp);
	arrow::r::Input<arrow::r::Pointer<struct ArrowSchema>>::type ptr(ptr_sexp);
	ExportField(field, ptr);
	return R_NilValue;
END_CPP11
}
// bridge.cpp
void ExportSchema(const std::shared_ptr<arrow::Schema>& schema, arrow::r::Pointer<struct ArrowSchema> ptr);
extern "C" SEXP _arrow_ExportSchema(SEXP schema_sexp, SEXP ptr_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Schema>&>::type schema(schema_sexp);
	arrow::r::Input<arrow::r::Pointer<struct ArrowSchema>>::type ptr(ptr_sexp);
	ExportSchema(schema, ptr);
	return R_NilValue;
END_CPP11
}
// bridge.cpp
void ExportArray(const std::shared_ptr<arrow::Array>& array, arrow::r::Pointer<struct ArrowArray> array_ptr, arrow::r::Pointer<struct ArrowSchema> schema_ptr);
extern "C" SEXP _arrow_ExportArray(SEXP array_sexp, SEXP array_ptr_sexp, SEXP schema_ptr_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Array>&>::type array(array_sexp);
	arrow::r::Input<arrow::r::Pointer<struct ArrowArray>>::type array_ptr(array_ptr_sexp);
	arrow::r::Input<arrow::r::Pointer<struct ArrowSchema>>::type schema_ptr(schema_ptr_sexp);
	ExportArray(array, array_ptr, schema_ptr);
	return R_NilValue;
END_CPP11
}
// bridge.cpp
void ExportRecordBatch(const std::shared_ptr<arrow::RecordBatch>& batch, arrow::r::Pointer<struct ArrowArray> array_ptr, arrow::r::Pointer<struct ArrowSchema> schema_ptr);
extern "C" SEXP _arrow_ExportRecordBatch(SEXP batch_sexp, SEXP array_ptr_sexp, SEXP schema_ptr_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::RecordBatch>&>::type batch(batch_sexp);
	arrow::r::Input<arrow::r::Pointer<struct ArrowArray>>::type array_ptr(array_ptr_sexp);
	arrow::r::Input<arrow::r::Pointer<struct ArrowSchema>>::type schema_ptr(schema_ptr_sexp);
	ExportRecordBatch(batch, array_ptr, schema_ptr);
	return R_NilValue;
END_CPP11
}
// bridge.cpp
void ExportRecordBatchReader(const std::shared_ptr<arrow::RecordBatchReader>& reader, arrow::r::Pointer<struct ArrowArrayStream> stream_ptr);
extern "C" SEXP _arrow_ExportRecordBatchReader(SEXP reader_sexp, SEXP stream_ptr_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::RecordBatchReader>&>::type reader(reader_sexp);
	arrow::r::Input<arrow::r::Pointer<struct ArrowArrayStream>>::type stream_ptr(stream_ptr_sexp);
	ExportRecordBatchReader(reader, stream_ptr);
	return R_NilValue;
END_CPP11
}
// buffer.cpp
bool Buffer__is_mutable(const std::shared_ptr<arrow::Buffer>& buffer);
extern "C" SEXP _arrow_Buffer__is_mutable(SEXP buffer_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Buffer>&>::type buffer(buffer_sexp);
	return cpp11::as_sexp(Buffer__is_mutable(buffer));
END_CPP11
}
// buffer.cpp
void Buffer__ZeroPadding(const std::shared_ptr<arrow::Buffer>& buffer);
extern "C" SEXP _arrow_Buffer__ZeroPadding(SEXP buffer_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Buffer>&>::type buffer(buffer_sexp);
	Buffer__ZeroPadding(buffer);
	return R_NilValue;
END_CPP11
}
// buffer.cpp
r_vec_size Buffer__capacity(const std::shared_ptr<arrow::Buffer>& buffer);
extern "C" SEXP _arrow_Buffer__capacity(SEXP buffer_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Buffer>&>::type buffer(buffer_sexp);
	return cpp11::as_sexp(Buffer__capacity(buffer));
END_CPP11
}
// buffer.cpp
r_vec_size Buffer__size(const std::shared_ptr<arrow::Buffer>& buffer);
extern "C" SEXP _arrow_Buffer__size(SEXP buffer_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Buffer>&>::type buffer(buffer_sexp);
	return cpp11::as_sexp(Buffer__size(buffer));
END_CPP11
}
// buffer.cpp
std::shared_ptr<arrow::Buffer> r___RBuffer__initialize(SEXP x);
extern "C" SEXP _arrow_r___RBuffer__initialize(SEXP x_sexp){
BEGIN_CPP11
	arrow::r::Input<SEXP>::type x(x_sexp);
	return cpp11::as_sexp(r___RBuffer__initialize(x));
END_CPP11
}
// buffer.cpp
cpp11::writable::raws Buffer__data(const std::shared_ptr<arrow::Buffer>& buffer);
extern "C" SEXP _arrow_Buffer__data(SEXP buffer_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Buffer>&>::type buffer(buffer_sexp);
	return cpp11::as_sexp(Buffer__data(buffer));
END_CPP11
}
// buffer.cpp
bool Buffer__Equals(const std::shared_ptr<arrow::Buffer>& x, const std::shared_ptr<arrow::Buffer>& y);
extern "C" SEXP _arrow_Buffer__Equals(SEXP x_sexp, SEXP y_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Buffer>&>::type x(x_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::Buffer>&>::type y(y_sexp);
	return cpp11::as_sexp(Buffer__Equals(x, y));
END_CPP11
}
// chunkedarray.cpp
r_vec_size ChunkedArray__length(const std::shared_ptr<arrow::ChunkedArray>& chunked_array);
extern "C" SEXP _arrow_ChunkedArray__length(SEXP chunked_array_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::ChunkedArray>&>::type chunked_array(chunked_array_sexp);
	return cpp11::as_sexp(ChunkedArray__length(chunked_array));
END_CPP11
}
// chunkedarray.cpp
r_vec_size ChunkedArray__null_count(const std::shared_ptr<arrow::ChunkedArray>& chunked_array);
extern "C" SEXP _arrow_ChunkedArray__null_count(SEXP chunked_array_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::ChunkedArray>&>::type chunked_array(chunked_array_sexp);
	return cpp11::as_sexp(ChunkedArray__null_count(chunked_array));
END_CPP11
}
// chunkedarray.cpp
r_vec_size ChunkedArray__num_chunks(const std::shared_ptr<arrow::ChunkedArray>& chunked_array);
extern "C" SEXP _arrow_ChunkedArray__num_chunks(SEXP chunked_array_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::ChunkedArray>&>::type chunked_array(chunked_array_sexp);
	return cpp11::as_sexp(ChunkedArray__num_chunks(chunked_array));
END_CPP11
}
// chunkedarray.cpp
std::shared_ptr<arrow::Array> ChunkedArray__chunk(const std::shared_ptr<arrow::ChunkedArray>& chunked_array, int i);
extern "C" SEXP _arrow_ChunkedArray__chunk(SEXP chunked_array_sexp, SEXP i_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::ChunkedArray>&>::type chunked_array(chunked_array_sexp);
	arrow::r::Input<int>::type i(i_sexp);
	return cpp11::as_sexp(ChunkedArray__chunk(chunked_array, i));
END_CPP11
}
// chunkedarray.cpp
cpp11::list ChunkedArray__chunks(const std::shared_ptr<arrow::ChunkedArray>& chunked_array);
extern "C" SEXP _arrow_ChunkedArray__chunks(SEXP chunked_array_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::ChunkedArray>&>::type chunked_array(chunked_array_sexp);
	return cpp11::as_sexp(ChunkedArray__chunks(chunked_array));
END_CPP11
}
// chunkedarray.cpp
std::shared_ptr<arrow::DataType> ChunkedArray__type(const std::shared_ptr<arrow::ChunkedArray>& chunked_array);
extern "C" SEXP _arrow_ChunkedArray__type(SEXP chunked_array_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::ChunkedArray>&>::type chunked_array(chunked_array_sexp);
	return cpp11::as_sexp(ChunkedArray__type(chunked_array));
END_CPP11
}
// chunkedarray.cpp
std::shared_ptr<arrow::ChunkedArray> ChunkedArray__Slice1(const std::shared_ptr<arrow::ChunkedArray>& chunked_array, R_xlen_t offset);
extern "C" SEXP _arrow_ChunkedArray__Slice1(SEXP chunked_array_sexp, SEXP offset_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::ChunkedArray>&>::type chunked_array(chunked_array_sexp);
	arrow::r::Input<R_xlen_t>::type offset(offset_sexp);
	return cpp11::as_sexp(ChunkedArray__Slice1(chunked_array, offset));
END_CPP11
}
// chunkedarray.cpp
std::shared_ptr<arrow::ChunkedArray> ChunkedArray__Slice2(const std::shared_ptr<arrow::ChunkedArray>& chunked_array, R_xlen_t offset, R_xlen_t length);
extern "C" SEXP _arrow_ChunkedArray__Slice2(SEXP chunked_array_sexp, SEXP offset_sexp, SEXP length_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::ChunkedArray>&>::type chunked_array(chunked_array_sexp);
	arrow::r::Input<R_xlen_t>::type offset(offset_sexp);
	arrow::r::Input<R_xlen_t>::type length(length_sexp);
	return cpp11::as_sexp(ChunkedArray__Slice2(chunked_array, offset, length));
END_CPP11
}
// chunkedarray.cpp
std::shared_ptr<arrow::ChunkedArray> ChunkedArray__View(const std::shared_ptr<arrow::ChunkedArray>& array, const std::shared_ptr<arrow::DataType>& type);
extern "C" SEXP _arrow_ChunkedArray__View(SEXP array_sexp, SEXP type_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::ChunkedArray>&>::type array(array_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::DataType>&>::type type(type_sexp);
	return cpp11::as_sexp(ChunkedArray__View(array, type));
END_CPP11
}
// chunkedarray.cpp
void ChunkedArray__Validate(const std::shared_ptr<arrow::ChunkedArray>& chunked_array);
extern "C" SEXP _arrow_ChunkedArray__Validate(SEXP chunked_array_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::ChunkedArray>&>::type chunked_array(chunked_array_sexp);
	ChunkedArray__Validate(chunked_array);
	return R_NilValue;
END_CPP11
}
// chunkedarray.cpp
bool ChunkedArray__Equals(const std::shared_ptr<arrow::ChunkedArray>& x, const std::shared_ptr<arrow::ChunkedArray>& y);
extern "C" SEXP _arrow_ChunkedArray__Equals(SEXP x_sexp, SEXP y_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::ChunkedArray>&>::type x(x_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::ChunkedArray>&>::type y(y_sexp);
	return cpp11::as_sexp(ChunkedArray__Equals(x, y));
END_CPP11
}
// chunkedarray.cpp
std::string ChunkedArray__ToString(const std::shared_ptr<arrow::ChunkedArray>& x);
extern "C" SEXP _arrow_ChunkedArray__ToString(SEXP x_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::ChunkedArray>&>::type x(x_sexp);
	return cpp11::as_sexp(ChunkedArray__ToString(x));
END_CPP11
}
// chunkedarray.cpp
std::shared_ptr<arrow::ChunkedArray> ChunkedArray__from_list(cpp11::list chunks, SEXP s_type);
extern "C" SEXP _arrow_ChunkedArray__from_list(SEXP chunks_sexp, SEXP s_type_sexp){
BEGIN_CPP11
	arrow::r::Input<cpp11::list>::type chunks(chunks_sexp);
	arrow::r::Input<SEXP>::type s_type(s_type_sexp);
	return cpp11::as_sexp(ChunkedArray__from_list(chunks, s_type));
END_CPP11
}
// chunkedarray.cpp
r_vec_size ChunkedArray__ReferencedBufferSize(const std::shared_ptr<arrow::ChunkedArray>& chunked_array);
extern "C" SEXP _arrow_ChunkedArray__ReferencedBufferSize(SEXP chunked_array_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::ChunkedArray>&>::type chunked_array(chunked_array_sexp);
	return cpp11::as_sexp(ChunkedArray__ReferencedBufferSize(chunked_array));
END_CPP11
}
// compression.cpp
std::shared_ptr<arrow::util::Codec> util___Codec__Create(arrow::Compression::type codec, R_xlen_t compression_level);
extern "C" SEXP _arrow_util___Codec__Create(SEXP codec_sexp, SEXP compression_level_sexp){
BEGIN_CPP11
	arrow::r::Input<arrow::Compression::type>::type codec(codec_sexp);
	arrow::r::Input<R_xlen_t>::type compression_level(compression_level_sexp);
	return cpp11::as_sexp(util___Codec__Create(codec, compression_level));
END_CPP11
}
// compression.cpp
std::string util___Codec__name(const std::shared_ptr<arrow::util::Codec>& codec);
extern "C" SEXP _arrow_util___Codec__name(SEXP codec_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::util::Codec>&>::type codec(codec_sexp);
	return cpp11::as_sexp(util___Codec__name(codec));
END_CPP11
}
// compression.cpp
bool util___Codec__IsAvailable(arrow::Compression::type codec);
extern "C" SEXP _arrow_util___Codec__IsAvailable(SEXP codec_sexp){
BEGIN_CPP11
	arrow::r::Input<arrow::Compression::type>::type codec(codec_sexp);
	return cpp11::as_sexp(util___Codec__IsAvailable(codec));
END_CPP11
}
// compression.cpp
std::shared_ptr<arrow::io::CompressedOutputStream> io___CompressedOutputStream__Make(const std::shared_ptr<arrow::util::Codec>& codec, const std::shared_ptr<arrow::io::OutputStream>& raw);
extern "C" SEXP _arrow_io___CompressedOutputStream__Make(SEXP codec_sexp, SEXP raw_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::util::Codec>&>::type codec(codec_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::io::OutputStream>&>::type raw(raw_sexp);
	return cpp11::as_sexp(io___CompressedOutputStream__Make(codec, raw));
END_CPP11
}
// compression.cpp
std::shared_ptr<arrow::io::CompressedInputStream> io___CompressedInputStream__Make(const std::shared_ptr<arrow::util::Codec>& codec, const std::shared_ptr<arrow::io::InputStream>& raw);
extern "C" SEXP _arrow_io___CompressedInputStream__Make(SEXP codec_sexp, SEXP raw_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::util::Codec>&>::type codec(codec_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::io::InputStream>&>::type raw(raw_sexp);
	return cpp11::as_sexp(io___CompressedInputStream__Make(codec, raw));
END_CPP11
}
// compute-exec.cpp
std::shared_ptr<compute::ExecPlan> ExecPlan_create(bool use_threads);
extern "C" SEXP _arrow_ExecPlan_create(SEXP use_threads_sexp){
BEGIN_CPP11
	arrow::r::Input<bool>::type use_threads(use_threads_sexp);
	return cpp11::as_sexp(ExecPlan_create(use_threads));
END_CPP11
}
// compute-exec.cpp
cpp11::list ExecPlanReader__batches(const std::shared_ptr<arrow::RecordBatchReader>& reader);
extern "C" SEXP _arrow_ExecPlanReader__batches(SEXP reader_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::RecordBatchReader>&>::type reader(reader_sexp);
	return cpp11::as_sexp(ExecPlanReader__batches(reader));
END_CPP11
}
// compute-exec.cpp
std::shared_ptr<arrow::Table> Table__from_ExecPlanReader(const std::shared_ptr<arrow::RecordBatchReader>& reader);
extern "C" SEXP _arrow_Table__from_ExecPlanReader(SEXP reader_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::RecordBatchReader>&>::type reader(reader_sexp);
	return cpp11::as_sexp(Table__from_ExecPlanReader(reader));
END_CPP11
}
// compute-exec.cpp
std::shared_ptr<compute::ExecPlan> ExecPlanReader__Plan(const std::shared_ptr<ExecPlanReader>& reader);
extern "C" SEXP _arrow_ExecPlanReader__Plan(SEXP reader_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<ExecPlanReader>&>::type reader(reader_sexp);
	return cpp11::as_sexp(ExecPlanReader__Plan(reader));
END_CPP11
}
// compute-exec.cpp
std::string ExecPlanReader__PlanStatus(const std::shared_ptr<ExecPlanReader>& reader);
extern "C" SEXP _arrow_ExecPlanReader__PlanStatus(SEXP reader_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<ExecPlanReader>&>::type reader(reader_sexp);
	return cpp11::as_sexp(ExecPlanReader__PlanStatus(reader));
END_CPP11
}
// compute-exec.cpp
std::shared_ptr<ExecPlanReader> ExecPlan_run(const std::shared_ptr<compute::ExecPlan>& plan, const std::shared_ptr<compute::ExecNode>& final_node, cpp11::list sort_options, cpp11::strings metadata, int64_t head);
extern "C" SEXP _arrow_ExecPlan_run(SEXP plan_sexp, SEXP final_node_sexp, SEXP sort_options_sexp, SEXP metadata_sexp, SEXP head_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<compute::ExecPlan>&>::type plan(plan_sexp);
	arrow::r::Input<const std::shared_ptr<compute::ExecNode>&>::type final_node(final_node_sexp);
	arrow::r::Input<cpp11::list>::type sort_options(sort_options_sexp);
	arrow::r::Input<cpp11::strings>::type metadata(metadata_sexp);
	arrow::r::Input<int64_t>::type head(head_sexp);
	return cpp11::as_sexp(ExecPlan_run(plan, final_node, sort_options, metadata, head));
END_CPP11
}
// compute-exec.cpp
std::string ExecPlan_ToString(const std::shared_ptr<compute::ExecPlan>& plan);
extern "C" SEXP _arrow_ExecPlan_ToString(SEXP plan_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<compute::ExecPlan>&>::type plan(plan_sexp);
	return cpp11::as_sexp(ExecPlan_ToString(plan));
END_CPP11
}
// compute-exec.cpp
void ExecPlan_UnsafeDelete(const std::shared_ptr<compute::ExecPlan>& plan);
extern "C" SEXP _arrow_ExecPlan_UnsafeDelete(SEXP plan_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<compute::ExecPlan>&>::type plan(plan_sexp);
	ExecPlan_UnsafeDelete(plan);
	return R_NilValue;
END_CPP11
}
// compute-exec.cpp
std::shared_ptr<arrow::Schema> ExecNode_output_schema(const std::shared_ptr<compute::ExecNode>& node);
extern "C" SEXP _arrow_ExecNode_output_schema(SEXP node_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<compute::ExecNode>&>::type node(node_sexp);
	return cpp11::as_sexp(ExecNode_output_schema(node));
END_CPP11
}
// compute-exec.cpp
#if defined(ARROW_R_WITH_DATASET)
std::shared_ptr<compute::ExecNode> ExecNode_Scan(const std::shared_ptr<compute::ExecPlan>& plan, const std::shared_ptr<ds::Dataset>& dataset, const std::shared_ptr<compute::Expression>& filter, cpp11::list projection);
extern "C" SEXP _arrow_ExecNode_Scan(SEXP plan_sexp, SEXP dataset_sexp, SEXP filter_sexp, SEXP projection_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<compute::ExecPlan>&>::type plan(plan_sexp);
	arrow::r::Input<const std::shared_ptr<ds::Dataset>&>::type dataset(dataset_sexp);
	arrow::r::Input<const std::shared_ptr<compute::Expression>&>::type filter(filter_sexp);
	arrow::r::Input<cpp11::list>::type projection(projection_sexp);
	return cpp11::as_sexp(ExecNode_Scan(plan, dataset, filter, projection));
END_CPP11
}
#else
extern "C" SEXP _arrow_ExecNode_Scan(SEXP plan_sexp, SEXP dataset_sexp, SEXP filter_sexp, SEXP projection_sexp){
	Rf_error("Cannot call ExecNode_Scan(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// compute-exec.cpp
#if defined(ARROW_R_WITH_DATASET)
void ExecPlan_Write(const std::shared_ptr<compute::ExecPlan>& plan, const std::shared_ptr<compute::ExecNode>& final_node, cpp11::strings metadata, const std::shared_ptr<ds::FileWriteOptions>& file_write_options, const std::shared_ptr<fs::FileSystem>& filesystem, std::string base_dir, const std::shared_ptr<ds::Partitioning>& partitioning, std::string basename_template, arrow::dataset::ExistingDataBehavior existing_data_behavior, int max_partitions, uint32_t max_open_files, uint64_t max_rows_per_file, uint64_t min_rows_per_group, uint64_t max_rows_per_group);
extern "C" SEXP _arrow_ExecPlan_Write(SEXP plan_sexp, SEXP final_node_sexp, SEXP metadata_sexp, SEXP file_write_options_sexp, SEXP filesystem_sexp, SEXP base_dir_sexp, SEXP partitioning_sexp, SEXP basename_template_sexp, SEXP existing_data_behavior_sexp, SEXP max_partitions_sexp, SEXP max_open_files_sexp, SEXP max_rows_per_file_sexp, SEXP min_rows_per_group_sexp, SEXP max_rows_per_group_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<compute::ExecPlan>&>::type plan(plan_sexp);
	arrow::r::Input<const std::shared_ptr<compute::ExecNode>&>::type final_node(final_node_sexp);
	arrow::r::Input<cpp11::strings>::type metadata(metadata_sexp);
	arrow::r::Input<const std::shared_ptr<ds::FileWriteOptions>&>::type file_write_options(file_write_options_sexp);
	arrow::r::Input<const std::shared_ptr<fs::FileSystem>&>::type filesystem(filesystem_sexp);
	arrow::r::Input<std::string>::type base_dir(base_dir_sexp);
	arrow::r::Input<const std::shared_ptr<ds::Partitioning>&>::type partitioning(partitioning_sexp);
	arrow::r::Input<std::string>::type basename_template(basename_template_sexp);
	arrow::r::Input<arrow::dataset::ExistingDataBehavior>::type existing_data_behavior(existing_data_behavior_sexp);
	arrow::r::Input<int>::type max_partitions(max_partitions_sexp);
	arrow::r::Input<uint32_t>::type max_open_files(max_open_files_sexp);
	arrow::r::Input<uint64_t>::type max_rows_per_file(max_rows_per_file_sexp);
	arrow::r::Input<uint64_t>::type min_rows_per_group(min_rows_per_group_sexp);
	arrow::r::Input<uint64_t>::type max_rows_per_group(max_rows_per_group_sexp);
	ExecPlan_Write(plan, final_node, metadata, file_write_options, filesystem, base_dir, partitioning, basename_template, existing_data_behavior, max_partitions, max_open_files, max_rows_per_file, min_rows_per_group, max_rows_per_group);
	return R_NilValue;
END_CPP11
}
#else
extern "C" SEXP _arrow_ExecPlan_Write(SEXP plan_sexp, SEXP final_node_sexp, SEXP metadata_sexp, SEXP file_write_options_sexp, SEXP filesystem_sexp, SEXP base_dir_sexp, SEXP partitioning_sexp, SEXP basename_template_sexp, SEXP existing_data_behavior_sexp, SEXP max_partitions_sexp, SEXP max_open_files_sexp, SEXP max_rows_per_file_sexp, SEXP min_rows_per_group_sexp, SEXP max_rows_per_group_sexp){
	Rf_error("Cannot call ExecPlan_Write(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// compute-exec.cpp
std::shared_ptr<compute::ExecNode> ExecNode_Filter(const std::shared_ptr<compute::ExecNode>& input, const std::shared_ptr<compute::Expression>& filter);
extern "C" SEXP _arrow_ExecNode_Filter(SEXP input_sexp, SEXP filter_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<compute::ExecNode>&>::type input(input_sexp);
	arrow::r::Input<const std::shared_ptr<compute::Expression>&>::type filter(filter_sexp);
	return cpp11::as_sexp(ExecNode_Filter(input, filter));
END_CPP11
}
// compute-exec.cpp
std::shared_ptr<compute::ExecNode> ExecNode_Project(const std::shared_ptr<compute::ExecNode>& input, const std::vector<std::shared_ptr<compute::Expression>>& exprs, std::vector<std::string> names);
extern "C" SEXP _arrow_ExecNode_Project(SEXP input_sexp, SEXP exprs_sexp, SEXP names_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<compute::ExecNode>&>::type input(input_sexp);
	arrow::r::Input<const std::vector<std::shared_ptr<compute::Expression>>&>::type exprs(exprs_sexp);
	arrow::r::Input<std::vector<std::string>>::type names(names_sexp);
	return cpp11::as_sexp(ExecNode_Project(input, exprs, names));
END_CPP11
}
// compute-exec.cpp
std::shared_ptr<compute::ExecNode> ExecNode_Aggregate(const std::shared_ptr<compute::ExecNode>& input, cpp11::list options, std::vector<std::string> key_names);
extern "C" SEXP _arrow_ExecNode_Aggregate(SEXP input_sexp, SEXP options_sexp, SEXP key_names_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<compute::ExecNode>&>::type input(input_sexp);
	arrow::r::Input<cpp11::list>::type options(options_sexp);
	arrow::r::Input<std::vector<std::string>>::type key_names(key_names_sexp);
	return cpp11::as_sexp(ExecNode_Aggregate(input, options, key_names));
END_CPP11
}
// compute-exec.cpp
std::shared_ptr<compute::ExecNode> ExecNode_Join(const std::shared_ptr<compute::ExecNode>& input, compute::JoinType join_type, const std::shared_ptr<compute::ExecNode>& right_data, std::vector<std::string> left_keys, std::vector<std::string> right_keys, std::vector<std::string> left_output, std::vector<std::string> right_output, std::string output_suffix_for_left, std::string output_suffix_for_right);
extern "C" SEXP _arrow_ExecNode_Join(SEXP input_sexp, SEXP join_type_sexp, SEXP right_data_sexp, SEXP left_keys_sexp, SEXP right_keys_sexp, SEXP left_output_sexp, SEXP right_output_sexp, SEXP output_suffix_for_left_sexp, SEXP output_suffix_for_right_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<compute::ExecNode>&>::type input(input_sexp);
	arrow::r::Input<compute::JoinType>::type join_type(join_type_sexp);
	arrow::r::Input<const std::shared_ptr<compute::ExecNode>&>::type right_data(right_data_sexp);
	arrow::r::Input<std::vector<std::string>>::type left_keys(left_keys_sexp);
	arrow::r::Input<std::vector<std::string>>::type right_keys(right_keys_sexp);
	arrow::r::Input<std::vector<std::string>>::type left_output(left_output_sexp);
	arrow::r::Input<std::vector<std::string>>::type right_output(right_output_sexp);
	arrow::r::Input<std::string>::type output_suffix_for_left(output_suffix_for_left_sexp);
	arrow::r::Input<std::string>::type output_suffix_for_right(output_suffix_for_right_sexp);
	return cpp11::as_sexp(ExecNode_Join(input, join_type, right_data, left_keys, right_keys, left_output, right_output, output_suffix_for_left, output_suffix_for_right));
END_CPP11
}
// compute-exec.cpp
std::shared_ptr<compute::ExecNode> ExecNode_Union(const std::shared_ptr<compute::ExecNode>& input, const std::shared_ptr<compute::ExecNode>& right_data);
extern "C" SEXP _arrow_ExecNode_Union(SEXP input_sexp, SEXP right_data_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<compute::ExecNode>&>::type input(input_sexp);
	arrow::r::Input<const std::shared_ptr<compute::ExecNode>&>::type right_data(right_data_sexp);
	return cpp11::as_sexp(ExecNode_Union(input, right_data));
END_CPP11
}
// compute-exec.cpp
std::shared_ptr<compute::ExecNode> ExecNode_SourceNode(const std::shared_ptr<compute::ExecPlan>& plan, const std::shared_ptr<arrow::RecordBatchReader>& reader);
extern "C" SEXP _arrow_ExecNode_SourceNode(SEXP plan_sexp, SEXP reader_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<compute::ExecPlan>&>::type plan(plan_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::RecordBatchReader>&>::type reader(reader_sexp);
	return cpp11::as_sexp(ExecNode_SourceNode(plan, reader));
END_CPP11
}
// compute-exec.cpp
std::shared_ptr<compute::ExecNode> ExecNode_TableSourceNode(const std::shared_ptr<compute::ExecPlan>& plan, const std::shared_ptr<arrow::Table>& table);
extern "C" SEXP _arrow_ExecNode_TableSourceNode(SEXP plan_sexp, SEXP table_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<compute::ExecPlan>&>::type plan(plan_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::Table>&>::type table(table_sexp);
	return cpp11::as_sexp(ExecNode_TableSourceNode(plan, table));
END_CPP11
}
// compute-exec.cpp
#if defined(ARROW_R_WITH_SUBSTRAIT)
std::string substrait__internal__SubstraitToJSON(const std::shared_ptr<arrow::Buffer>& serialized_plan);
extern "C" SEXP _arrow_substrait__internal__SubstraitToJSON(SEXP serialized_plan_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Buffer>&>::type serialized_plan(serialized_plan_sexp);
	return cpp11::as_sexp(substrait__internal__SubstraitToJSON(serialized_plan));
END_CPP11
}
#else
extern "C" SEXP _arrow_substrait__internal__SubstraitToJSON(SEXP serialized_plan_sexp){
	Rf_error("Cannot call substrait__internal__SubstraitToJSON(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// compute-exec.cpp
#if defined(ARROW_R_WITH_SUBSTRAIT)
std::shared_ptr<arrow::Buffer> substrait__internal__SubstraitFromJSON(std::string substrait_json);
extern "C" SEXP _arrow_substrait__internal__SubstraitFromJSON(SEXP substrait_json_sexp){
BEGIN_CPP11
	arrow::r::Input<std::string>::type substrait_json(substrait_json_sexp);
	return cpp11::as_sexp(substrait__internal__SubstraitFromJSON(substrait_json));
END_CPP11
}
#else
extern "C" SEXP _arrow_substrait__internal__SubstraitFromJSON(SEXP substrait_json_sexp){
	Rf_error("Cannot call substrait__internal__SubstraitFromJSON(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// compute-exec.cpp
#if defined(ARROW_R_WITH_SUBSTRAIT)
std::shared_ptr<arrow::Table> ExecPlan_run_substrait(const std::shared_ptr<compute::ExecPlan>& plan, const std::shared_ptr<arrow::Buffer>& serialized_plan);
extern "C" SEXP _arrow_ExecPlan_run_substrait(SEXP plan_sexp, SEXP serialized_plan_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<compute::ExecPlan>&>::type plan(plan_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::Buffer>&>::type serialized_plan(serialized_plan_sexp);
	return cpp11::as_sexp(ExecPlan_run_substrait(plan, serialized_plan));
END_CPP11
}
#else
extern "C" SEXP _arrow_ExecPlan_run_substrait(SEXP plan_sexp, SEXP serialized_plan_sexp){
	Rf_error("Cannot call ExecPlan_run_substrait(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// compute.cpp
std::shared_ptr<arrow::RecordBatch> RecordBatch__cast(const std::shared_ptr<arrow::RecordBatch>& batch, const std::shared_ptr<arrow::Schema>& schema, cpp11::list options);
extern "C" SEXP _arrow_RecordBatch__cast(SEXP batch_sexp, SEXP schema_sexp, SEXP options_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::RecordBatch>&>::type batch(batch_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::Schema>&>::type schema(schema_sexp);
	arrow::r::Input<cpp11::list>::type options(options_sexp);
	return cpp11::as_sexp(RecordBatch__cast(batch, schema, options));
END_CPP11
}
// compute.cpp
std::shared_ptr<arrow::Table> Table__cast(const std::shared_ptr<arrow::Table>& table, const std::shared_ptr<arrow::Schema>& schema, cpp11::list options);
extern "C" SEXP _arrow_Table__cast(SEXP table_sexp, SEXP schema_sexp, SEXP options_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Table>&>::type table(table_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::Schema>&>::type schema(schema_sexp);
	arrow::r::Input<cpp11::list>::type options(options_sexp);
	return cpp11::as_sexp(Table__cast(table, schema, options));
END_CPP11
}
// compute.cpp
SEXP compute__CallFunction(std::string func_name, cpp11::list args, cpp11::list options);
extern "C" SEXP _arrow_compute__CallFunction(SEXP func_name_sexp, SEXP args_sexp, SEXP options_sexp){
BEGIN_CPP11
	arrow::r::Input<std::string>::type func_name(func_name_sexp);
	arrow::r::Input<cpp11::list>::type args(args_sexp);
	arrow::r::Input<cpp11::list>::type options(options_sexp);
	return cpp11::as_sexp(compute__CallFunction(func_name, args, options));
END_CPP11
}
// compute.cpp
std::vector<std::string> compute__GetFunctionNames();
extern "C" SEXP _arrow_compute__GetFunctionNames(){
BEGIN_CPP11
	return cpp11::as_sexp(compute__GetFunctionNames());
END_CPP11
}
// compute.cpp
void RegisterScalarUDF(std::string name, cpp11::list func_sexp);
extern "C" SEXP _arrow_RegisterScalarUDF(SEXP name_sexp, SEXP func_sexp_sexp){
BEGIN_CPP11
	arrow::r::Input<std::string>::type name(name_sexp);
	arrow::r::Input<cpp11::list>::type func_sexp(func_sexp_sexp);
	RegisterScalarUDF(name, func_sexp);
	return R_NilValue;
END_CPP11
}
// config.cpp
std::vector<std::string> build_info();
extern "C" SEXP _arrow_build_info(){
BEGIN_CPP11
	return cpp11::as_sexp(build_info());
END_CPP11
}
// config.cpp
std::vector<std::string> runtime_info();
extern "C" SEXP _arrow_runtime_info(){
BEGIN_CPP11
	return cpp11::as_sexp(runtime_info());
END_CPP11
}
// config.cpp
void set_timezone_database(cpp11::strings path);
extern "C" SEXP _arrow_set_timezone_database(SEXP path_sexp){
BEGIN_CPP11
	arrow::r::Input<cpp11::strings>::type path(path_sexp);
	set_timezone_database(path);
	return R_NilValue;
END_CPP11
}
// csv.cpp
std::shared_ptr<arrow::csv::WriteOptions> csv___WriteOptions__initialize(cpp11::list options);
extern "C" SEXP _arrow_csv___WriteOptions__initialize(SEXP options_sexp){
BEGIN_CPP11
	arrow::r::Input<cpp11::list>::type options(options_sexp);
	return cpp11::as_sexp(csv___WriteOptions__initialize(options));
END_CPP11
}
// csv.cpp
std::shared_ptr<arrow::csv::ReadOptions> csv___ReadOptions__initialize(cpp11::list options);
extern "C" SEXP _arrow_csv___ReadOptions__initialize(SEXP options_sexp){
BEGIN_CPP11
	arrow::r::Input<cpp11::list>::type options(options_sexp);
	return cpp11::as_sexp(csv___ReadOptions__initialize(options));
END_CPP11
}
// csv.cpp
std::shared_ptr<arrow::csv::ParseOptions> csv___ParseOptions__initialize(cpp11::list options);
extern "C" SEXP _arrow_csv___ParseOptions__initialize(SEXP options_sexp){
BEGIN_CPP11
	arrow::r::Input<cpp11::list>::type options(options_sexp);
	return cpp11::as_sexp(csv___ParseOptions__initialize(options));
END_CPP11
}
// csv.cpp
SEXP csv___ReadOptions__column_names(const std::shared_ptr<arrow::csv::ReadOptions>& options);
extern "C" SEXP _arrow_csv___ReadOptions__column_names(SEXP options_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::csv::ReadOptions>&>::type options(options_sexp);
	return cpp11::as_sexp(csv___ReadOptions__column_names(options));
END_CPP11
}
// csv.cpp
std::shared_ptr<arrow::csv::ConvertOptions> csv___ConvertOptions__initialize(cpp11::list options);
extern "C" SEXP _arrow_csv___ConvertOptions__initialize(SEXP options_sexp){
BEGIN_CPP11
	arrow::r::Input<cpp11::list>::type options(options_sexp);
	return cpp11::as_sexp(csv___ConvertOptions__initialize(options));
END_CPP11
}
// csv.cpp
std::shared_ptr<arrow::csv::TableReader> csv___TableReader__Make(const std::shared_ptr<arrow::io::InputStream>& input, const std::shared_ptr<arrow::csv::ReadOptions>& read_options, const std::shared_ptr<arrow::csv::ParseOptions>& parse_options, const std::shared_ptr<arrow::csv::ConvertOptions>& convert_options);
extern "C" SEXP _arrow_csv___TableReader__Make(SEXP input_sexp, SEXP read_options_sexp, SEXP parse_options_sexp, SEXP convert_options_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::io::InputStream>&>::type input(input_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::csv::ReadOptions>&>::type read_options(read_options_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::csv::ParseOptions>&>::type parse_options(parse_options_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::csv::ConvertOptions>&>::type convert_options(convert_options_sexp);
	return cpp11::as_sexp(csv___TableReader__Make(input, read_options, parse_options, convert_options));
END_CPP11
}
// csv.cpp
std::shared_ptr<arrow::Table> csv___TableReader__Read(const std::shared_ptr<arrow::csv::TableReader>& table_reader);
extern "C" SEXP _arrow_csv___TableReader__Read(SEXP table_reader_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::csv::TableReader>&>::type table_reader(table_reader_sexp);
	return cpp11::as_sexp(csv___TableReader__Read(table_reader));
END_CPP11
}
// csv.cpp
std::string TimestampParser__kind(const std::shared_ptr<arrow::TimestampParser>& parser);
extern "C" SEXP _arrow_TimestampParser__kind(SEXP parser_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::TimestampParser>&>::type parser(parser_sexp);
	return cpp11::as_sexp(TimestampParser__kind(parser));
END_CPP11
}
// csv.cpp
std::string TimestampParser__format(const std::shared_ptr<arrow::TimestampParser>& parser);
extern "C" SEXP _arrow_TimestampParser__format(SEXP parser_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::TimestampParser>&>::type parser(parser_sexp);
	return cpp11::as_sexp(TimestampParser__format(parser));
END_CPP11
}
// csv.cpp
std::shared_ptr<arrow::TimestampParser> TimestampParser__MakeStrptime(std::string format);
extern "C" SEXP _arrow_TimestampParser__MakeStrptime(SEXP format_sexp){
BEGIN_CPP11
	arrow::r::Input<std::string>::type format(format_sexp);
	return cpp11::as_sexp(TimestampParser__MakeStrptime(format));
END_CPP11
}
// csv.cpp
std::shared_ptr<arrow::TimestampParser> TimestampParser__MakeISO8601();
extern "C" SEXP _arrow_TimestampParser__MakeISO8601(){
BEGIN_CPP11
	return cpp11::as_sexp(TimestampParser__MakeISO8601());
END_CPP11
}
// csv.cpp
void csv___WriteCSV__Table(const std::shared_ptr<arrow::Table>& table, const std::shared_ptr<arrow::csv::WriteOptions>& write_options, const std::shared_ptr<arrow::io::OutputStream>& stream);
extern "C" SEXP _arrow_csv___WriteCSV__Table(SEXP table_sexp, SEXP write_options_sexp, SEXP stream_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Table>&>::type table(table_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::csv::WriteOptions>&>::type write_options(write_options_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::io::OutputStream>&>::type stream(stream_sexp);
	csv___WriteCSV__Table(table, write_options, stream);
	return R_NilValue;
END_CPP11
}
// csv.cpp
void csv___WriteCSV__RecordBatch(const std::shared_ptr<arrow::RecordBatch>& record_batch, const std::shared_ptr<arrow::csv::WriteOptions>& write_options, const std::shared_ptr<arrow::io::OutputStream>& stream);
extern "C" SEXP _arrow_csv___WriteCSV__RecordBatch(SEXP record_batch_sexp, SEXP write_options_sexp, SEXP stream_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::RecordBatch>&>::type record_batch(record_batch_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::csv::WriteOptions>&>::type write_options(write_options_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::io::OutputStream>&>::type stream(stream_sexp);
	csv___WriteCSV__RecordBatch(record_batch, write_options, stream);
	return R_NilValue;
END_CPP11
}
// csv.cpp
void csv___WriteCSV__RecordBatchReader(const std::shared_ptr<arrow::RecordBatchReader>& reader, const std::shared_ptr<arrow::csv::WriteOptions>& write_options, const std::shared_ptr<arrow::io::OutputStream>& stream);
extern "C" SEXP _arrow_csv___WriteCSV__RecordBatchReader(SEXP reader_sexp, SEXP write_options_sexp, SEXP stream_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::RecordBatchReader>&>::type reader(reader_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::csv::WriteOptions>&>::type write_options(write_options_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::io::OutputStream>&>::type stream(stream_sexp);
	csv___WriteCSV__RecordBatchReader(reader, write_options, stream);
	return R_NilValue;
END_CPP11
}
// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
std::shared_ptr<ds::ScannerBuilder> dataset___Dataset__NewScan(const std::shared_ptr<ds::Dataset>& ds);
extern "C" SEXP _arrow_dataset___Dataset__NewScan(SEXP ds_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<ds::Dataset>&>::type ds(ds_sexp);
	return cpp11::as_sexp(dataset___Dataset__NewScan(ds));
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___Dataset__NewScan(SEXP ds_sexp){
	Rf_error("Cannot call dataset___Dataset__NewScan(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
std::shared_ptr<arrow::Schema> dataset___Dataset__schema(const std::shared_ptr<ds::Dataset>& dataset);
extern "C" SEXP _arrow_dataset___Dataset__schema(SEXP dataset_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<ds::Dataset>&>::type dataset(dataset_sexp);
	return cpp11::as_sexp(dataset___Dataset__schema(dataset));
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___Dataset__schema(SEXP dataset_sexp){
	Rf_error("Cannot call dataset___Dataset__schema(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
std::string dataset___Dataset__type_name(const std::shared_ptr<ds::Dataset>& dataset);
extern "C" SEXP _arrow_dataset___Dataset__type_name(SEXP dataset_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<ds::Dataset>&>::type dataset(dataset_sexp);
	return cpp11::as_sexp(dataset___Dataset__type_name(dataset));
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___Dataset__type_name(SEXP dataset_sexp){
	Rf_error("Cannot call dataset___Dataset__type_name(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
std::shared_ptr<ds::Dataset> dataset___Dataset__ReplaceSchema(const std::shared_ptr<ds::Dataset>& dataset, const std::shared_ptr<arrow::Schema>& schm);
extern "C" SEXP _arrow_dataset___Dataset__ReplaceSchema(SEXP dataset_sexp, SEXP schm_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<ds::Dataset>&>::type dataset(dataset_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::Schema>&>::type schm(schm_sexp);
	return cpp11::as_sexp(dataset___Dataset__ReplaceSchema(dataset, schm));
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___Dataset__ReplaceSchema(SEXP dataset_sexp, SEXP schm_sexp){
	Rf_error("Cannot call dataset___Dataset__ReplaceSchema(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
std::shared_ptr<ds::Dataset> dataset___UnionDataset__create(const ds::DatasetVector& datasets, const std::shared_ptr<arrow::Schema>& schm);
extern "C" SEXP _arrow_dataset___UnionDataset__create(SEXP datasets_sexp, SEXP schm_sexp){
BEGIN_CPP11
	arrow::r::Input<const ds::DatasetVector&>::type datasets(datasets_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::Schema>&>::type schm(schm_sexp);
	return cpp11::as_sexp(dataset___UnionDataset__create(datasets, schm));
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___UnionDataset__create(SEXP datasets_sexp, SEXP schm_sexp){
	Rf_error("Cannot call dataset___UnionDataset__create(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
std::shared_ptr<ds::Dataset> dataset___InMemoryDataset__create(const std::shared_ptr<arrow::Table>& table);
extern "C" SEXP _arrow_dataset___InMemoryDataset__create(SEXP table_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Table>&>::type table(table_sexp);
	return cpp11::as_sexp(dataset___InMemoryDataset__create(table));
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___InMemoryDataset__create(SEXP table_sexp){
	Rf_error("Cannot call dataset___InMemoryDataset__create(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
cpp11::list dataset___UnionDataset__children(const std::shared_ptr<ds::UnionDataset>& ds);
extern "C" SEXP _arrow_dataset___UnionDataset__children(SEXP ds_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<ds::UnionDataset>&>::type ds(ds_sexp);
	return cpp11::as_sexp(dataset___UnionDataset__children(ds));
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___UnionDataset__children(SEXP ds_sexp){
	Rf_error("Cannot call dataset___UnionDataset__children(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
std::shared_ptr<ds::FileFormat> dataset___FileSystemDataset__format(const std::shared_ptr<ds::FileSystemDataset>& dataset);
extern "C" SEXP _arrow_dataset___FileSystemDataset__format(SEXP dataset_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<ds::FileSystemDataset>&>::type dataset(dataset_sexp);
	return cpp11::as_sexp(dataset___FileSystemDataset__format(dataset));
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___FileSystemDataset__format(SEXP dataset_sexp){
	Rf_error("Cannot call dataset___FileSystemDataset__format(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
std::shared_ptr<fs::FileSystem> dataset___FileSystemDataset__filesystem(const std::shared_ptr<ds::FileSystemDataset>& dataset);
extern "C" SEXP _arrow_dataset___FileSystemDataset__filesystem(SEXP dataset_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<ds::FileSystemDataset>&>::type dataset(dataset_sexp);
	return cpp11::as_sexp(dataset___FileSystemDataset__filesystem(dataset));
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___FileSystemDataset__filesystem(SEXP dataset_sexp){
	Rf_error("Cannot call dataset___FileSystemDataset__filesystem(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
std::vector<std::string> dataset___FileSystemDataset__files(const std::shared_ptr<ds::FileSystemDataset>& dataset);
extern "C" SEXP _arrow_dataset___FileSystemDataset__files(SEXP dataset_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<ds::FileSystemDataset>&>::type dataset(dataset_sexp);
	return cpp11::as_sexp(dataset___FileSystemDataset__files(dataset));
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___FileSystemDataset__files(SEXP dataset_sexp){
	Rf_error("Cannot call dataset___FileSystemDataset__files(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
std::shared_ptr<ds::Dataset> dataset___DatasetFactory__Finish1(const std::shared_ptr<ds::DatasetFactory>& factory, bool unify_schemas);
extern "C" SEXP _arrow_dataset___DatasetFactory__Finish1(SEXP factory_sexp, SEXP unify_schemas_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<ds::DatasetFactory>&>::type factory(factory_sexp);
	arrow::r::Input<bool>::type unify_schemas(unify_schemas_sexp);
	return cpp11::as_sexp(dataset___DatasetFactory__Finish1(factory, unify_schemas));
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___DatasetFactory__Finish1(SEXP factory_sexp, SEXP unify_schemas_sexp){
	Rf_error("Cannot call dataset___DatasetFactory__Finish1(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
std::shared_ptr<ds::Dataset> dataset___DatasetFactory__Finish2(const std::shared_ptr<ds::DatasetFactory>& factory, const std::shared_ptr<arrow::Schema>& schema);
extern "C" SEXP _arrow_dataset___DatasetFactory__Finish2(SEXP factory_sexp, SEXP schema_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<ds::DatasetFactory>&>::type factory(factory_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::Schema>&>::type schema(schema_sexp);
	return cpp11::as_sexp(dataset___DatasetFactory__Finish2(factory, schema));
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___DatasetFactory__Finish2(SEXP factory_sexp, SEXP schema_sexp){
	Rf_error("Cannot call dataset___DatasetFactory__Finish2(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
std::shared_ptr<arrow::Schema> dataset___DatasetFactory__Inspect(const std::shared_ptr<ds::DatasetFactory>& factory, bool unify_schemas);
extern "C" SEXP _arrow_dataset___DatasetFactory__Inspect(SEXP factory_sexp, SEXP unify_schemas_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<ds::DatasetFactory>&>::type factory(factory_sexp);
	arrow::r::Input<bool>::type unify_schemas(unify_schemas_sexp);
	return cpp11::as_sexp(dataset___DatasetFactory__Inspect(factory, unify_schemas));
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___DatasetFactory__Inspect(SEXP factory_sexp, SEXP unify_schemas_sexp){
	Rf_error("Cannot call dataset___DatasetFactory__Inspect(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
std::shared_ptr<ds::DatasetFactory> dataset___UnionDatasetFactory__Make(const std::vector<std::shared_ptr<ds::DatasetFactory>>& children);
extern "C" SEXP _arrow_dataset___UnionDatasetFactory__Make(SEXP children_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::vector<std::shared_ptr<ds::DatasetFactory>>&>::type children(children_sexp);
	return cpp11::as_sexp(dataset___UnionDatasetFactory__Make(children));
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___UnionDatasetFactory__Make(SEXP children_sexp){
	Rf_error("Cannot call dataset___UnionDatasetFactory__Make(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
std::shared_ptr<ds::FileSystemDatasetFactory> dataset___FileSystemDatasetFactory__Make(const std::shared_ptr<fs::FileSystem>& fs, const std::shared_ptr<fs::FileSelector>& selector, const std::shared_ptr<ds::FileFormat>& format, cpp11::list fsf_options);
extern "C" SEXP _arrow_dataset___FileSystemDatasetFactory__Make(SEXP fs_sexp, SEXP selector_sexp, SEXP format_sexp, SEXP fsf_options_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<fs::FileSystem>&>::type fs(fs_sexp);
	arrow::r::Input<const std::shared_ptr<fs::FileSelector>&>::type selector(selector_sexp);
	arrow::r::Input<const std::shared_ptr<ds::FileFormat>&>::type format(format_sexp);
	arrow::r::Input<cpp11::list>::type fsf_options(fsf_options_sexp);
	return cpp11::as_sexp(dataset___FileSystemDatasetFactory__Make(fs, selector, format, fsf_options));
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___FileSystemDatasetFactory__Make(SEXP fs_sexp, SEXP selector_sexp, SEXP format_sexp, SEXP fsf_options_sexp){
	Rf_error("Cannot call dataset___FileSystemDatasetFactory__Make(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
std::shared_ptr<ds::FileSystemDatasetFactory> dataset___FileSystemDatasetFactory__MakePaths(const std::shared_ptr<fs::FileSystem>& fs, const std::vector<std::string>& paths, const std::shared_ptr<ds::FileFormat>& format, bool exclude_invalid_files);
extern "C" SEXP _arrow_dataset___FileSystemDatasetFactory__MakePaths(SEXP fs_sexp, SEXP paths_sexp, SEXP format_sexp, SEXP exclude_invalid_files_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<fs::FileSystem>&>::type fs(fs_sexp);
	arrow::r::Input<const std::vector<std::string>&>::type paths(paths_sexp);
	arrow::r::Input<const std::shared_ptr<ds::FileFormat>&>::type format(format_sexp);
	arrow::r::Input<bool>::type exclude_invalid_files(exclude_invalid_files_sexp);
	return cpp11::as_sexp(dataset___FileSystemDatasetFactory__MakePaths(fs, paths, format, exclude_invalid_files));
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___FileSystemDatasetFactory__MakePaths(SEXP fs_sexp, SEXP paths_sexp, SEXP format_sexp, SEXP exclude_invalid_files_sexp){
	Rf_error("Cannot call dataset___FileSystemDatasetFactory__MakePaths(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
std::string dataset___FileFormat__type_name(const std::shared_ptr<ds::FileFormat>& format);
extern "C" SEXP _arrow_dataset___FileFormat__type_name(SEXP format_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<ds::FileFormat>&>::type format(format_sexp);
	return cpp11::as_sexp(dataset___FileFormat__type_name(format));
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___FileFormat__type_name(SEXP format_sexp){
	Rf_error("Cannot call dataset___FileFormat__type_name(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
std::shared_ptr<ds::FileWriteOptions> dataset___FileFormat__DefaultWriteOptions(const std::shared_ptr<ds::FileFormat>& fmt);
extern "C" SEXP _arrow_dataset___FileFormat__DefaultWriteOptions(SEXP fmt_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<ds::FileFormat>&>::type fmt(fmt_sexp);
	return cpp11::as_sexp(dataset___FileFormat__DefaultWriteOptions(fmt));
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___FileFormat__DefaultWriteOptions(SEXP fmt_sexp){
	Rf_error("Cannot call dataset___FileFormat__DefaultWriteOptions(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
std::shared_ptr<ds::ParquetFileFormat> dataset___ParquetFileFormat__Make(const std::shared_ptr<ds::ParquetFragmentScanOptions>& options, cpp11::strings dict_columns);
extern "C" SEXP _arrow_dataset___ParquetFileFormat__Make(SEXP options_sexp, SEXP dict_columns_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<ds::ParquetFragmentScanOptions>&>::type options(options_sexp);
	arrow::r::Input<cpp11::strings>::type dict_columns(dict_columns_sexp);
	return cpp11::as_sexp(dataset___ParquetFileFormat__Make(options, dict_columns));
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___ParquetFileFormat__Make(SEXP options_sexp, SEXP dict_columns_sexp){
	Rf_error("Cannot call dataset___ParquetFileFormat__Make(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
std::string dataset___FileWriteOptions__type_name(const std::shared_ptr<ds::FileWriteOptions>& options);
extern "C" SEXP _arrow_dataset___FileWriteOptions__type_name(SEXP options_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<ds::FileWriteOptions>&>::type options(options_sexp);
	return cpp11::as_sexp(dataset___FileWriteOptions__type_name(options));
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___FileWriteOptions__type_name(SEXP options_sexp){
	Rf_error("Cannot call dataset___FileWriteOptions__type_name(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
void dataset___ParquetFileWriteOptions__update(const std::shared_ptr<ds::ParquetFileWriteOptions>& options, const std::shared_ptr<parquet::WriterProperties>& writer_props, const std::shared_ptr<parquet::ArrowWriterProperties>& arrow_writer_props);
extern "C" SEXP _arrow_dataset___ParquetFileWriteOptions__update(SEXP options_sexp, SEXP writer_props_sexp, SEXP arrow_writer_props_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<ds::ParquetFileWriteOptions>&>::type options(options_sexp);
	arrow::r::Input<const std::shared_ptr<parquet::WriterProperties>&>::type writer_props(writer_props_sexp);
	arrow::r::Input<const std::shared_ptr<parquet::ArrowWriterProperties>&>::type arrow_writer_props(arrow_writer_props_sexp);
	dataset___ParquetFileWriteOptions__update(options, writer_props, arrow_writer_props);
	return R_NilValue;
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___ParquetFileWriteOptions__update(SEXP options_sexp, SEXP writer_props_sexp, SEXP arrow_writer_props_sexp){
	Rf_error("Cannot call dataset___ParquetFileWriteOptions__update(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
void dataset___IpcFileWriteOptions__update2(const std::shared_ptr<ds::IpcFileWriteOptions>& ipc_options, bool use_legacy_format, const std::shared_ptr<arrow::util::Codec>& codec, arrow::ipc::MetadataVersion metadata_version);
extern "C" SEXP _arrow_dataset___IpcFileWriteOptions__update2(SEXP ipc_options_sexp, SEXP use_legacy_format_sexp, SEXP codec_sexp, SEXP metadata_version_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<ds::IpcFileWriteOptions>&>::type ipc_options(ipc_options_sexp);
	arrow::r::Input<bool>::type use_legacy_format(use_legacy_format_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::util::Codec>&>::type codec(codec_sexp);
	arrow::r::Input<arrow::ipc::MetadataVersion>::type metadata_version(metadata_version_sexp);
	dataset___IpcFileWriteOptions__update2(ipc_options, use_legacy_format, codec, metadata_version);
	return R_NilValue;
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___IpcFileWriteOptions__update2(SEXP ipc_options_sexp, SEXP use_legacy_format_sexp, SEXP codec_sexp, SEXP metadata_version_sexp){
	Rf_error("Cannot call dataset___IpcFileWriteOptions__update2(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
void dataset___IpcFileWriteOptions__update1(const std::shared_ptr<ds::IpcFileWriteOptions>& ipc_options, bool use_legacy_format, arrow::ipc::MetadataVersion metadata_version);
extern "C" SEXP _arrow_dataset___IpcFileWriteOptions__update1(SEXP ipc_options_sexp, SEXP use_legacy_format_sexp, SEXP metadata_version_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<ds::IpcFileWriteOptions>&>::type ipc_options(ipc_options_sexp);
	arrow::r::Input<bool>::type use_legacy_format(use_legacy_format_sexp);
	arrow::r::Input<arrow::ipc::MetadataVersion>::type metadata_version(metadata_version_sexp);
	dataset___IpcFileWriteOptions__update1(ipc_options, use_legacy_format, metadata_version);
	return R_NilValue;
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___IpcFileWriteOptions__update1(SEXP ipc_options_sexp, SEXP use_legacy_format_sexp, SEXP metadata_version_sexp){
	Rf_error("Cannot call dataset___IpcFileWriteOptions__update1(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
void dataset___CsvFileWriteOptions__update(const std::shared_ptr<ds::CsvFileWriteOptions>& csv_options, const std::shared_ptr<arrow::csv::WriteOptions>& write_options);
extern "C" SEXP _arrow_dataset___CsvFileWriteOptions__update(SEXP csv_options_sexp, SEXP write_options_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<ds::CsvFileWriteOptions>&>::type csv_options(csv_options_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::csv::WriteOptions>&>::type write_options(write_options_sexp);
	dataset___CsvFileWriteOptions__update(csv_options, write_options);
	return R_NilValue;
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___CsvFileWriteOptions__update(SEXP csv_options_sexp, SEXP write_options_sexp){
	Rf_error("Cannot call dataset___CsvFileWriteOptions__update(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
std::shared_ptr<ds::IpcFileFormat> dataset___IpcFileFormat__Make();
extern "C" SEXP _arrow_dataset___IpcFileFormat__Make(){
BEGIN_CPP11
	return cpp11::as_sexp(dataset___IpcFileFormat__Make());
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___IpcFileFormat__Make(){
	Rf_error("Cannot call dataset___IpcFileFormat__Make(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
std::shared_ptr<ds::CsvFileFormat> dataset___CsvFileFormat__Make(const std::shared_ptr<arrow::csv::ParseOptions>& parse_options, const std::shared_ptr<arrow::csv::ConvertOptions>& convert_options, const std::shared_ptr<arrow::csv::ReadOptions>& read_options);
extern "C" SEXP _arrow_dataset___CsvFileFormat__Make(SEXP parse_options_sexp, SEXP convert_options_sexp, SEXP read_options_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::csv::ParseOptions>&>::type parse_options(parse_options_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::csv::ConvertOptions>&>::type convert_options(convert_options_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::csv::ReadOptions>&>::type read_options(read_options_sexp);
	return cpp11::as_sexp(dataset___CsvFileFormat__Make(parse_options, convert_options, read_options));
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___CsvFileFormat__Make(SEXP parse_options_sexp, SEXP convert_options_sexp, SEXP read_options_sexp){
	Rf_error("Cannot call dataset___CsvFileFormat__Make(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
std::string dataset___FragmentScanOptions__type_name(const std::shared_ptr<ds::FragmentScanOptions>& fragment_scan_options);
extern "C" SEXP _arrow_dataset___FragmentScanOptions__type_name(SEXP fragment_scan_options_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<ds::FragmentScanOptions>&>::type fragment_scan_options(fragment_scan_options_sexp);
	return cpp11::as_sexp(dataset___FragmentScanOptions__type_name(fragment_scan_options));
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___FragmentScanOptions__type_name(SEXP fragment_scan_options_sexp){
	Rf_error("Cannot call dataset___FragmentScanOptions__type_name(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
std::shared_ptr<ds::CsvFragmentScanOptions> dataset___CsvFragmentScanOptions__Make(const std::shared_ptr<arrow::csv::ConvertOptions>& convert_options, const std::shared_ptr<arrow::csv::ReadOptions>& read_options);
extern "C" SEXP _arrow_dataset___CsvFragmentScanOptions__Make(SEXP convert_options_sexp, SEXP read_options_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::csv::ConvertOptions>&>::type convert_options(convert_options_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::csv::ReadOptions>&>::type read_options(read_options_sexp);
	return cpp11::as_sexp(dataset___CsvFragmentScanOptions__Make(convert_options, read_options));
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___CsvFragmentScanOptions__Make(SEXP convert_options_sexp, SEXP read_options_sexp){
	Rf_error("Cannot call dataset___CsvFragmentScanOptions__Make(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
std::shared_ptr<ds::ParquetFragmentScanOptions> dataset___ParquetFragmentScanOptions__Make(bool use_buffered_stream, int64_t buffer_size, bool pre_buffer);
extern "C" SEXP _arrow_dataset___ParquetFragmentScanOptions__Make(SEXP use_buffered_stream_sexp, SEXP buffer_size_sexp, SEXP pre_buffer_sexp){
BEGIN_CPP11
	arrow::r::Input<bool>::type use_buffered_stream(use_buffered_stream_sexp);
	arrow::r::Input<int64_t>::type buffer_size(buffer_size_sexp);
	arrow::r::Input<bool>::type pre_buffer(pre_buffer_sexp);
	return cpp11::as_sexp(dataset___ParquetFragmentScanOptions__Make(use_buffered_stream, buffer_size, pre_buffer));
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___ParquetFragmentScanOptions__Make(SEXP use_buffered_stream_sexp, SEXP buffer_size_sexp, SEXP pre_buffer_sexp){
	Rf_error("Cannot call dataset___ParquetFragmentScanOptions__Make(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
std::shared_ptr<ds::DirectoryPartitioning> dataset___DirectoryPartitioning(const std::shared_ptr<arrow::Schema>& schm, const std::string& segment_encoding);
extern "C" SEXP _arrow_dataset___DirectoryPartitioning(SEXP schm_sexp, SEXP segment_encoding_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Schema>&>::type schm(schm_sexp);
	arrow::r::Input<const std::string&>::type segment_encoding(segment_encoding_sexp);
	return cpp11::as_sexp(dataset___DirectoryPartitioning(schm, segment_encoding));
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___DirectoryPartitioning(SEXP schm_sexp, SEXP segment_encoding_sexp){
	Rf_error("Cannot call dataset___DirectoryPartitioning(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
std::shared_ptr<ds::PartitioningFactory> dataset___DirectoryPartitioning__MakeFactory(const std::vector<std::string>& field_names, const std::string& segment_encoding);
extern "C" SEXP _arrow_dataset___DirectoryPartitioning__MakeFactory(SEXP field_names_sexp, SEXP segment_encoding_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::vector<std::string>&>::type field_names(field_names_sexp);
	arrow::r::Input<const std::string&>::type segment_encoding(segment_encoding_sexp);
	return cpp11::as_sexp(dataset___DirectoryPartitioning__MakeFactory(field_names, segment_encoding));
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___DirectoryPartitioning__MakeFactory(SEXP field_names_sexp, SEXP segment_encoding_sexp){
	Rf_error("Cannot call dataset___DirectoryPartitioning__MakeFactory(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
std::shared_ptr<ds::HivePartitioning> dataset___HivePartitioning(const std::shared_ptr<arrow::Schema>& schm, const std::string& null_fallback, const std::string& segment_encoding);
extern "C" SEXP _arrow_dataset___HivePartitioning(SEXP schm_sexp, SEXP null_fallback_sexp, SEXP segment_encoding_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Schema>&>::type schm(schm_sexp);
	arrow::r::Input<const std::string&>::type null_fallback(null_fallback_sexp);
	arrow::r::Input<const std::string&>::type segment_encoding(segment_encoding_sexp);
	return cpp11::as_sexp(dataset___HivePartitioning(schm, null_fallback, segment_encoding));
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___HivePartitioning(SEXP schm_sexp, SEXP null_fallback_sexp, SEXP segment_encoding_sexp){
	Rf_error("Cannot call dataset___HivePartitioning(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
std::shared_ptr<ds::PartitioningFactory> dataset___HivePartitioning__MakeFactory(const std::string& null_fallback, const std::string& segment_encoding);
extern "C" SEXP _arrow_dataset___HivePartitioning__MakeFactory(SEXP null_fallback_sexp, SEXP segment_encoding_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::string&>::type null_fallback(null_fallback_sexp);
	arrow::r::Input<const std::string&>::type segment_encoding(segment_encoding_sexp);
	return cpp11::as_sexp(dataset___HivePartitioning__MakeFactory(null_fallback, segment_encoding));
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___HivePartitioning__MakeFactory(SEXP null_fallback_sexp, SEXP segment_encoding_sexp){
	Rf_error("Cannot call dataset___HivePartitioning__MakeFactory(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
std::shared_ptr<arrow::Schema> dataset___PartitioningFactory__Inspect(const std::shared_ptr<ds::PartitioningFactory>& factory, const std::vector<std::string>& paths);
extern "C" SEXP _arrow_dataset___PartitioningFactory__Inspect(SEXP factory_sexp, SEXP paths_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<ds::PartitioningFactory>&>::type factory(factory_sexp);
	arrow::r::Input<const std::vector<std::string>&>::type paths(paths_sexp);
	return cpp11::as_sexp(dataset___PartitioningFactory__Inspect(factory, paths));
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___PartitioningFactory__Inspect(SEXP factory_sexp, SEXP paths_sexp){
	Rf_error("Cannot call dataset___PartitioningFactory__Inspect(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
std::shared_ptr<ds::Partitioning> dataset___PartitioningFactory__Finish(const std::shared_ptr<ds::PartitioningFactory>& factory, const std::shared_ptr<arrow::Schema>& schema);
extern "C" SEXP _arrow_dataset___PartitioningFactory__Finish(SEXP factory_sexp, SEXP schema_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<ds::PartitioningFactory>&>::type factory(factory_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::Schema>&>::type schema(schema_sexp);
	return cpp11::as_sexp(dataset___PartitioningFactory__Finish(factory, schema));
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___PartitioningFactory__Finish(SEXP factory_sexp, SEXP schema_sexp){
	Rf_error("Cannot call dataset___PartitioningFactory__Finish(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
std::string dataset___PartitioningFactory__type_name(const std::shared_ptr<ds::PartitioningFactory>& factory);
extern "C" SEXP _arrow_dataset___PartitioningFactory__type_name(SEXP factory_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<ds::PartitioningFactory>&>::type factory(factory_sexp);
	return cpp11::as_sexp(dataset___PartitioningFactory__type_name(factory));
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___PartitioningFactory__type_name(SEXP factory_sexp){
	Rf_error("Cannot call dataset___PartitioningFactory__type_name(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
void dataset___ScannerBuilder__ProjectNames(const std::shared_ptr<ds::ScannerBuilder>& sb, const std::vector<std::string>& cols);
extern "C" SEXP _arrow_dataset___ScannerBuilder__ProjectNames(SEXP sb_sexp, SEXP cols_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<ds::ScannerBuilder>&>::type sb(sb_sexp);
	arrow::r::Input<const std::vector<std::string>&>::type cols(cols_sexp);
	dataset___ScannerBuilder__ProjectNames(sb, cols);
	return R_NilValue;
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___ScannerBuilder__ProjectNames(SEXP sb_sexp, SEXP cols_sexp){
	Rf_error("Cannot call dataset___ScannerBuilder__ProjectNames(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
void dataset___ScannerBuilder__ProjectExprs(const std::shared_ptr<ds::ScannerBuilder>& sb, const std::vector<std::shared_ptr<compute::Expression>>& exprs, const std::vector<std::string>& names);
extern "C" SEXP _arrow_dataset___ScannerBuilder__ProjectExprs(SEXP sb_sexp, SEXP exprs_sexp, SEXP names_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<ds::ScannerBuilder>&>::type sb(sb_sexp);
	arrow::r::Input<const std::vector<std::shared_ptr<compute::Expression>>&>::type exprs(exprs_sexp);
	arrow::r::Input<const std::vector<std::string>&>::type names(names_sexp);
	dataset___ScannerBuilder__ProjectExprs(sb, exprs, names);
	return R_NilValue;
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___ScannerBuilder__ProjectExprs(SEXP sb_sexp, SEXP exprs_sexp, SEXP names_sexp){
	Rf_error("Cannot call dataset___ScannerBuilder__ProjectExprs(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
void dataset___ScannerBuilder__Filter(const std::shared_ptr<ds::ScannerBuilder>& sb, const std::shared_ptr<compute::Expression>& expr);
extern "C" SEXP _arrow_dataset___ScannerBuilder__Filter(SEXP sb_sexp, SEXP expr_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<ds::ScannerBuilder>&>::type sb(sb_sexp);
	arrow::r::Input<const std::shared_ptr<compute::Expression>&>::type expr(expr_sexp);
	dataset___ScannerBuilder__Filter(sb, expr);
	return R_NilValue;
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___ScannerBuilder__Filter(SEXP sb_sexp, SEXP expr_sexp){
	Rf_error("Cannot call dataset___ScannerBuilder__Filter(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
void dataset___ScannerBuilder__UseThreads(const std::shared_ptr<ds::ScannerBuilder>& sb, bool threads);
extern "C" SEXP _arrow_dataset___ScannerBuilder__UseThreads(SEXP sb_sexp, SEXP threads_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<ds::ScannerBuilder>&>::type sb(sb_sexp);
	arrow::r::Input<bool>::type threads(threads_sexp);
	dataset___ScannerBuilder__UseThreads(sb, threads);
	return R_NilValue;
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___ScannerBuilder__UseThreads(SEXP sb_sexp, SEXP threads_sexp){
	Rf_error("Cannot call dataset___ScannerBuilder__UseThreads(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
void dataset___ScannerBuilder__BatchSize(const std::shared_ptr<ds::ScannerBuilder>& sb, int64_t batch_size);
extern "C" SEXP _arrow_dataset___ScannerBuilder__BatchSize(SEXP sb_sexp, SEXP batch_size_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<ds::ScannerBuilder>&>::type sb(sb_sexp);
	arrow::r::Input<int64_t>::type batch_size(batch_size_sexp);
	dataset___ScannerBuilder__BatchSize(sb, batch_size);
	return R_NilValue;
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___ScannerBuilder__BatchSize(SEXP sb_sexp, SEXP batch_size_sexp){
	Rf_error("Cannot call dataset___ScannerBuilder__BatchSize(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
void dataset___ScannerBuilder__FragmentScanOptions(const std::shared_ptr<ds::ScannerBuilder>& sb, const std::shared_ptr<ds::FragmentScanOptions>& options);
extern "C" SEXP _arrow_dataset___ScannerBuilder__FragmentScanOptions(SEXP sb_sexp, SEXP options_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<ds::ScannerBuilder>&>::type sb(sb_sexp);
	arrow::r::Input<const std::shared_ptr<ds::FragmentScanOptions>&>::type options(options_sexp);
	dataset___ScannerBuilder__FragmentScanOptions(sb, options);
	return R_NilValue;
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___ScannerBuilder__FragmentScanOptions(SEXP sb_sexp, SEXP options_sexp){
	Rf_error("Cannot call dataset___ScannerBuilder__FragmentScanOptions(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
std::shared_ptr<arrow::Schema> dataset___ScannerBuilder__schema(const std::shared_ptr<ds::ScannerBuilder>& sb);
extern "C" SEXP _arrow_dataset___ScannerBuilder__schema(SEXP sb_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<ds::ScannerBuilder>&>::type sb(sb_sexp);
	return cpp11::as_sexp(dataset___ScannerBuilder__schema(sb));
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___ScannerBuilder__schema(SEXP sb_sexp){
	Rf_error("Cannot call dataset___ScannerBuilder__schema(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
std::shared_ptr<ds::Scanner> dataset___ScannerBuilder__Finish(const std::shared_ptr<ds::ScannerBuilder>& sb);
extern "C" SEXP _arrow_dataset___ScannerBuilder__Finish(SEXP sb_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<ds::ScannerBuilder>&>::type sb(sb_sexp);
	return cpp11::as_sexp(dataset___ScannerBuilder__Finish(sb));
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___ScannerBuilder__Finish(SEXP sb_sexp){
	Rf_error("Cannot call dataset___ScannerBuilder__Finish(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
std::shared_ptr<ds::ScannerBuilder> dataset___ScannerBuilder__FromRecordBatchReader(const std::shared_ptr<arrow::RecordBatchReader>& reader);
extern "C" SEXP _arrow_dataset___ScannerBuilder__FromRecordBatchReader(SEXP reader_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::RecordBatchReader>&>::type reader(reader_sexp);
	return cpp11::as_sexp(dataset___ScannerBuilder__FromRecordBatchReader(reader));
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___ScannerBuilder__FromRecordBatchReader(SEXP reader_sexp){
	Rf_error("Cannot call dataset___ScannerBuilder__FromRecordBatchReader(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
std::shared_ptr<arrow::Table> dataset___Scanner__ToTable(const std::shared_ptr<ds::Scanner>& scanner);
extern "C" SEXP _arrow_dataset___Scanner__ToTable(SEXP scanner_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<ds::Scanner>&>::type scanner(scanner_sexp);
	return cpp11::as_sexp(dataset___Scanner__ToTable(scanner));
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___Scanner__ToTable(SEXP scanner_sexp){
	Rf_error("Cannot call dataset___Scanner__ToTable(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
cpp11::list dataset___Scanner__ScanBatches(const std::shared_ptr<ds::Scanner>& scanner);
extern "C" SEXP _arrow_dataset___Scanner__ScanBatches(SEXP scanner_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<ds::Scanner>&>::type scanner(scanner_sexp);
	return cpp11::as_sexp(dataset___Scanner__ScanBatches(scanner));
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___Scanner__ScanBatches(SEXP scanner_sexp){
	Rf_error("Cannot call dataset___Scanner__ScanBatches(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
std::shared_ptr<arrow::RecordBatchReader> dataset___Scanner__ToRecordBatchReader(const std::shared_ptr<ds::Scanner>& scanner);
extern "C" SEXP _arrow_dataset___Scanner__ToRecordBatchReader(SEXP scanner_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<ds::Scanner>&>::type scanner(scanner_sexp);
	return cpp11::as_sexp(dataset___Scanner__ToRecordBatchReader(scanner));
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___Scanner__ToRecordBatchReader(SEXP scanner_sexp){
	Rf_error("Cannot call dataset___Scanner__ToRecordBatchReader(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
std::shared_ptr<arrow::Table> dataset___Scanner__head(const std::shared_ptr<ds::Scanner>& scanner, int n);
extern "C" SEXP _arrow_dataset___Scanner__head(SEXP scanner_sexp, SEXP n_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<ds::Scanner>&>::type scanner(scanner_sexp);
	arrow::r::Input<int>::type n(n_sexp);
	return cpp11::as_sexp(dataset___Scanner__head(scanner, n));
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___Scanner__head(SEXP scanner_sexp, SEXP n_sexp){
	Rf_error("Cannot call dataset___Scanner__head(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
std::shared_ptr<arrow::Schema> dataset___Scanner__schema(const std::shared_ptr<ds::Scanner>& sc);
extern "C" SEXP _arrow_dataset___Scanner__schema(SEXP sc_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<ds::Scanner>&>::type sc(sc_sexp);
	return cpp11::as_sexp(dataset___Scanner__schema(sc));
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___Scanner__schema(SEXP sc_sexp){
	Rf_error("Cannot call dataset___Scanner__schema(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
std::shared_ptr<arrow::Table> dataset___Scanner__TakeRows(const std::shared_ptr<ds::Scanner>& scanner, const std::shared_ptr<arrow::Array>& indices);
extern "C" SEXP _arrow_dataset___Scanner__TakeRows(SEXP scanner_sexp, SEXP indices_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<ds::Scanner>&>::type scanner(scanner_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::Array>&>::type indices(indices_sexp);
	return cpp11::as_sexp(dataset___Scanner__TakeRows(scanner, indices));
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___Scanner__TakeRows(SEXP scanner_sexp, SEXP indices_sexp){
	Rf_error("Cannot call dataset___Scanner__TakeRows(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// dataset.cpp
#if defined(ARROW_R_WITH_DATASET)
r_vec_size dataset___Scanner__CountRows(const std::shared_ptr<ds::Scanner>& scanner);
extern "C" SEXP _arrow_dataset___Scanner__CountRows(SEXP scanner_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<ds::Scanner>&>::type scanner(scanner_sexp);
	return cpp11::as_sexp(dataset___Scanner__CountRows(scanner));
END_CPP11
}
#else
extern "C" SEXP _arrow_dataset___Scanner__CountRows(SEXP scanner_sexp){
	Rf_error("Cannot call dataset___Scanner__CountRows(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// datatype.cpp
std::shared_ptr<arrow::DataType> Int8__initialize();
extern "C" SEXP _arrow_Int8__initialize(){
BEGIN_CPP11
	return cpp11::as_sexp(Int8__initialize());
END_CPP11
}
// datatype.cpp
std::shared_ptr<arrow::DataType> Int16__initialize();
extern "C" SEXP _arrow_Int16__initialize(){
BEGIN_CPP11
	return cpp11::as_sexp(Int16__initialize());
END_CPP11
}
// datatype.cpp
std::shared_ptr<arrow::DataType> Int32__initialize();
extern "C" SEXP _arrow_Int32__initialize(){
BEGIN_CPP11
	return cpp11::as_sexp(Int32__initialize());
END_CPP11
}
// datatype.cpp
std::shared_ptr<arrow::DataType> Int64__initialize();
extern "C" SEXP _arrow_Int64__initialize(){
BEGIN_CPP11
	return cpp11::as_sexp(Int64__initialize());
END_CPP11
}
// datatype.cpp
std::shared_ptr<arrow::DataType> UInt8__initialize();
extern "C" SEXP _arrow_UInt8__initialize(){
BEGIN_CPP11
	return cpp11::as_sexp(UInt8__initialize());
END_CPP11
}
// datatype.cpp
std::shared_ptr<arrow::DataType> UInt16__initialize();
extern "C" SEXP _arrow_UInt16__initialize(){
BEGIN_CPP11
	return cpp11::as_sexp(UInt16__initialize());
END_CPP11
}
// datatype.cpp
std::shared_ptr<arrow::DataType> UInt32__initialize();
extern "C" SEXP _arrow_UInt32__initialize(){
BEGIN_CPP11
	return cpp11::as_sexp(UInt32__initialize());
END_CPP11
}
// datatype.cpp
std::shared_ptr<arrow::DataType> UInt64__initialize();
extern "C" SEXP _arrow_UInt64__initialize(){
BEGIN_CPP11
	return cpp11::as_sexp(UInt64__initialize());
END_CPP11
}
// datatype.cpp
std::shared_ptr<arrow::DataType> Float16__initialize();
extern "C" SEXP _arrow_Float16__initialize(){
BEGIN_CPP11
	return cpp11::as_sexp(Float16__initialize());
END_CPP11
}
// datatype.cpp
std::shared_ptr<arrow::DataType> Float32__initialize();
extern "C" SEXP _arrow_Float32__initialize(){
BEGIN_CPP11
	return cpp11::as_sexp(Float32__initialize());
END_CPP11
}
// datatype.cpp
std::shared_ptr<arrow::DataType> Float64__initialize();
extern "C" SEXP _arrow_Float64__initialize(){
BEGIN_CPP11
	return cpp11::as_sexp(Float64__initialize());
END_CPP11
}
// datatype.cpp
std::shared_ptr<arrow::DataType> Boolean__initialize();
extern "C" SEXP _arrow_Boolean__initialize(){
BEGIN_CPP11
	return cpp11::as_sexp(Boolean__initialize());
END_CPP11
}
// datatype.cpp
std::shared_ptr<arrow::DataType> Utf8__initialize();
extern "C" SEXP _arrow_Utf8__initialize(){
BEGIN_CPP11
	return cpp11::as_sexp(Utf8__initialize());
END_CPP11
}
// datatype.cpp
std::shared_ptr<arrow::DataType> LargeUtf8__initialize();
extern "C" SEXP _arrow_LargeUtf8__initialize(){
BEGIN_CPP11
	return cpp11::as_sexp(LargeUtf8__initialize());
END_CPP11
}
// datatype.cpp
std::shared_ptr<arrow::DataType> Binary__initialize();
extern "C" SEXP _arrow_Binary__initialize(){
BEGIN_CPP11
	return cpp11::as_sexp(Binary__initialize());
END_CPP11
}
// datatype.cpp
std::shared_ptr<arrow::DataType> LargeBinary__initialize();
extern "C" SEXP _arrow_LargeBinary__initialize(){
BEGIN_CPP11
	return cpp11::as_sexp(LargeBinary__initialize());
END_CPP11
}
// datatype.cpp
std::shared_ptr<arrow::DataType> Date32__initialize();
extern "C" SEXP _arrow_Date32__initialize(){
BEGIN_CPP11
	return cpp11::as_sexp(Date32__initialize());
END_CPP11
}
// datatype.cpp
std::shared_ptr<arrow::DataType> Date64__initialize();
extern "C" SEXP _arrow_Date64__initialize(){
BEGIN_CPP11
	return cpp11::as_sexp(Date64__initialize());
END_CPP11
}
// datatype.cpp
std::shared_ptr<arrow::DataType> Null__initialize();
extern "C" SEXP _arrow_Null__initialize(){
BEGIN_CPP11
	return cpp11::as_sexp(Null__initialize());
END_CPP11
}
// datatype.cpp
std::shared_ptr<arrow::DataType> Decimal128Type__initialize(int32_t precision, int32_t scale);
extern "C" SEXP _arrow_Decimal128Type__initialize(SEXP precision_sexp, SEXP scale_sexp){
BEGIN_CPP11
	arrow::r::Input<int32_t>::type precision(precision_sexp);
	arrow::r::Input<int32_t>::type scale(scale_sexp);
	return cpp11::as_sexp(Decimal128Type__initialize(precision, scale));
END_CPP11
}
// datatype.cpp
std::shared_ptr<arrow::DataType> Decimal256Type__initialize(int32_t precision, int32_t scale);
extern "C" SEXP _arrow_Decimal256Type__initialize(SEXP precision_sexp, SEXP scale_sexp){
BEGIN_CPP11
	arrow::r::Input<int32_t>::type precision(precision_sexp);
	arrow::r::Input<int32_t>::type scale(scale_sexp);
	return cpp11::as_sexp(Decimal256Type__initialize(precision, scale));
END_CPP11
}
// datatype.cpp
std::shared_ptr<arrow::DataType> DayTimeInterval__initialize();
extern "C" SEXP _arrow_DayTimeInterval__initialize(){
BEGIN_CPP11
	return cpp11::as_sexp(DayTimeInterval__initialize());
END_CPP11
}
// datatype.cpp
std::shared_ptr<arrow::DataType> FixedSizeBinary__initialize(R_xlen_t byte_width);
extern "C" SEXP _arrow_FixedSizeBinary__initialize(SEXP byte_width_sexp){
BEGIN_CPP11
	arrow::r::Input<R_xlen_t>::type byte_width(byte_width_sexp);
	return cpp11::as_sexp(FixedSizeBinary__initialize(byte_width));
END_CPP11
}
// datatype.cpp
int FixedSizeBinary__byte_width(const std::shared_ptr<arrow::FixedSizeBinaryType>& type);
extern "C" SEXP _arrow_FixedSizeBinary__byte_width(SEXP type_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::FixedSizeBinaryType>&>::type type(type_sexp);
	return cpp11::as_sexp(FixedSizeBinary__byte_width(type));
END_CPP11
}
// datatype.cpp
std::shared_ptr<arrow::DataType> Timestamp__initialize(arrow::TimeUnit::type unit, const std::string& timezone);
extern "C" SEXP _arrow_Timestamp__initialize(SEXP unit_sexp, SEXP timezone_sexp){
BEGIN_CPP11
	arrow::r::Input<arrow::TimeUnit::type>::type unit(unit_sexp);
	arrow::r::Input<const std::string&>::type timezone(timezone_sexp);
	return cpp11::as_sexp(Timestamp__initialize(unit, timezone));
END_CPP11
}
// datatype.cpp
std::shared_ptr<arrow::DataType> Time32__initialize(arrow::TimeUnit::type unit);
extern "C" SEXP _arrow_Time32__initialize(SEXP unit_sexp){
BEGIN_CPP11
	arrow::r::Input<arrow::TimeUnit::type>::type unit(unit_sexp);
	return cpp11::as_sexp(Time32__initialize(unit));
END_CPP11
}
// datatype.cpp
std::shared_ptr<arrow::DataType> Time64__initialize(arrow::TimeUnit::type unit);
extern "C" SEXP _arrow_Time64__initialize(SEXP unit_sexp){
BEGIN_CPP11
	arrow::r::Input<arrow::TimeUnit::type>::type unit(unit_sexp);
	return cpp11::as_sexp(Time64__initialize(unit));
END_CPP11
}
// datatype.cpp
std::shared_ptr<arrow::DataType> Duration__initialize(arrow::TimeUnit::type unit);
extern "C" SEXP _arrow_Duration__initialize(SEXP unit_sexp){
BEGIN_CPP11
	arrow::r::Input<arrow::TimeUnit::type>::type unit(unit_sexp);
	return cpp11::as_sexp(Duration__initialize(unit));
END_CPP11
}
// datatype.cpp
std::shared_ptr<arrow::DataType> list__(SEXP x);
extern "C" SEXP _arrow_list__(SEXP x_sexp){
BEGIN_CPP11
	arrow::r::Input<SEXP>::type x(x_sexp);
	return cpp11::as_sexp(list__(x));
END_CPP11
}
// datatype.cpp
std::shared_ptr<arrow::DataType> large_list__(SEXP x);
extern "C" SEXP _arrow_large_list__(SEXP x_sexp){
BEGIN_CPP11
	arrow::r::Input<SEXP>::type x(x_sexp);
	return cpp11::as_sexp(large_list__(x));
END_CPP11
}
// datatype.cpp
std::shared_ptr<arrow::DataType> fixed_size_list__(SEXP x, int list_size);
extern "C" SEXP _arrow_fixed_size_list__(SEXP x_sexp, SEXP list_size_sexp){
BEGIN_CPP11
	arrow::r::Input<SEXP>::type x(x_sexp);
	arrow::r::Input<int>::type list_size(list_size_sexp);
	return cpp11::as_sexp(fixed_size_list__(x, list_size));
END_CPP11
}
// datatype.cpp
std::shared_ptr<arrow::DataType> map__(SEXP key, SEXP item, bool keys_sorted);
extern "C" SEXP _arrow_map__(SEXP key_sexp, SEXP item_sexp, SEXP keys_sorted_sexp){
BEGIN_CPP11
	arrow::r::Input<SEXP>::type key(key_sexp);
	arrow::r::Input<SEXP>::type item(item_sexp);
	arrow::r::Input<bool>::type keys_sorted(keys_sorted_sexp);
	return cpp11::as_sexp(map__(key, item, keys_sorted));
END_CPP11
}
// datatype.cpp
std::shared_ptr<arrow::DataType> struct__(const std::vector<std::shared_ptr<arrow::Field>>& fields);
extern "C" SEXP _arrow_struct__(SEXP fields_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::vector<std::shared_ptr<arrow::Field>>&>::type fields(fields_sexp);
	return cpp11::as_sexp(struct__(fields));
END_CPP11
}
// datatype.cpp
std::string DataType__ToString(const std::shared_ptr<arrow::DataType>& type);
extern "C" SEXP _arrow_DataType__ToString(SEXP type_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::DataType>&>::type type(type_sexp);
	return cpp11::as_sexp(DataType__ToString(type));
END_CPP11
}
// datatype.cpp
std::string DataType__name(const std::shared_ptr<arrow::DataType>& type);
extern "C" SEXP _arrow_DataType__name(SEXP type_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::DataType>&>::type type(type_sexp);
	return cpp11::as_sexp(DataType__name(type));
END_CPP11
}
// datatype.cpp
bool DataType__Equals(const std::shared_ptr<arrow::DataType>& lhs, const std::shared_ptr<arrow::DataType>& rhs, bool check_metadata);
extern "C" SEXP _arrow_DataType__Equals(SEXP lhs_sexp, SEXP rhs_sexp, SEXP check_metadata_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::DataType>&>::type lhs(lhs_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::DataType>&>::type rhs(rhs_sexp);
	arrow::r::Input<bool>::type check_metadata(check_metadata_sexp);
	return cpp11::as_sexp(DataType__Equals(lhs, rhs, check_metadata));
END_CPP11
}
// datatype.cpp
int DataType__num_fields(const std::shared_ptr<arrow::DataType>& type);
extern "C" SEXP _arrow_DataType__num_fields(SEXP type_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::DataType>&>::type type(type_sexp);
	return cpp11::as_sexp(DataType__num_fields(type));
END_CPP11
}
// datatype.cpp
cpp11::list DataType__fields(const std::shared_ptr<arrow::DataType>& type);
extern "C" SEXP _arrow_DataType__fields(SEXP type_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::DataType>&>::type type(type_sexp);
	return cpp11::as_sexp(DataType__fields(type));
END_CPP11
}
// datatype.cpp
arrow::Type::type DataType__id(const std::shared_ptr<arrow::DataType>& type);
extern "C" SEXP _arrow_DataType__id(SEXP type_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::DataType>&>::type type(type_sexp);
	return cpp11::as_sexp(DataType__id(type));
END_CPP11
}
// datatype.cpp
std::string ListType__ToString(const std::shared_ptr<arrow::ListType>& type);
extern "C" SEXP _arrow_ListType__ToString(SEXP type_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::ListType>&>::type type(type_sexp);
	return cpp11::as_sexp(ListType__ToString(type));
END_CPP11
}
// datatype.cpp
int FixedWidthType__bit_width(const std::shared_ptr<arrow::FixedWidthType>& type);
extern "C" SEXP _arrow_FixedWidthType__bit_width(SEXP type_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::FixedWidthType>&>::type type(type_sexp);
	return cpp11::as_sexp(FixedWidthType__bit_width(type));
END_CPP11
}
// datatype.cpp
arrow::DateUnit DateType__unit(const std::shared_ptr<arrow::DateType>& type);
extern "C" SEXP _arrow_DateType__unit(SEXP type_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::DateType>&>::type type(type_sexp);
	return cpp11::as_sexp(DateType__unit(type));
END_CPP11
}
// datatype.cpp
arrow::TimeUnit::type TimeType__unit(const std::shared_ptr<arrow::TimeType>& type);
extern "C" SEXP _arrow_TimeType__unit(SEXP type_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::TimeType>&>::type type(type_sexp);
	return cpp11::as_sexp(TimeType__unit(type));
END_CPP11
}
// datatype.cpp
arrow::TimeUnit::type DurationType__unit(const std::shared_ptr<arrow::DurationType>& type);
extern "C" SEXP _arrow_DurationType__unit(SEXP type_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::DurationType>&>::type type(type_sexp);
	return cpp11::as_sexp(DurationType__unit(type));
END_CPP11
}
// datatype.cpp
int32_t DecimalType__precision(const std::shared_ptr<arrow::DecimalType>& type);
extern "C" SEXP _arrow_DecimalType__precision(SEXP type_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::DecimalType>&>::type type(type_sexp);
	return cpp11::as_sexp(DecimalType__precision(type));
END_CPP11
}
// datatype.cpp
int32_t DecimalType__scale(const std::shared_ptr<arrow::DecimalType>& type);
extern "C" SEXP _arrow_DecimalType__scale(SEXP type_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::DecimalType>&>::type type(type_sexp);
	return cpp11::as_sexp(DecimalType__scale(type));
END_CPP11
}
// datatype.cpp
std::string TimestampType__timezone(const std::shared_ptr<arrow::TimestampType>& type);
extern "C" SEXP _arrow_TimestampType__timezone(SEXP type_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::TimestampType>&>::type type(type_sexp);
	return cpp11::as_sexp(TimestampType__timezone(type));
END_CPP11
}
// datatype.cpp
arrow::TimeUnit::type TimestampType__unit(const std::shared_ptr<arrow::TimestampType>& type);
extern "C" SEXP _arrow_TimestampType__unit(SEXP type_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::TimestampType>&>::type type(type_sexp);
	return cpp11::as_sexp(TimestampType__unit(type));
END_CPP11
}
// datatype.cpp
std::shared_ptr<arrow::DataType> DictionaryType__initialize(const std::shared_ptr<arrow::DataType>& index_type, const std::shared_ptr<arrow::DataType>& value_type, bool ordered);
extern "C" SEXP _arrow_DictionaryType__initialize(SEXP index_type_sexp, SEXP value_type_sexp, SEXP ordered_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::DataType>&>::type index_type(index_type_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::DataType>&>::type value_type(value_type_sexp);
	arrow::r::Input<bool>::type ordered(ordered_sexp);
	return cpp11::as_sexp(DictionaryType__initialize(index_type, value_type, ordered));
END_CPP11
}
// datatype.cpp
std::shared_ptr<arrow::DataType> DictionaryType__index_type(const std::shared_ptr<arrow::DictionaryType>& type);
extern "C" SEXP _arrow_DictionaryType__index_type(SEXP type_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::DictionaryType>&>::type type(type_sexp);
	return cpp11::as_sexp(DictionaryType__index_type(type));
END_CPP11
}
// datatype.cpp
std::shared_ptr<arrow::DataType> DictionaryType__value_type(const std::shared_ptr<arrow::DictionaryType>& type);
extern "C" SEXP _arrow_DictionaryType__value_type(SEXP type_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::DictionaryType>&>::type type(type_sexp);
	return cpp11::as_sexp(DictionaryType__value_type(type));
END_CPP11
}
// datatype.cpp
std::string DictionaryType__name(const std::shared_ptr<arrow::DictionaryType>& type);
extern "C" SEXP _arrow_DictionaryType__name(SEXP type_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::DictionaryType>&>::type type(type_sexp);
	return cpp11::as_sexp(DictionaryType__name(type));
END_CPP11
}
// datatype.cpp
bool DictionaryType__ordered(const std::shared_ptr<arrow::DictionaryType>& type);
extern "C" SEXP _arrow_DictionaryType__ordered(SEXP type_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::DictionaryType>&>::type type(type_sexp);
	return cpp11::as_sexp(DictionaryType__ordered(type));
END_CPP11
}
// datatype.cpp
std::shared_ptr<arrow::Field> StructType__GetFieldByName(const std::shared_ptr<arrow::StructType>& type, const std::string& name);
extern "C" SEXP _arrow_StructType__GetFieldByName(SEXP type_sexp, SEXP name_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::StructType>&>::type type(type_sexp);
	arrow::r::Input<const std::string&>::type name(name_sexp);
	return cpp11::as_sexp(StructType__GetFieldByName(type, name));
END_CPP11
}
// datatype.cpp
int StructType__GetFieldIndex(const std::shared_ptr<arrow::StructType>& type, const std::string& name);
extern "C" SEXP _arrow_StructType__GetFieldIndex(SEXP type_sexp, SEXP name_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::StructType>&>::type type(type_sexp);
	arrow::r::Input<const std::string&>::type name(name_sexp);
	return cpp11::as_sexp(StructType__GetFieldIndex(type, name));
END_CPP11
}
// datatype.cpp
std::vector<std::string> StructType__field_names(const std::shared_ptr<arrow::StructType>& type);
extern "C" SEXP _arrow_StructType__field_names(SEXP type_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::StructType>&>::type type(type_sexp);
	return cpp11::as_sexp(StructType__field_names(type));
END_CPP11
}
// datatype.cpp
std::shared_ptr<arrow::Field> ListType__value_field(const std::shared_ptr<arrow::ListType>& type);
extern "C" SEXP _arrow_ListType__value_field(SEXP type_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::ListType>&>::type type(type_sexp);
	return cpp11::as_sexp(ListType__value_field(type));
END_CPP11
}
// datatype.cpp
std::shared_ptr<arrow::DataType> ListType__value_type(const std::shared_ptr<arrow::ListType>& type);
extern "C" SEXP _arrow_ListType__value_type(SEXP type_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::ListType>&>::type type(type_sexp);
	return cpp11::as_sexp(ListType__value_type(type));
END_CPP11
}
// datatype.cpp
std::shared_ptr<arrow::Field> LargeListType__value_field(const std::shared_ptr<arrow::LargeListType>& type);
extern "C" SEXP _arrow_LargeListType__value_field(SEXP type_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::LargeListType>&>::type type(type_sexp);
	return cpp11::as_sexp(LargeListType__value_field(type));
END_CPP11
}
// datatype.cpp
std::shared_ptr<arrow::DataType> LargeListType__value_type(const std::shared_ptr<arrow::LargeListType>& type);
extern "C" SEXP _arrow_LargeListType__value_type(SEXP type_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::LargeListType>&>::type type(type_sexp);
	return cpp11::as_sexp(LargeListType__value_type(type));
END_CPP11
}
// datatype.cpp
std::shared_ptr<arrow::Field> FixedSizeListType__value_field(const std::shared_ptr<arrow::FixedSizeListType>& type);
extern "C" SEXP _arrow_FixedSizeListType__value_field(SEXP type_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::FixedSizeListType>&>::type type(type_sexp);
	return cpp11::as_sexp(FixedSizeListType__value_field(type));
END_CPP11
}
// datatype.cpp
std::shared_ptr<arrow::DataType> FixedSizeListType__value_type(const std::shared_ptr<arrow::FixedSizeListType>& type);
extern "C" SEXP _arrow_FixedSizeListType__value_type(SEXP type_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::FixedSizeListType>&>::type type(type_sexp);
	return cpp11::as_sexp(FixedSizeListType__value_type(type));
END_CPP11
}
// datatype.cpp
int FixedSizeListType__list_size(const std::shared_ptr<arrow::FixedSizeListType>& type);
extern "C" SEXP _arrow_FixedSizeListType__list_size(SEXP type_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::FixedSizeListType>&>::type type(type_sexp);
	return cpp11::as_sexp(FixedSizeListType__list_size(type));
END_CPP11
}
// datatype.cpp
std::shared_ptr<arrow::Field> MapType__key_field(const std::shared_ptr<arrow::MapType>& type);
extern "C" SEXP _arrow_MapType__key_field(SEXP type_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::MapType>&>::type type(type_sexp);
	return cpp11::as_sexp(MapType__key_field(type));
END_CPP11
}
// datatype.cpp
std::shared_ptr<arrow::Field> MapType__item_field(const std::shared_ptr<arrow::MapType>& type);
extern "C" SEXP _arrow_MapType__item_field(SEXP type_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::MapType>&>::type type(type_sexp);
	return cpp11::as_sexp(MapType__item_field(type));
END_CPP11
}
// datatype.cpp
std::shared_ptr<arrow::DataType> MapType__key_type(const std::shared_ptr<arrow::MapType>& type);
extern "C" SEXP _arrow_MapType__key_type(SEXP type_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::MapType>&>::type type(type_sexp);
	return cpp11::as_sexp(MapType__key_type(type));
END_CPP11
}
// datatype.cpp
std::shared_ptr<arrow::DataType> MapType__item_type(const std::shared_ptr<arrow::MapType>& type);
extern "C" SEXP _arrow_MapType__item_type(SEXP type_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::MapType>&>::type type(type_sexp);
	return cpp11::as_sexp(MapType__item_type(type));
END_CPP11
}
// datatype.cpp
bool MapType__keys_sorted(const std::shared_ptr<arrow::MapType>& type);
extern "C" SEXP _arrow_MapType__keys_sorted(SEXP type_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::MapType>&>::type type(type_sexp);
	return cpp11::as_sexp(MapType__keys_sorted(type));
END_CPP11
}
// expression.cpp
bool compute___expr__equals(const std::shared_ptr<compute::Expression>& lhs, const std::shared_ptr<compute::Expression>& rhs);
extern "C" SEXP _arrow_compute___expr__equals(SEXP lhs_sexp, SEXP rhs_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<compute::Expression>&>::type lhs(lhs_sexp);
	arrow::r::Input<const std::shared_ptr<compute::Expression>&>::type rhs(rhs_sexp);
	return cpp11::as_sexp(compute___expr__equals(lhs, rhs));
END_CPP11
}
// expression.cpp
std::shared_ptr<compute::Expression> compute___expr__call(std::string func_name, cpp11::list argument_list, cpp11::list options);
extern "C" SEXP _arrow_compute___expr__call(SEXP func_name_sexp, SEXP argument_list_sexp, SEXP options_sexp){
BEGIN_CPP11
	arrow::r::Input<std::string>::type func_name(func_name_sexp);
	arrow::r::Input<cpp11::list>::type argument_list(argument_list_sexp);
	arrow::r::Input<cpp11::list>::type options(options_sexp);
	return cpp11::as_sexp(compute___expr__call(func_name, argument_list, options));
END_CPP11
}
// expression.cpp
bool compute___expr__is_field_ref(const std::shared_ptr<compute::Expression>& x);
extern "C" SEXP _arrow_compute___expr__is_field_ref(SEXP x_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<compute::Expression>&>::type x(x_sexp);
	return cpp11::as_sexp(compute___expr__is_field_ref(x));
END_CPP11
}
// expression.cpp
std::string compute___expr__get_field_ref_name(const std::shared_ptr<compute::Expression>& x);
extern "C" SEXP _arrow_compute___expr__get_field_ref_name(SEXP x_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<compute::Expression>&>::type x(x_sexp);
	return cpp11::as_sexp(compute___expr__get_field_ref_name(x));
END_CPP11
}
// expression.cpp
std::shared_ptr<compute::Expression> compute___expr__field_ref(std::string name);
extern "C" SEXP _arrow_compute___expr__field_ref(SEXP name_sexp){
BEGIN_CPP11
	arrow::r::Input<std::string>::type name(name_sexp);
	return cpp11::as_sexp(compute___expr__field_ref(name));
END_CPP11
}
// expression.cpp
std::shared_ptr<compute::Expression> compute___expr__nested_field_ref(const std::shared_ptr<compute::Expression>& x, std::string name);
extern "C" SEXP _arrow_compute___expr__nested_field_ref(SEXP x_sexp, SEXP name_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<compute::Expression>&>::type x(x_sexp);
	arrow::r::Input<std::string>::type name(name_sexp);
	return cpp11::as_sexp(compute___expr__nested_field_ref(x, name));
END_CPP11
}
// expression.cpp
std::shared_ptr<compute::Expression> compute___expr__scalar(const std::shared_ptr<arrow::Scalar>& x);
extern "C" SEXP _arrow_compute___expr__scalar(SEXP x_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Scalar>&>::type x(x_sexp);
	return cpp11::as_sexp(compute___expr__scalar(x));
END_CPP11
}
// expression.cpp
std::string compute___expr__ToString(const std::shared_ptr<compute::Expression>& x);
extern "C" SEXP _arrow_compute___expr__ToString(SEXP x_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<compute::Expression>&>::type x(x_sexp);
	return cpp11::as_sexp(compute___expr__ToString(x));
END_CPP11
}
// expression.cpp
std::shared_ptr<arrow::DataType> compute___expr__type(const std::shared_ptr<compute::Expression>& x, const std::shared_ptr<arrow::Schema>& schema);
extern "C" SEXP _arrow_compute___expr__type(SEXP x_sexp, SEXP schema_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<compute::Expression>&>::type x(x_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::Schema>&>::type schema(schema_sexp);
	return cpp11::as_sexp(compute___expr__type(x, schema));
END_CPP11
}
// expression.cpp
arrow::Type::type compute___expr__type_id(const std::shared_ptr<compute::Expression>& x, const std::shared_ptr<arrow::Schema>& schema);
extern "C" SEXP _arrow_compute___expr__type_id(SEXP x_sexp, SEXP schema_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<compute::Expression>&>::type x(x_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::Schema>&>::type schema(schema_sexp);
	return cpp11::as_sexp(compute___expr__type_id(x, schema));
END_CPP11
}
// extension-impl.cpp
cpp11::environment ExtensionType__initialize(const std::shared_ptr<arrow::DataType>& storage_type, std::string extension_name, cpp11::raws extension_metadata, cpp11::environment r6_class);
extern "C" SEXP _arrow_ExtensionType__initialize(SEXP storage_type_sexp, SEXP extension_name_sexp, SEXP extension_metadata_sexp, SEXP r6_class_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::DataType>&>::type storage_type(storage_type_sexp);
	arrow::r::Input<std::string>::type extension_name(extension_name_sexp);
	arrow::r::Input<cpp11::raws>::type extension_metadata(extension_metadata_sexp);
	arrow::r::Input<cpp11::environment>::type r6_class(r6_class_sexp);
	return cpp11::as_sexp(ExtensionType__initialize(storage_type, extension_name, extension_metadata, r6_class));
END_CPP11
}
// extension-impl.cpp
std::string ExtensionType__extension_name(const std::shared_ptr<arrow::ExtensionType>& type);
extern "C" SEXP _arrow_ExtensionType__extension_name(SEXP type_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::ExtensionType>&>::type type(type_sexp);
	return cpp11::as_sexp(ExtensionType__extension_name(type));
END_CPP11
}
// extension-impl.cpp
cpp11::raws ExtensionType__Serialize(const std::shared_ptr<arrow::ExtensionType>& type);
extern "C" SEXP _arrow_ExtensionType__Serialize(SEXP type_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::ExtensionType>&>::type type(type_sexp);
	return cpp11::as_sexp(ExtensionType__Serialize(type));
END_CPP11
}
// extension-impl.cpp
std::shared_ptr<arrow::DataType> ExtensionType__storage_type(const std::shared_ptr<arrow::ExtensionType>& type);
extern "C" SEXP _arrow_ExtensionType__storage_type(SEXP type_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::ExtensionType>&>::type type(type_sexp);
	return cpp11::as_sexp(ExtensionType__storage_type(type));
END_CPP11
}
// extension-impl.cpp
std::shared_ptr<arrow::Array> ExtensionType__MakeArray(const std::shared_ptr<arrow::ExtensionType>& type, const std::shared_ptr<arrow::ArrayData>& data);
extern "C" SEXP _arrow_ExtensionType__MakeArray(SEXP type_sexp, SEXP data_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::ExtensionType>&>::type type(type_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::ArrayData>&>::type data(data_sexp);
	return cpp11::as_sexp(ExtensionType__MakeArray(type, data));
END_CPP11
}
// extension-impl.cpp
cpp11::environment ExtensionType__r6_class(const std::shared_ptr<arrow::ExtensionType>& type);
extern "C" SEXP _arrow_ExtensionType__r6_class(SEXP type_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::ExtensionType>&>::type type(type_sexp);
	return cpp11::as_sexp(ExtensionType__r6_class(type));
END_CPP11
}
// extension-impl.cpp
std::shared_ptr<arrow::Array> ExtensionArray__storage(const std::shared_ptr<arrow::ExtensionArray>& array);
extern "C" SEXP _arrow_ExtensionArray__storage(SEXP array_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::ExtensionArray>&>::type array(array_sexp);
	return cpp11::as_sexp(ExtensionArray__storage(array));
END_CPP11
}
// extension-impl.cpp
void arrow__RegisterRExtensionType(const std::shared_ptr<arrow::DataType>& type);
extern "C" SEXP _arrow_arrow__RegisterRExtensionType(SEXP type_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::DataType>&>::type type(type_sexp);
	arrow__RegisterRExtensionType(type);
	return R_NilValue;
END_CPP11
}
// extension-impl.cpp
void arrow__UnregisterRExtensionType(std::string type_name);
extern "C" SEXP _arrow_arrow__UnregisterRExtensionType(SEXP type_name_sexp){
BEGIN_CPP11
	arrow::r::Input<std::string>::type type_name(type_name_sexp);
	arrow__UnregisterRExtensionType(type_name);
	return R_NilValue;
END_CPP11
}
// feather.cpp
void ipc___WriteFeather__Table(const std::shared_ptr<arrow::io::OutputStream>& stream, const std::shared_ptr<arrow::Table>& table, int version, int chunk_size, arrow::Compression::type compression, int compression_level);
extern "C" SEXP _arrow_ipc___WriteFeather__Table(SEXP stream_sexp, SEXP table_sexp, SEXP version_sexp, SEXP chunk_size_sexp, SEXP compression_sexp, SEXP compression_level_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::io::OutputStream>&>::type stream(stream_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::Table>&>::type table(table_sexp);
	arrow::r::Input<int>::type version(version_sexp);
	arrow::r::Input<int>::type chunk_size(chunk_size_sexp);
	arrow::r::Input<arrow::Compression::type>::type compression(compression_sexp);
	arrow::r::Input<int>::type compression_level(compression_level_sexp);
	ipc___WriteFeather__Table(stream, table, version, chunk_size, compression, compression_level);
	return R_NilValue;
END_CPP11
}
// feather.cpp
int ipc___feather___Reader__version(const std::shared_ptr<arrow::ipc::feather::Reader>& reader);
extern "C" SEXP _arrow_ipc___feather___Reader__version(SEXP reader_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::ipc::feather::Reader>&>::type reader(reader_sexp);
	return cpp11::as_sexp(ipc___feather___Reader__version(reader));
END_CPP11
}
// feather.cpp
std::shared_ptr<arrow::Table> ipc___feather___Reader__Read(const std::shared_ptr<arrow::ipc::feather::Reader>& reader, cpp11::sexp columns);
extern "C" SEXP _arrow_ipc___feather___Reader__Read(SEXP reader_sexp, SEXP columns_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::ipc::feather::Reader>&>::type reader(reader_sexp);
	arrow::r::Input<cpp11::sexp>::type columns(columns_sexp);
	return cpp11::as_sexp(ipc___feather___Reader__Read(reader, columns));
END_CPP11
}
// feather.cpp
std::shared_ptr<arrow::ipc::feather::Reader> ipc___feather___Reader__Open(const std::shared_ptr<arrow::io::RandomAccessFile>& stream);
extern "C" SEXP _arrow_ipc___feather___Reader__Open(SEXP stream_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::io::RandomAccessFile>&>::type stream(stream_sexp);
	return cpp11::as_sexp(ipc___feather___Reader__Open(stream));
END_CPP11
}
// feather.cpp
std::shared_ptr<arrow::Schema> ipc___feather___Reader__schema(const std::shared_ptr<arrow::ipc::feather::Reader>& reader);
extern "C" SEXP _arrow_ipc___feather___Reader__schema(SEXP reader_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::ipc::feather::Reader>&>::type reader(reader_sexp);
	return cpp11::as_sexp(ipc___feather___Reader__schema(reader));
END_CPP11
}
// field.cpp
std::shared_ptr<arrow::Field> Field__initialize(const std::string& name, const std::shared_ptr<arrow::DataType>& field, bool nullable);
extern "C" SEXP _arrow_Field__initialize(SEXP name_sexp, SEXP field_sexp, SEXP nullable_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::string&>::type name(name_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::DataType>&>::type field(field_sexp);
	arrow::r::Input<bool>::type nullable(nullable_sexp);
	return cpp11::as_sexp(Field__initialize(name, field, nullable));
END_CPP11
}
// field.cpp
std::string Field__ToString(const std::shared_ptr<arrow::Field>& field);
extern "C" SEXP _arrow_Field__ToString(SEXP field_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Field>&>::type field(field_sexp);
	return cpp11::as_sexp(Field__ToString(field));
END_CPP11
}
// field.cpp
std::string Field__name(const std::shared_ptr<arrow::Field>& field);
extern "C" SEXP _arrow_Field__name(SEXP field_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Field>&>::type field(field_sexp);
	return cpp11::as_sexp(Field__name(field));
END_CPP11
}
// field.cpp
bool Field__Equals(const std::shared_ptr<arrow::Field>& field, const std::shared_ptr<arrow::Field>& other);
extern "C" SEXP _arrow_Field__Equals(SEXP field_sexp, SEXP other_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Field>&>::type field(field_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::Field>&>::type other(other_sexp);
	return cpp11::as_sexp(Field__Equals(field, other));
END_CPP11
}
// field.cpp
bool Field__nullable(const std::shared_ptr<arrow::Field>& field);
extern "C" SEXP _arrow_Field__nullable(SEXP field_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Field>&>::type field(field_sexp);
	return cpp11::as_sexp(Field__nullable(field));
END_CPP11
}
// field.cpp
std::shared_ptr<arrow::DataType> Field__type(const std::shared_ptr<arrow::Field>& field);
extern "C" SEXP _arrow_Field__type(SEXP field_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Field>&>::type field(field_sexp);
	return cpp11::as_sexp(Field__type(field));
END_CPP11
}
// filesystem.cpp
fs::FileType fs___FileInfo__type(const std::shared_ptr<fs::FileInfo>& x);
extern "C" SEXP _arrow_fs___FileInfo__type(SEXP x_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<fs::FileInfo>&>::type x(x_sexp);
	return cpp11::as_sexp(fs___FileInfo__type(x));
END_CPP11
}
// filesystem.cpp
void fs___FileInfo__set_type(const std::shared_ptr<fs::FileInfo>& x, fs::FileType type);
extern "C" SEXP _arrow_fs___FileInfo__set_type(SEXP x_sexp, SEXP type_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<fs::FileInfo>&>::type x(x_sexp);
	arrow::r::Input<fs::FileType>::type type(type_sexp);
	fs___FileInfo__set_type(x, type);
	return R_NilValue;
END_CPP11
}
// filesystem.cpp
std::string fs___FileInfo__path(const std::shared_ptr<fs::FileInfo>& x);
extern "C" SEXP _arrow_fs___FileInfo__path(SEXP x_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<fs::FileInfo>&>::type x(x_sexp);
	return cpp11::as_sexp(fs___FileInfo__path(x));
END_CPP11
}
// filesystem.cpp
void fs___FileInfo__set_path(const std::shared_ptr<fs::FileInfo>& x, const std::string& path);
extern "C" SEXP _arrow_fs___FileInfo__set_path(SEXP x_sexp, SEXP path_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<fs::FileInfo>&>::type x(x_sexp);
	arrow::r::Input<const std::string&>::type path(path_sexp);
	fs___FileInfo__set_path(x, path);
	return R_NilValue;
END_CPP11
}
// filesystem.cpp
r_vec_size fs___FileInfo__size(const std::shared_ptr<fs::FileInfo>& x);
extern "C" SEXP _arrow_fs___FileInfo__size(SEXP x_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<fs::FileInfo>&>::type x(x_sexp);
	return cpp11::as_sexp(fs___FileInfo__size(x));
END_CPP11
}
// filesystem.cpp
void fs___FileInfo__set_size(const std::shared_ptr<fs::FileInfo>& x, int64_t size);
extern "C" SEXP _arrow_fs___FileInfo__set_size(SEXP x_sexp, SEXP size_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<fs::FileInfo>&>::type x(x_sexp);
	arrow::r::Input<int64_t>::type size(size_sexp);
	fs___FileInfo__set_size(x, size);
	return R_NilValue;
END_CPP11
}
// filesystem.cpp
std::string fs___FileInfo__base_name(const std::shared_ptr<fs::FileInfo>& x);
extern "C" SEXP _arrow_fs___FileInfo__base_name(SEXP x_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<fs::FileInfo>&>::type x(x_sexp);
	return cpp11::as_sexp(fs___FileInfo__base_name(x));
END_CPP11
}
// filesystem.cpp
std::string fs___FileInfo__extension(const std::shared_ptr<fs::FileInfo>& x);
extern "C" SEXP _arrow_fs___FileInfo__extension(SEXP x_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<fs::FileInfo>&>::type x(x_sexp);
	return cpp11::as_sexp(fs___FileInfo__extension(x));
END_CPP11
}
// filesystem.cpp
SEXP fs___FileInfo__mtime(const std::shared_ptr<fs::FileInfo>& x);
extern "C" SEXP _arrow_fs___FileInfo__mtime(SEXP x_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<fs::FileInfo>&>::type x(x_sexp);
	return cpp11::as_sexp(fs___FileInfo__mtime(x));
END_CPP11
}
// filesystem.cpp
void fs___FileInfo__set_mtime(const std::shared_ptr<fs::FileInfo>& x, SEXP time);
extern "C" SEXP _arrow_fs___FileInfo__set_mtime(SEXP x_sexp, SEXP time_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<fs::FileInfo>&>::type x(x_sexp);
	arrow::r::Input<SEXP>::type time(time_sexp);
	fs___FileInfo__set_mtime(x, time);
	return R_NilValue;
END_CPP11
}
// filesystem.cpp
std::string fs___FileSelector__base_dir(const std::shared_ptr<fs::FileSelector>& selector);
extern "C" SEXP _arrow_fs___FileSelector__base_dir(SEXP selector_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<fs::FileSelector>&>::type selector(selector_sexp);
	return cpp11::as_sexp(fs___FileSelector__base_dir(selector));
END_CPP11
}
// filesystem.cpp
bool fs___FileSelector__allow_not_found(const std::shared_ptr<fs::FileSelector>& selector);
extern "C" SEXP _arrow_fs___FileSelector__allow_not_found(SEXP selector_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<fs::FileSelector>&>::type selector(selector_sexp);
	return cpp11::as_sexp(fs___FileSelector__allow_not_found(selector));
END_CPP11
}
// filesystem.cpp
bool fs___FileSelector__recursive(const std::shared_ptr<fs::FileSelector>& selector);
extern "C" SEXP _arrow_fs___FileSelector__recursive(SEXP selector_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<fs::FileSelector>&>::type selector(selector_sexp);
	return cpp11::as_sexp(fs___FileSelector__recursive(selector));
END_CPP11
}
// filesystem.cpp
std::shared_ptr<fs::FileSelector> fs___FileSelector__create(const std::string& base_dir, bool allow_not_found, bool recursive);
extern "C" SEXP _arrow_fs___FileSelector__create(SEXP base_dir_sexp, SEXP allow_not_found_sexp, SEXP recursive_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::string&>::type base_dir(base_dir_sexp);
	arrow::r::Input<bool>::type allow_not_found(allow_not_found_sexp);
	arrow::r::Input<bool>::type recursive(recursive_sexp);
	return cpp11::as_sexp(fs___FileSelector__create(base_dir, allow_not_found, recursive));
END_CPP11
}
// filesystem.cpp
cpp11::list fs___FileSystem__GetTargetInfos_Paths(const std::shared_ptr<fs::FileSystem>& file_system, const std::vector<std::string>& paths);
extern "C" SEXP _arrow_fs___FileSystem__GetTargetInfos_Paths(SEXP file_system_sexp, SEXP paths_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<fs::FileSystem>&>::type file_system(file_system_sexp);
	arrow::r::Input<const std::vector<std::string>&>::type paths(paths_sexp);
	return cpp11::as_sexp(fs___FileSystem__GetTargetInfos_Paths(file_system, paths));
END_CPP11
}
// filesystem.cpp
cpp11::list fs___FileSystem__GetTargetInfos_FileSelector(const std::shared_ptr<fs::FileSystem>& file_system, const std::shared_ptr<fs::FileSelector>& selector);
extern "C" SEXP _arrow_fs___FileSystem__GetTargetInfos_FileSelector(SEXP file_system_sexp, SEXP selector_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<fs::FileSystem>&>::type file_system(file_system_sexp);
	arrow::r::Input<const std::shared_ptr<fs::FileSelector>&>::type selector(selector_sexp);
	return cpp11::as_sexp(fs___FileSystem__GetTargetInfos_FileSelector(file_system, selector));
END_CPP11
}
// filesystem.cpp
void fs___FileSystem__CreateDir(const std::shared_ptr<fs::FileSystem>& file_system, const std::string& path, bool recursive);
extern "C" SEXP _arrow_fs___FileSystem__CreateDir(SEXP file_system_sexp, SEXP path_sexp, SEXP recursive_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<fs::FileSystem>&>::type file_system(file_system_sexp);
	arrow::r::Input<const std::string&>::type path(path_sexp);
	arrow::r::Input<bool>::type recursive(recursive_sexp);
	fs___FileSystem__CreateDir(file_system, path, recursive);
	return R_NilValue;
END_CPP11
}
// filesystem.cpp
void fs___FileSystem__DeleteDir(const std::shared_ptr<fs::FileSystem>& file_system, const std::string& path);
extern "C" SEXP _arrow_fs___FileSystem__DeleteDir(SEXP file_system_sexp, SEXP path_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<fs::FileSystem>&>::type file_system(file_system_sexp);
	arrow::r::Input<const std::string&>::type path(path_sexp);
	fs___FileSystem__DeleteDir(file_system, path);
	return R_NilValue;
END_CPP11
}
// filesystem.cpp
void fs___FileSystem__DeleteDirContents(const std::shared_ptr<fs::FileSystem>& file_system, const std::string& path);
extern "C" SEXP _arrow_fs___FileSystem__DeleteDirContents(SEXP file_system_sexp, SEXP path_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<fs::FileSystem>&>::type file_system(file_system_sexp);
	arrow::r::Input<const std::string&>::type path(path_sexp);
	fs___FileSystem__DeleteDirContents(file_system, path);
	return R_NilValue;
END_CPP11
}
// filesystem.cpp
void fs___FileSystem__DeleteFile(const std::shared_ptr<fs::FileSystem>& file_system, const std::string& path);
extern "C" SEXP _arrow_fs___FileSystem__DeleteFile(SEXP file_system_sexp, SEXP path_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<fs::FileSystem>&>::type file_system(file_system_sexp);
	arrow::r::Input<const std::string&>::type path(path_sexp);
	fs___FileSystem__DeleteFile(file_system, path);
	return R_NilValue;
END_CPP11
}
// filesystem.cpp
void fs___FileSystem__DeleteFiles(const std::shared_ptr<fs::FileSystem>& file_system, const std::vector<std::string>& paths);
extern "C" SEXP _arrow_fs___FileSystem__DeleteFiles(SEXP file_system_sexp, SEXP paths_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<fs::FileSystem>&>::type file_system(file_system_sexp);
	arrow::r::Input<const std::vector<std::string>&>::type paths(paths_sexp);
	fs___FileSystem__DeleteFiles(file_system, paths);
	return R_NilValue;
END_CPP11
}
// filesystem.cpp
void fs___FileSystem__Move(const std::shared_ptr<fs::FileSystem>& file_system, const std::string& src, const std::string& dest);
extern "C" SEXP _arrow_fs___FileSystem__Move(SEXP file_system_sexp, SEXP src_sexp, SEXP dest_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<fs::FileSystem>&>::type file_system(file_system_sexp);
	arrow::r::Input<const std::string&>::type src(src_sexp);
	arrow::r::Input<const std::string&>::type dest(dest_sexp);
	fs___FileSystem__Move(file_system, src, dest);
	return R_NilValue;
END_CPP11
}
// filesystem.cpp
void fs___FileSystem__CopyFile(const std::shared_ptr<fs::FileSystem>& file_system, const std::string& src, const std::string& dest);
extern "C" SEXP _arrow_fs___FileSystem__CopyFile(SEXP file_system_sexp, SEXP src_sexp, SEXP dest_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<fs::FileSystem>&>::type file_system(file_system_sexp);
	arrow::r::Input<const std::string&>::type src(src_sexp);
	arrow::r::Input<const std::string&>::type dest(dest_sexp);
	fs___FileSystem__CopyFile(file_system, src, dest);
	return R_NilValue;
END_CPP11
}
// filesystem.cpp
std::shared_ptr<arrow::io::InputStream> fs___FileSystem__OpenInputStream(const std::shared_ptr<fs::FileSystem>& file_system, const std::string& path);
extern "C" SEXP _arrow_fs___FileSystem__OpenInputStream(SEXP file_system_sexp, SEXP path_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<fs::FileSystem>&>::type file_system(file_system_sexp);
	arrow::r::Input<const std::string&>::type path(path_sexp);
	return cpp11::as_sexp(fs___FileSystem__OpenInputStream(file_system, path));
END_CPP11
}
// filesystem.cpp
std::shared_ptr<arrow::io::RandomAccessFile> fs___FileSystem__OpenInputFile(const std::shared_ptr<fs::FileSystem>& file_system, const std::string& path);
extern "C" SEXP _arrow_fs___FileSystem__OpenInputFile(SEXP file_system_sexp, SEXP path_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<fs::FileSystem>&>::type file_system(file_system_sexp);
	arrow::r::Input<const std::string&>::type path(path_sexp);
	return cpp11::as_sexp(fs___FileSystem__OpenInputFile(file_system, path));
END_CPP11
}
// filesystem.cpp
std::shared_ptr<arrow::io::OutputStream> fs___FileSystem__OpenOutputStream(const std::shared_ptr<fs::FileSystem>& file_system, const std::string& path);
extern "C" SEXP _arrow_fs___FileSystem__OpenOutputStream(SEXP file_system_sexp, SEXP path_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<fs::FileSystem>&>::type file_system(file_system_sexp);
	arrow::r::Input<const std::string&>::type path(path_sexp);
	return cpp11::as_sexp(fs___FileSystem__OpenOutputStream(file_system, path));
END_CPP11
}
// filesystem.cpp
std::shared_ptr<arrow::io::OutputStream> fs___FileSystem__OpenAppendStream(const std::shared_ptr<fs::FileSystem>& file_system, const std::string& path);
extern "C" SEXP _arrow_fs___FileSystem__OpenAppendStream(SEXP file_system_sexp, SEXP path_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<fs::FileSystem>&>::type file_system(file_system_sexp);
	arrow::r::Input<const std::string&>::type path(path_sexp);
	return cpp11::as_sexp(fs___FileSystem__OpenAppendStream(file_system, path));
END_CPP11
}
// filesystem.cpp
std::string fs___FileSystem__type_name(const std::shared_ptr<fs::FileSystem>& file_system);
extern "C" SEXP _arrow_fs___FileSystem__type_name(SEXP file_system_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<fs::FileSystem>&>::type file_system(file_system_sexp);
	return cpp11::as_sexp(fs___FileSystem__type_name(file_system));
END_CPP11
}
// filesystem.cpp
std::shared_ptr<fs::LocalFileSystem> fs___LocalFileSystem__create();
extern "C" SEXP _arrow_fs___LocalFileSystem__create(){
BEGIN_CPP11
	return cpp11::as_sexp(fs___LocalFileSystem__create());
END_CPP11
}
// filesystem.cpp
std::shared_ptr<fs::SubTreeFileSystem> fs___SubTreeFileSystem__create(const std::string& base_path, const std::shared_ptr<fs::FileSystem>& base_fs);
extern "C" SEXP _arrow_fs___SubTreeFileSystem__create(SEXP base_path_sexp, SEXP base_fs_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::string&>::type base_path(base_path_sexp);
	arrow::r::Input<const std::shared_ptr<fs::FileSystem>&>::type base_fs(base_fs_sexp);
	return cpp11::as_sexp(fs___SubTreeFileSystem__create(base_path, base_fs));
END_CPP11
}
// filesystem.cpp
std::shared_ptr<fs::FileSystem> fs___SubTreeFileSystem__base_fs(const std::shared_ptr<fs::SubTreeFileSystem>& file_system);
extern "C" SEXP _arrow_fs___SubTreeFileSystem__base_fs(SEXP file_system_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<fs::SubTreeFileSystem>&>::type file_system(file_system_sexp);
	return cpp11::as_sexp(fs___SubTreeFileSystem__base_fs(file_system));
END_CPP11
}
// filesystem.cpp
std::string fs___SubTreeFileSystem__base_path(const std::shared_ptr<fs::SubTreeFileSystem>& file_system);
extern "C" SEXP _arrow_fs___SubTreeFileSystem__base_path(SEXP file_system_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<fs::SubTreeFileSystem>&>::type file_system(file_system_sexp);
	return cpp11::as_sexp(fs___SubTreeFileSystem__base_path(file_system));
END_CPP11
}
// filesystem.cpp
cpp11::writable::list fs___FileSystemFromUri(const std::string& path);
extern "C" SEXP _arrow_fs___FileSystemFromUri(SEXP path_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::string&>::type path(path_sexp);
	return cpp11::as_sexp(fs___FileSystemFromUri(path));
END_CPP11
}
// filesystem.cpp
void fs___CopyFiles(const std::shared_ptr<fs::FileSystem>& source_fs, const std::shared_ptr<fs::FileSelector>& source_sel, const std::shared_ptr<fs::FileSystem>& destination_fs, const std::string& destination_base_dir, int64_t chunk_size, bool use_threads);
extern "C" SEXP _arrow_fs___CopyFiles(SEXP source_fs_sexp, SEXP source_sel_sexp, SEXP destination_fs_sexp, SEXP destination_base_dir_sexp, SEXP chunk_size_sexp, SEXP use_threads_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<fs::FileSystem>&>::type source_fs(source_fs_sexp);
	arrow::r::Input<const std::shared_ptr<fs::FileSelector>&>::type source_sel(source_sel_sexp);
	arrow::r::Input<const std::shared_ptr<fs::FileSystem>&>::type destination_fs(destination_fs_sexp);
	arrow::r::Input<const std::string&>::type destination_base_dir(destination_base_dir_sexp);
	arrow::r::Input<int64_t>::type chunk_size(chunk_size_sexp);
	arrow::r::Input<bool>::type use_threads(use_threads_sexp);
	fs___CopyFiles(source_fs, source_sel, destination_fs, destination_base_dir, chunk_size, use_threads);
	return R_NilValue;
END_CPP11
}
// filesystem.cpp
#if defined(ARROW_R_WITH_S3)
std::shared_ptr<fs::S3FileSystem> fs___S3FileSystem__create(bool anonymous, std::string access_key, std::string secret_key, std::string session_token, std::string role_arn, std::string session_name, std::string external_id, int load_frequency, std::string region, std::string endpoint_override, std::string scheme, std::string proxy_options, bool background_writes, bool allow_bucket_creation, bool allow_bucket_deletion, double connect_timeout, double request_timeout);
extern "C" SEXP _arrow_fs___S3FileSystem__create(SEXP anonymous_sexp, SEXP access_key_sexp, SEXP secret_key_sexp, SEXP session_token_sexp, SEXP role_arn_sexp, SEXP session_name_sexp, SEXP external_id_sexp, SEXP load_frequency_sexp, SEXP region_sexp, SEXP endpoint_override_sexp, SEXP scheme_sexp, SEXP proxy_options_sexp, SEXP background_writes_sexp, SEXP allow_bucket_creation_sexp, SEXP allow_bucket_deletion_sexp, SEXP connect_timeout_sexp, SEXP request_timeout_sexp){
BEGIN_CPP11
	arrow::r::Input<bool>::type anonymous(anonymous_sexp);
	arrow::r::Input<std::string>::type access_key(access_key_sexp);
	arrow::r::Input<std::string>::type secret_key(secret_key_sexp);
	arrow::r::Input<std::string>::type session_token(session_token_sexp);
	arrow::r::Input<std::string>::type role_arn(role_arn_sexp);
	arrow::r::Input<std::string>::type session_name(session_name_sexp);
	arrow::r::Input<std::string>::type external_id(external_id_sexp);
	arrow::r::Input<int>::type load_frequency(load_frequency_sexp);
	arrow::r::Input<std::string>::type region(region_sexp);
	arrow::r::Input<std::string>::type endpoint_override(endpoint_override_sexp);
	arrow::r::Input<std::string>::type scheme(scheme_sexp);
	arrow::r::Input<std::string>::type proxy_options(proxy_options_sexp);
	arrow::r::Input<bool>::type background_writes(background_writes_sexp);
	arrow::r::Input<bool>::type allow_bucket_creation(allow_bucket_creation_sexp);
	arrow::r::Input<bool>::type allow_bucket_deletion(allow_bucket_deletion_sexp);
	arrow::r::Input<double>::type connect_timeout(connect_timeout_sexp);
	arrow::r::Input<double>::type request_timeout(request_timeout_sexp);
	return cpp11::as_sexp(fs___S3FileSystem__create(anonymous, access_key, secret_key, session_token, role_arn, session_name, external_id, load_frequency, region, endpoint_override, scheme, proxy_options, background_writes, allow_bucket_creation, allow_bucket_deletion, connect_timeout, request_timeout));
END_CPP11
}
#else
extern "C" SEXP _arrow_fs___S3FileSystem__create(SEXP anonymous_sexp, SEXP access_key_sexp, SEXP secret_key_sexp, SEXP session_token_sexp, SEXP role_arn_sexp, SEXP session_name_sexp, SEXP external_id_sexp, SEXP load_frequency_sexp, SEXP region_sexp, SEXP endpoint_override_sexp, SEXP scheme_sexp, SEXP proxy_options_sexp, SEXP background_writes_sexp, SEXP allow_bucket_creation_sexp, SEXP allow_bucket_deletion_sexp, SEXP connect_timeout_sexp, SEXP request_timeout_sexp){
	Rf_error("Cannot call fs___S3FileSystem__create(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// filesystem.cpp
#if defined(ARROW_R_WITH_S3)
std::string fs___S3FileSystem__region(const std::shared_ptr<fs::S3FileSystem>& fs);
extern "C" SEXP _arrow_fs___S3FileSystem__region(SEXP fs_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<fs::S3FileSystem>&>::type fs(fs_sexp);
	return cpp11::as_sexp(fs___S3FileSystem__region(fs));
END_CPP11
}
#else
extern "C" SEXP _arrow_fs___S3FileSystem__region(SEXP fs_sexp){
	Rf_error("Cannot call fs___S3FileSystem__region(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// filesystem.cpp
#if defined(ARROW_R_WITH_GCS)
std::shared_ptr<fs::GcsFileSystem> fs___GcsFileSystem__Make(bool anonymous, cpp11::list options);
extern "C" SEXP _arrow_fs___GcsFileSystem__Make(SEXP anonymous_sexp, SEXP options_sexp){
BEGIN_CPP11
	arrow::r::Input<bool>::type anonymous(anonymous_sexp);
	arrow::r::Input<cpp11::list>::type options(options_sexp);
	return cpp11::as_sexp(fs___GcsFileSystem__Make(anonymous, options));
END_CPP11
}
#else
extern "C" SEXP _arrow_fs___GcsFileSystem__Make(SEXP anonymous_sexp, SEXP options_sexp){
	Rf_error("Cannot call fs___GcsFileSystem__Make(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// filesystem.cpp
#if defined(ARROW_R_WITH_GCS)
cpp11::list fs___GcsFileSystem__options(const std::shared_ptr<fs::GcsFileSystem>& fs);
extern "C" SEXP _arrow_fs___GcsFileSystem__options(SEXP fs_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<fs::GcsFileSystem>&>::type fs(fs_sexp);
	return cpp11::as_sexp(fs___GcsFileSystem__options(fs));
END_CPP11
}
#else
extern "C" SEXP _arrow_fs___GcsFileSystem__options(SEXP fs_sexp){
	Rf_error("Cannot call fs___GcsFileSystem__options(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// io.cpp
std::shared_ptr<arrow::Buffer> io___Readable__Read(const std::shared_ptr<arrow::io::Readable>& x, int64_t nbytes);
extern "C" SEXP _arrow_io___Readable__Read(SEXP x_sexp, SEXP nbytes_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::io::Readable>&>::type x(x_sexp);
	arrow::r::Input<int64_t>::type nbytes(nbytes_sexp);
	return cpp11::as_sexp(io___Readable__Read(x, nbytes));
END_CPP11
}
// io.cpp
void io___InputStream__Close(const std::shared_ptr<arrow::io::InputStream>& x);
extern "C" SEXP _arrow_io___InputStream__Close(SEXP x_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::io::InputStream>&>::type x(x_sexp);
	io___InputStream__Close(x);
	return R_NilValue;
END_CPP11
}
// io.cpp
void io___OutputStream__Close(const std::shared_ptr<arrow::io::OutputStream>& x);
extern "C" SEXP _arrow_io___OutputStream__Close(SEXP x_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::io::OutputStream>&>::type x(x_sexp);
	io___OutputStream__Close(x);
	return R_NilValue;
END_CPP11
}
// io.cpp
r_vec_size io___RandomAccessFile__GetSize(const std::shared_ptr<arrow::io::RandomAccessFile>& x);
extern "C" SEXP _arrow_io___RandomAccessFile__GetSize(SEXP x_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::io::RandomAccessFile>&>::type x(x_sexp);
	return cpp11::as_sexp(io___RandomAccessFile__GetSize(x));
END_CPP11
}
// io.cpp
bool io___RandomAccessFile__supports_zero_copy(const std::shared_ptr<arrow::io::RandomAccessFile>& x);
extern "C" SEXP _arrow_io___RandomAccessFile__supports_zero_copy(SEXP x_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::io::RandomAccessFile>&>::type x(x_sexp);
	return cpp11::as_sexp(io___RandomAccessFile__supports_zero_copy(x));
END_CPP11
}
// io.cpp
void io___RandomAccessFile__Seek(const std::shared_ptr<arrow::io::RandomAccessFile>& x, int64_t position);
extern "C" SEXP _arrow_io___RandomAccessFile__Seek(SEXP x_sexp, SEXP position_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::io::RandomAccessFile>&>::type x(x_sexp);
	arrow::r::Input<int64_t>::type position(position_sexp);
	io___RandomAccessFile__Seek(x, position);
	return R_NilValue;
END_CPP11
}
// io.cpp
r_vec_size io___RandomAccessFile__Tell(const std::shared_ptr<arrow::io::RandomAccessFile>& x);
extern "C" SEXP _arrow_io___RandomAccessFile__Tell(SEXP x_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::io::RandomAccessFile>&>::type x(x_sexp);
	return cpp11::as_sexp(io___RandomAccessFile__Tell(x));
END_CPP11
}
// io.cpp
std::shared_ptr<arrow::Buffer> io___RandomAccessFile__Read0(const std::shared_ptr<arrow::io::RandomAccessFile>& x);
extern "C" SEXP _arrow_io___RandomAccessFile__Read0(SEXP x_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::io::RandomAccessFile>&>::type x(x_sexp);
	return cpp11::as_sexp(io___RandomAccessFile__Read0(x));
END_CPP11
}
// io.cpp
std::shared_ptr<arrow::Buffer> io___RandomAccessFile__ReadAt(const std::shared_ptr<arrow::io::RandomAccessFile>& x, int64_t position, int64_t nbytes);
extern "C" SEXP _arrow_io___RandomAccessFile__ReadAt(SEXP x_sexp, SEXP position_sexp, SEXP nbytes_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::io::RandomAccessFile>&>::type x(x_sexp);
	arrow::r::Input<int64_t>::type position(position_sexp);
	arrow::r::Input<int64_t>::type nbytes(nbytes_sexp);
	return cpp11::as_sexp(io___RandomAccessFile__ReadAt(x, position, nbytes));
END_CPP11
}
// io.cpp
cpp11::strings io___RandomAccessFile__ReadMetadata(const std::shared_ptr<arrow::io::RandomAccessFile>& x);
extern "C" SEXP _arrow_io___RandomAccessFile__ReadMetadata(SEXP x_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::io::RandomAccessFile>&>::type x(x_sexp);
	return cpp11::as_sexp(io___RandomAccessFile__ReadMetadata(x));
END_CPP11
}
// io.cpp
std::shared_ptr<arrow::io::MemoryMappedFile> io___MemoryMappedFile__Create(const std::string& path, int64_t size);
extern "C" SEXP _arrow_io___MemoryMappedFile__Create(SEXP path_sexp, SEXP size_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::string&>::type path(path_sexp);
	arrow::r::Input<int64_t>::type size(size_sexp);
	return cpp11::as_sexp(io___MemoryMappedFile__Create(path, size));
END_CPP11
}
// io.cpp
std::shared_ptr<arrow::io::MemoryMappedFile> io___MemoryMappedFile__Open(const std::string& path, arrow::io::FileMode::type mode);
extern "C" SEXP _arrow_io___MemoryMappedFile__Open(SEXP path_sexp, SEXP mode_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::string&>::type path(path_sexp);
	arrow::r::Input<arrow::io::FileMode::type>::type mode(mode_sexp);
	return cpp11::as_sexp(io___MemoryMappedFile__Open(path, mode));
END_CPP11
}
// io.cpp
void io___MemoryMappedFile__Resize(const std::shared_ptr<arrow::io::MemoryMappedFile>& x, int64_t size);
extern "C" SEXP _arrow_io___MemoryMappedFile__Resize(SEXP x_sexp, SEXP size_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::io::MemoryMappedFile>&>::type x(x_sexp);
	arrow::r::Input<int64_t>::type size(size_sexp);
	io___MemoryMappedFile__Resize(x, size);
	return R_NilValue;
END_CPP11
}
// io.cpp
std::shared_ptr<arrow::io::ReadableFile> io___ReadableFile__Open(const std::string& path);
extern "C" SEXP _arrow_io___ReadableFile__Open(SEXP path_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::string&>::type path(path_sexp);
	return cpp11::as_sexp(io___ReadableFile__Open(path));
END_CPP11
}
// io.cpp
std::shared_ptr<arrow::io::BufferReader> io___BufferReader__initialize(const std::shared_ptr<arrow::Buffer>& buffer);
extern "C" SEXP _arrow_io___BufferReader__initialize(SEXP buffer_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Buffer>&>::type buffer(buffer_sexp);
	return cpp11::as_sexp(io___BufferReader__initialize(buffer));
END_CPP11
}
// io.cpp
void io___Writable__write(const std::shared_ptr<arrow::io::Writable>& stream, const std::shared_ptr<arrow::Buffer>& buf);
extern "C" SEXP _arrow_io___Writable__write(SEXP stream_sexp, SEXP buf_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::io::Writable>&>::type stream(stream_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::Buffer>&>::type buf(buf_sexp);
	io___Writable__write(stream, buf);
	return R_NilValue;
END_CPP11
}
// io.cpp
r_vec_size io___OutputStream__Tell(const std::shared_ptr<arrow::io::OutputStream>& stream);
extern "C" SEXP _arrow_io___OutputStream__Tell(SEXP stream_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::io::OutputStream>&>::type stream(stream_sexp);
	return cpp11::as_sexp(io___OutputStream__Tell(stream));
END_CPP11
}
// io.cpp
std::shared_ptr<arrow::io::FileOutputStream> io___FileOutputStream__Open(const std::string& path);
extern "C" SEXP _arrow_io___FileOutputStream__Open(SEXP path_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::string&>::type path(path_sexp);
	return cpp11::as_sexp(io___FileOutputStream__Open(path));
END_CPP11
}
// io.cpp
std::shared_ptr<arrow::io::BufferOutputStream> io___BufferOutputStream__Create(int64_t initial_capacity);
extern "C" SEXP _arrow_io___BufferOutputStream__Create(SEXP initial_capacity_sexp){
BEGIN_CPP11
	arrow::r::Input<int64_t>::type initial_capacity(initial_capacity_sexp);
	return cpp11::as_sexp(io___BufferOutputStream__Create(initial_capacity));
END_CPP11
}
// io.cpp
r_vec_size io___BufferOutputStream__capacity(const std::shared_ptr<arrow::io::BufferOutputStream>& stream);
extern "C" SEXP _arrow_io___BufferOutputStream__capacity(SEXP stream_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::io::BufferOutputStream>&>::type stream(stream_sexp);
	return cpp11::as_sexp(io___BufferOutputStream__capacity(stream));
END_CPP11
}
// io.cpp
std::shared_ptr<arrow::Buffer> io___BufferOutputStream__Finish(const std::shared_ptr<arrow::io::BufferOutputStream>& stream);
extern "C" SEXP _arrow_io___BufferOutputStream__Finish(SEXP stream_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::io::BufferOutputStream>&>::type stream(stream_sexp);
	return cpp11::as_sexp(io___BufferOutputStream__Finish(stream));
END_CPP11
}
// io.cpp
r_vec_size io___BufferOutputStream__Tell(const std::shared_ptr<arrow::io::BufferOutputStream>& stream);
extern "C" SEXP _arrow_io___BufferOutputStream__Tell(SEXP stream_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::io::BufferOutputStream>&>::type stream(stream_sexp);
	return cpp11::as_sexp(io___BufferOutputStream__Tell(stream));
END_CPP11
}
// io.cpp
void io___BufferOutputStream__Write(const std::shared_ptr<arrow::io::BufferOutputStream>& stream, cpp11::raws bytes);
extern "C" SEXP _arrow_io___BufferOutputStream__Write(SEXP stream_sexp, SEXP bytes_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::io::BufferOutputStream>&>::type stream(stream_sexp);
	arrow::r::Input<cpp11::raws>::type bytes(bytes_sexp);
	io___BufferOutputStream__Write(stream, bytes);
	return R_NilValue;
END_CPP11
}
// io.cpp
std::shared_ptr<arrow::io::InputStream> MakeRConnectionInputStream(cpp11::sexp con);
extern "C" SEXP _arrow_MakeRConnectionInputStream(SEXP con_sexp){
BEGIN_CPP11
	arrow::r::Input<cpp11::sexp>::type con(con_sexp);
	return cpp11::as_sexp(MakeRConnectionInputStream(con));
END_CPP11
}
// io.cpp
std::shared_ptr<arrow::io::OutputStream> MakeRConnectionOutputStream(cpp11::sexp con);
extern "C" SEXP _arrow_MakeRConnectionOutputStream(SEXP con_sexp){
BEGIN_CPP11
	arrow::r::Input<cpp11::sexp>::type con(con_sexp);
	return cpp11::as_sexp(MakeRConnectionOutputStream(con));
END_CPP11
}
// io.cpp
std::shared_ptr<arrow::io::RandomAccessFile> MakeRConnectionRandomAccessFile(cpp11::sexp con);
extern "C" SEXP _arrow_MakeRConnectionRandomAccessFile(SEXP con_sexp){
BEGIN_CPP11
	arrow::r::Input<cpp11::sexp>::type con(con_sexp);
	return cpp11::as_sexp(MakeRConnectionRandomAccessFile(con));
END_CPP11
}
// io.cpp
std::shared_ptr<arrow::io::InputStream> MakeReencodeInputStream(const std::shared_ptr<arrow::io::InputStream>& wrapped, std::string from);
extern "C" SEXP _arrow_MakeReencodeInputStream(SEXP wrapped_sexp, SEXP from_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::io::InputStream>&>::type wrapped(wrapped_sexp);
	arrow::r::Input<std::string>::type from(from_sexp);
	return cpp11::as_sexp(MakeReencodeInputStream(wrapped, from));
END_CPP11
}
// json.cpp
#if defined(ARROW_R_WITH_JSON)
std::shared_ptr<arrow::json::ReadOptions> json___ReadOptions__initialize(bool use_threads, int block_size);
extern "C" SEXP _arrow_json___ReadOptions__initialize(SEXP use_threads_sexp, SEXP block_size_sexp){
BEGIN_CPP11
	arrow::r::Input<bool>::type use_threads(use_threads_sexp);
	arrow::r::Input<int>::type block_size(block_size_sexp);
	return cpp11::as_sexp(json___ReadOptions__initialize(use_threads, block_size));
END_CPP11
}
#else
extern "C" SEXP _arrow_json___ReadOptions__initialize(SEXP use_threads_sexp, SEXP block_size_sexp){
	Rf_error("Cannot call json___ReadOptions__initialize(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// json.cpp
#if defined(ARROW_R_WITH_JSON)
std::shared_ptr<arrow::json::ParseOptions> json___ParseOptions__initialize1(bool newlines_in_values);
extern "C" SEXP _arrow_json___ParseOptions__initialize1(SEXP newlines_in_values_sexp){
BEGIN_CPP11
	arrow::r::Input<bool>::type newlines_in_values(newlines_in_values_sexp);
	return cpp11::as_sexp(json___ParseOptions__initialize1(newlines_in_values));
END_CPP11
}
#else
extern "C" SEXP _arrow_json___ParseOptions__initialize1(SEXP newlines_in_values_sexp){
	Rf_error("Cannot call json___ParseOptions__initialize1(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// json.cpp
#if defined(ARROW_R_WITH_JSON)
std::shared_ptr<arrow::json::ParseOptions> json___ParseOptions__initialize2(bool newlines_in_values, const std::shared_ptr<arrow::Schema>& explicit_schema);
extern "C" SEXP _arrow_json___ParseOptions__initialize2(SEXP newlines_in_values_sexp, SEXP explicit_schema_sexp){
BEGIN_CPP11
	arrow::r::Input<bool>::type newlines_in_values(newlines_in_values_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::Schema>&>::type explicit_schema(explicit_schema_sexp);
	return cpp11::as_sexp(json___ParseOptions__initialize2(newlines_in_values, explicit_schema));
END_CPP11
}
#else
extern "C" SEXP _arrow_json___ParseOptions__initialize2(SEXP newlines_in_values_sexp, SEXP explicit_schema_sexp){
	Rf_error("Cannot call json___ParseOptions__initialize2(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// json.cpp
#if defined(ARROW_R_WITH_JSON)
std::shared_ptr<arrow::json::TableReader> json___TableReader__Make(const std::shared_ptr<arrow::io::InputStream>& input, const std::shared_ptr<arrow::json::ReadOptions>& read_options, const std::shared_ptr<arrow::json::ParseOptions>& parse_options);
extern "C" SEXP _arrow_json___TableReader__Make(SEXP input_sexp, SEXP read_options_sexp, SEXP parse_options_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::io::InputStream>&>::type input(input_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::json::ReadOptions>&>::type read_options(read_options_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::json::ParseOptions>&>::type parse_options(parse_options_sexp);
	return cpp11::as_sexp(json___TableReader__Make(input, read_options, parse_options));
END_CPP11
}
#else
extern "C" SEXP _arrow_json___TableReader__Make(SEXP input_sexp, SEXP read_options_sexp, SEXP parse_options_sexp){
	Rf_error("Cannot call json___TableReader__Make(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// json.cpp
#if defined(ARROW_R_WITH_JSON)
std::shared_ptr<arrow::Table> json___TableReader__Read(const std::shared_ptr<arrow::json::TableReader>& table_reader);
extern "C" SEXP _arrow_json___TableReader__Read(SEXP table_reader_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::json::TableReader>&>::type table_reader(table_reader_sexp);
	return cpp11::as_sexp(json___TableReader__Read(table_reader));
END_CPP11
}
#else
extern "C" SEXP _arrow_json___TableReader__Read(SEXP table_reader_sexp){
	Rf_error("Cannot call json___TableReader__Read(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// memorypool.cpp
std::shared_ptr<arrow::MemoryPool> MemoryPool__default();
extern "C" SEXP _arrow_MemoryPool__default(){
BEGIN_CPP11
	return cpp11::as_sexp(MemoryPool__default());
END_CPP11
}
// memorypool.cpp
double MemoryPool__bytes_allocated(const std::shared_ptr<arrow::MemoryPool>& pool);
extern "C" SEXP _arrow_MemoryPool__bytes_allocated(SEXP pool_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::MemoryPool>&>::type pool(pool_sexp);
	return cpp11::as_sexp(MemoryPool__bytes_allocated(pool));
END_CPP11
}
// memorypool.cpp
double MemoryPool__max_memory(const std::shared_ptr<arrow::MemoryPool>& pool);
extern "C" SEXP _arrow_MemoryPool__max_memory(SEXP pool_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::MemoryPool>&>::type pool(pool_sexp);
	return cpp11::as_sexp(MemoryPool__max_memory(pool));
END_CPP11
}
// memorypool.cpp
std::string MemoryPool__backend_name(const std::shared_ptr<arrow::MemoryPool>& pool);
extern "C" SEXP _arrow_MemoryPool__backend_name(SEXP pool_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::MemoryPool>&>::type pool(pool_sexp);
	return cpp11::as_sexp(MemoryPool__backend_name(pool));
END_CPP11
}
// memorypool.cpp
std::vector<std::string> supported_memory_backends();
extern "C" SEXP _arrow_supported_memory_backends(){
BEGIN_CPP11
	return cpp11::as_sexp(supported_memory_backends());
END_CPP11
}
// message.cpp
r_vec_size ipc___Message__body_length(const std::unique_ptr<arrow::ipc::Message>& message);
extern "C" SEXP _arrow_ipc___Message__body_length(SEXP message_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::unique_ptr<arrow::ipc::Message>&>::type message(message_sexp);
	return cpp11::as_sexp(ipc___Message__body_length(message));
END_CPP11
}
// message.cpp
std::shared_ptr<arrow::Buffer> ipc___Message__metadata(const std::unique_ptr<arrow::ipc::Message>& message);
extern "C" SEXP _arrow_ipc___Message__metadata(SEXP message_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::unique_ptr<arrow::ipc::Message>&>::type message(message_sexp);
	return cpp11::as_sexp(ipc___Message__metadata(message));
END_CPP11
}
// message.cpp
std::shared_ptr<arrow::Buffer> ipc___Message__body(const std::unique_ptr<arrow::ipc::Message>& message);
extern "C" SEXP _arrow_ipc___Message__body(SEXP message_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::unique_ptr<arrow::ipc::Message>&>::type message(message_sexp);
	return cpp11::as_sexp(ipc___Message__body(message));
END_CPP11
}
// message.cpp
r_vec_size ipc___Message__Verify(const std::unique_ptr<arrow::ipc::Message>& message);
extern "C" SEXP _arrow_ipc___Message__Verify(SEXP message_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::unique_ptr<arrow::ipc::Message>&>::type message(message_sexp);
	return cpp11::as_sexp(ipc___Message__Verify(message));
END_CPP11
}
// message.cpp
arrow::ipc::MessageType ipc___Message__type(const std::unique_ptr<arrow::ipc::Message>& message);
extern "C" SEXP _arrow_ipc___Message__type(SEXP message_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::unique_ptr<arrow::ipc::Message>&>::type message(message_sexp);
	return cpp11::as_sexp(ipc___Message__type(message));
END_CPP11
}
// message.cpp
bool ipc___Message__Equals(const std::unique_ptr<arrow::ipc::Message>& x, const std::unique_ptr<arrow::ipc::Message>& y);
extern "C" SEXP _arrow_ipc___Message__Equals(SEXP x_sexp, SEXP y_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::unique_ptr<arrow::ipc::Message>&>::type x(x_sexp);
	arrow::r::Input<const std::unique_ptr<arrow::ipc::Message>&>::type y(y_sexp);
	return cpp11::as_sexp(ipc___Message__Equals(x, y));
END_CPP11
}
// message.cpp
std::shared_ptr<arrow::RecordBatch> ipc___ReadRecordBatch__Message__Schema(const std::unique_ptr<arrow::ipc::Message>& message, const std::shared_ptr<arrow::Schema>& schema);
extern "C" SEXP _arrow_ipc___ReadRecordBatch__Message__Schema(SEXP message_sexp, SEXP schema_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::unique_ptr<arrow::ipc::Message>&>::type message(message_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::Schema>&>::type schema(schema_sexp);
	return cpp11::as_sexp(ipc___ReadRecordBatch__Message__Schema(message, schema));
END_CPP11
}
// message.cpp
std::shared_ptr<arrow::Schema> ipc___ReadSchema_InputStream(const std::shared_ptr<arrow::io::InputStream>& stream);
extern "C" SEXP _arrow_ipc___ReadSchema_InputStream(SEXP stream_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::io::InputStream>&>::type stream(stream_sexp);
	return cpp11::as_sexp(ipc___ReadSchema_InputStream(stream));
END_CPP11
}
// message.cpp
std::shared_ptr<arrow::Schema> ipc___ReadSchema_Message(const std::unique_ptr<arrow::ipc::Message>& message);
extern "C" SEXP _arrow_ipc___ReadSchema_Message(SEXP message_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::unique_ptr<arrow::ipc::Message>&>::type message(message_sexp);
	return cpp11::as_sexp(ipc___ReadSchema_Message(message));
END_CPP11
}
// message.cpp
std::shared_ptr<arrow::ipc::MessageReader> ipc___MessageReader__Open(const std::shared_ptr<arrow::io::InputStream>& stream);
extern "C" SEXP _arrow_ipc___MessageReader__Open(SEXP stream_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::io::InputStream>&>::type stream(stream_sexp);
	return cpp11::as_sexp(ipc___MessageReader__Open(stream));
END_CPP11
}
// message.cpp
std::shared_ptr<arrow::ipc::Message> ipc___MessageReader__ReadNextMessage(const std::unique_ptr<arrow::ipc::MessageReader>& reader);
extern "C" SEXP _arrow_ipc___MessageReader__ReadNextMessage(SEXP reader_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::unique_ptr<arrow::ipc::MessageReader>&>::type reader(reader_sexp);
	return cpp11::as_sexp(ipc___MessageReader__ReadNextMessage(reader));
END_CPP11
}
// message.cpp
std::shared_ptr<arrow::ipc::Message> ipc___ReadMessage(const std::shared_ptr<arrow::io::InputStream>& stream);
extern "C" SEXP _arrow_ipc___ReadMessage(SEXP stream_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::io::InputStream>&>::type stream(stream_sexp);
	return cpp11::as_sexp(ipc___ReadMessage(stream));
END_CPP11
}
// parquet.cpp
#if defined(ARROW_R_WITH_PARQUET)
std::shared_ptr<parquet::ArrowReaderProperties> parquet___arrow___ArrowReaderProperties__Make(bool use_threads);
extern "C" SEXP _arrow_parquet___arrow___ArrowReaderProperties__Make(SEXP use_threads_sexp){
BEGIN_CPP11
	arrow::r::Input<bool>::type use_threads(use_threads_sexp);
	return cpp11::as_sexp(parquet___arrow___ArrowReaderProperties__Make(use_threads));
END_CPP11
}
#else
extern "C" SEXP _arrow_parquet___arrow___ArrowReaderProperties__Make(SEXP use_threads_sexp){
	Rf_error("Cannot call parquet___arrow___ArrowReaderProperties__Make(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// parquet.cpp
#if defined(ARROW_R_WITH_PARQUET)
void parquet___arrow___ArrowReaderProperties__set_use_threads(const std::shared_ptr<parquet::ArrowReaderProperties>& properties, bool use_threads);
extern "C" SEXP _arrow_parquet___arrow___ArrowReaderProperties__set_use_threads(SEXP properties_sexp, SEXP use_threads_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<parquet::ArrowReaderProperties>&>::type properties(properties_sexp);
	arrow::r::Input<bool>::type use_threads(use_threads_sexp);
	parquet___arrow___ArrowReaderProperties__set_use_threads(properties, use_threads);
	return R_NilValue;
END_CPP11
}
#else
extern "C" SEXP _arrow_parquet___arrow___ArrowReaderProperties__set_use_threads(SEXP properties_sexp, SEXP use_threads_sexp){
	Rf_error("Cannot call parquet___arrow___ArrowReaderProperties__set_use_threads(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// parquet.cpp
#if defined(ARROW_R_WITH_PARQUET)
bool parquet___arrow___ArrowReaderProperties__get_use_threads(const std::shared_ptr<parquet::ArrowReaderProperties>& properties, bool use_threads);
extern "C" SEXP _arrow_parquet___arrow___ArrowReaderProperties__get_use_threads(SEXP properties_sexp, SEXP use_threads_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<parquet::ArrowReaderProperties>&>::type properties(properties_sexp);
	arrow::r::Input<bool>::type use_threads(use_threads_sexp);
	return cpp11::as_sexp(parquet___arrow___ArrowReaderProperties__get_use_threads(properties, use_threads));
END_CPP11
}
#else
extern "C" SEXP _arrow_parquet___arrow___ArrowReaderProperties__get_use_threads(SEXP properties_sexp, SEXP use_threads_sexp){
	Rf_error("Cannot call parquet___arrow___ArrowReaderProperties__get_use_threads(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// parquet.cpp
#if defined(ARROW_R_WITH_PARQUET)
bool parquet___arrow___ArrowReaderProperties__get_read_dictionary(const std::shared_ptr<parquet::ArrowReaderProperties>& properties, int column_index);
extern "C" SEXP _arrow_parquet___arrow___ArrowReaderProperties__get_read_dictionary(SEXP properties_sexp, SEXP column_index_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<parquet::ArrowReaderProperties>&>::type properties(properties_sexp);
	arrow::r::Input<int>::type column_index(column_index_sexp);
	return cpp11::as_sexp(parquet___arrow___ArrowReaderProperties__get_read_dictionary(properties, column_index));
END_CPP11
}
#else
extern "C" SEXP _arrow_parquet___arrow___ArrowReaderProperties__get_read_dictionary(SEXP properties_sexp, SEXP column_index_sexp){
	Rf_error("Cannot call parquet___arrow___ArrowReaderProperties__get_read_dictionary(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// parquet.cpp
#if defined(ARROW_R_WITH_PARQUET)
void parquet___arrow___ArrowReaderProperties__set_read_dictionary(const std::shared_ptr<parquet::ArrowReaderProperties>& properties, int column_index, bool read_dict);
extern "C" SEXP _arrow_parquet___arrow___ArrowReaderProperties__set_read_dictionary(SEXP properties_sexp, SEXP column_index_sexp, SEXP read_dict_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<parquet::ArrowReaderProperties>&>::type properties(properties_sexp);
	arrow::r::Input<int>::type column_index(column_index_sexp);
	arrow::r::Input<bool>::type read_dict(read_dict_sexp);
	parquet___arrow___ArrowReaderProperties__set_read_dictionary(properties, column_index, read_dict);
	return R_NilValue;
END_CPP11
}
#else
extern "C" SEXP _arrow_parquet___arrow___ArrowReaderProperties__set_read_dictionary(SEXP properties_sexp, SEXP column_index_sexp, SEXP read_dict_sexp){
	Rf_error("Cannot call parquet___arrow___ArrowReaderProperties__set_read_dictionary(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// parquet.cpp
#if defined(ARROW_R_WITH_PARQUET)
void parquet___arrow___ArrowReaderProperties__set_coerce_int96_timestamp_unit(const std::shared_ptr<parquet::ArrowReaderProperties>& properties, arrow::TimeUnit::type unit);
extern "C" SEXP _arrow_parquet___arrow___ArrowReaderProperties__set_coerce_int96_timestamp_unit(SEXP properties_sexp, SEXP unit_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<parquet::ArrowReaderProperties>&>::type properties(properties_sexp);
	arrow::r::Input<arrow::TimeUnit::type>::type unit(unit_sexp);
	parquet___arrow___ArrowReaderProperties__set_coerce_int96_timestamp_unit(properties, unit);
	return R_NilValue;
END_CPP11
}
#else
extern "C" SEXP _arrow_parquet___arrow___ArrowReaderProperties__set_coerce_int96_timestamp_unit(SEXP properties_sexp, SEXP unit_sexp){
	Rf_error("Cannot call parquet___arrow___ArrowReaderProperties__set_coerce_int96_timestamp_unit(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// parquet.cpp
#if defined(ARROW_R_WITH_PARQUET)
arrow::TimeUnit::type parquet___arrow___ArrowReaderProperties__get_coerce_int96_timestamp_unit(const std::shared_ptr<parquet::ArrowReaderProperties>& properties);
extern "C" SEXP _arrow_parquet___arrow___ArrowReaderProperties__get_coerce_int96_timestamp_unit(SEXP properties_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<parquet::ArrowReaderProperties>&>::type properties(properties_sexp);
	return cpp11::as_sexp(parquet___arrow___ArrowReaderProperties__get_coerce_int96_timestamp_unit(properties));
END_CPP11
}
#else
extern "C" SEXP _arrow_parquet___arrow___ArrowReaderProperties__get_coerce_int96_timestamp_unit(SEXP properties_sexp){
	Rf_error("Cannot call parquet___arrow___ArrowReaderProperties__get_coerce_int96_timestamp_unit(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// parquet.cpp
#if defined(ARROW_R_WITH_PARQUET)
std::shared_ptr<parquet::arrow::FileReader> parquet___arrow___FileReader__OpenFile(const std::shared_ptr<arrow::io::RandomAccessFile>& file, const std::shared_ptr<parquet::ArrowReaderProperties>& props);
extern "C" SEXP _arrow_parquet___arrow___FileReader__OpenFile(SEXP file_sexp, SEXP props_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::io::RandomAccessFile>&>::type file(file_sexp);
	arrow::r::Input<const std::shared_ptr<parquet::ArrowReaderProperties>&>::type props(props_sexp);
	return cpp11::as_sexp(parquet___arrow___FileReader__OpenFile(file, props));
END_CPP11
}
#else
extern "C" SEXP _arrow_parquet___arrow___FileReader__OpenFile(SEXP file_sexp, SEXP props_sexp){
	Rf_error("Cannot call parquet___arrow___FileReader__OpenFile(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// parquet.cpp
#if defined(ARROW_R_WITH_PARQUET)
std::shared_ptr<arrow::Table> parquet___arrow___FileReader__ReadTable1(const std::shared_ptr<parquet::arrow::FileReader>& reader);
extern "C" SEXP _arrow_parquet___arrow___FileReader__ReadTable1(SEXP reader_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<parquet::arrow::FileReader>&>::type reader(reader_sexp);
	return cpp11::as_sexp(parquet___arrow___FileReader__ReadTable1(reader));
END_CPP11
}
#else
extern "C" SEXP _arrow_parquet___arrow___FileReader__ReadTable1(SEXP reader_sexp){
	Rf_error("Cannot call parquet___arrow___FileReader__ReadTable1(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// parquet.cpp
#if defined(ARROW_R_WITH_PARQUET)
std::shared_ptr<arrow::Table> parquet___arrow___FileReader__ReadTable2(const std::shared_ptr<parquet::arrow::FileReader>& reader, const std::vector<int>& column_indices);
extern "C" SEXP _arrow_parquet___arrow___FileReader__ReadTable2(SEXP reader_sexp, SEXP column_indices_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<parquet::arrow::FileReader>&>::type reader(reader_sexp);
	arrow::r::Input<const std::vector<int>&>::type column_indices(column_indices_sexp);
	return cpp11::as_sexp(parquet___arrow___FileReader__ReadTable2(reader, column_indices));
END_CPP11
}
#else
extern "C" SEXP _arrow_parquet___arrow___FileReader__ReadTable2(SEXP reader_sexp, SEXP column_indices_sexp){
	Rf_error("Cannot call parquet___arrow___FileReader__ReadTable2(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// parquet.cpp
#if defined(ARROW_R_WITH_PARQUET)
std::shared_ptr<arrow::Table> parquet___arrow___FileReader__ReadRowGroup1(const std::shared_ptr<parquet::arrow::FileReader>& reader, int i);
extern "C" SEXP _arrow_parquet___arrow___FileReader__ReadRowGroup1(SEXP reader_sexp, SEXP i_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<parquet::arrow::FileReader>&>::type reader(reader_sexp);
	arrow::r::Input<int>::type i(i_sexp);
	return cpp11::as_sexp(parquet___arrow___FileReader__ReadRowGroup1(reader, i));
END_CPP11
}
#else
extern "C" SEXP _arrow_parquet___arrow___FileReader__ReadRowGroup1(SEXP reader_sexp, SEXP i_sexp){
	Rf_error("Cannot call parquet___arrow___FileReader__ReadRowGroup1(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// parquet.cpp
#if defined(ARROW_R_WITH_PARQUET)
std::shared_ptr<arrow::Table> parquet___arrow___FileReader__ReadRowGroup2(const std::shared_ptr<parquet::arrow::FileReader>& reader, int i, const std::vector<int>& column_indices);
extern "C" SEXP _arrow_parquet___arrow___FileReader__ReadRowGroup2(SEXP reader_sexp, SEXP i_sexp, SEXP column_indices_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<parquet::arrow::FileReader>&>::type reader(reader_sexp);
	arrow::r::Input<int>::type i(i_sexp);
	arrow::r::Input<const std::vector<int>&>::type column_indices(column_indices_sexp);
	return cpp11::as_sexp(parquet___arrow___FileReader__ReadRowGroup2(reader, i, column_indices));
END_CPP11
}
#else
extern "C" SEXP _arrow_parquet___arrow___FileReader__ReadRowGroup2(SEXP reader_sexp, SEXP i_sexp, SEXP column_indices_sexp){
	Rf_error("Cannot call parquet___arrow___FileReader__ReadRowGroup2(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// parquet.cpp
#if defined(ARROW_R_WITH_PARQUET)
std::shared_ptr<arrow::Table> parquet___arrow___FileReader__ReadRowGroups1(const std::shared_ptr<parquet::arrow::FileReader>& reader, const std::vector<int>& row_groups);
extern "C" SEXP _arrow_parquet___arrow___FileReader__ReadRowGroups1(SEXP reader_sexp, SEXP row_groups_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<parquet::arrow::FileReader>&>::type reader(reader_sexp);
	arrow::r::Input<const std::vector<int>&>::type row_groups(row_groups_sexp);
	return cpp11::as_sexp(parquet___arrow___FileReader__ReadRowGroups1(reader, row_groups));
END_CPP11
}
#else
extern "C" SEXP _arrow_parquet___arrow___FileReader__ReadRowGroups1(SEXP reader_sexp, SEXP row_groups_sexp){
	Rf_error("Cannot call parquet___arrow___FileReader__ReadRowGroups1(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// parquet.cpp
#if defined(ARROW_R_WITH_PARQUET)
std::shared_ptr<arrow::Table> parquet___arrow___FileReader__ReadRowGroups2(const std::shared_ptr<parquet::arrow::FileReader>& reader, const std::vector<int>& row_groups, const std::vector<int>& column_indices);
extern "C" SEXP _arrow_parquet___arrow___FileReader__ReadRowGroups2(SEXP reader_sexp, SEXP row_groups_sexp, SEXP column_indices_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<parquet::arrow::FileReader>&>::type reader(reader_sexp);
	arrow::r::Input<const std::vector<int>&>::type row_groups(row_groups_sexp);
	arrow::r::Input<const std::vector<int>&>::type column_indices(column_indices_sexp);
	return cpp11::as_sexp(parquet___arrow___FileReader__ReadRowGroups2(reader, row_groups, column_indices));
END_CPP11
}
#else
extern "C" SEXP _arrow_parquet___arrow___FileReader__ReadRowGroups2(SEXP reader_sexp, SEXP row_groups_sexp, SEXP column_indices_sexp){
	Rf_error("Cannot call parquet___arrow___FileReader__ReadRowGroups2(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// parquet.cpp
#if defined(ARROW_R_WITH_PARQUET)
r_vec_size parquet___arrow___FileReader__num_rows(const std::shared_ptr<parquet::arrow::FileReader>& reader);
extern "C" SEXP _arrow_parquet___arrow___FileReader__num_rows(SEXP reader_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<parquet::arrow::FileReader>&>::type reader(reader_sexp);
	return cpp11::as_sexp(parquet___arrow___FileReader__num_rows(reader));
END_CPP11
}
#else
extern "C" SEXP _arrow_parquet___arrow___FileReader__num_rows(SEXP reader_sexp){
	Rf_error("Cannot call parquet___arrow___FileReader__num_rows(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// parquet.cpp
#if defined(ARROW_R_WITH_PARQUET)
int parquet___arrow___FileReader__num_columns(const std::shared_ptr<parquet::arrow::FileReader>& reader);
extern "C" SEXP _arrow_parquet___arrow___FileReader__num_columns(SEXP reader_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<parquet::arrow::FileReader>&>::type reader(reader_sexp);
	return cpp11::as_sexp(parquet___arrow___FileReader__num_columns(reader));
END_CPP11
}
#else
extern "C" SEXP _arrow_parquet___arrow___FileReader__num_columns(SEXP reader_sexp){
	Rf_error("Cannot call parquet___arrow___FileReader__num_columns(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// parquet.cpp
#if defined(ARROW_R_WITH_PARQUET)
int parquet___arrow___FileReader__num_row_groups(const std::shared_ptr<parquet::arrow::FileReader>& reader);
extern "C" SEXP _arrow_parquet___arrow___FileReader__num_row_groups(SEXP reader_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<parquet::arrow::FileReader>&>::type reader(reader_sexp);
	return cpp11::as_sexp(parquet___arrow___FileReader__num_row_groups(reader));
END_CPP11
}
#else
extern "C" SEXP _arrow_parquet___arrow___FileReader__num_row_groups(SEXP reader_sexp){
	Rf_error("Cannot call parquet___arrow___FileReader__num_row_groups(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// parquet.cpp
#if defined(ARROW_R_WITH_PARQUET)
std::shared_ptr<arrow::ChunkedArray> parquet___arrow___FileReader__ReadColumn(const std::shared_ptr<parquet::arrow::FileReader>& reader, int i);
extern "C" SEXP _arrow_parquet___arrow___FileReader__ReadColumn(SEXP reader_sexp, SEXP i_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<parquet::arrow::FileReader>&>::type reader(reader_sexp);
	arrow::r::Input<int>::type i(i_sexp);
	return cpp11::as_sexp(parquet___arrow___FileReader__ReadColumn(reader, i));
END_CPP11
}
#else
extern "C" SEXP _arrow_parquet___arrow___FileReader__ReadColumn(SEXP reader_sexp, SEXP i_sexp){
	Rf_error("Cannot call parquet___arrow___FileReader__ReadColumn(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// parquet.cpp
#if defined(ARROW_R_WITH_PARQUET)
std::shared_ptr<parquet::ArrowWriterProperties> parquet___ArrowWriterProperties___create(bool allow_truncated_timestamps, bool use_deprecated_int96_timestamps, int timestamp_unit);
extern "C" SEXP _arrow_parquet___ArrowWriterProperties___create(SEXP allow_truncated_timestamps_sexp, SEXP use_deprecated_int96_timestamps_sexp, SEXP timestamp_unit_sexp){
BEGIN_CPP11
	arrow::r::Input<bool>::type allow_truncated_timestamps(allow_truncated_timestamps_sexp);
	arrow::r::Input<bool>::type use_deprecated_int96_timestamps(use_deprecated_int96_timestamps_sexp);
	arrow::r::Input<int>::type timestamp_unit(timestamp_unit_sexp);
	return cpp11::as_sexp(parquet___ArrowWriterProperties___create(allow_truncated_timestamps, use_deprecated_int96_timestamps, timestamp_unit));
END_CPP11
}
#else
extern "C" SEXP _arrow_parquet___ArrowWriterProperties___create(SEXP allow_truncated_timestamps_sexp, SEXP use_deprecated_int96_timestamps_sexp, SEXP timestamp_unit_sexp){
	Rf_error("Cannot call parquet___ArrowWriterProperties___create(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// parquet.cpp
#if defined(ARROW_R_WITH_PARQUET)
std::shared_ptr<parquet::WriterPropertiesBuilder> parquet___WriterProperties___Builder__create();
extern "C" SEXP _arrow_parquet___WriterProperties___Builder__create(){
BEGIN_CPP11
	return cpp11::as_sexp(parquet___WriterProperties___Builder__create());
END_CPP11
}
#else
extern "C" SEXP _arrow_parquet___WriterProperties___Builder__create(){
	Rf_error("Cannot call parquet___WriterProperties___Builder__create(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// parquet.cpp
#if defined(ARROW_R_WITH_PARQUET)
void parquet___WriterProperties___Builder__version(const std::shared_ptr<parquet::WriterPropertiesBuilder>& builder, const parquet::ParquetVersion::type& version);
extern "C" SEXP _arrow_parquet___WriterProperties___Builder__version(SEXP builder_sexp, SEXP version_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<parquet::WriterPropertiesBuilder>&>::type builder(builder_sexp);
	arrow::r::Input<const parquet::ParquetVersion::type&>::type version(version_sexp);
	parquet___WriterProperties___Builder__version(builder, version);
	return R_NilValue;
END_CPP11
}
#else
extern "C" SEXP _arrow_parquet___WriterProperties___Builder__version(SEXP builder_sexp, SEXP version_sexp){
	Rf_error("Cannot call parquet___WriterProperties___Builder__version(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// parquet.cpp
#if defined(ARROW_R_WITH_PARQUET)
void parquet___ArrowWriterProperties___Builder__set_compressions(const std::shared_ptr<parquet::WriterPropertiesBuilder>& builder, const std::vector<std::string>& paths, cpp11::integers types);
extern "C" SEXP _arrow_parquet___ArrowWriterProperties___Builder__set_compressions(SEXP builder_sexp, SEXP paths_sexp, SEXP types_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<parquet::WriterPropertiesBuilder>&>::type builder(builder_sexp);
	arrow::r::Input<const std::vector<std::string>&>::type paths(paths_sexp);
	arrow::r::Input<cpp11::integers>::type types(types_sexp);
	parquet___ArrowWriterProperties___Builder__set_compressions(builder, paths, types);
	return R_NilValue;
END_CPP11
}
#else
extern "C" SEXP _arrow_parquet___ArrowWriterProperties___Builder__set_compressions(SEXP builder_sexp, SEXP paths_sexp, SEXP types_sexp){
	Rf_error("Cannot call parquet___ArrowWriterProperties___Builder__set_compressions(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// parquet.cpp
#if defined(ARROW_R_WITH_PARQUET)
void parquet___ArrowWriterProperties___Builder__set_compression_levels(const std::shared_ptr<parquet::WriterPropertiesBuilder>& builder, const std::vector<std::string>& paths, cpp11::integers levels);
extern "C" SEXP _arrow_parquet___ArrowWriterProperties___Builder__set_compression_levels(SEXP builder_sexp, SEXP paths_sexp, SEXP levels_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<parquet::WriterPropertiesBuilder>&>::type builder(builder_sexp);
	arrow::r::Input<const std::vector<std::string>&>::type paths(paths_sexp);
	arrow::r::Input<cpp11::integers>::type levels(levels_sexp);
	parquet___ArrowWriterProperties___Builder__set_compression_levels(builder, paths, levels);
	return R_NilValue;
END_CPP11
}
#else
extern "C" SEXP _arrow_parquet___ArrowWriterProperties___Builder__set_compression_levels(SEXP builder_sexp, SEXP paths_sexp, SEXP levels_sexp){
	Rf_error("Cannot call parquet___ArrowWriterProperties___Builder__set_compression_levels(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// parquet.cpp
#if defined(ARROW_R_WITH_PARQUET)
void parquet___ArrowWriterProperties___Builder__set_use_dictionary(const std::shared_ptr<parquet::WriterPropertiesBuilder>& builder, const std::vector<std::string>& paths, cpp11::logicals use_dictionary);
extern "C" SEXP _arrow_parquet___ArrowWriterProperties___Builder__set_use_dictionary(SEXP builder_sexp, SEXP paths_sexp, SEXP use_dictionary_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<parquet::WriterPropertiesBuilder>&>::type builder(builder_sexp);
	arrow::r::Input<const std::vector<std::string>&>::type paths(paths_sexp);
	arrow::r::Input<cpp11::logicals>::type use_dictionary(use_dictionary_sexp);
	parquet___ArrowWriterProperties___Builder__set_use_dictionary(builder, paths, use_dictionary);
	return R_NilValue;
END_CPP11
}
#else
extern "C" SEXP _arrow_parquet___ArrowWriterProperties___Builder__set_use_dictionary(SEXP builder_sexp, SEXP paths_sexp, SEXP use_dictionary_sexp){
	Rf_error("Cannot call parquet___ArrowWriterProperties___Builder__set_use_dictionary(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// parquet.cpp
#if defined(ARROW_R_WITH_PARQUET)
void parquet___ArrowWriterProperties___Builder__set_write_statistics(const std::shared_ptr<parquet::WriterPropertiesBuilder>& builder, const std::vector<std::string>& paths, cpp11::logicals write_statistics);
extern "C" SEXP _arrow_parquet___ArrowWriterProperties___Builder__set_write_statistics(SEXP builder_sexp, SEXP paths_sexp, SEXP write_statistics_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<parquet::WriterPropertiesBuilder>&>::type builder(builder_sexp);
	arrow::r::Input<const std::vector<std::string>&>::type paths(paths_sexp);
	arrow::r::Input<cpp11::logicals>::type write_statistics(write_statistics_sexp);
	parquet___ArrowWriterProperties___Builder__set_write_statistics(builder, paths, write_statistics);
	return R_NilValue;
END_CPP11
}
#else
extern "C" SEXP _arrow_parquet___ArrowWriterProperties___Builder__set_write_statistics(SEXP builder_sexp, SEXP paths_sexp, SEXP write_statistics_sexp){
	Rf_error("Cannot call parquet___ArrowWriterProperties___Builder__set_write_statistics(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// parquet.cpp
#if defined(ARROW_R_WITH_PARQUET)
void parquet___ArrowWriterProperties___Builder__data_page_size(const std::shared_ptr<parquet::WriterPropertiesBuilder>& builder, int64_t data_page_size);
extern "C" SEXP _arrow_parquet___ArrowWriterProperties___Builder__data_page_size(SEXP builder_sexp, SEXP data_page_size_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<parquet::WriterPropertiesBuilder>&>::type builder(builder_sexp);
	arrow::r::Input<int64_t>::type data_page_size(data_page_size_sexp);
	parquet___ArrowWriterProperties___Builder__data_page_size(builder, data_page_size);
	return R_NilValue;
END_CPP11
}
#else
extern "C" SEXP _arrow_parquet___ArrowWriterProperties___Builder__data_page_size(SEXP builder_sexp, SEXP data_page_size_sexp){
	Rf_error("Cannot call parquet___ArrowWriterProperties___Builder__data_page_size(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// parquet.cpp
#if defined(ARROW_R_WITH_PARQUET)
std::shared_ptr<parquet::WriterProperties> parquet___WriterProperties___Builder__build(const std::shared_ptr<parquet::WriterPropertiesBuilder>& builder);
extern "C" SEXP _arrow_parquet___WriterProperties___Builder__build(SEXP builder_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<parquet::WriterPropertiesBuilder>&>::type builder(builder_sexp);
	return cpp11::as_sexp(parquet___WriterProperties___Builder__build(builder));
END_CPP11
}
#else
extern "C" SEXP _arrow_parquet___WriterProperties___Builder__build(SEXP builder_sexp){
	Rf_error("Cannot call parquet___WriterProperties___Builder__build(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// parquet.cpp
#if defined(ARROW_R_WITH_PARQUET)
std::shared_ptr<parquet::arrow::FileWriter> parquet___arrow___ParquetFileWriter__Open(const std::shared_ptr<arrow::Schema>& schema, const std::shared_ptr<arrow::io::OutputStream>& sink, const std::shared_ptr<parquet::WriterProperties>& properties, const std::shared_ptr<parquet::ArrowWriterProperties>& arrow_properties);
extern "C" SEXP _arrow_parquet___arrow___ParquetFileWriter__Open(SEXP schema_sexp, SEXP sink_sexp, SEXP properties_sexp, SEXP arrow_properties_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Schema>&>::type schema(schema_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::io::OutputStream>&>::type sink(sink_sexp);
	arrow::r::Input<const std::shared_ptr<parquet::WriterProperties>&>::type properties(properties_sexp);
	arrow::r::Input<const std::shared_ptr<parquet::ArrowWriterProperties>&>::type arrow_properties(arrow_properties_sexp);
	return cpp11::as_sexp(parquet___arrow___ParquetFileWriter__Open(schema, sink, properties, arrow_properties));
END_CPP11
}
#else
extern "C" SEXP _arrow_parquet___arrow___ParquetFileWriter__Open(SEXP schema_sexp, SEXP sink_sexp, SEXP properties_sexp, SEXP arrow_properties_sexp){
	Rf_error("Cannot call parquet___arrow___ParquetFileWriter__Open(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// parquet.cpp
#if defined(ARROW_R_WITH_PARQUET)
void parquet___arrow___FileWriter__WriteTable(const std::shared_ptr<parquet::arrow::FileWriter>& writer, const std::shared_ptr<arrow::Table>& table, int64_t chunk_size);
extern "C" SEXP _arrow_parquet___arrow___FileWriter__WriteTable(SEXP writer_sexp, SEXP table_sexp, SEXP chunk_size_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<parquet::arrow::FileWriter>&>::type writer(writer_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::Table>&>::type table(table_sexp);
	arrow::r::Input<int64_t>::type chunk_size(chunk_size_sexp);
	parquet___arrow___FileWriter__WriteTable(writer, table, chunk_size);
	return R_NilValue;
END_CPP11
}
#else
extern "C" SEXP _arrow_parquet___arrow___FileWriter__WriteTable(SEXP writer_sexp, SEXP table_sexp, SEXP chunk_size_sexp){
	Rf_error("Cannot call parquet___arrow___FileWriter__WriteTable(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// parquet.cpp
#if defined(ARROW_R_WITH_PARQUET)
void parquet___arrow___FileWriter__Close(const std::shared_ptr<parquet::arrow::FileWriter>& writer);
extern "C" SEXP _arrow_parquet___arrow___FileWriter__Close(SEXP writer_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<parquet::arrow::FileWriter>&>::type writer(writer_sexp);
	parquet___arrow___FileWriter__Close(writer);
	return R_NilValue;
END_CPP11
}
#else
extern "C" SEXP _arrow_parquet___arrow___FileWriter__Close(SEXP writer_sexp){
	Rf_error("Cannot call parquet___arrow___FileWriter__Close(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// parquet.cpp
#if defined(ARROW_R_WITH_PARQUET)
void parquet___arrow___WriteTable(const std::shared_ptr<arrow::Table>& table, const std::shared_ptr<arrow::io::OutputStream>& sink, const std::shared_ptr<parquet::WriterProperties>& properties, const std::shared_ptr<parquet::ArrowWriterProperties>& arrow_properties);
extern "C" SEXP _arrow_parquet___arrow___WriteTable(SEXP table_sexp, SEXP sink_sexp, SEXP properties_sexp, SEXP arrow_properties_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Table>&>::type table(table_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::io::OutputStream>&>::type sink(sink_sexp);
	arrow::r::Input<const std::shared_ptr<parquet::WriterProperties>&>::type properties(properties_sexp);
	arrow::r::Input<const std::shared_ptr<parquet::ArrowWriterProperties>&>::type arrow_properties(arrow_properties_sexp);
	parquet___arrow___WriteTable(table, sink, properties, arrow_properties);
	return R_NilValue;
END_CPP11
}
#else
extern "C" SEXP _arrow_parquet___arrow___WriteTable(SEXP table_sexp, SEXP sink_sexp, SEXP properties_sexp, SEXP arrow_properties_sexp){
	Rf_error("Cannot call parquet___arrow___WriteTable(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// parquet.cpp
#if defined(ARROW_R_WITH_PARQUET)
std::shared_ptr<arrow::Schema> parquet___arrow___FileReader__GetSchema(const std::shared_ptr<parquet::arrow::FileReader>& reader);
extern "C" SEXP _arrow_parquet___arrow___FileReader__GetSchema(SEXP reader_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<parquet::arrow::FileReader>&>::type reader(reader_sexp);
	return cpp11::as_sexp(parquet___arrow___FileReader__GetSchema(reader));
END_CPP11
}
#else
extern "C" SEXP _arrow_parquet___arrow___FileReader__GetSchema(SEXP reader_sexp){
	Rf_error("Cannot call parquet___arrow___FileReader__GetSchema(). See https://arrow.apache.org/docs/r/articles/install.html for help installing Arrow C++ libraries. ");
}
#endif

// r_to_arrow.cpp
std::shared_ptr<arrow::Table> Table__from_dots(SEXP lst, SEXP schema_sxp, bool use_threads);
extern "C" SEXP _arrow_Table__from_dots(SEXP lst_sexp, SEXP schema_sxp_sexp, SEXP use_threads_sexp){
BEGIN_CPP11
	arrow::r::Input<SEXP>::type lst(lst_sexp);
	arrow::r::Input<SEXP>::type schema_sxp(schema_sxp_sexp);
	arrow::r::Input<bool>::type use_threads(use_threads_sexp);
	return cpp11::as_sexp(Table__from_dots(lst, schema_sxp, use_threads));
END_CPP11
}
// r_to_arrow.cpp
SEXP vec_to_Array(SEXP x, SEXP s_type);
extern "C" SEXP _arrow_vec_to_Array(SEXP x_sexp, SEXP s_type_sexp){
BEGIN_CPP11
	arrow::r::Input<SEXP>::type x(x_sexp);
	arrow::r::Input<SEXP>::type s_type(s_type_sexp);
	return cpp11::as_sexp(vec_to_Array(x, s_type));
END_CPP11
}
// r_to_arrow.cpp
std::shared_ptr<arrow::Array> DictionaryArray__FromArrays(const std::shared_ptr<arrow::DataType>& type, const std::shared_ptr<arrow::Array>& indices, const std::shared_ptr<arrow::Array>& dict);
extern "C" SEXP _arrow_DictionaryArray__FromArrays(SEXP type_sexp, SEXP indices_sexp, SEXP dict_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::DataType>&>::type type(type_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::Array>&>::type indices(indices_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::Array>&>::type dict(dict_sexp);
	return cpp11::as_sexp(DictionaryArray__FromArrays(type, indices, dict));
END_CPP11
}
// recordbatch.cpp
r_vec_size RecordBatch__num_columns(const std::shared_ptr<arrow::RecordBatch>& x);
extern "C" SEXP _arrow_RecordBatch__num_columns(SEXP x_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::RecordBatch>&>::type x(x_sexp);
	return cpp11::as_sexp(RecordBatch__num_columns(x));
END_CPP11
}
// recordbatch.cpp
r_vec_size RecordBatch__num_rows(const std::shared_ptr<arrow::RecordBatch>& x);
extern "C" SEXP _arrow_RecordBatch__num_rows(SEXP x_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::RecordBatch>&>::type x(x_sexp);
	return cpp11::as_sexp(RecordBatch__num_rows(x));
END_CPP11
}
// recordbatch.cpp
std::shared_ptr<arrow::Schema> RecordBatch__schema(const std::shared_ptr<arrow::RecordBatch>& x);
extern "C" SEXP _arrow_RecordBatch__schema(SEXP x_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::RecordBatch>&>::type x(x_sexp);
	return cpp11::as_sexp(RecordBatch__schema(x));
END_CPP11
}
// recordbatch.cpp
std::shared_ptr<arrow::RecordBatch> RecordBatch__RenameColumns(const std::shared_ptr<arrow::RecordBatch>& batch, const std::vector<std::string>& names);
extern "C" SEXP _arrow_RecordBatch__RenameColumns(SEXP batch_sexp, SEXP names_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::RecordBatch>&>::type batch(batch_sexp);
	arrow::r::Input<const std::vector<std::string>&>::type names(names_sexp);
	return cpp11::as_sexp(RecordBatch__RenameColumns(batch, names));
END_CPP11
}
// recordbatch.cpp
std::shared_ptr<arrow::RecordBatch> RecordBatch__ReplaceSchemaMetadata(const std::shared_ptr<arrow::RecordBatch>& x, cpp11::strings metadata);
extern "C" SEXP _arrow_RecordBatch__ReplaceSchemaMetadata(SEXP x_sexp, SEXP metadata_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::RecordBatch>&>::type x(x_sexp);
	arrow::r::Input<cpp11::strings>::type metadata(metadata_sexp);
	return cpp11::as_sexp(RecordBatch__ReplaceSchemaMetadata(x, metadata));
END_CPP11
}
// recordbatch.cpp
cpp11::list RecordBatch__columns(const std::shared_ptr<arrow::RecordBatch>& batch);
extern "C" SEXP _arrow_RecordBatch__columns(SEXP batch_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::RecordBatch>&>::type batch(batch_sexp);
	return cpp11::as_sexp(RecordBatch__columns(batch));
END_CPP11
}
// recordbatch.cpp
std::shared_ptr<arrow::Array> RecordBatch__column(const std::shared_ptr<arrow::RecordBatch>& batch, R_xlen_t i);
extern "C" SEXP _arrow_RecordBatch__column(SEXP batch_sexp, SEXP i_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::RecordBatch>&>::type batch(batch_sexp);
	arrow::r::Input<R_xlen_t>::type i(i_sexp);
	return cpp11::as_sexp(RecordBatch__column(batch, i));
END_CPP11
}
// recordbatch.cpp
std::shared_ptr<arrow::Array> RecordBatch__GetColumnByName(const std::shared_ptr<arrow::RecordBatch>& batch, const std::string& name);
extern "C" SEXP _arrow_RecordBatch__GetColumnByName(SEXP batch_sexp, SEXP name_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::RecordBatch>&>::type batch(batch_sexp);
	arrow::r::Input<const std::string&>::type name(name_sexp);
	return cpp11::as_sexp(RecordBatch__GetColumnByName(batch, name));
END_CPP11
}
// recordbatch.cpp
std::shared_ptr<arrow::RecordBatch> RecordBatch__SelectColumns(const std::shared_ptr<arrow::RecordBatch>& batch, const std::vector<int>& indices);
extern "C" SEXP _arrow_RecordBatch__SelectColumns(SEXP batch_sexp, SEXP indices_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::RecordBatch>&>::type batch(batch_sexp);
	arrow::r::Input<const std::vector<int>&>::type indices(indices_sexp);
	return cpp11::as_sexp(RecordBatch__SelectColumns(batch, indices));
END_CPP11
}
// recordbatch.cpp
bool RecordBatch__Equals(const std::shared_ptr<arrow::RecordBatch>& self, const std::shared_ptr<arrow::RecordBatch>& other, bool check_metadata);
extern "C" SEXP _arrow_RecordBatch__Equals(SEXP self_sexp, SEXP other_sexp, SEXP check_metadata_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::RecordBatch>&>::type self(self_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::RecordBatch>&>::type other(other_sexp);
	arrow::r::Input<bool>::type check_metadata(check_metadata_sexp);
	return cpp11::as_sexp(RecordBatch__Equals(self, other, check_metadata));
END_CPP11
}
// recordbatch.cpp
std::shared_ptr<arrow::RecordBatch> RecordBatch__AddColumn(const std::shared_ptr<arrow::RecordBatch>& batch, R_xlen_t i, const std::shared_ptr<arrow::Field>& field, const std::shared_ptr<arrow::Array>& column);
extern "C" SEXP _arrow_RecordBatch__AddColumn(SEXP batch_sexp, SEXP i_sexp, SEXP field_sexp, SEXP column_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::RecordBatch>&>::type batch(batch_sexp);
	arrow::r::Input<R_xlen_t>::type i(i_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::Field>&>::type field(field_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::Array>&>::type column(column_sexp);
	return cpp11::as_sexp(RecordBatch__AddColumn(batch, i, field, column));
END_CPP11
}
// recordbatch.cpp
std::shared_ptr<arrow::RecordBatch> RecordBatch__SetColumn(const std::shared_ptr<arrow::RecordBatch>& batch, R_xlen_t i, const std::shared_ptr<arrow::Field>& field, const std::shared_ptr<arrow::Array>& column);
extern "C" SEXP _arrow_RecordBatch__SetColumn(SEXP batch_sexp, SEXP i_sexp, SEXP field_sexp, SEXP column_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::RecordBatch>&>::type batch(batch_sexp);
	arrow::r::Input<R_xlen_t>::type i(i_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::Field>&>::type field(field_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::Array>&>::type column(column_sexp);
	return cpp11::as_sexp(RecordBatch__SetColumn(batch, i, field, column));
END_CPP11
}
// recordbatch.cpp
std::shared_ptr<arrow::RecordBatch> RecordBatch__RemoveColumn(const std::shared_ptr<arrow::RecordBatch>& batch, R_xlen_t i);
extern "C" SEXP _arrow_RecordBatch__RemoveColumn(SEXP batch_sexp, SEXP i_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::RecordBatch>&>::type batch(batch_sexp);
	arrow::r::Input<R_xlen_t>::type i(i_sexp);
	return cpp11::as_sexp(RecordBatch__RemoveColumn(batch, i));
END_CPP11
}
// recordbatch.cpp
std::string RecordBatch__column_name(const std::shared_ptr<arrow::RecordBatch>& batch, R_xlen_t i);
extern "C" SEXP _arrow_RecordBatch__column_name(SEXP batch_sexp, SEXP i_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::RecordBatch>&>::type batch(batch_sexp);
	arrow::r::Input<R_xlen_t>::type i(i_sexp);
	return cpp11::as_sexp(RecordBatch__column_name(batch, i));
END_CPP11
}
// recordbatch.cpp
cpp11::writable::strings RecordBatch__names(const std::shared_ptr<arrow::RecordBatch>& batch);
extern "C" SEXP _arrow_RecordBatch__names(SEXP batch_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::RecordBatch>&>::type batch(batch_sexp);
	return cpp11::as_sexp(RecordBatch__names(batch));
END_CPP11
}
// recordbatch.cpp
std::shared_ptr<arrow::RecordBatch> RecordBatch__Slice1(const std::shared_ptr<arrow::RecordBatch>& self, R_xlen_t offset);
extern "C" SEXP _arrow_RecordBatch__Slice1(SEXP self_sexp, SEXP offset_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::RecordBatch>&>::type self(self_sexp);
	arrow::r::Input<R_xlen_t>::type offset(offset_sexp);
	return cpp11::as_sexp(RecordBatch__Slice1(self, offset));
END_CPP11
}
// recordbatch.cpp
std::shared_ptr<arrow::RecordBatch> RecordBatch__Slice2(const std::shared_ptr<arrow::RecordBatch>& self, R_xlen_t offset, R_xlen_t length);
extern "C" SEXP _arrow_RecordBatch__Slice2(SEXP self_sexp, SEXP offset_sexp, SEXP length_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::RecordBatch>&>::type self(self_sexp);
	arrow::r::Input<R_xlen_t>::type offset(offset_sexp);
	arrow::r::Input<R_xlen_t>::type length(length_sexp);
	return cpp11::as_sexp(RecordBatch__Slice2(self, offset, length));
END_CPP11
}
// recordbatch.cpp
cpp11::raws ipc___SerializeRecordBatch__Raw(const std::shared_ptr<arrow::RecordBatch>& batch);
extern "C" SEXP _arrow_ipc___SerializeRecordBatch__Raw(SEXP batch_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::RecordBatch>&>::type batch(batch_sexp);
	return cpp11::as_sexp(ipc___SerializeRecordBatch__Raw(batch));
END_CPP11
}
// recordbatch.cpp
std::shared_ptr<arrow::RecordBatch> ipc___ReadRecordBatch__InputStream__Schema(const std::shared_ptr<arrow::io::InputStream>& stream, const std::shared_ptr<arrow::Schema>& schema);
extern "C" SEXP _arrow_ipc___ReadRecordBatch__InputStream__Schema(SEXP stream_sexp, SEXP schema_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::io::InputStream>&>::type stream(stream_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::Schema>&>::type schema(schema_sexp);
	return cpp11::as_sexp(ipc___ReadRecordBatch__InputStream__Schema(stream, schema));
END_CPP11
}
// recordbatch.cpp
std::shared_ptr<arrow::RecordBatch> RecordBatch__from_arrays(SEXP schema_sxp, SEXP lst);
extern "C" SEXP _arrow_RecordBatch__from_arrays(SEXP schema_sxp_sexp, SEXP lst_sexp){
BEGIN_CPP11
	arrow::r::Input<SEXP>::type schema_sxp(schema_sxp_sexp);
	arrow::r::Input<SEXP>::type lst(lst_sexp);
	return cpp11::as_sexp(RecordBatch__from_arrays(schema_sxp, lst));
END_CPP11
}
// recordbatch.cpp
r_vec_size RecordBatch__ReferencedBufferSize(const std::shared_ptr<arrow::RecordBatch>& batch);
extern "C" SEXP _arrow_RecordBatch__ReferencedBufferSize(SEXP batch_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::RecordBatch>&>::type batch(batch_sexp);
	return cpp11::as_sexp(RecordBatch__ReferencedBufferSize(batch));
END_CPP11
}
// recordbatchreader.cpp
std::shared_ptr<arrow::Schema> RecordBatchReader__schema(const std::shared_ptr<arrow::RecordBatchReader>& reader);
extern "C" SEXP _arrow_RecordBatchReader__schema(SEXP reader_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::RecordBatchReader>&>::type reader(reader_sexp);
	return cpp11::as_sexp(RecordBatchReader__schema(reader));
END_CPP11
}
// recordbatchreader.cpp
void RecordBatchReader__Close(const std::shared_ptr<arrow::RecordBatchReader>& reader);
extern "C" SEXP _arrow_RecordBatchReader__Close(SEXP reader_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::RecordBatchReader>&>::type reader(reader_sexp);
	RecordBatchReader__Close(reader);
	return R_NilValue;
END_CPP11
}
// recordbatchreader.cpp
void RecordBatchReader__UnsafeDelete(const std::shared_ptr<arrow::RecordBatchReader>& reader);
extern "C" SEXP _arrow_RecordBatchReader__UnsafeDelete(SEXP reader_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::RecordBatchReader>&>::type reader(reader_sexp);
	RecordBatchReader__UnsafeDelete(reader);
	return R_NilValue;
END_CPP11
}
// recordbatchreader.cpp
std::shared_ptr<arrow::RecordBatch> RecordBatchReader__ReadNext(const std::shared_ptr<arrow::RecordBatchReader>& reader);
extern "C" SEXP _arrow_RecordBatchReader__ReadNext(SEXP reader_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::RecordBatchReader>&>::type reader(reader_sexp);
	return cpp11::as_sexp(RecordBatchReader__ReadNext(reader));
END_CPP11
}
// recordbatchreader.cpp
cpp11::list RecordBatchReader__batches(const std::shared_ptr<arrow::RecordBatchReader>& reader);
extern "C" SEXP _arrow_RecordBatchReader__batches(SEXP reader_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::RecordBatchReader>&>::type reader(reader_sexp);
	return cpp11::as_sexp(RecordBatchReader__batches(reader));
END_CPP11
}
// recordbatchreader.cpp
std::shared_ptr<arrow::RecordBatchReader> RecordBatchReader__from_batches(const std::vector<std::shared_ptr<arrow::RecordBatch>>& batches, cpp11::sexp schema_sxp);
extern "C" SEXP _arrow_RecordBatchReader__from_batches(SEXP batches_sexp, SEXP schema_sxp_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::vector<std::shared_ptr<arrow::RecordBatch>>&>::type batches(batches_sexp);
	arrow::r::Input<cpp11::sexp>::type schema_sxp(schema_sxp_sexp);
	return cpp11::as_sexp(RecordBatchReader__from_batches(batches, schema_sxp));
END_CPP11
}
// recordbatchreader.cpp
std::shared_ptr<arrow::RecordBatchReader> RecordBatchReader__from_function(cpp11::sexp fun_sexp, const std::shared_ptr<arrow::Schema>& schema);
extern "C" SEXP _arrow_RecordBatchReader__from_function(SEXP fun_sexp_sexp, SEXP schema_sexp){
BEGIN_CPP11
	arrow::r::Input<cpp11::sexp>::type fun_sexp(fun_sexp_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::Schema>&>::type schema(schema_sexp);
	return cpp11::as_sexp(RecordBatchReader__from_function(fun_sexp, schema));
END_CPP11
}
// recordbatchreader.cpp
std::shared_ptr<arrow::RecordBatchReader> RecordBatchReader__from_Table(const std::shared_ptr<arrow::Table>& table);
extern "C" SEXP _arrow_RecordBatchReader__from_Table(SEXP table_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Table>&>::type table(table_sexp);
	return cpp11::as_sexp(RecordBatchReader__from_Table(table));
END_CPP11
}
// recordbatchreader.cpp
std::shared_ptr<arrow::Table> Table__from_RecordBatchReader(const std::shared_ptr<arrow::RecordBatchReader>& reader);
extern "C" SEXP _arrow_Table__from_RecordBatchReader(SEXP reader_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::RecordBatchReader>&>::type reader(reader_sexp);
	return cpp11::as_sexp(Table__from_RecordBatchReader(reader));
END_CPP11
}
// recordbatchreader.cpp
std::shared_ptr<arrow::RecordBatchReader> RecordBatchReader__Head(const std::shared_ptr<arrow::RecordBatchReader>& reader, int64_t num_rows);
extern "C" SEXP _arrow_RecordBatchReader__Head(SEXP reader_sexp, SEXP num_rows_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::RecordBatchReader>&>::type reader(reader_sexp);
	arrow::r::Input<int64_t>::type num_rows(num_rows_sexp);
	return cpp11::as_sexp(RecordBatchReader__Head(reader, num_rows));
END_CPP11
}
// recordbatchreader.cpp
std::shared_ptr<arrow::ipc::RecordBatchStreamReader> ipc___RecordBatchStreamReader__Open(const std::shared_ptr<arrow::io::InputStream>& stream);
extern "C" SEXP _arrow_ipc___RecordBatchStreamReader__Open(SEXP stream_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::io::InputStream>&>::type stream(stream_sexp);
	return cpp11::as_sexp(ipc___RecordBatchStreamReader__Open(stream));
END_CPP11
}
// recordbatchreader.cpp
std::shared_ptr<arrow::Schema> ipc___RecordBatchFileReader__schema(const std::shared_ptr<arrow::ipc::RecordBatchFileReader>& reader);
extern "C" SEXP _arrow_ipc___RecordBatchFileReader__schema(SEXP reader_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::ipc::RecordBatchFileReader>&>::type reader(reader_sexp);
	return cpp11::as_sexp(ipc___RecordBatchFileReader__schema(reader));
END_CPP11
}
// recordbatchreader.cpp
int ipc___RecordBatchFileReader__num_record_batches(const std::shared_ptr<arrow::ipc::RecordBatchFileReader>& reader);
extern "C" SEXP _arrow_ipc___RecordBatchFileReader__num_record_batches(SEXP reader_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::ipc::RecordBatchFileReader>&>::type reader(reader_sexp);
	return cpp11::as_sexp(ipc___RecordBatchFileReader__num_record_batches(reader));
END_CPP11
}
// recordbatchreader.cpp
std::shared_ptr<arrow::RecordBatch> ipc___RecordBatchFileReader__ReadRecordBatch(const std::shared_ptr<arrow::ipc::RecordBatchFileReader>& reader, int i);
extern "C" SEXP _arrow_ipc___RecordBatchFileReader__ReadRecordBatch(SEXP reader_sexp, SEXP i_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::ipc::RecordBatchFileReader>&>::type reader(reader_sexp);
	arrow::r::Input<int>::type i(i_sexp);
	return cpp11::as_sexp(ipc___RecordBatchFileReader__ReadRecordBatch(reader, i));
END_CPP11
}
// recordbatchreader.cpp
std::shared_ptr<arrow::ipc::RecordBatchFileReader> ipc___RecordBatchFileReader__Open(const std::shared_ptr<arrow::io::RandomAccessFile>& file);
extern "C" SEXP _arrow_ipc___RecordBatchFileReader__Open(SEXP file_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::io::RandomAccessFile>&>::type file(file_sexp);
	return cpp11::as_sexp(ipc___RecordBatchFileReader__Open(file));
END_CPP11
}
// recordbatchreader.cpp
std::shared_ptr<arrow::Table> Table__from_RecordBatchFileReader(const std::shared_ptr<arrow::ipc::RecordBatchFileReader>& reader);
extern "C" SEXP _arrow_Table__from_RecordBatchFileReader(SEXP reader_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::ipc::RecordBatchFileReader>&>::type reader(reader_sexp);
	return cpp11::as_sexp(Table__from_RecordBatchFileReader(reader));
END_CPP11
}
// recordbatchreader.cpp
cpp11::list ipc___RecordBatchFileReader__batches(const std::shared_ptr<arrow::ipc::RecordBatchFileReader>& reader);
extern "C" SEXP _arrow_ipc___RecordBatchFileReader__batches(SEXP reader_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::ipc::RecordBatchFileReader>&>::type reader(reader_sexp);
	return cpp11::as_sexp(ipc___RecordBatchFileReader__batches(reader));
END_CPP11
}
// recordbatchwriter.cpp
void ipc___RecordBatchWriter__WriteRecordBatch(const std::shared_ptr<arrow::ipc::RecordBatchWriter>& batch_writer, const std::shared_ptr<arrow::RecordBatch>& batch);
extern "C" SEXP _arrow_ipc___RecordBatchWriter__WriteRecordBatch(SEXP batch_writer_sexp, SEXP batch_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::ipc::RecordBatchWriter>&>::type batch_writer(batch_writer_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::RecordBatch>&>::type batch(batch_sexp);
	ipc___RecordBatchWriter__WriteRecordBatch(batch_writer, batch);
	return R_NilValue;
END_CPP11
}
// recordbatchwriter.cpp
void ipc___RecordBatchWriter__WriteTable(const std::shared_ptr<arrow::ipc::RecordBatchWriter>& batch_writer, const std::shared_ptr<arrow::Table>& table);
extern "C" SEXP _arrow_ipc___RecordBatchWriter__WriteTable(SEXP batch_writer_sexp, SEXP table_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::ipc::RecordBatchWriter>&>::type batch_writer(batch_writer_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::Table>&>::type table(table_sexp);
	ipc___RecordBatchWriter__WriteTable(batch_writer, table);
	return R_NilValue;
END_CPP11
}
// recordbatchwriter.cpp
void ipc___RecordBatchWriter__Close(const std::shared_ptr<arrow::ipc::RecordBatchWriter>& batch_writer);
extern "C" SEXP _arrow_ipc___RecordBatchWriter__Close(SEXP batch_writer_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::ipc::RecordBatchWriter>&>::type batch_writer(batch_writer_sexp);
	ipc___RecordBatchWriter__Close(batch_writer);
	return R_NilValue;
END_CPP11
}
// recordbatchwriter.cpp
std::shared_ptr<arrow::ipc::RecordBatchWriter> ipc___RecordBatchFileWriter__Open(const std::shared_ptr<arrow::io::OutputStream>& stream, const std::shared_ptr<arrow::Schema>& schema, bool use_legacy_format, arrow::ipc::MetadataVersion metadata_version);
extern "C" SEXP _arrow_ipc___RecordBatchFileWriter__Open(SEXP stream_sexp, SEXP schema_sexp, SEXP use_legacy_format_sexp, SEXP metadata_version_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::io::OutputStream>&>::type stream(stream_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::Schema>&>::type schema(schema_sexp);
	arrow::r::Input<bool>::type use_legacy_format(use_legacy_format_sexp);
	arrow::r::Input<arrow::ipc::MetadataVersion>::type metadata_version(metadata_version_sexp);
	return cpp11::as_sexp(ipc___RecordBatchFileWriter__Open(stream, schema, use_legacy_format, metadata_version));
END_CPP11
}
// recordbatchwriter.cpp
std::shared_ptr<arrow::ipc::RecordBatchWriter> ipc___RecordBatchStreamWriter__Open(const std::shared_ptr<arrow::io::OutputStream>& stream, const std::shared_ptr<arrow::Schema>& schema, bool use_legacy_format, arrow::ipc::MetadataVersion metadata_version);
extern "C" SEXP _arrow_ipc___RecordBatchStreamWriter__Open(SEXP stream_sexp, SEXP schema_sexp, SEXP use_legacy_format_sexp, SEXP metadata_version_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::io::OutputStream>&>::type stream(stream_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::Schema>&>::type schema(schema_sexp);
	arrow::r::Input<bool>::type use_legacy_format(use_legacy_format_sexp);
	arrow::r::Input<arrow::ipc::MetadataVersion>::type metadata_version(metadata_version_sexp);
	return cpp11::as_sexp(ipc___RecordBatchStreamWriter__Open(stream, schema, use_legacy_format, metadata_version));
END_CPP11
}
// safe-call-into-r-impl.cpp
void InitializeMainRThread();
extern "C" SEXP _arrow_InitializeMainRThread(){
BEGIN_CPP11
	InitializeMainRThread();
	return R_NilValue;
END_CPP11
}
// safe-call-into-r-impl.cpp
void DeinitializeMainRThread();
extern "C" SEXP _arrow_DeinitializeMainRThread(){
BEGIN_CPP11
	DeinitializeMainRThread();
	return R_NilValue;
END_CPP11
}
// safe-call-into-r-impl.cpp
bool SetEnableSignalStopSource(bool enabled);
extern "C" SEXP _arrow_SetEnableSignalStopSource(SEXP enabled_sexp){
BEGIN_CPP11
	arrow::r::Input<bool>::type enabled(enabled_sexp);
	return cpp11::as_sexp(SetEnableSignalStopSource(enabled));
END_CPP11
}
// safe-call-into-r-impl.cpp
bool CanRunWithCapturedR();
extern "C" SEXP _arrow_CanRunWithCapturedR(){
BEGIN_CPP11
	return cpp11::as_sexp(CanRunWithCapturedR());
END_CPP11
}
// safe-call-into-r-impl.cpp
std::string TestSafeCallIntoR(cpp11::function r_fun_that_returns_a_string, std::string opt);
extern "C" SEXP _arrow_TestSafeCallIntoR(SEXP r_fun_that_returns_a_string_sexp, SEXP opt_sexp){
BEGIN_CPP11
	arrow::r::Input<cpp11::function>::type r_fun_that_returns_a_string(r_fun_that_returns_a_string_sexp);
	arrow::r::Input<std::string>::type opt(opt_sexp);
	return cpp11::as_sexp(TestSafeCallIntoR(r_fun_that_returns_a_string, opt));
END_CPP11
}
// scalar.cpp
std::shared_ptr<arrow::Scalar> Array__GetScalar(const std::shared_ptr<arrow::Array>& x, int64_t i);
extern "C" SEXP _arrow_Array__GetScalar(SEXP x_sexp, SEXP i_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Array>&>::type x(x_sexp);
	arrow::r::Input<int64_t>::type i(i_sexp);
	return cpp11::as_sexp(Array__GetScalar(x, i));
END_CPP11
}
// scalar.cpp
std::string Scalar__ToString(const std::shared_ptr<arrow::Scalar>& s);
extern "C" SEXP _arrow_Scalar__ToString(SEXP s_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Scalar>&>::type s(s_sexp);
	return cpp11::as_sexp(Scalar__ToString(s));
END_CPP11
}
// scalar.cpp
std::shared_ptr<arrow::Scalar> StructScalar__field(const std::shared_ptr<arrow::StructScalar>& s, int i);
extern "C" SEXP _arrow_StructScalar__field(SEXP s_sexp, SEXP i_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::StructScalar>&>::type s(s_sexp);
	arrow::r::Input<int>::type i(i_sexp);
	return cpp11::as_sexp(StructScalar__field(s, i));
END_CPP11
}
// scalar.cpp
std::shared_ptr<arrow::Scalar> StructScalar__GetFieldByName(const std::shared_ptr<arrow::StructScalar>& s, const std::string& name);
extern "C" SEXP _arrow_StructScalar__GetFieldByName(SEXP s_sexp, SEXP name_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::StructScalar>&>::type s(s_sexp);
	arrow::r::Input<const std::string&>::type name(name_sexp);
	return cpp11::as_sexp(StructScalar__GetFieldByName(s, name));
END_CPP11
}
// scalar.cpp
std::shared_ptr<arrow::Array> MakeArrayFromScalar(const std::shared_ptr<arrow::Scalar>& scalar, int n);
extern "C" SEXP _arrow_MakeArrayFromScalar(SEXP scalar_sexp, SEXP n_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Scalar>&>::type scalar(scalar_sexp);
	arrow::r::Input<int>::type n(n_sexp);
	return cpp11::as_sexp(MakeArrayFromScalar(scalar, n));
END_CPP11
}
// scalar.cpp
bool Scalar__is_valid(const std::shared_ptr<arrow::Scalar>& s);
extern "C" SEXP _arrow_Scalar__is_valid(SEXP s_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Scalar>&>::type s(s_sexp);
	return cpp11::as_sexp(Scalar__is_valid(s));
END_CPP11
}
// scalar.cpp
std::shared_ptr<arrow::DataType> Scalar__type(const std::shared_ptr<arrow::Scalar>& s);
extern "C" SEXP _arrow_Scalar__type(SEXP s_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Scalar>&>::type s(s_sexp);
	return cpp11::as_sexp(Scalar__type(s));
END_CPP11
}
// scalar.cpp
bool Scalar__Equals(const std::shared_ptr<arrow::Scalar>& lhs, const std::shared_ptr<arrow::Scalar>& rhs);
extern "C" SEXP _arrow_Scalar__Equals(SEXP lhs_sexp, SEXP rhs_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Scalar>&>::type lhs(lhs_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::Scalar>&>::type rhs(rhs_sexp);
	return cpp11::as_sexp(Scalar__Equals(lhs, rhs));
END_CPP11
}
// scalar.cpp
bool Scalar__ApproxEquals(const std::shared_ptr<arrow::Scalar>& lhs, const std::shared_ptr<arrow::Scalar>& rhs);
extern "C" SEXP _arrow_Scalar__ApproxEquals(SEXP lhs_sexp, SEXP rhs_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Scalar>&>::type lhs(lhs_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::Scalar>&>::type rhs(rhs_sexp);
	return cpp11::as_sexp(Scalar__ApproxEquals(lhs, rhs));
END_CPP11
}
// schema.cpp
std::shared_ptr<arrow::Schema> Schema__from_fields(const std::vector<std::shared_ptr<arrow::Field>>& fields);
extern "C" SEXP _arrow_Schema__from_fields(SEXP fields_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::vector<std::shared_ptr<arrow::Field>>&>::type fields(fields_sexp);
	return cpp11::as_sexp(Schema__from_fields(fields));
END_CPP11
}
// schema.cpp
std::shared_ptr<arrow::Schema> Schema__from_list(cpp11::list field_list);
extern "C" SEXP _arrow_Schema__from_list(SEXP field_list_sexp){
BEGIN_CPP11
	arrow::r::Input<cpp11::list>::type field_list(field_list_sexp);
	return cpp11::as_sexp(Schema__from_list(field_list));
END_CPP11
}
// schema.cpp
std::string Schema__ToString(const std::shared_ptr<arrow::Schema>& s);
extern "C" SEXP _arrow_Schema__ToString(SEXP s_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Schema>&>::type s(s_sexp);
	return cpp11::as_sexp(Schema__ToString(s));
END_CPP11
}
// schema.cpp
int Schema__num_fields(const std::shared_ptr<arrow::Schema>& s);
extern "C" SEXP _arrow_Schema__num_fields(SEXP s_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Schema>&>::type s(s_sexp);
	return cpp11::as_sexp(Schema__num_fields(s));
END_CPP11
}
// schema.cpp
std::shared_ptr<arrow::Field> Schema__field(const std::shared_ptr<arrow::Schema>& s, int i);
extern "C" SEXP _arrow_Schema__field(SEXP s_sexp, SEXP i_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Schema>&>::type s(s_sexp);
	arrow::r::Input<int>::type i(i_sexp);
	return cpp11::as_sexp(Schema__field(s, i));
END_CPP11
}
// schema.cpp
std::shared_ptr<arrow::Schema> Schema__AddField(const std::shared_ptr<arrow::Schema>& s, int i, const std::shared_ptr<arrow::Field>& field);
extern "C" SEXP _arrow_Schema__AddField(SEXP s_sexp, SEXP i_sexp, SEXP field_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Schema>&>::type s(s_sexp);
	arrow::r::Input<int>::type i(i_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::Field>&>::type field(field_sexp);
	return cpp11::as_sexp(Schema__AddField(s, i, field));
END_CPP11
}
// schema.cpp
std::shared_ptr<arrow::Schema> Schema__SetField(const std::shared_ptr<arrow::Schema>& s, int i, const std::shared_ptr<arrow::Field>& field);
extern "C" SEXP _arrow_Schema__SetField(SEXP s_sexp, SEXP i_sexp, SEXP field_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Schema>&>::type s(s_sexp);
	arrow::r::Input<int>::type i(i_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::Field>&>::type field(field_sexp);
	return cpp11::as_sexp(Schema__SetField(s, i, field));
END_CPP11
}
// schema.cpp
std::shared_ptr<arrow::Schema> Schema__RemoveField(const std::shared_ptr<arrow::Schema>& s, int i);
extern "C" SEXP _arrow_Schema__RemoveField(SEXP s_sexp, SEXP i_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Schema>&>::type s(s_sexp);
	arrow::r::Input<int>::type i(i_sexp);
	return cpp11::as_sexp(Schema__RemoveField(s, i));
END_CPP11
}
// schema.cpp
std::shared_ptr<arrow::Field> Schema__GetFieldByName(const std::shared_ptr<arrow::Schema>& s, std::string x);
extern "C" SEXP _arrow_Schema__GetFieldByName(SEXP s_sexp, SEXP x_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Schema>&>::type s(s_sexp);
	arrow::r::Input<std::string>::type x(x_sexp);
	return cpp11::as_sexp(Schema__GetFieldByName(s, x));
END_CPP11
}
// schema.cpp
cpp11::list Schema__fields(const std::shared_ptr<arrow::Schema>& schema);
extern "C" SEXP _arrow_Schema__fields(SEXP schema_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Schema>&>::type schema(schema_sexp);
	return cpp11::as_sexp(Schema__fields(schema));
END_CPP11
}
// schema.cpp
std::vector<std::string> Schema__field_names(const std::shared_ptr<arrow::Schema>& schema);
extern "C" SEXP _arrow_Schema__field_names(SEXP schema_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Schema>&>::type schema(schema_sexp);
	return cpp11::as_sexp(Schema__field_names(schema));
END_CPP11
}
// schema.cpp
bool Schema__HasMetadata(const std::shared_ptr<arrow::Schema>& schema);
extern "C" SEXP _arrow_Schema__HasMetadata(SEXP schema_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Schema>&>::type schema(schema_sexp);
	return cpp11::as_sexp(Schema__HasMetadata(schema));
END_CPP11
}
// schema.cpp
cpp11::writable::list Schema__metadata(const std::shared_ptr<arrow::Schema>& schema);
extern "C" SEXP _arrow_Schema__metadata(SEXP schema_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Schema>&>::type schema(schema_sexp);
	return cpp11::as_sexp(Schema__metadata(schema));
END_CPP11
}
// schema.cpp
std::shared_ptr<arrow::Schema> Schema__WithMetadata(const std::shared_ptr<arrow::Schema>& schema, cpp11::strings metadata);
extern "C" SEXP _arrow_Schema__WithMetadata(SEXP schema_sexp, SEXP metadata_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Schema>&>::type schema(schema_sexp);
	arrow::r::Input<cpp11::strings>::type metadata(metadata_sexp);
	return cpp11::as_sexp(Schema__WithMetadata(schema, metadata));
END_CPP11
}
// schema.cpp
cpp11::writable::raws Schema__serialize(const std::shared_ptr<arrow::Schema>& schema);
extern "C" SEXP _arrow_Schema__serialize(SEXP schema_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Schema>&>::type schema(schema_sexp);
	return cpp11::as_sexp(Schema__serialize(schema));
END_CPP11
}
// schema.cpp
bool Schema__Equals(const std::shared_ptr<arrow::Schema>& schema, const std::shared_ptr<arrow::Schema>& other, bool check_metadata);
extern "C" SEXP _arrow_Schema__Equals(SEXP schema_sexp, SEXP other_sexp, SEXP check_metadata_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Schema>&>::type schema(schema_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::Schema>&>::type other(other_sexp);
	arrow::r::Input<bool>::type check_metadata(check_metadata_sexp);
	return cpp11::as_sexp(Schema__Equals(schema, other, check_metadata));
END_CPP11
}
// schema.cpp
std::shared_ptr<arrow::Schema> arrow__UnifySchemas(const std::vector<std::shared_ptr<arrow::Schema>>& schemas);
extern "C" SEXP _arrow_arrow__UnifySchemas(SEXP schemas_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::vector<std::shared_ptr<arrow::Schema>>&>::type schemas(schemas_sexp);
	return cpp11::as_sexp(arrow__UnifySchemas(schemas));
END_CPP11
}
// table.cpp
r_vec_size Table__num_columns(const std::shared_ptr<arrow::Table>& x);
extern "C" SEXP _arrow_Table__num_columns(SEXP x_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Table>&>::type x(x_sexp);
	return cpp11::as_sexp(Table__num_columns(x));
END_CPP11
}
// table.cpp
r_vec_size Table__num_rows(const std::shared_ptr<arrow::Table>& x);
extern "C" SEXP _arrow_Table__num_rows(SEXP x_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Table>&>::type x(x_sexp);
	return cpp11::as_sexp(Table__num_rows(x));
END_CPP11
}
// table.cpp
std::shared_ptr<arrow::Schema> Table__schema(const std::shared_ptr<arrow::Table>& x);
extern "C" SEXP _arrow_Table__schema(SEXP x_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Table>&>::type x(x_sexp);
	return cpp11::as_sexp(Table__schema(x));
END_CPP11
}
// table.cpp
std::shared_ptr<arrow::Table> Table__ReplaceSchemaMetadata(const std::shared_ptr<arrow::Table>& x, cpp11::strings metadata);
extern "C" SEXP _arrow_Table__ReplaceSchemaMetadata(SEXP x_sexp, SEXP metadata_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Table>&>::type x(x_sexp);
	arrow::r::Input<cpp11::strings>::type metadata(metadata_sexp);
	return cpp11::as_sexp(Table__ReplaceSchemaMetadata(x, metadata));
END_CPP11
}
// table.cpp
std::shared_ptr<arrow::ChunkedArray> Table__column(const std::shared_ptr<arrow::Table>& table, R_xlen_t i);
extern "C" SEXP _arrow_Table__column(SEXP table_sexp, SEXP i_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Table>&>::type table(table_sexp);
	arrow::r::Input<R_xlen_t>::type i(i_sexp);
	return cpp11::as_sexp(Table__column(table, i));
END_CPP11
}
// table.cpp
std::shared_ptr<arrow::Field> Table__field(const std::shared_ptr<arrow::Table>& table, R_xlen_t i);
extern "C" SEXP _arrow_Table__field(SEXP table_sexp, SEXP i_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Table>&>::type table(table_sexp);
	arrow::r::Input<R_xlen_t>::type i(i_sexp);
	return cpp11::as_sexp(Table__field(table, i));
END_CPP11
}
// table.cpp
cpp11::list Table__columns(const std::shared_ptr<arrow::Table>& table);
extern "C" SEXP _arrow_Table__columns(SEXP table_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Table>&>::type table(table_sexp);
	return cpp11::as_sexp(Table__columns(table));
END_CPP11
}
// table.cpp
std::vector<std::string> Table__ColumnNames(const std::shared_ptr<arrow::Table>& table);
extern "C" SEXP _arrow_Table__ColumnNames(SEXP table_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Table>&>::type table(table_sexp);
	return cpp11::as_sexp(Table__ColumnNames(table));
END_CPP11
}
// table.cpp
std::shared_ptr<arrow::Table> Table__RenameColumns(const std::shared_ptr<arrow::Table>& table, const std::vector<std::string>& names);
extern "C" SEXP _arrow_Table__RenameColumns(SEXP table_sexp, SEXP names_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Table>&>::type table(table_sexp);
	arrow::r::Input<const std::vector<std::string>&>::type names(names_sexp);
	return cpp11::as_sexp(Table__RenameColumns(table, names));
END_CPP11
}
// table.cpp
std::shared_ptr<arrow::Table> Table__Slice1(const std::shared_ptr<arrow::Table>& table, R_xlen_t offset);
extern "C" SEXP _arrow_Table__Slice1(SEXP table_sexp, SEXP offset_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Table>&>::type table(table_sexp);
	arrow::r::Input<R_xlen_t>::type offset(offset_sexp);
	return cpp11::as_sexp(Table__Slice1(table, offset));
END_CPP11
}
// table.cpp
std::shared_ptr<arrow::Table> Table__Slice2(const std::shared_ptr<arrow::Table>& table, R_xlen_t offset, R_xlen_t length);
extern "C" SEXP _arrow_Table__Slice2(SEXP table_sexp, SEXP offset_sexp, SEXP length_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Table>&>::type table(table_sexp);
	arrow::r::Input<R_xlen_t>::type offset(offset_sexp);
	arrow::r::Input<R_xlen_t>::type length(length_sexp);
	return cpp11::as_sexp(Table__Slice2(table, offset, length));
END_CPP11
}
// table.cpp
bool Table__Equals(const std::shared_ptr<arrow::Table>& lhs, const std::shared_ptr<arrow::Table>& rhs, bool check_metadata);
extern "C" SEXP _arrow_Table__Equals(SEXP lhs_sexp, SEXP rhs_sexp, SEXP check_metadata_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Table>&>::type lhs(lhs_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::Table>&>::type rhs(rhs_sexp);
	arrow::r::Input<bool>::type check_metadata(check_metadata_sexp);
	return cpp11::as_sexp(Table__Equals(lhs, rhs, check_metadata));
END_CPP11
}
// table.cpp
bool Table__Validate(const std::shared_ptr<arrow::Table>& table);
extern "C" SEXP _arrow_Table__Validate(SEXP table_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Table>&>::type table(table_sexp);
	return cpp11::as_sexp(Table__Validate(table));
END_CPP11
}
// table.cpp
bool Table__ValidateFull(const std::shared_ptr<arrow::Table>& table);
extern "C" SEXP _arrow_Table__ValidateFull(SEXP table_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Table>&>::type table(table_sexp);
	return cpp11::as_sexp(Table__ValidateFull(table));
END_CPP11
}
// table.cpp
std::shared_ptr<arrow::ChunkedArray> Table__GetColumnByName(const std::shared_ptr<arrow::Table>& table, const std::string& name);
extern "C" SEXP _arrow_Table__GetColumnByName(SEXP table_sexp, SEXP name_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Table>&>::type table(table_sexp);
	arrow::r::Input<const std::string&>::type name(name_sexp);
	return cpp11::as_sexp(Table__GetColumnByName(table, name));
END_CPP11
}
// table.cpp
std::shared_ptr<arrow::Table> Table__RemoveColumn(const std::shared_ptr<arrow::Table>& table, R_xlen_t i);
extern "C" SEXP _arrow_Table__RemoveColumn(SEXP table_sexp, SEXP i_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Table>&>::type table(table_sexp);
	arrow::r::Input<R_xlen_t>::type i(i_sexp);
	return cpp11::as_sexp(Table__RemoveColumn(table, i));
END_CPP11
}
// table.cpp
std::shared_ptr<arrow::Table> Table__AddColumn(const std::shared_ptr<arrow::Table>& table, R_xlen_t i, const std::shared_ptr<arrow::Field>& field, const std::shared_ptr<arrow::ChunkedArray>& column);
extern "C" SEXP _arrow_Table__AddColumn(SEXP table_sexp, SEXP i_sexp, SEXP field_sexp, SEXP column_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Table>&>::type table(table_sexp);
	arrow::r::Input<R_xlen_t>::type i(i_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::Field>&>::type field(field_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::ChunkedArray>&>::type column(column_sexp);
	return cpp11::as_sexp(Table__AddColumn(table, i, field, column));
END_CPP11
}
// table.cpp
std::shared_ptr<arrow::Table> Table__SetColumn(const std::shared_ptr<arrow::Table>& table, R_xlen_t i, const std::shared_ptr<arrow::Field>& field, const std::shared_ptr<arrow::ChunkedArray>& column);
extern "C" SEXP _arrow_Table__SetColumn(SEXP table_sexp, SEXP i_sexp, SEXP field_sexp, SEXP column_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Table>&>::type table(table_sexp);
	arrow::r::Input<R_xlen_t>::type i(i_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::Field>&>::type field(field_sexp);
	arrow::r::Input<const std::shared_ptr<arrow::ChunkedArray>&>::type column(column_sexp);
	return cpp11::as_sexp(Table__SetColumn(table, i, field, column));
END_CPP11
}
// table.cpp
std::shared_ptr<arrow::Table> Table__SelectColumns(const std::shared_ptr<arrow::Table>& table, const std::vector<int>& indices);
extern "C" SEXP _arrow_Table__SelectColumns(SEXP table_sexp, SEXP indices_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Table>&>::type table(table_sexp);
	arrow::r::Input<const std::vector<int>&>::type indices(indices_sexp);
	return cpp11::as_sexp(Table__SelectColumns(table, indices));
END_CPP11
}
// table.cpp
bool all_record_batches(SEXP lst);
extern "C" SEXP _arrow_all_record_batches(SEXP lst_sexp){
BEGIN_CPP11
	arrow::r::Input<SEXP>::type lst(lst_sexp);
	return cpp11::as_sexp(all_record_batches(lst));
END_CPP11
}
// table.cpp
std::shared_ptr<arrow::Table> Table__from_record_batches(const std::vector<std::shared_ptr<arrow::RecordBatch>>& batches, SEXP schema_sxp);
extern "C" SEXP _arrow_Table__from_record_batches(SEXP batches_sexp, SEXP schema_sxp_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::vector<std::shared_ptr<arrow::RecordBatch>>&>::type batches(batches_sexp);
	arrow::r::Input<SEXP>::type schema_sxp(schema_sxp_sexp);
	return cpp11::as_sexp(Table__from_record_batches(batches, schema_sxp));
END_CPP11
}
// table.cpp
std::shared_ptr<arrow::Table> Table__from_schema(const std::shared_ptr<arrow::Schema>& schema);
extern "C" SEXP _arrow_Table__from_schema(SEXP schema_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Schema>&>::type schema(schema_sexp);
	return cpp11::as_sexp(Table__from_schema(schema));
END_CPP11
}
// table.cpp
r_vec_size Table__ReferencedBufferSize(const std::shared_ptr<arrow::Table>& table);
extern "C" SEXP _arrow_Table__ReferencedBufferSize(SEXP table_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::shared_ptr<arrow::Table>&>::type table(table_sexp);
	return cpp11::as_sexp(Table__ReferencedBufferSize(table));
END_CPP11
}
// table.cpp
std::shared_ptr<arrow::Table> Table__ConcatenateTables(const std::vector<std::shared_ptr<arrow::Table>>& tables, bool unify_schemas);
extern "C" SEXP _arrow_Table__ConcatenateTables(SEXP tables_sexp, SEXP unify_schemas_sexp){
BEGIN_CPP11
	arrow::r::Input<const std::vector<std::shared_ptr<arrow::Table>>&>::type tables(tables_sexp);
	arrow::r::Input<bool>::type unify_schemas(unify_schemas_sexp);
	return cpp11::as_sexp(Table__ConcatenateTables(tables, unify_schemas));
END_CPP11
}
// threadpool.cpp
int GetCpuThreadPoolCapacity();
extern "C" SEXP _arrow_GetCpuThreadPoolCapacity(){
BEGIN_CPP11
	return cpp11::as_sexp(GetCpuThreadPoolCapacity());
END_CPP11
}
// threadpool.cpp
void SetCpuThreadPoolCapacity(int threads);
extern "C" SEXP _arrow_SetCpuThreadPoolCapacity(SEXP threads_sexp){
BEGIN_CPP11
	arrow::r::Input<int>::type threads(threads_sexp);
	SetCpuThreadPoolCapacity(threads);
	return R_NilValue;
END_CPP11
}
// threadpool.cpp
int GetIOThreadPoolCapacity();
extern "C" SEXP _arrow_GetIOThreadPoolCapacity(){
BEGIN_CPP11
	return cpp11::as_sexp(GetIOThreadPoolCapacity());
END_CPP11
}
// threadpool.cpp
void SetIOThreadPoolCapacity(int threads);
extern "C" SEXP _arrow_SetIOThreadPoolCapacity(SEXP threads_sexp){
BEGIN_CPP11
	arrow::r::Input<int>::type threads(threads_sexp);
	SetIOThreadPoolCapacity(threads);
	return R_NilValue;
END_CPP11
}
// type_infer.cpp
std::shared_ptr<arrow::DataType> Array__infer_type(SEXP x);
extern "C" SEXP _arrow_Array__infer_type(SEXP x_sexp){
BEGIN_CPP11
	arrow::r::Input<SEXP>::type x(x_sexp);
	return cpp11::as_sexp(Array__infer_type(x));
END_CPP11
}
extern "C" SEXP _dataset_available() {
return Rf_ScalarLogical(
#if defined(ARROW_R_WITH_DATASET)
  TRUE
#else
  FALSE
#endif
);
}
extern "C" SEXP _substrait_available() {
return Rf_ScalarLogical(
#if defined(ARROW_R_WITH_SUBSTRAIT)
  TRUE
#else
  FALSE
#endif
);
}
extern "C" SEXP _parquet_available() {
return Rf_ScalarLogical(
#if defined(ARROW_R_WITH_PARQUET)
  TRUE
#else
  FALSE
#endif
);
}
extern "C" SEXP _s3_available() {
return Rf_ScalarLogical(
#if defined(ARROW_R_WITH_S3)
  TRUE
#else
  FALSE
#endif
);
}
extern "C" SEXP _gcs_available() {
return Rf_ScalarLogical(
#if defined(ARROW_R_WITH_GCS)
  TRUE
#else
  FALSE
#endif
);
}
extern "C" SEXP _json_available() {
return Rf_ScalarLogical(
#if defined(ARROW_R_WITH_JSON)
  TRUE
#else
  FALSE
#endif
);
}
static const R_CallMethodDef CallEntries[] = {
		{ "_dataset_available", (DL_FUNC)& _dataset_available, 0 },
		{ "_substrait_available", (DL_FUNC)& _substrait_available, 0 },
		{ "_parquet_available", (DL_FUNC)& _parquet_available, 0 },
		{ "_s3_available", (DL_FUNC)& _s3_available, 0 },
		{ "_gcs_available", (DL_FUNC)& _gcs_available, 0 },
		{ "_json_available", (DL_FUNC)& _json_available, 0 },
		{ "_arrow_is_arrow_altrep", (DL_FUNC) &_arrow_is_arrow_altrep, 1}, 
		{ "_arrow_test_arrow_altrep_set_string_elt", (DL_FUNC) &_arrow_test_arrow_altrep_set_string_elt, 3}, 
		{ "_arrow_test_arrow_altrep_is_materialized", (DL_FUNC) &_arrow_test_arrow_altrep_is_materialized, 1}, 
		{ "_arrow_test_arrow_altrep_force_materialize", (DL_FUNC) &_arrow_test_arrow_altrep_force_materialize, 1}, 
		{ "_arrow_test_arrow_altrep_copy_by_element", (DL_FUNC) &_arrow_test_arrow_altrep_copy_by_element, 1}, 
		{ "_arrow_test_arrow_altrep_copy_by_region", (DL_FUNC) &_arrow_test_arrow_altrep_copy_by_region, 2}, 
		{ "_arrow_test_arrow_altrep_copy_by_dataptr", (DL_FUNC) &_arrow_test_arrow_altrep_copy_by_dataptr, 1}, 
		{ "_arrow_Array__Slice1", (DL_FUNC) &_arrow_Array__Slice1, 2}, 
		{ "_arrow_Array__Slice2", (DL_FUNC) &_arrow_Array__Slice2, 3}, 
		{ "_arrow_Array__IsNull", (DL_FUNC) &_arrow_Array__IsNull, 2}, 
		{ "_arrow_Array__IsValid", (DL_FUNC) &_arrow_Array__IsValid, 2}, 
		{ "_arrow_Array__length", (DL_FUNC) &_arrow_Array__length, 1}, 
		{ "_arrow_Array__offset", (DL_FUNC) &_arrow_Array__offset, 1}, 
		{ "_arrow_Array__null_count", (DL_FUNC) &_arrow_Array__null_count, 1}, 
		{ "_arrow_Array__type", (DL_FUNC) &_arrow_Array__type, 1}, 
		{ "_arrow_Array__ToString", (DL_FUNC) &_arrow_Array__ToString, 1}, 
		{ "_arrow_Array__type_id", (DL_FUNC) &_arrow_Array__type_id, 1}, 
		{ "_arrow_Array__Equals", (DL_FUNC) &_arrow_Array__Equals, 2}, 
		{ "_arrow_Array__ApproxEquals", (DL_FUNC) &_arrow_Array__ApproxEquals, 2}, 
		{ "_arrow_Array__Diff", (DL_FUNC) &_arrow_Array__Diff, 2}, 
		{ "_arrow_Array__data", (DL_FUNC) &_arrow_Array__data, 1}, 
		{ "_arrow_Array__RangeEquals", (DL_FUNC) &_arrow_Array__RangeEquals, 5}, 
		{ "_arrow_Array__View", (DL_FUNC) &_arrow_Array__View, 2}, 
		{ "_arrow_Array__Validate", (DL_FUNC) &_arrow_Array__Validate, 1}, 
		{ "_arrow_DictionaryArray__indices", (DL_FUNC) &_arrow_DictionaryArray__indices, 1}, 
		{ "_arrow_DictionaryArray__dictionary", (DL_FUNC) &_arrow_DictionaryArray__dictionary, 1}, 
		{ "_arrow_StructArray__field", (DL_FUNC) &_arrow_StructArray__field, 2}, 
		{ "_arrow_StructArray__GetFieldByName", (DL_FUNC) &_arrow_StructArray__GetFieldByName, 2}, 
		{ "_arrow_StructArray__from_RecordBatch", (DL_FUNC) &_arrow_StructArray__from_RecordBatch, 1}, 
		{ "_arrow_StructArray__Flatten", (DL_FUNC) &_arrow_StructArray__Flatten, 1}, 
		{ "_arrow_ListArray__value_type", (DL_FUNC) &_arrow_ListArray__value_type, 1}, 
		{ "_arrow_LargeListArray__value_type", (DL_FUNC) &_arrow_LargeListArray__value_type, 1}, 
		{ "_arrow_ListArray__values", (DL_FUNC) &_arrow_ListArray__values, 1}, 
		{ "_arrow_LargeListArray__values", (DL_FUNC) &_arrow_LargeListArray__values, 1}, 
		{ "_arrow_ListArray__value_length", (DL_FUNC) &_arrow_ListArray__value_length, 2}, 
		{ "_arrow_LargeListArray__value_length", (DL_FUNC) &_arrow_LargeListArray__value_length, 2}, 
		{ "_arrow_FixedSizeListArray__value_length", (DL_FUNC) &_arrow_FixedSizeListArray__value_length, 2}, 
		{ "_arrow_ListArray__value_offset", (DL_FUNC) &_arrow_ListArray__value_offset, 2}, 
		{ "_arrow_LargeListArray__value_offset", (DL_FUNC) &_arrow_LargeListArray__value_offset, 2}, 
		{ "_arrow_FixedSizeListArray__value_offset", (DL_FUNC) &_arrow_FixedSizeListArray__value_offset, 2}, 
		{ "_arrow_ListArray__raw_value_offsets", (DL_FUNC) &_arrow_ListArray__raw_value_offsets, 1}, 
		{ "_arrow_LargeListArray__raw_value_offsets", (DL_FUNC) &_arrow_LargeListArray__raw_value_offsets, 1}, 
		{ "_arrow_MapArray__keys", (DL_FUNC) &_arrow_MapArray__keys, 1}, 
		{ "_arrow_MapArray__items", (DL_FUNC) &_arrow_MapArray__items, 1}, 
		{ "_arrow_MapArray__keys_nested", (DL_FUNC) &_arrow_MapArray__keys_nested, 1}, 
		{ "_arrow_MapArray__items_nested", (DL_FUNC) &_arrow_MapArray__items_nested, 1}, 
		{ "_arrow_Array__Same", (DL_FUNC) &_arrow_Array__Same, 2}, 
		{ "_arrow_Array__ReferencedBufferSize", (DL_FUNC) &_arrow_Array__ReferencedBufferSize, 1}, 
		{ "_arrow_arrow__Concatenate", (DL_FUNC) &_arrow_arrow__Concatenate, 1}, 
		{ "_arrow_Array__as_vector", (DL_FUNC) &_arrow_Array__as_vector, 1}, 
		{ "_arrow_ChunkedArray__as_vector", (DL_FUNC) &_arrow_ChunkedArray__as_vector, 2}, 
		{ "_arrow_RecordBatch__to_dataframe", (DL_FUNC) &_arrow_RecordBatch__to_dataframe, 2}, 
		{ "_arrow_Table__to_dataframe", (DL_FUNC) &_arrow_Table__to_dataframe, 2}, 
		{ "_arrow_ArrayData__get_type", (DL_FUNC) &_arrow_ArrayData__get_type, 1}, 
		{ "_arrow_ArrayData__get_length", (DL_FUNC) &_arrow_ArrayData__get_length, 1}, 
		{ "_arrow_ArrayData__get_null_count", (DL_FUNC) &_arrow_ArrayData__get_null_count, 1}, 
		{ "_arrow_ArrayData__get_offset", (DL_FUNC) &_arrow_ArrayData__get_offset, 1}, 
		{ "_arrow_ArrayData__buffers", (DL_FUNC) &_arrow_ArrayData__buffers, 1}, 
		{ "_arrow_external_pointer_addr_double", (DL_FUNC) &_arrow_external_pointer_addr_double, 1}, 
		{ "_arrow_external_pointer_addr_character", (DL_FUNC) &_arrow_external_pointer_addr_character, 1}, 
		{ "_arrow_external_pointer_addr_integer64", (DL_FUNC) &_arrow_external_pointer_addr_integer64, 1}, 
		{ "_arrow_external_pointer_addr_raw", (DL_FUNC) &_arrow_external_pointer_addr_raw, 1}, 
		{ "_arrow_allocate_arrow_schema", (DL_FUNC) &_arrow_allocate_arrow_schema, 0}, 
		{ "_arrow_delete_arrow_schema", (DL_FUNC) &_arrow_delete_arrow_schema, 1}, 
		{ "_arrow_allocate_arrow_array", (DL_FUNC) &_arrow_allocate_arrow_array, 0}, 
		{ "_arrow_delete_arrow_array", (DL_FUNC) &_arrow_delete_arrow_array, 1}, 
		{ "_arrow_allocate_arrow_array_stream", (DL_FUNC) &_arrow_allocate_arrow_array_stream, 0}, 
		{ "_arrow_delete_arrow_array_stream", (DL_FUNC) &_arrow_delete_arrow_array_stream, 1}, 
		{ "_arrow_ImportArray", (DL_FUNC) &_arrow_ImportArray, 2}, 
		{ "_arrow_ImportRecordBatch", (DL_FUNC) &_arrow_ImportRecordBatch, 2}, 
		{ "_arrow_ImportSchema", (DL_FUNC) &_arrow_ImportSchema, 1}, 
		{ "_arrow_ImportField", (DL_FUNC) &_arrow_ImportField, 1}, 
		{ "_arrow_ImportType", (DL_FUNC) &_arrow_ImportType, 1}, 
		{ "_arrow_ImportRecordBatchReader", (DL_FUNC) &_arrow_ImportRecordBatchReader, 1}, 
		{ "_arrow_ExportType", (DL_FUNC) &_arrow_ExportType, 2}, 
		{ "_arrow_ExportField", (DL_FUNC) &_arrow_ExportField, 2}, 
		{ "_arrow_ExportSchema", (DL_FUNC) &_arrow_ExportSchema, 2}, 
		{ "_arrow_ExportArray", (DL_FUNC) &_arrow_ExportArray, 3}, 
		{ "_arrow_ExportRecordBatch", (DL_FUNC) &_arrow_ExportRecordBatch, 3}, 
		{ "_arrow_ExportRecordBatchReader", (DL_FUNC) &_arrow_ExportRecordBatchReader, 2}, 
		{ "_arrow_Buffer__is_mutable", (DL_FUNC) &_arrow_Buffer__is_mutable, 1}, 
		{ "_arrow_Buffer__ZeroPadding", (DL_FUNC) &_arrow_Buffer__ZeroPadding, 1}, 
		{ "_arrow_Buffer__capacity", (DL_FUNC) &_arrow_Buffer__capacity, 1}, 
		{ "_arrow_Buffer__size", (DL_FUNC) &_arrow_Buffer__size, 1}, 
		{ "_arrow_r___RBuffer__initialize", (DL_FUNC) &_arrow_r___RBuffer__initialize, 1}, 
		{ "_arrow_Buffer__data", (DL_FUNC) &_arrow_Buffer__data, 1}, 
		{ "_arrow_Buffer__Equals", (DL_FUNC) &_arrow_Buffer__Equals, 2}, 
		{ "_arrow_ChunkedArray__length", (DL_FUNC) &_arrow_ChunkedArray__length, 1}, 
		{ "_arrow_ChunkedArray__null_count", (DL_FUNC) &_arrow_ChunkedArray__null_count, 1}, 
		{ "_arrow_ChunkedArray__num_chunks", (DL_FUNC) &_arrow_ChunkedArray__num_chunks, 1}, 
		{ "_arrow_ChunkedArray__chunk", (DL_FUNC) &_arrow_ChunkedArray__chunk, 2}, 
		{ "_arrow_ChunkedArray__chunks", (DL_FUNC) &_arrow_ChunkedArray__chunks, 1}, 
		{ "_arrow_ChunkedArray__type", (DL_FUNC) &_arrow_ChunkedArray__type, 1}, 
		{ "_arrow_ChunkedArray__Slice1", (DL_FUNC) &_arrow_ChunkedArray__Slice1, 2}, 
		{ "_arrow_ChunkedArray__Slice2", (DL_FUNC) &_arrow_ChunkedArray__Slice2, 3}, 
		{ "_arrow_ChunkedArray__View", (DL_FUNC) &_arrow_ChunkedArray__View, 2}, 
		{ "_arrow_ChunkedArray__Validate", (DL_FUNC) &_arrow_ChunkedArray__Validate, 1}, 
		{ "_arrow_ChunkedArray__Equals", (DL_FUNC) &_arrow_ChunkedArray__Equals, 2}, 
		{ "_arrow_ChunkedArray__ToString", (DL_FUNC) &_arrow_ChunkedArray__ToString, 1}, 
		{ "_arrow_ChunkedArray__from_list", (DL_FUNC) &_arrow_ChunkedArray__from_list, 2}, 
		{ "_arrow_ChunkedArray__ReferencedBufferSize", (DL_FUNC) &_arrow_ChunkedArray__ReferencedBufferSize, 1}, 
		{ "_arrow_util___Codec__Create", (DL_FUNC) &_arrow_util___Codec__Create, 2}, 
		{ "_arrow_util___Codec__name", (DL_FUNC) &_arrow_util___Codec__name, 1}, 
		{ "_arrow_util___Codec__IsAvailable", (DL_FUNC) &_arrow_util___Codec__IsAvailable, 1}, 
		{ "_arrow_io___CompressedOutputStream__Make", (DL_FUNC) &_arrow_io___CompressedOutputStream__Make, 2}, 
		{ "_arrow_io___CompressedInputStream__Make", (DL_FUNC) &_arrow_io___CompressedInputStream__Make, 2}, 
		{ "_arrow_ExecPlan_create", (DL_FUNC) &_arrow_ExecPlan_create, 1}, 
		{ "_arrow_ExecPlanReader__batches", (DL_FUNC) &_arrow_ExecPlanReader__batches, 1}, 
		{ "_arrow_Table__from_ExecPlanReader", (DL_FUNC) &_arrow_Table__from_ExecPlanReader, 1}, 
		{ "_arrow_ExecPlanReader__Plan", (DL_FUNC) &_arrow_ExecPlanReader__Plan, 1}, 
		{ "_arrow_ExecPlanReader__PlanStatus", (DL_FUNC) &_arrow_ExecPlanReader__PlanStatus, 1}, 
		{ "_arrow_ExecPlan_run", (DL_FUNC) &_arrow_ExecPlan_run, 5}, 
		{ "_arrow_ExecPlan_ToString", (DL_FUNC) &_arrow_ExecPlan_ToString, 1}, 
		{ "_arrow_ExecPlan_UnsafeDelete", (DL_FUNC) &_arrow_ExecPlan_UnsafeDelete, 1}, 
		{ "_arrow_ExecNode_output_schema", (DL_FUNC) &_arrow_ExecNode_output_schema, 1}, 
		{ "_arrow_ExecNode_Scan", (DL_FUNC) &_arrow_ExecNode_Scan, 4}, 
		{ "_arrow_ExecPlan_Write", (DL_FUNC) &_arrow_ExecPlan_Write, 14}, 
		{ "_arrow_ExecNode_Filter", (DL_FUNC) &_arrow_ExecNode_Filter, 2}, 
		{ "_arrow_ExecNode_Project", (DL_FUNC) &_arrow_ExecNode_Project, 3}, 
		{ "_arrow_ExecNode_Aggregate", (DL_FUNC) &_arrow_ExecNode_Aggregate, 3}, 
		{ "_arrow_ExecNode_Join", (DL_FUNC) &_arrow_ExecNode_Join, 9}, 
		{ "_arrow_ExecNode_Union", (DL_FUNC) &_arrow_ExecNode_Union, 2}, 
		{ "_arrow_ExecNode_SourceNode", (DL_FUNC) &_arrow_ExecNode_SourceNode, 2}, 
		{ "_arrow_ExecNode_TableSourceNode", (DL_FUNC) &_arrow_ExecNode_TableSourceNode, 2}, 
		{ "_arrow_substrait__internal__SubstraitToJSON", (DL_FUNC) &_arrow_substrait__internal__SubstraitToJSON, 1}, 
		{ "_arrow_substrait__internal__SubstraitFromJSON", (DL_FUNC) &_arrow_substrait__internal__SubstraitFromJSON, 1}, 
		{ "_arrow_ExecPlan_run_substrait", (DL_FUNC) &_arrow_ExecPlan_run_substrait, 2}, 
		{ "_arrow_RecordBatch__cast", (DL_FUNC) &_arrow_RecordBatch__cast, 3}, 
		{ "_arrow_Table__cast", (DL_FUNC) &_arrow_Table__cast, 3}, 
		{ "_arrow_compute__CallFunction", (DL_FUNC) &_arrow_compute__CallFunction, 3}, 
		{ "_arrow_compute__GetFunctionNames", (DL_FUNC) &_arrow_compute__GetFunctionNames, 0}, 
		{ "_arrow_RegisterScalarUDF", (DL_FUNC) &_arrow_RegisterScalarUDF, 2}, 
		{ "_arrow_build_info", (DL_FUNC) &_arrow_build_info, 0}, 
		{ "_arrow_runtime_info", (DL_FUNC) &_arrow_runtime_info, 0}, 
		{ "_arrow_set_timezone_database", (DL_FUNC) &_arrow_set_timezone_database, 1}, 
		{ "_arrow_csv___WriteOptions__initialize", (DL_FUNC) &_arrow_csv___WriteOptions__initialize, 1}, 
		{ "_arrow_csv___ReadOptions__initialize", (DL_FUNC) &_arrow_csv___ReadOptions__initialize, 1}, 
		{ "_arrow_csv___ParseOptions__initialize", (DL_FUNC) &_arrow_csv___ParseOptions__initialize, 1}, 
		{ "_arrow_csv___ReadOptions__column_names", (DL_FUNC) &_arrow_csv___ReadOptions__column_names, 1}, 
		{ "_arrow_csv___ConvertOptions__initialize", (DL_FUNC) &_arrow_csv___ConvertOptions__initialize, 1}, 
		{ "_arrow_csv___TableReader__Make", (DL_FUNC) &_arrow_csv___TableReader__Make, 4}, 
		{ "_arrow_csv___TableReader__Read", (DL_FUNC) &_arrow_csv___TableReader__Read, 1}, 
		{ "_arrow_TimestampParser__kind", (DL_FUNC) &_arrow_TimestampParser__kind, 1}, 
		{ "_arrow_TimestampParser__format", (DL_FUNC) &_arrow_TimestampParser__format, 1}, 
		{ "_arrow_TimestampParser__MakeStrptime", (DL_FUNC) &_arrow_TimestampParser__MakeStrptime, 1}, 
		{ "_arrow_TimestampParser__MakeISO8601", (DL_FUNC) &_arrow_TimestampParser__MakeISO8601, 0}, 
		{ "_arrow_csv___WriteCSV__Table", (DL_FUNC) &_arrow_csv___WriteCSV__Table, 3}, 
		{ "_arrow_csv___WriteCSV__RecordBatch", (DL_FUNC) &_arrow_csv___WriteCSV__RecordBatch, 3}, 
		{ "_arrow_csv___WriteCSV__RecordBatchReader", (DL_FUNC) &_arrow_csv___WriteCSV__RecordBatchReader, 3}, 
		{ "_arrow_dataset___Dataset__NewScan", (DL_FUNC) &_arrow_dataset___Dataset__NewScan, 1}, 
		{ "_arrow_dataset___Dataset__schema", (DL_FUNC) &_arrow_dataset___Dataset__schema, 1}, 
		{ "_arrow_dataset___Dataset__type_name", (DL_FUNC) &_arrow_dataset___Dataset__type_name, 1}, 
		{ "_arrow_dataset___Dataset__ReplaceSchema", (DL_FUNC) &_arrow_dataset___Dataset__ReplaceSchema, 2}, 
		{ "_arrow_dataset___UnionDataset__create", (DL_FUNC) &_arrow_dataset___UnionDataset__create, 2}, 
		{ "_arrow_dataset___InMemoryDataset__create", (DL_FUNC) &_arrow_dataset___InMemoryDataset__create, 1}, 
		{ "_arrow_dataset___UnionDataset__children", (DL_FUNC) &_arrow_dataset___UnionDataset__children, 1}, 
		{ "_arrow_dataset___FileSystemDataset__format", (DL_FUNC) &_arrow_dataset___FileSystemDataset__format, 1}, 
		{ "_arrow_dataset___FileSystemDataset__filesystem", (DL_FUNC) &_arrow_dataset___FileSystemDataset__filesystem, 1}, 
		{ "_arrow_dataset___FileSystemDataset__files", (DL_FUNC) &_arrow_dataset___FileSystemDataset__files, 1}, 
		{ "_arrow_dataset___DatasetFactory__Finish1", (DL_FUNC) &_arrow_dataset___DatasetFactory__Finish1, 2}, 
		{ "_arrow_dataset___DatasetFactory__Finish2", (DL_FUNC) &_arrow_dataset___DatasetFactory__Finish2, 2}, 
		{ "_arrow_dataset___DatasetFactory__Inspect", (DL_FUNC) &_arrow_dataset___DatasetFactory__Inspect, 2}, 
		{ "_arrow_dataset___UnionDatasetFactory__Make", (DL_FUNC) &_arrow_dataset___UnionDatasetFactory__Make, 1}, 
		{ "_arrow_dataset___FileSystemDatasetFactory__Make", (DL_FUNC) &_arrow_dataset___FileSystemDatasetFactory__Make, 4}, 
		{ "_arrow_dataset___FileSystemDatasetFactory__MakePaths", (DL_FUNC) &_arrow_dataset___FileSystemDatasetFactory__MakePaths, 4}, 
		{ "_arrow_dataset___FileFormat__type_name", (DL_FUNC) &_arrow_dataset___FileFormat__type_name, 1}, 
		{ "_arrow_dataset___FileFormat__DefaultWriteOptions", (DL_FUNC) &_arrow_dataset___FileFormat__DefaultWriteOptions, 1}, 
		{ "_arrow_dataset___ParquetFileFormat__Make", (DL_FUNC) &_arrow_dataset___ParquetFileFormat__Make, 2}, 
		{ "_arrow_dataset___FileWriteOptions__type_name", (DL_FUNC) &_arrow_dataset___FileWriteOptions__type_name, 1}, 
		{ "_arrow_dataset___ParquetFileWriteOptions__update", (DL_FUNC) &_arrow_dataset___ParquetFileWriteOptions__update, 3}, 
		{ "_arrow_dataset___IpcFileWriteOptions__update2", (DL_FUNC) &_arrow_dataset___IpcFileWriteOptions__update2, 4}, 
		{ "_arrow_dataset___IpcFileWriteOptions__update1", (DL_FUNC) &_arrow_dataset___IpcFileWriteOptions__update1, 3}, 
		{ "_arrow_dataset___CsvFileWriteOptions__update", (DL_FUNC) &_arrow_dataset___CsvFileWriteOptions__update, 2}, 
		{ "_arrow_dataset___IpcFileFormat__Make", (DL_FUNC) &_arrow_dataset___IpcFileFormat__Make, 0}, 
		{ "_arrow_dataset___CsvFileFormat__Make", (DL_FUNC) &_arrow_dataset___CsvFileFormat__Make, 3}, 
		{ "_arrow_dataset___FragmentScanOptions__type_name", (DL_FUNC) &_arrow_dataset___FragmentScanOptions__type_name, 1}, 
		{ "_arrow_dataset___CsvFragmentScanOptions__Make", (DL_FUNC) &_arrow_dataset___CsvFragmentScanOptions__Make, 2}, 
		{ "_arrow_dataset___ParquetFragmentScanOptions__Make", (DL_FUNC) &_arrow_dataset___ParquetFragmentScanOptions__Make, 3}, 
		{ "_arrow_dataset___DirectoryPartitioning", (DL_FUNC) &_arrow_dataset___DirectoryPartitioning, 2}, 
		{ "_arrow_dataset___DirectoryPartitioning__MakeFactory", (DL_FUNC) &_arrow_dataset___DirectoryPartitioning__MakeFactory, 2}, 
		{ "_arrow_dataset___HivePartitioning", (DL_FUNC) &_arrow_dataset___HivePartitioning, 3}, 
		{ "_arrow_dataset___HivePartitioning__MakeFactory", (DL_FUNC) &_arrow_dataset___HivePartitioning__MakeFactory, 2}, 
		{ "_arrow_dataset___PartitioningFactory__Inspect", (DL_FUNC) &_arrow_dataset___PartitioningFactory__Inspect, 2}, 
		{ "_arrow_dataset___PartitioningFactory__Finish", (DL_FUNC) &_arrow_dataset___PartitioningFactory__Finish, 2}, 
		{ "_arrow_dataset___PartitioningFactory__type_name", (DL_FUNC) &_arrow_dataset___PartitioningFactory__type_name, 1}, 
		{ "_arrow_dataset___ScannerBuilder__ProjectNames", (DL_FUNC) &_arrow_dataset___ScannerBuilder__ProjectNames, 2}, 
		{ "_arrow_dataset___ScannerBuilder__ProjectExprs", (DL_FUNC) &_arrow_dataset___ScannerBuilder__ProjectExprs, 3}, 
		{ "_arrow_dataset___ScannerBuilder__Filter", (DL_FUNC) &_arrow_dataset___ScannerBuilder__Filter, 2}, 
		{ "_arrow_dataset___ScannerBuilder__UseThreads", (DL_FUNC) &_arrow_dataset___ScannerBuilder__UseThreads, 2}, 
		{ "_arrow_dataset___ScannerBuilder__BatchSize", (DL_FUNC) &_arrow_dataset___ScannerBuilder__BatchSize, 2}, 
		{ "_arrow_dataset___ScannerBuilder__FragmentScanOptions", (DL_FUNC) &_arrow_dataset___ScannerBuilder__FragmentScanOptions, 2}, 
		{ "_arrow_dataset___ScannerBuilder__schema", (DL_FUNC) &_arrow_dataset___ScannerBuilder__schema, 1}, 
		{ "_arrow_dataset___ScannerBuilder__Finish", (DL_FUNC) &_arrow_dataset___ScannerBuilder__Finish, 1}, 
		{ "_arrow_dataset___ScannerBuilder__FromRecordBatchReader", (DL_FUNC) &_arrow_dataset___ScannerBuilder__FromRecordBatchReader, 1}, 
		{ "_arrow_dataset___Scanner__ToTable", (DL_FUNC) &_arrow_dataset___Scanner__ToTable, 1}, 
		{ "_arrow_dataset___Scanner__ScanBatches", (DL_FUNC) &_arrow_dataset___Scanner__ScanBatches, 1}, 
		{ "_arrow_dataset___Scanner__ToRecordBatchReader", (DL_FUNC) &_arrow_dataset___Scanner__ToRecordBatchReader, 1}, 
		{ "_arrow_dataset___Scanner__head", (DL_FUNC) &_arrow_dataset___Scanner__head, 2}, 
		{ "_arrow_dataset___Scanner__schema", (DL_FUNC) &_arrow_dataset___Scanner__schema, 1}, 
		{ "_arrow_dataset___Scanner__TakeRows", (DL_FUNC) &_arrow_dataset___Scanner__TakeRows, 2}, 
		{ "_arrow_dataset___Scanner__CountRows", (DL_FUNC) &_arrow_dataset___Scanner__CountRows, 1}, 
		{ "_arrow_Int8__initialize", (DL_FUNC) &_arrow_Int8__initialize, 0}, 
		{ "_arrow_Int16__initialize", (DL_FUNC) &_arrow_Int16__initialize, 0}, 
		{ "_arrow_Int32__initialize", (DL_FUNC) &_arrow_Int32__initialize, 0}, 
		{ "_arrow_Int64__initialize", (DL_FUNC) &_arrow_Int64__initialize, 0}, 
		{ "_arrow_UInt8__initialize", (DL_FUNC) &_arrow_UInt8__initialize, 0}, 
		{ "_arrow_UInt16__initialize", (DL_FUNC) &_arrow_UInt16__initialize, 0}, 
		{ "_arrow_UInt32__initialize", (DL_FUNC) &_arrow_UInt32__initialize, 0}, 
		{ "_arrow_UInt64__initialize", (DL_FUNC) &_arrow_UInt64__initialize, 0}, 
		{ "_arrow_Float16__initialize", (DL_FUNC) &_arrow_Float16__initialize, 0}, 
		{ "_arrow_Float32__initialize", (DL_FUNC) &_arrow_Float32__initialize, 0}, 
		{ "_arrow_Float64__initialize", (DL_FUNC) &_arrow_Float64__initialize, 0}, 
		{ "_arrow_Boolean__initialize", (DL_FUNC) &_arrow_Boolean__initialize, 0}, 
		{ "_arrow_Utf8__initialize", (DL_FUNC) &_arrow_Utf8__initialize, 0}, 
		{ "_arrow_LargeUtf8__initialize", (DL_FUNC) &_arrow_LargeUtf8__initialize, 0}, 
		{ "_arrow_Binary__initialize", (DL_FUNC) &_arrow_Binary__initialize, 0}, 
		{ "_arrow_LargeBinary__initialize", (DL_FUNC) &_arrow_LargeBinary__initialize, 0}, 
		{ "_arrow_Date32__initialize", (DL_FUNC) &_arrow_Date32__initialize, 0}, 
		{ "_arrow_Date64__initialize", (DL_FUNC) &_arrow_Date64__initialize, 0}, 
		{ "_arrow_Null__initialize", (DL_FUNC) &_arrow_Null__initialize, 0}, 
		{ "_arrow_Decimal128Type__initialize", (DL_FUNC) &_arrow_Decimal128Type__initialize, 2}, 
		{ "_arrow_Decimal256Type__initialize", (DL_FUNC) &_arrow_Decimal256Type__initialize, 2}, 
		{ "_arrow_DayTimeInterval__initialize", (DL_FUNC) &_arrow_DayTimeInterval__initialize, 0}, 
		{ "_arrow_FixedSizeBinary__initialize", (DL_FUNC) &_arrow_FixedSizeBinary__initialize, 1}, 
		{ "_arrow_FixedSizeBinary__byte_width", (DL_FUNC) &_arrow_FixedSizeBinary__byte_width, 1}, 
		{ "_arrow_Timestamp__initialize", (DL_FUNC) &_arrow_Timestamp__initialize, 2}, 
		{ "_arrow_Time32__initialize", (DL_FUNC) &_arrow_Time32__initialize, 1}, 
		{ "_arrow_Time64__initialize", (DL_FUNC) &_arrow_Time64__initialize, 1}, 
		{ "_arrow_Duration__initialize", (DL_FUNC) &_arrow_Duration__initialize, 1}, 
		{ "_arrow_list__", (DL_FUNC) &_arrow_list__, 1}, 
		{ "_arrow_large_list__", (DL_FUNC) &_arrow_large_list__, 1}, 
		{ "_arrow_fixed_size_list__", (DL_FUNC) &_arrow_fixed_size_list__, 2}, 
		{ "_arrow_map__", (DL_FUNC) &_arrow_map__, 3}, 
		{ "_arrow_struct__", (DL_FUNC) &_arrow_struct__, 1}, 
		{ "_arrow_DataType__ToString", (DL_FUNC) &_arrow_DataType__ToString, 1}, 
		{ "_arrow_DataType__name", (DL_FUNC) &_arrow_DataType__name, 1}, 
		{ "_arrow_DataType__Equals", (DL_FUNC) &_arrow_DataType__Equals, 3}, 
		{ "_arrow_DataType__num_fields", (DL_FUNC) &_arrow_DataType__num_fields, 1}, 
		{ "_arrow_DataType__fields", (DL_FUNC) &_arrow_DataType__fields, 1}, 
		{ "_arrow_DataType__id", (DL_FUNC) &_arrow_DataType__id, 1}, 
		{ "_arrow_ListType__ToString", (DL_FUNC) &_arrow_ListType__ToString, 1}, 
		{ "_arrow_FixedWidthType__bit_width", (DL_FUNC) &_arrow_FixedWidthType__bit_width, 1}, 
		{ "_arrow_DateType__unit", (DL_FUNC) &_arrow_DateType__unit, 1}, 
		{ "_arrow_TimeType__unit", (DL_FUNC) &_arrow_TimeType__unit, 1}, 
		{ "_arrow_DurationType__unit", (DL_FUNC) &_arrow_DurationType__unit, 1}, 
		{ "_arrow_DecimalType__precision", (DL_FUNC) &_arrow_DecimalType__precision, 1}, 
		{ "_arrow_DecimalType__scale", (DL_FUNC) &_arrow_DecimalType__scale, 1}, 
		{ "_arrow_TimestampType__timezone", (DL_FUNC) &_arrow_TimestampType__timezone, 1}, 
		{ "_arrow_TimestampType__unit", (DL_FUNC) &_arrow_TimestampType__unit, 1}, 
		{ "_arrow_DictionaryType__initialize", (DL_FUNC) &_arrow_DictionaryType__initialize, 3}, 
		{ "_arrow_DictionaryType__index_type", (DL_FUNC) &_arrow_DictionaryType__index_type, 1}, 
		{ "_arrow_DictionaryType__value_type", (DL_FUNC) &_arrow_DictionaryType__value_type, 1}, 
		{ "_arrow_DictionaryType__name", (DL_FUNC) &_arrow_DictionaryType__name, 1}, 
		{ "_arrow_DictionaryType__ordered", (DL_FUNC) &_arrow_DictionaryType__ordered, 1}, 
		{ "_arrow_StructType__GetFieldByName", (DL_FUNC) &_arrow_StructType__GetFieldByName, 2}, 
		{ "_arrow_StructType__GetFieldIndex", (DL_FUNC) &_arrow_StructType__GetFieldIndex, 2}, 
		{ "_arrow_StructType__field_names", (DL_FUNC) &_arrow_StructType__field_names, 1}, 
		{ "_arrow_ListType__value_field", (DL_FUNC) &_arrow_ListType__value_field, 1}, 
		{ "_arrow_ListType__value_type", (DL_FUNC) &_arrow_ListType__value_type, 1}, 
		{ "_arrow_LargeListType__value_field", (DL_FUNC) &_arrow_LargeListType__value_field, 1}, 
		{ "_arrow_LargeListType__value_type", (DL_FUNC) &_arrow_LargeListType__value_type, 1}, 
		{ "_arrow_FixedSizeListType__value_field", (DL_FUNC) &_arrow_FixedSizeListType__value_field, 1}, 
		{ "_arrow_FixedSizeListType__value_type", (DL_FUNC) &_arrow_FixedSizeListType__value_type, 1}, 
		{ "_arrow_FixedSizeListType__list_size", (DL_FUNC) &_arrow_FixedSizeListType__list_size, 1}, 
		{ "_arrow_MapType__key_field", (DL_FUNC) &_arrow_MapType__key_field, 1}, 
		{ "_arrow_MapType__item_field", (DL_FUNC) &_arrow_MapType__item_field, 1}, 
		{ "_arrow_MapType__key_type", (DL_FUNC) &_arrow_MapType__key_type, 1}, 
		{ "_arrow_MapType__item_type", (DL_FUNC) &_arrow_MapType__item_type, 1}, 
		{ "_arrow_MapType__keys_sorted", (DL_FUNC) &_arrow_MapType__keys_sorted, 1}, 
		{ "_arrow_compute___expr__equals", (DL_FUNC) &_arrow_compute___expr__equals, 2}, 
		{ "_arrow_compute___expr__call", (DL_FUNC) &_arrow_compute___expr__call, 3}, 
		{ "_arrow_compute___expr__is_field_ref", (DL_FUNC) &_arrow_compute___expr__is_field_ref, 1}, 
		{ "_arrow_compute___expr__get_field_ref_name", (DL_FUNC) &_arrow_compute___expr__get_field_ref_name, 1}, 
		{ "_arrow_compute___expr__field_ref", (DL_FUNC) &_arrow_compute___expr__field_ref, 1}, 
		{ "_arrow_compute___expr__nested_field_ref", (DL_FUNC) &_arrow_compute___expr__nested_field_ref, 2}, 
		{ "_arrow_compute___expr__scalar", (DL_FUNC) &_arrow_compute___expr__scalar, 1}, 
		{ "_arrow_compute___expr__ToString", (DL_FUNC) &_arrow_compute___expr__ToString, 1}, 
		{ "_arrow_compute___expr__type", (DL_FUNC) &_arrow_compute___expr__type, 2}, 
		{ "_arrow_compute___expr__type_id", (DL_FUNC) &_arrow_compute___expr__type_id, 2}, 
		{ "_arrow_ExtensionType__initialize", (DL_FUNC) &_arrow_ExtensionType__initialize, 4}, 
		{ "_arrow_ExtensionType__extension_name", (DL_FUNC) &_arrow_ExtensionType__extension_name, 1}, 
		{ "_arrow_ExtensionType__Serialize", (DL_FUNC) &_arrow_ExtensionType__Serialize, 1}, 
		{ "_arrow_ExtensionType__storage_type", (DL_FUNC) &_arrow_ExtensionType__storage_type, 1}, 
		{ "_arrow_ExtensionType__MakeArray", (DL_FUNC) &_arrow_ExtensionType__MakeArray, 2}, 
		{ "_arrow_ExtensionType__r6_class", (DL_FUNC) &_arrow_ExtensionType__r6_class, 1}, 
		{ "_arrow_ExtensionArray__storage", (DL_FUNC) &_arrow_ExtensionArray__storage, 1}, 
		{ "_arrow_arrow__RegisterRExtensionType", (DL_FUNC) &_arrow_arrow__RegisterRExtensionType, 1}, 
		{ "_arrow_arrow__UnregisterRExtensionType", (DL_FUNC) &_arrow_arrow__UnregisterRExtensionType, 1}, 
		{ "_arrow_ipc___WriteFeather__Table", (DL_FUNC) &_arrow_ipc___WriteFeather__Table, 6}, 
		{ "_arrow_ipc___feather___Reader__version", (DL_FUNC) &_arrow_ipc___feather___Reader__version, 1}, 
		{ "_arrow_ipc___feather___Reader__Read", (DL_FUNC) &_arrow_ipc___feather___Reader__Read, 2}, 
		{ "_arrow_ipc___feather___Reader__Open", (DL_FUNC) &_arrow_ipc___feather___Reader__Open, 1}, 
		{ "_arrow_ipc___feather___Reader__schema", (DL_FUNC) &_arrow_ipc___feather___Reader__schema, 1}, 
		{ "_arrow_Field__initialize", (DL_FUNC) &_arrow_Field__initialize, 3}, 
		{ "_arrow_Field__ToString", (DL_FUNC) &_arrow_Field__ToString, 1}, 
		{ "_arrow_Field__name", (DL_FUNC) &_arrow_Field__name, 1}, 
		{ "_arrow_Field__Equals", (DL_FUNC) &_arrow_Field__Equals, 2}, 
		{ "_arrow_Field__nullable", (DL_FUNC) &_arrow_Field__nullable, 1}, 
		{ "_arrow_Field__type", (DL_FUNC) &_arrow_Field__type, 1}, 
		{ "_arrow_fs___FileInfo__type", (DL_FUNC) &_arrow_fs___FileInfo__type, 1}, 
		{ "_arrow_fs___FileInfo__set_type", (DL_FUNC) &_arrow_fs___FileInfo__set_type, 2}, 
		{ "_arrow_fs___FileInfo__path", (DL_FUNC) &_arrow_fs___FileInfo__path, 1}, 
		{ "_arrow_fs___FileInfo__set_path", (DL_FUNC) &_arrow_fs___FileInfo__set_path, 2}, 
		{ "_arrow_fs___FileInfo__size", (DL_FUNC) &_arrow_fs___FileInfo__size, 1}, 
		{ "_arrow_fs___FileInfo__set_size", (DL_FUNC) &_arrow_fs___FileInfo__set_size, 2}, 
		{ "_arrow_fs___FileInfo__base_name", (DL_FUNC) &_arrow_fs___FileInfo__base_name, 1}, 
		{ "_arrow_fs___FileInfo__extension", (DL_FUNC) &_arrow_fs___FileInfo__extension, 1}, 
		{ "_arrow_fs___FileInfo__mtime", (DL_FUNC) &_arrow_fs___FileInfo__mtime, 1}, 
		{ "_arrow_fs___FileInfo__set_mtime", (DL_FUNC) &_arrow_fs___FileInfo__set_mtime, 2}, 
		{ "_arrow_fs___FileSelector__base_dir", (DL_FUNC) &_arrow_fs___FileSelector__base_dir, 1}, 
		{ "_arrow_fs___FileSelector__allow_not_found", (DL_FUNC) &_arrow_fs___FileSelector__allow_not_found, 1}, 
		{ "_arrow_fs___FileSelector__recursive", (DL_FUNC) &_arrow_fs___FileSelector__recursive, 1}, 
		{ "_arrow_fs___FileSelector__create", (DL_FUNC) &_arrow_fs___FileSelector__create, 3}, 
		{ "_arrow_fs___FileSystem__GetTargetInfos_Paths", (DL_FUNC) &_arrow_fs___FileSystem__GetTargetInfos_Paths, 2}, 
		{ "_arrow_fs___FileSystem__GetTargetInfos_FileSelector", (DL_FUNC) &_arrow_fs___FileSystem__GetTargetInfos_FileSelector, 2}, 
		{ "_arrow_fs___FileSystem__CreateDir", (DL_FUNC) &_arrow_fs___FileSystem__CreateDir, 3}, 
		{ "_arrow_fs___FileSystem__DeleteDir", (DL_FUNC) &_arrow_fs___FileSystem__DeleteDir, 2}, 
		{ "_arrow_fs___FileSystem__DeleteDirContents", (DL_FUNC) &_arrow_fs___FileSystem__DeleteDirContents, 2}, 
		{ "_arrow_fs___FileSystem__DeleteFile", (DL_FUNC) &_arrow_fs___FileSystem__DeleteFile, 2}, 
		{ "_arrow_fs___FileSystem__DeleteFiles", (DL_FUNC) &_arrow_fs___FileSystem__DeleteFiles, 2}, 
		{ "_arrow_fs___FileSystem__Move", (DL_FUNC) &_arrow_fs___FileSystem__Move, 3}, 
		{ "_arrow_fs___FileSystem__CopyFile", (DL_FUNC) &_arrow_fs___FileSystem__CopyFile, 3}, 
		{ "_arrow_fs___FileSystem__OpenInputStream", (DL_FUNC) &_arrow_fs___FileSystem__OpenInputStream, 2}, 
		{ "_arrow_fs___FileSystem__OpenInputFile", (DL_FUNC) &_arrow_fs___FileSystem__OpenInputFile, 2}, 
		{ "_arrow_fs___FileSystem__OpenOutputStream", (DL_FUNC) &_arrow_fs___FileSystem__OpenOutputStream, 2}, 
		{ "_arrow_fs___FileSystem__OpenAppendStream", (DL_FUNC) &_arrow_fs___FileSystem__OpenAppendStream, 2}, 
		{ "_arrow_fs___FileSystem__type_name", (DL_FUNC) &_arrow_fs___FileSystem__type_name, 1}, 
		{ "_arrow_fs___LocalFileSystem__create", (DL_FUNC) &_arrow_fs___LocalFileSystem__create, 0}, 
		{ "_arrow_fs___SubTreeFileSystem__create", (DL_FUNC) &_arrow_fs___SubTreeFileSystem__create, 2}, 
		{ "_arrow_fs___SubTreeFileSystem__base_fs", (DL_FUNC) &_arrow_fs___SubTreeFileSystem__base_fs, 1}, 
		{ "_arrow_fs___SubTreeFileSystem__base_path", (DL_FUNC) &_arrow_fs___SubTreeFileSystem__base_path, 1}, 
		{ "_arrow_fs___FileSystemFromUri", (DL_FUNC) &_arrow_fs___FileSystemFromUri, 1}, 
		{ "_arrow_fs___CopyFiles", (DL_FUNC) &_arrow_fs___CopyFiles, 6}, 
		{ "_arrow_fs___S3FileSystem__create", (DL_FUNC) &_arrow_fs___S3FileSystem__create, 17}, 
		{ "_arrow_fs___S3FileSystem__region", (DL_FUNC) &_arrow_fs___S3FileSystem__region, 1}, 
		{ "_arrow_fs___GcsFileSystem__Make", (DL_FUNC) &_arrow_fs___GcsFileSystem__Make, 2}, 
		{ "_arrow_fs___GcsFileSystem__options", (DL_FUNC) &_arrow_fs___GcsFileSystem__options, 1}, 
		{ "_arrow_io___Readable__Read", (DL_FUNC) &_arrow_io___Readable__Read, 2}, 
		{ "_arrow_io___InputStream__Close", (DL_FUNC) &_arrow_io___InputStream__Close, 1}, 
		{ "_arrow_io___OutputStream__Close", (DL_FUNC) &_arrow_io___OutputStream__Close, 1}, 
		{ "_arrow_io___RandomAccessFile__GetSize", (DL_FUNC) &_arrow_io___RandomAccessFile__GetSize, 1}, 
		{ "_arrow_io___RandomAccessFile__supports_zero_copy", (DL_FUNC) &_arrow_io___RandomAccessFile__supports_zero_copy, 1}, 
		{ "_arrow_io___RandomAccessFile__Seek", (DL_FUNC) &_arrow_io___RandomAccessFile__Seek, 2}, 
		{ "_arrow_io___RandomAccessFile__Tell", (DL_FUNC) &_arrow_io___RandomAccessFile__Tell, 1}, 
		{ "_arrow_io___RandomAccessFile__Read0", (DL_FUNC) &_arrow_io___RandomAccessFile__Read0, 1}, 
		{ "_arrow_io___RandomAccessFile__ReadAt", (DL_FUNC) &_arrow_io___RandomAccessFile__ReadAt, 3}, 
		{ "_arrow_io___RandomAccessFile__ReadMetadata", (DL_FUNC) &_arrow_io___RandomAccessFile__ReadMetadata, 1}, 
		{ "_arrow_io___MemoryMappedFile__Create", (DL_FUNC) &_arrow_io___MemoryMappedFile__Create, 2}, 
		{ "_arrow_io___MemoryMappedFile__Open", (DL_FUNC) &_arrow_io___MemoryMappedFile__Open, 2}, 
		{ "_arrow_io___MemoryMappedFile__Resize", (DL_FUNC) &_arrow_io___MemoryMappedFile__Resize, 2}, 
		{ "_arrow_io___ReadableFile__Open", (DL_FUNC) &_arrow_io___ReadableFile__Open, 1}, 
		{ "_arrow_io___BufferReader__initialize", (DL_FUNC) &_arrow_io___BufferReader__initialize, 1}, 
		{ "_arrow_io___Writable__write", (DL_FUNC) &_arrow_io___Writable__write, 2}, 
		{ "_arrow_io___OutputStream__Tell", (DL_FUNC) &_arrow_io___OutputStream__Tell, 1}, 
		{ "_arrow_io___FileOutputStream__Open", (DL_FUNC) &_arrow_io___FileOutputStream__Open, 1}, 
		{ "_arrow_io___BufferOutputStream__Create", (DL_FUNC) &_arrow_io___BufferOutputStream__Create, 1}, 
		{ "_arrow_io___BufferOutputStream__capacity", (DL_FUNC) &_arrow_io___BufferOutputStream__capacity, 1}, 
		{ "_arrow_io___BufferOutputStream__Finish", (DL_FUNC) &_arrow_io___BufferOutputStream__Finish, 1}, 
		{ "_arrow_io___BufferOutputStream__Tell", (DL_FUNC) &_arrow_io___BufferOutputStream__Tell, 1}, 
		{ "_arrow_io___BufferOutputStream__Write", (DL_FUNC) &_arrow_io___BufferOutputStream__Write, 2}, 
		{ "_arrow_MakeRConnectionInputStream", (DL_FUNC) &_arrow_MakeRConnectionInputStream, 1}, 
		{ "_arrow_MakeRConnectionOutputStream", (DL_FUNC) &_arrow_MakeRConnectionOutputStream, 1}, 
		{ "_arrow_MakeRConnectionRandomAccessFile", (DL_FUNC) &_arrow_MakeRConnectionRandomAccessFile, 1}, 
		{ "_arrow_MakeReencodeInputStream", (DL_FUNC) &_arrow_MakeReencodeInputStream, 2}, 
		{ "_arrow_json___ReadOptions__initialize", (DL_FUNC) &_arrow_json___ReadOptions__initialize, 2}, 
		{ "_arrow_json___ParseOptions__initialize1", (DL_FUNC) &_arrow_json___ParseOptions__initialize1, 1}, 
		{ "_arrow_json___ParseOptions__initialize2", (DL_FUNC) &_arrow_json___ParseOptions__initialize2, 2}, 
		{ "_arrow_json___TableReader__Make", (DL_FUNC) &_arrow_json___TableReader__Make, 3}, 
		{ "_arrow_json___TableReader__Read", (DL_FUNC) &_arrow_json___TableReader__Read, 1}, 
		{ "_arrow_MemoryPool__default", (DL_FUNC) &_arrow_MemoryPool__default, 0}, 
		{ "_arrow_MemoryPool__bytes_allocated", (DL_FUNC) &_arrow_MemoryPool__bytes_allocated, 1}, 
		{ "_arrow_MemoryPool__max_memory", (DL_FUNC) &_arrow_MemoryPool__max_memory, 1}, 
		{ "_arrow_MemoryPool__backend_name", (DL_FUNC) &_arrow_MemoryPool__backend_name, 1}, 
		{ "_arrow_supported_memory_backends", (DL_FUNC) &_arrow_supported_memory_backends, 0}, 
		{ "_arrow_ipc___Message__body_length", (DL_FUNC) &_arrow_ipc___Message__body_length, 1}, 
		{ "_arrow_ipc___Message__metadata", (DL_FUNC) &_arrow_ipc___Message__metadata, 1}, 
		{ "_arrow_ipc___Message__body", (DL_FUNC) &_arrow_ipc___Message__body, 1}, 
		{ "_arrow_ipc___Message__Verify", (DL_FUNC) &_arrow_ipc___Message__Verify, 1}, 
		{ "_arrow_ipc___Message__type", (DL_FUNC) &_arrow_ipc___Message__type, 1}, 
		{ "_arrow_ipc___Message__Equals", (DL_FUNC) &_arrow_ipc___Message__Equals, 2}, 
		{ "_arrow_ipc___ReadRecordBatch__Message__Schema", (DL_FUNC) &_arrow_ipc___ReadRecordBatch__Message__Schema, 2}, 
		{ "_arrow_ipc___ReadSchema_InputStream", (DL_FUNC) &_arrow_ipc___ReadSchema_InputStream, 1}, 
		{ "_arrow_ipc___ReadSchema_Message", (DL_FUNC) &_arrow_ipc___ReadSchema_Message, 1}, 
		{ "_arrow_ipc___MessageReader__Open", (DL_FUNC) &_arrow_ipc___MessageReader__Open, 1}, 
		{ "_arrow_ipc___MessageReader__ReadNextMessage", (DL_FUNC) &_arrow_ipc___MessageReader__ReadNextMessage, 1}, 
		{ "_arrow_ipc___ReadMessage", (DL_FUNC) &_arrow_ipc___ReadMessage, 1}, 
		{ "_arrow_parquet___arrow___ArrowReaderProperties__Make", (DL_FUNC) &_arrow_parquet___arrow___ArrowReaderProperties__Make, 1}, 
		{ "_arrow_parquet___arrow___ArrowReaderProperties__set_use_threads", (DL_FUNC) &_arrow_parquet___arrow___ArrowReaderProperties__set_use_threads, 2}, 
		{ "_arrow_parquet___arrow___ArrowReaderProperties__get_use_threads", (DL_FUNC) &_arrow_parquet___arrow___ArrowReaderProperties__get_use_threads, 2}, 
		{ "_arrow_parquet___arrow___ArrowReaderProperties__get_read_dictionary", (DL_FUNC) &_arrow_parquet___arrow___ArrowReaderProperties__get_read_dictionary, 2}, 
		{ "_arrow_parquet___arrow___ArrowReaderProperties__set_read_dictionary", (DL_FUNC) &_arrow_parquet___arrow___ArrowReaderProperties__set_read_dictionary, 3}, 
		{ "_arrow_parquet___arrow___ArrowReaderProperties__set_coerce_int96_timestamp_unit", (DL_FUNC) &_arrow_parquet___arrow___ArrowReaderProperties__set_coerce_int96_timestamp_unit, 2}, 
		{ "_arrow_parquet___arrow___ArrowReaderProperties__get_coerce_int96_timestamp_unit", (DL_FUNC) &_arrow_parquet___arrow___ArrowReaderProperties__get_coerce_int96_timestamp_unit, 1}, 
		{ "_arrow_parquet___arrow___FileReader__OpenFile", (DL_FUNC) &_arrow_parquet___arrow___FileReader__OpenFile, 2}, 
		{ "_arrow_parquet___arrow___FileReader__ReadTable1", (DL_FUNC) &_arrow_parquet___arrow___FileReader__ReadTable1, 1}, 
		{ "_arrow_parquet___arrow___FileReader__ReadTable2", (DL_FUNC) &_arrow_parquet___arrow___FileReader__ReadTable2, 2}, 
		{ "_arrow_parquet___arrow___FileReader__ReadRowGroup1", (DL_FUNC) &_arrow_parquet___arrow___FileReader__ReadRowGroup1, 2}, 
		{ "_arrow_parquet___arrow___FileReader__ReadRowGroup2", (DL_FUNC) &_arrow_parquet___arrow___FileReader__ReadRowGroup2, 3}, 
		{ "_arrow_parquet___arrow___FileReader__ReadRowGroups1", (DL_FUNC) &_arrow_parquet___arrow___FileReader__ReadRowGroups1, 2}, 
		{ "_arrow_parquet___arrow___FileReader__ReadRowGroups2", (DL_FUNC) &_arrow_parquet___arrow___FileReader__ReadRowGroups2, 3}, 
		{ "_arrow_parquet___arrow___FileReader__num_rows", (DL_FUNC) &_arrow_parquet___arrow___FileReader__num_rows, 1}, 
		{ "_arrow_parquet___arrow___FileReader__num_columns", (DL_FUNC) &_arrow_parquet___arrow___FileReader__num_columns, 1}, 
		{ "_arrow_parquet___arrow___FileReader__num_row_groups", (DL_FUNC) &_arrow_parquet___arrow___FileReader__num_row_groups, 1}, 
		{ "_arrow_parquet___arrow___FileReader__ReadColumn", (DL_FUNC) &_arrow_parquet___arrow___FileReader__ReadColumn, 2}, 
		{ "_arrow_parquet___ArrowWriterProperties___create", (DL_FUNC) &_arrow_parquet___ArrowWriterProperties___create, 3}, 
		{ "_arrow_parquet___WriterProperties___Builder__create", (DL_FUNC) &_arrow_parquet___WriterProperties___Builder__create, 0}, 
		{ "_arrow_parquet___WriterProperties___Builder__version", (DL_FUNC) &_arrow_parquet___WriterProperties___Builder__version, 2}, 
		{ "_arrow_parquet___ArrowWriterProperties___Builder__set_compressions", (DL_FUNC) &_arrow_parquet___ArrowWriterProperties___Builder__set_compressions, 3}, 
		{ "_arrow_parquet___ArrowWriterProperties___Builder__set_compression_levels", (DL_FUNC) &_arrow_parquet___ArrowWriterProperties___Builder__set_compression_levels, 3}, 
		{ "_arrow_parquet___ArrowWriterProperties___Builder__set_use_dictionary", (DL_FUNC) &_arrow_parquet___ArrowWriterProperties___Builder__set_use_dictionary, 3}, 
		{ "_arrow_parquet___ArrowWriterProperties___Builder__set_write_statistics", (DL_FUNC) &_arrow_parquet___ArrowWriterProperties___Builder__set_write_statistics, 3}, 
		{ "_arrow_parquet___ArrowWriterProperties___Builder__data_page_size", (DL_FUNC) &_arrow_parquet___ArrowWriterProperties___Builder__data_page_size, 2}, 
		{ "_arrow_parquet___WriterProperties___Builder__build", (DL_FUNC) &_arrow_parquet___WriterProperties___Builder__build, 1}, 
		{ "_arrow_parquet___arrow___ParquetFileWriter__Open", (DL_FUNC) &_arrow_parquet___arrow___ParquetFileWriter__Open, 4}, 
		{ "_arrow_parquet___arrow___FileWriter__WriteTable", (DL_FUNC) &_arrow_parquet___arrow___FileWriter__WriteTable, 3}, 
		{ "_arrow_parquet___arrow___FileWriter__Close", (DL_FUNC) &_arrow_parquet___arrow___FileWriter__Close, 1}, 
		{ "_arrow_parquet___arrow___WriteTable", (DL_FUNC) &_arrow_parquet___arrow___WriteTable, 4}, 
		{ "_arrow_parquet___arrow___FileReader__GetSchema", (DL_FUNC) &_arrow_parquet___arrow___FileReader__GetSchema, 1}, 
		{ "_arrow_Table__from_dots", (DL_FUNC) &_arrow_Table__from_dots, 3}, 
		{ "_arrow_vec_to_Array", (DL_FUNC) &_arrow_vec_to_Array, 2}, 
		{ "_arrow_DictionaryArray__FromArrays", (DL_FUNC) &_arrow_DictionaryArray__FromArrays, 3}, 
		{ "_arrow_RecordBatch__num_columns", (DL_FUNC) &_arrow_RecordBatch__num_columns, 1}, 
		{ "_arrow_RecordBatch__num_rows", (DL_FUNC) &_arrow_RecordBatch__num_rows, 1}, 
		{ "_arrow_RecordBatch__schema", (DL_FUNC) &_arrow_RecordBatch__schema, 1}, 
		{ "_arrow_RecordBatch__RenameColumns", (DL_FUNC) &_arrow_RecordBatch__RenameColumns, 2}, 
		{ "_arrow_RecordBatch__ReplaceSchemaMetadata", (DL_FUNC) &_arrow_RecordBatch__ReplaceSchemaMetadata, 2}, 
		{ "_arrow_RecordBatch__columns", (DL_FUNC) &_arrow_RecordBatch__columns, 1}, 
		{ "_arrow_RecordBatch__column", (DL_FUNC) &_arrow_RecordBatch__column, 2}, 
		{ "_arrow_RecordBatch__GetColumnByName", (DL_FUNC) &_arrow_RecordBatch__GetColumnByName, 2}, 
		{ "_arrow_RecordBatch__SelectColumns", (DL_FUNC) &_arrow_RecordBatch__SelectColumns, 2}, 
		{ "_arrow_RecordBatch__Equals", (DL_FUNC) &_arrow_RecordBatch__Equals, 3}, 
		{ "_arrow_RecordBatch__AddColumn", (DL_FUNC) &_arrow_RecordBatch__AddColumn, 4}, 
		{ "_arrow_RecordBatch__SetColumn", (DL_FUNC) &_arrow_RecordBatch__SetColumn, 4}, 
		{ "_arrow_RecordBatch__RemoveColumn", (DL_FUNC) &_arrow_RecordBatch__RemoveColumn, 2}, 
		{ "_arrow_RecordBatch__column_name", (DL_FUNC) &_arrow_RecordBatch__column_name, 2}, 
		{ "_arrow_RecordBatch__names", (DL_FUNC) &_arrow_RecordBatch__names, 1}, 
		{ "_arrow_RecordBatch__Slice1", (DL_FUNC) &_arrow_RecordBatch__Slice1, 2}, 
		{ "_arrow_RecordBatch__Slice2", (DL_FUNC) &_arrow_RecordBatch__Slice2, 3}, 
		{ "_arrow_ipc___SerializeRecordBatch__Raw", (DL_FUNC) &_arrow_ipc___SerializeRecordBatch__Raw, 1}, 
		{ "_arrow_ipc___ReadRecordBatch__InputStream__Schema", (DL_FUNC) &_arrow_ipc___ReadRecordBatch__InputStream__Schema, 2}, 
		{ "_arrow_RecordBatch__from_arrays", (DL_FUNC) &_arrow_RecordBatch__from_arrays, 2}, 
		{ "_arrow_RecordBatch__ReferencedBufferSize", (DL_FUNC) &_arrow_RecordBatch__ReferencedBufferSize, 1}, 
		{ "_arrow_RecordBatchReader__schema", (DL_FUNC) &_arrow_RecordBatchReader__schema, 1}, 
		{ "_arrow_RecordBatchReader__Close", (DL_FUNC) &_arrow_RecordBatchReader__Close, 1}, 
		{ "_arrow_RecordBatchReader__UnsafeDelete", (DL_FUNC) &_arrow_RecordBatchReader__UnsafeDelete, 1}, 
		{ "_arrow_RecordBatchReader__ReadNext", (DL_FUNC) &_arrow_RecordBatchReader__ReadNext, 1}, 
		{ "_arrow_RecordBatchReader__batches", (DL_FUNC) &_arrow_RecordBatchReader__batches, 1}, 
		{ "_arrow_RecordBatchReader__from_batches", (DL_FUNC) &_arrow_RecordBatchReader__from_batches, 2}, 
		{ "_arrow_RecordBatchReader__from_function", (DL_FUNC) &_arrow_RecordBatchReader__from_function, 2}, 
		{ "_arrow_RecordBatchReader__from_Table", (DL_FUNC) &_arrow_RecordBatchReader__from_Table, 1}, 
		{ "_arrow_Table__from_RecordBatchReader", (DL_FUNC) &_arrow_Table__from_RecordBatchReader, 1}, 
		{ "_arrow_RecordBatchReader__Head", (DL_FUNC) &_arrow_RecordBatchReader__Head, 2}, 
		{ "_arrow_ipc___RecordBatchStreamReader__Open", (DL_FUNC) &_arrow_ipc___RecordBatchStreamReader__Open, 1}, 
		{ "_arrow_ipc___RecordBatchFileReader__schema", (DL_FUNC) &_arrow_ipc___RecordBatchFileReader__schema, 1}, 
		{ "_arrow_ipc___RecordBatchFileReader__num_record_batches", (DL_FUNC) &_arrow_ipc___RecordBatchFileReader__num_record_batches, 1}, 
		{ "_arrow_ipc___RecordBatchFileReader__ReadRecordBatch", (DL_FUNC) &_arrow_ipc___RecordBatchFileReader__ReadRecordBatch, 2}, 
		{ "_arrow_ipc___RecordBatchFileReader__Open", (DL_FUNC) &_arrow_ipc___RecordBatchFileReader__Open, 1}, 
		{ "_arrow_Table__from_RecordBatchFileReader", (DL_FUNC) &_arrow_Table__from_RecordBatchFileReader, 1}, 
		{ "_arrow_ipc___RecordBatchFileReader__batches", (DL_FUNC) &_arrow_ipc___RecordBatchFileReader__batches, 1}, 
		{ "_arrow_ipc___RecordBatchWriter__WriteRecordBatch", (DL_FUNC) &_arrow_ipc___RecordBatchWriter__WriteRecordBatch, 2}, 
		{ "_arrow_ipc___RecordBatchWriter__WriteTable", (DL_FUNC) &_arrow_ipc___RecordBatchWriter__WriteTable, 2}, 
		{ "_arrow_ipc___RecordBatchWriter__Close", (DL_FUNC) &_arrow_ipc___RecordBatchWriter__Close, 1}, 
		{ "_arrow_ipc___RecordBatchFileWriter__Open", (DL_FUNC) &_arrow_ipc___RecordBatchFileWriter__Open, 4}, 
		{ "_arrow_ipc___RecordBatchStreamWriter__Open", (DL_FUNC) &_arrow_ipc___RecordBatchStreamWriter__Open, 4}, 
		{ "_arrow_InitializeMainRThread", (DL_FUNC) &_arrow_InitializeMainRThread, 0}, 
		{ "_arrow_DeinitializeMainRThread", (DL_FUNC) &_arrow_DeinitializeMainRThread, 0}, 
		{ "_arrow_SetEnableSignalStopSource", (DL_FUNC) &_arrow_SetEnableSignalStopSource, 1}, 
		{ "_arrow_CanRunWithCapturedR", (DL_FUNC) &_arrow_CanRunWithCapturedR, 0}, 
		{ "_arrow_TestSafeCallIntoR", (DL_FUNC) &_arrow_TestSafeCallIntoR, 2}, 
		{ "_arrow_Array__GetScalar", (DL_FUNC) &_arrow_Array__GetScalar, 2}, 
		{ "_arrow_Scalar__ToString", (DL_FUNC) &_arrow_Scalar__ToString, 1}, 
		{ "_arrow_StructScalar__field", (DL_FUNC) &_arrow_StructScalar__field, 2}, 
		{ "_arrow_StructScalar__GetFieldByName", (DL_FUNC) &_arrow_StructScalar__GetFieldByName, 2}, 
		{ "_arrow_MakeArrayFromScalar", (DL_FUNC) &_arrow_MakeArrayFromScalar, 2}, 
		{ "_arrow_Scalar__is_valid", (DL_FUNC) &_arrow_Scalar__is_valid, 1}, 
		{ "_arrow_Scalar__type", (DL_FUNC) &_arrow_Scalar__type, 1}, 
		{ "_arrow_Scalar__Equals", (DL_FUNC) &_arrow_Scalar__Equals, 2}, 
		{ "_arrow_Scalar__ApproxEquals", (DL_FUNC) &_arrow_Scalar__ApproxEquals, 2}, 
		{ "_arrow_Schema__from_fields", (DL_FUNC) &_arrow_Schema__from_fields, 1}, 
		{ "_arrow_Schema__from_list", (DL_FUNC) &_arrow_Schema__from_list, 1}, 
		{ "_arrow_Schema__ToString", (DL_FUNC) &_arrow_Schema__ToString, 1}, 
		{ "_arrow_Schema__num_fields", (DL_FUNC) &_arrow_Schema__num_fields, 1}, 
		{ "_arrow_Schema__field", (DL_FUNC) &_arrow_Schema__field, 2}, 
		{ "_arrow_Schema__AddField", (DL_FUNC) &_arrow_Schema__AddField, 3}, 
		{ "_arrow_Schema__SetField", (DL_FUNC) &_arrow_Schema__SetField, 3}, 
		{ "_arrow_Schema__RemoveField", (DL_FUNC) &_arrow_Schema__RemoveField, 2}, 
		{ "_arrow_Schema__GetFieldByName", (DL_FUNC) &_arrow_Schema__GetFieldByName, 2}, 
		{ "_arrow_Schema__fields", (DL_FUNC) &_arrow_Schema__fields, 1}, 
		{ "_arrow_Schema__field_names", (DL_FUNC) &_arrow_Schema__field_names, 1}, 
		{ "_arrow_Schema__HasMetadata", (DL_FUNC) &_arrow_Schema__HasMetadata, 1}, 
		{ "_arrow_Schema__metadata", (DL_FUNC) &_arrow_Schema__metadata, 1}, 
		{ "_arrow_Schema__WithMetadata", (DL_FUNC) &_arrow_Schema__WithMetadata, 2}, 
		{ "_arrow_Schema__serialize", (DL_FUNC) &_arrow_Schema__serialize, 1}, 
		{ "_arrow_Schema__Equals", (DL_FUNC) &_arrow_Schema__Equals, 3}, 
		{ "_arrow_arrow__UnifySchemas", (DL_FUNC) &_arrow_arrow__UnifySchemas, 1}, 
		{ "_arrow_Table__num_columns", (DL_FUNC) &_arrow_Table__num_columns, 1}, 
		{ "_arrow_Table__num_rows", (DL_FUNC) &_arrow_Table__num_rows, 1}, 
		{ "_arrow_Table__schema", (DL_FUNC) &_arrow_Table__schema, 1}, 
		{ "_arrow_Table__ReplaceSchemaMetadata", (DL_FUNC) &_arrow_Table__ReplaceSchemaMetadata, 2}, 
		{ "_arrow_Table__column", (DL_FUNC) &_arrow_Table__column, 2}, 
		{ "_arrow_Table__field", (DL_FUNC) &_arrow_Table__field, 2}, 
		{ "_arrow_Table__columns", (DL_FUNC) &_arrow_Table__columns, 1}, 
		{ "_arrow_Table__ColumnNames", (DL_FUNC) &_arrow_Table__ColumnNames, 1}, 
		{ "_arrow_Table__RenameColumns", (DL_FUNC) &_arrow_Table__RenameColumns, 2}, 
		{ "_arrow_Table__Slice1", (DL_FUNC) &_arrow_Table__Slice1, 2}, 
		{ "_arrow_Table__Slice2", (DL_FUNC) &_arrow_Table__Slice2, 3}, 
		{ "_arrow_Table__Equals", (DL_FUNC) &_arrow_Table__Equals, 3}, 
		{ "_arrow_Table__Validate", (DL_FUNC) &_arrow_Table__Validate, 1}, 
		{ "_arrow_Table__ValidateFull", (DL_FUNC) &_arrow_Table__ValidateFull, 1}, 
		{ "_arrow_Table__GetColumnByName", (DL_FUNC) &_arrow_Table__GetColumnByName, 2}, 
		{ "_arrow_Table__RemoveColumn", (DL_FUNC) &_arrow_Table__RemoveColumn, 2}, 
		{ "_arrow_Table__AddColumn", (DL_FUNC) &_arrow_Table__AddColumn, 4}, 
		{ "_arrow_Table__SetColumn", (DL_FUNC) &_arrow_Table__SetColumn, 4}, 
		{ "_arrow_Table__SelectColumns", (DL_FUNC) &_arrow_Table__SelectColumns, 2}, 
		{ "_arrow_all_record_batches", (DL_FUNC) &_arrow_all_record_batches, 1}, 
		{ "_arrow_Table__from_record_batches", (DL_FUNC) &_arrow_Table__from_record_batches, 2}, 
		{ "_arrow_Table__from_schema", (DL_FUNC) &_arrow_Table__from_schema, 1}, 
		{ "_arrow_Table__ReferencedBufferSize", (DL_FUNC) &_arrow_Table__ReferencedBufferSize, 1}, 
		{ "_arrow_Table__ConcatenateTables", (DL_FUNC) &_arrow_Table__ConcatenateTables, 2}, 
		{ "_arrow_GetCpuThreadPoolCapacity", (DL_FUNC) &_arrow_GetCpuThreadPoolCapacity, 0}, 
		{ "_arrow_SetCpuThreadPoolCapacity", (DL_FUNC) &_arrow_SetCpuThreadPoolCapacity, 1}, 
		{ "_arrow_GetIOThreadPoolCapacity", (DL_FUNC) &_arrow_GetIOThreadPoolCapacity, 0}, 
		{ "_arrow_SetIOThreadPoolCapacity", (DL_FUNC) &_arrow_SetIOThreadPoolCapacity, 1}, 
		{ "_arrow_Array__infer_type", (DL_FUNC) &_arrow_Array__infer_type, 1}, 
		{NULL, NULL, 0}
};
extern "C" void R_init_arrow(DllInfo* dll){
  R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
  R_useDynamicSymbols(dll, FALSE);

  #if defined(HAS_ALTREP)
  arrow::r::altrep::Init_Altrep_classes(dll);
  #endif

}


