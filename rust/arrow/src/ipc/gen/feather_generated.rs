// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

// automatically generated by the FlatBuffers compiler, do not modify


#![allow(dead_code)]
#![allow(unused_imports)]
extern crate flatbuffers;

pub mod arrow {
    #![allow(dead_code)]
    #![allow(unused_imports)]

    use std::cmp::Ordering;
    use std::mem;

    extern crate flatbuffers;
    use self::flatbuffers::EndianScalar;
    pub mod ipc {
        #![allow(dead_code)]
        #![allow(unused_imports)]

        use std::cmp::Ordering;
        use std::mem;

        extern crate flatbuffers;
        use self::flatbuffers::EndianScalar;
        pub mod feather {
            #![allow(dead_code)]
            #![allow(unused_imports)]

            use std::cmp::Ordering;
            use std::mem;

            extern crate flatbuffers;
            use self::flatbuffers::EndianScalar;
            pub mod fbs {
                #![allow(dead_code)]
                #![allow(unused_imports)]

                use std::cmp::Ordering;
                use std::mem;

                extern crate flatbuffers;
                use self::flatbuffers::EndianScalar;

                /// Feather is an experimental serialization format implemented using
                /// techniques from Apache Arrow. It was created as a proof-of-concept of
                /// an interoperable file format for storing data frames
                /// originating in Python or R. It enabled the developers
                /// to sidestep some of the open design questions in Arrow
                /// from early 2016 and instead create something simple and useful for
                /// the intended use cases.
                #[allow(non_camel_case_types)]
                #[repr(i8)]
                #[derive(Clone, Copy, PartialEq, Debug)]
                pub enum Type {
                    BOOL = 0,
                    INT8 = 1,
                    INT16 = 2,
                    INT32 = 3,
                    INT64 = 4,
                    UINT8 = 5,
                    UINT16 = 6,
                    UINT32 = 7,
                    UINT64 = 8,
                    FLOAT = 9,
                    DOUBLE = 10,
                    UTF8 = 11,
                    BINARY = 12,
                    CATEGORY = 13,
                    TIMESTAMP = 14,
                    DATE = 15,
                    TIME = 16,
                }

                const ENUM_MIN_TYPE: i8 = 0;
                const ENUM_MAX_TYPE: i8 = 16;

                impl<'a> flatbuffers::Follow<'a> for Type {
                    type Inner = Self;
                    #[inline]
                    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        flatbuffers::read_scalar_at::<Self>(buf, loc)
                    }
                }

                impl flatbuffers::EndianScalar for Type {
                    #[inline]
                    fn to_little_endian(self) -> Self {
                        let n = i8::to_le(self as i8);
                        let p = &n as *const i8 as *const Type;
                        unsafe { *p }
                    }
                    #[inline]
                    fn from_little_endian(self) -> Self {
                        let n = i8::from_le(self as i8);
                        let p = &n as *const i8 as *const Type;
                        unsafe { *p }
                    }
                }

                impl flatbuffers::Push for Type {
                    type Output = Type;
                    #[inline]
                    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                        flatbuffers::emplace_scalar::<Type>(dst, *self);
                    }
                }

                #[allow(non_camel_case_types)]
                const ENUM_VALUES_TYPE: [Type; 17] = [
                    Type::BOOL,
                    Type::INT8,
                    Type::INT16,
                    Type::INT32,
                    Type::INT64,
                    Type::UINT8,
                    Type::UINT16,
                    Type::UINT32,
                    Type::UINT64,
                    Type::FLOAT,
                    Type::DOUBLE,
                    Type::UTF8,
                    Type::BINARY,
                    Type::CATEGORY,
                    Type::TIMESTAMP,
                    Type::DATE,
                    Type::TIME,
                ];

                #[allow(non_camel_case_types)]
                const ENUM_NAMES_TYPE: [&'static str; 17] = [
                    "BOOL",
                    "INT8",
                    "INT16",
                    "INT32",
                    "INT64",
                    "UINT8",
                    "UINT16",
                    "UINT32",
                    "UINT64",
                    "FLOAT",
                    "DOUBLE",
                    "UTF8",
                    "BINARY",
                    "CATEGORY",
                    "TIMESTAMP",
                    "DATE",
                    "TIME",
                ];

                pub fn enum_name_type(e: Type) -> &'static str {
                    let index: usize = e as usize;
                    ENUM_NAMES_TYPE[index]
                }

                #[allow(non_camel_case_types)]
                #[repr(i8)]
                #[derive(Clone, Copy, PartialEq, Debug)]
                pub enum Encoding {
                    PLAIN = 0,
                    /// Data is stored dictionary-encoded
                    /// dictionary size: <INT32 Dictionary size>
                    /// dictionary data: <TYPE primitive array>
                    /// dictionary index: <INT32 primitive array>
                    ///
                    /// TODO: do we care about storing the index values in a smaller
                    /// typeclass
                    DICTIONARY = 1,
                }

                const ENUM_MIN_ENCODING: i8 = 0;
                const ENUM_MAX_ENCODING: i8 = 1;

                impl<'a> flatbuffers::Follow<'a> for Encoding {
                    type Inner = Self;
                    #[inline]
                    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        flatbuffers::read_scalar_at::<Self>(buf, loc)
                    }
                }

                impl flatbuffers::EndianScalar for Encoding {
                    #[inline]
                    fn to_little_endian(self) -> Self {
                        let n = i8::to_le(self as i8);
                        let p = &n as *const i8 as *const Encoding;
                        unsafe { *p }
                    }
                    #[inline]
                    fn from_little_endian(self) -> Self {
                        let n = i8::from_le(self as i8);
                        let p = &n as *const i8 as *const Encoding;
                        unsafe { *p }
                    }
                }

                impl flatbuffers::Push for Encoding {
                    type Output = Encoding;
                    #[inline]
                    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                        flatbuffers::emplace_scalar::<Encoding>(dst, *self);
                    }
                }

                #[allow(non_camel_case_types)]
                const ENUM_VALUES_ENCODING: [Encoding; 2] =
                    [Encoding::PLAIN, Encoding::DICTIONARY];

                #[allow(non_camel_case_types)]
                const ENUM_NAMES_ENCODING: [&'static str; 2] = ["PLAIN", "DICTIONARY"];

                pub fn enum_name_encoding(e: Encoding) -> &'static str {
                    let index: usize = e as usize;
                    ENUM_NAMES_ENCODING[index]
                }

                #[allow(non_camel_case_types)]
                #[repr(i8)]
                #[derive(Clone, Copy, PartialEq, Debug)]
                pub enum TimeUnit {
                    SECOND = 0,
                    MILLISECOND = 1,
                    MICROSECOND = 2,
                    NANOSECOND = 3,
                }

                const ENUM_MIN_TIME_UNIT: i8 = 0;
                const ENUM_MAX_TIME_UNIT: i8 = 3;

                impl<'a> flatbuffers::Follow<'a> for TimeUnit {
                    type Inner = Self;
                    #[inline]
                    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        flatbuffers::read_scalar_at::<Self>(buf, loc)
                    }
                }

                impl flatbuffers::EndianScalar for TimeUnit {
                    #[inline]
                    fn to_little_endian(self) -> Self {
                        let n = i8::to_le(self as i8);
                        let p = &n as *const i8 as *const TimeUnit;
                        unsafe { *p }
                    }
                    #[inline]
                    fn from_little_endian(self) -> Self {
                        let n = i8::from_le(self as i8);
                        let p = &n as *const i8 as *const TimeUnit;
                        unsafe { *p }
                    }
                }

                impl flatbuffers::Push for TimeUnit {
                    type Output = TimeUnit;
                    #[inline]
                    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                        flatbuffers::emplace_scalar::<TimeUnit>(dst, *self);
                    }
                }

                #[allow(non_camel_case_types)]
                const ENUM_VALUES_TIME_UNIT: [TimeUnit; 4] = [
                    TimeUnit::SECOND,
                    TimeUnit::MILLISECOND,
                    TimeUnit::MICROSECOND,
                    TimeUnit::NANOSECOND,
                ];

                #[allow(non_camel_case_types)]
                const ENUM_NAMES_TIME_UNIT: [&'static str; 4] =
                    ["SECOND", "MILLISECOND", "MICROSECOND", "NANOSECOND"];

                pub fn enum_name_time_unit(e: TimeUnit) -> &'static str {
                    let index: usize = e as usize;
                    ENUM_NAMES_TIME_UNIT[index]
                }

                #[allow(non_camel_case_types)]
                #[repr(u8)]
                #[derive(Clone, Copy, PartialEq, Debug)]
                pub enum TypeMetadata {
                    NONE = 0,
                    CategoryMetadata = 1,
                    TimestampMetadata = 2,
                    DateMetadata = 3,
                    TimeMetadata = 4,
                }

                const ENUM_MIN_TYPE_METADATA: u8 = 0;
                const ENUM_MAX_TYPE_METADATA: u8 = 4;

                impl<'a> flatbuffers::Follow<'a> for TypeMetadata {
                    type Inner = Self;
                    #[inline]
                    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        flatbuffers::read_scalar_at::<Self>(buf, loc)
                    }
                }

                impl flatbuffers::EndianScalar for TypeMetadata {
                    #[inline]
                    fn to_little_endian(self) -> Self {
                        let n = u8::to_le(self as u8);
                        let p = &n as *const u8 as *const TypeMetadata;
                        unsafe { *p }
                    }
                    #[inline]
                    fn from_little_endian(self) -> Self {
                        let n = u8::from_le(self as u8);
                        let p = &n as *const u8 as *const TypeMetadata;
                        unsafe { *p }
                    }
                }

                impl flatbuffers::Push for TypeMetadata {
                    type Output = TypeMetadata;
                    #[inline]
                    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
                        flatbuffers::emplace_scalar::<TypeMetadata>(dst, *self);
                    }
                }

                #[allow(non_camel_case_types)]
                const ENUM_VALUES_TYPE_METADATA: [TypeMetadata; 5] = [
                    TypeMetadata::NONE,
                    TypeMetadata::CategoryMetadata,
                    TypeMetadata::TimestampMetadata,
                    TypeMetadata::DateMetadata,
                    TypeMetadata::TimeMetadata,
                ];

                #[allow(non_camel_case_types)]
                const ENUM_NAMES_TYPE_METADATA: [&'static str; 5] = [
                    "NONE",
                    "CategoryMetadata",
                    "TimestampMetadata",
                    "DateMetadata",
                    "TimeMetadata",
                ];

                pub fn enum_name_type_metadata(e: TypeMetadata) -> &'static str {
                    let index: usize = e as usize;
                    ENUM_NAMES_TYPE_METADATA[index]
                }

                pub struct TypeMetadataUnionTableOffset {}
                pub enum PrimitiveArrayOffset {}
                #[derive(Copy, Clone, Debug, PartialEq)]

                pub struct PrimitiveArray<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for PrimitiveArray<'a> {
                    type Inner = PrimitiveArray<'a>;
                    #[inline]
                    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table { buf: buf, loc: loc },
                        }
                    }
                }

                impl<'a> PrimitiveArray<'a> {
                    #[inline]
                    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        PrimitiveArray { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                        args: &'args PrimitiveArrayArgs,
                    ) -> flatbuffers::WIPOffset<PrimitiveArray<'bldr>>
                    {
                        let mut builder = PrimitiveArrayBuilder::new(_fbb);
                        builder.add_total_bytes(args.total_bytes);
                        builder.add_null_count(args.null_count);
                        builder.add_length(args.length);
                        builder.add_offset(args.offset);
                        builder.add_encoding(args.encoding);
                        builder.add_type_(args.type_);
                        builder.finish()
                    }

                    pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
                    pub const VT_ENCODING: flatbuffers::VOffsetT = 6;
                    pub const VT_OFFSET: flatbuffers::VOffsetT = 8;
                    pub const VT_LENGTH: flatbuffers::VOffsetT = 10;
                    pub const VT_NULL_COUNT: flatbuffers::VOffsetT = 12;
                    pub const VT_TOTAL_BYTES: flatbuffers::VOffsetT = 14;

                    #[inline]
                    pub fn type_(&self) -> Type {
                        self._tab
                            .get::<Type>(PrimitiveArray::VT_TYPE_, Some(Type::BOOL))
                            .unwrap()
                    }
                    #[inline]
                    pub fn encoding(&self) -> Encoding {
                        self._tab
                            .get::<Encoding>(
                                PrimitiveArray::VT_ENCODING,
                                Some(Encoding::PLAIN),
                            )
                            .unwrap()
                    }
                    /// Relative memory offset of the start of the array data excluding
                    /// the size of the metadata
                    #[inline]
                    pub fn offset(&self) -> i64 {
                        self._tab
                            .get::<i64>(PrimitiveArray::VT_OFFSET, Some(0))
                            .unwrap()
                    }
                    /// The number of logical values in the array
                    #[inline]
                    pub fn length(&self) -> i64 {
                        self._tab
                            .get::<i64>(PrimitiveArray::VT_LENGTH, Some(0))
                            .unwrap()
                    }
                    /// The number of observed nulls
                    #[inline]
                    pub fn null_count(&self) -> i64 {
                        self._tab
                            .get::<i64>(PrimitiveArray::VT_NULL_COUNT, Some(0))
                            .unwrap()
                    }
                    /// The total size of the actual data in the file
                    #[inline]
                    pub fn total_bytes(&self) -> i64 {
                        self._tab
                            .get::<i64>(PrimitiveArray::VT_TOTAL_BYTES, Some(0))
                            .unwrap()
                    }
                }

                pub struct PrimitiveArrayArgs {
                    pub type_: Type,
                    pub encoding: Encoding,
                    pub offset: i64,
                    pub length: i64,
                    pub null_count: i64,
                    pub total_bytes: i64,
                }
                impl<'a> Default for PrimitiveArrayArgs {
                    #[inline]
                    fn default() -> Self {
                        PrimitiveArrayArgs {
                            type_: Type::BOOL,
                            encoding: Encoding::PLAIN,
                            offset: 0,
                            length: 0,
                            null_count: 0,
                            total_bytes: 0,
                        }
                    }
                }
                pub struct PrimitiveArrayBuilder<'a: 'b, 'b> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b> PrimitiveArrayBuilder<'a, 'b> {
                    #[inline]
                    pub fn add_type_(&mut self, type_: Type) {
                        self.fbb_.push_slot::<Type>(
                            PrimitiveArray::VT_TYPE_,
                            type_,
                            Type::BOOL,
                        );
                    }
                    #[inline]
                    pub fn add_encoding(&mut self, encoding: Encoding) {
                        self.fbb_.push_slot::<Encoding>(
                            PrimitiveArray::VT_ENCODING,
                            encoding,
                            Encoding::PLAIN,
                        );
                    }
                    #[inline]
                    pub fn add_offset(&mut self, offset: i64) {
                        self.fbb_
                            .push_slot::<i64>(PrimitiveArray::VT_OFFSET, offset, 0);
                    }
                    #[inline]
                    pub fn add_length(&mut self, length: i64) {
                        self.fbb_
                            .push_slot::<i64>(PrimitiveArray::VT_LENGTH, length, 0);
                    }
                    #[inline]
                    pub fn add_null_count(&mut self, null_count: i64) {
                        self.fbb_.push_slot::<i64>(
                            PrimitiveArray::VT_NULL_COUNT,
                            null_count,
                            0,
                        );
                    }
                    #[inline]
                    pub fn add_total_bytes(&mut self, total_bytes: i64) {
                        self.fbb_.push_slot::<i64>(
                            PrimitiveArray::VT_TOTAL_BYTES,
                            total_bytes,
                            0,
                        );
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    ) -> PrimitiveArrayBuilder<'a, 'b> {
                        let start = _fbb.start_table();
                        PrimitiveArrayBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<PrimitiveArray<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                pub enum CategoryMetadataOffset {}
                #[derive(Copy, Clone, Debug, PartialEq)]

                pub struct CategoryMetadata<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for CategoryMetadata<'a> {
                    type Inner = CategoryMetadata<'a>;
                    #[inline]
                    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table { buf: buf, loc: loc },
                        }
                    }
                }

                impl<'a> CategoryMetadata<'a> {
                    #[inline]
                    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        CategoryMetadata { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                        args: &'args CategoryMetadataArgs<'args>,
                    ) -> flatbuffers::WIPOffset<CategoryMetadata<'bldr>>
                    {
                        let mut builder = CategoryMetadataBuilder::new(_fbb);
                        if let Some(x) = args.levels {
                            builder.add_levels(x);
                        }
                        builder.add_ordered(args.ordered);
                        builder.finish()
                    }

                    pub const VT_LEVELS: flatbuffers::VOffsetT = 4;
                    pub const VT_ORDERED: flatbuffers::VOffsetT = 6;

                    /// The category codes are presumed to be integers that are valid
                    /// indexes into the levels array
                    #[inline]
                    pub fn levels(&self) -> Option<PrimitiveArray<'a>> {
                        self._tab
                            .get::<flatbuffers::ForwardsUOffset<PrimitiveArray<'a>>>(
                                CategoryMetadata::VT_LEVELS,
                                None,
                            )
                    }
                    #[inline]
                    pub fn ordered(&self) -> bool {
                        self._tab
                            .get::<bool>(CategoryMetadata::VT_ORDERED, Some(false))
                            .unwrap()
                    }
                }

                pub struct CategoryMetadataArgs<'a> {
                    pub levels: Option<flatbuffers::WIPOffset<PrimitiveArray<'a>>>,
                    pub ordered: bool,
                }
                impl<'a> Default for CategoryMetadataArgs<'a> {
                    #[inline]
                    fn default() -> Self {
                        CategoryMetadataArgs {
                            levels: None,
                            ordered: false,
                        }
                    }
                }
                pub struct CategoryMetadataBuilder<'a: 'b, 'b> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b> CategoryMetadataBuilder<'a, 'b> {
                    #[inline]
                    pub fn add_levels(
                        &mut self,
                        levels: flatbuffers::WIPOffset<PrimitiveArray<'b>>,
                    ) {
                        self.fbb_
                            .push_slot_always::<flatbuffers::WIPOffset<PrimitiveArray>>(
                                CategoryMetadata::VT_LEVELS,
                                levels,
                            );
                    }
                    #[inline]
                    pub fn add_ordered(&mut self, ordered: bool) {
                        self.fbb_.push_slot::<bool>(
                            CategoryMetadata::VT_ORDERED,
                            ordered,
                            false,
                        );
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    ) -> CategoryMetadataBuilder<'a, 'b> {
                        let start = _fbb.start_table();
                        CategoryMetadataBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<CategoryMetadata<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                pub enum TimestampMetadataOffset {}
                #[derive(Copy, Clone, Debug, PartialEq)]

                pub struct TimestampMetadata<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for TimestampMetadata<'a> {
                    type Inner = TimestampMetadata<'a>;
                    #[inline]
                    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table { buf: buf, loc: loc },
                        }
                    }
                }

                impl<'a> TimestampMetadata<'a> {
                    #[inline]
                    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        TimestampMetadata { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                        args: &'args TimestampMetadataArgs<'args>,
                    ) -> flatbuffers::WIPOffset<TimestampMetadata<'bldr>>
                    {
                        let mut builder = TimestampMetadataBuilder::new(_fbb);
                        if let Some(x) = args.timezone {
                            builder.add_timezone(x);
                        }
                        builder.add_unit(args.unit);
                        builder.finish()
                    }

                    pub const VT_UNIT: flatbuffers::VOffsetT = 4;
                    pub const VT_TIMEZONE: flatbuffers::VOffsetT = 6;

                    #[inline]
                    pub fn unit(&self) -> TimeUnit {
                        self._tab
                            .get::<TimeUnit>(
                                TimestampMetadata::VT_UNIT,
                                Some(TimeUnit::SECOND),
                            )
                            .unwrap()
                    }
                    /// Timestamp data is assumed to be UTC, but the time zone is stored
                    /// here for presentation as localized
                    #[inline]
                    pub fn timezone(&self) -> Option<&'a str> {
                        self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                            TimestampMetadata::VT_TIMEZONE,
                            None,
                        )
                    }
                }

                pub struct TimestampMetadataArgs<'a> {
                    pub unit: TimeUnit,
                    pub timezone: Option<flatbuffers::WIPOffset<&'a str>>,
                }
                impl<'a> Default for TimestampMetadataArgs<'a> {
                    #[inline]
                    fn default() -> Self {
                        TimestampMetadataArgs {
                            unit: TimeUnit::SECOND,
                            timezone: None,
                        }
                    }
                }
                pub struct TimestampMetadataBuilder<'a: 'b, 'b> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b> TimestampMetadataBuilder<'a, 'b> {
                    #[inline]
                    pub fn add_unit(&mut self, unit: TimeUnit) {
                        self.fbb_.push_slot::<TimeUnit>(
                            TimestampMetadata::VT_UNIT,
                            unit,
                            TimeUnit::SECOND,
                        );
                    }
                    #[inline]
                    pub fn add_timezone(
                        &mut self,
                        timezone: flatbuffers::WIPOffset<&'b str>,
                    ) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            TimestampMetadata::VT_TIMEZONE,
                            timezone,
                        );
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    ) -> TimestampMetadataBuilder<'a, 'b> {
                        let start = _fbb.start_table();
                        TimestampMetadataBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<TimestampMetadata<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                pub enum DateMetadataOffset {}
                #[derive(Copy, Clone, Debug, PartialEq)]

                pub struct DateMetadata<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for DateMetadata<'a> {
                    type Inner = DateMetadata<'a>;
                    #[inline]
                    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table { buf: buf, loc: loc },
                        }
                    }
                }

                impl<'a> DateMetadata<'a> {
                    #[inline]
                    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        DateMetadata { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                        _args: &'args DateMetadataArgs,
                    ) -> flatbuffers::WIPOffset<DateMetadata<'bldr>> {
                        let mut builder = DateMetadataBuilder::new(_fbb);
                        builder.finish()
                    }
                }

                pub struct DateMetadataArgs {}
                impl<'a> Default for DateMetadataArgs {
                    #[inline]
                    fn default() -> Self {
                        DateMetadataArgs {}
                    }
                }
                pub struct DateMetadataBuilder<'a: 'b, 'b> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b> DateMetadataBuilder<'a, 'b> {
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    ) -> DateMetadataBuilder<'a, 'b> {
                        let start = _fbb.start_table();
                        DateMetadataBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<DateMetadata<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                pub enum TimeMetadataOffset {}
                #[derive(Copy, Clone, Debug, PartialEq)]

                pub struct TimeMetadata<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for TimeMetadata<'a> {
                    type Inner = TimeMetadata<'a>;
                    #[inline]
                    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table { buf: buf, loc: loc },
                        }
                    }
                }

                impl<'a> TimeMetadata<'a> {
                    #[inline]
                    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        TimeMetadata { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                        args: &'args TimeMetadataArgs,
                    ) -> flatbuffers::WIPOffset<TimeMetadata<'bldr>> {
                        let mut builder = TimeMetadataBuilder::new(_fbb);
                        builder.add_unit(args.unit);
                        builder.finish()
                    }

                    pub const VT_UNIT: flatbuffers::VOffsetT = 4;

                    #[inline]
                    pub fn unit(&self) -> TimeUnit {
                        self._tab
                            .get::<TimeUnit>(
                                TimeMetadata::VT_UNIT,
                                Some(TimeUnit::SECOND),
                            )
                            .unwrap()
                    }
                }

                pub struct TimeMetadataArgs {
                    pub unit: TimeUnit,
                }
                impl<'a> Default for TimeMetadataArgs {
                    #[inline]
                    fn default() -> Self {
                        TimeMetadataArgs {
                            unit: TimeUnit::SECOND,
                        }
                    }
                }
                pub struct TimeMetadataBuilder<'a: 'b, 'b> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b> TimeMetadataBuilder<'a, 'b> {
                    #[inline]
                    pub fn add_unit(&mut self, unit: TimeUnit) {
                        self.fbb_.push_slot::<TimeUnit>(
                            TimeMetadata::VT_UNIT,
                            unit,
                            TimeUnit::SECOND,
                        );
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    ) -> TimeMetadataBuilder<'a, 'b> {
                        let start = _fbb.start_table();
                        TimeMetadataBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<TimeMetadata<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                pub enum ColumnOffset {}
                #[derive(Copy, Clone, Debug, PartialEq)]

                pub struct Column<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for Column<'a> {
                    type Inner = Column<'a>;
                    #[inline]
                    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table { buf: buf, loc: loc },
                        }
                    }
                }

                impl<'a> Column<'a> {
                    #[inline]
                    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        Column { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                        args: &'args ColumnArgs<'args>,
                    ) -> flatbuffers::WIPOffset<Column<'bldr>> {
                        let mut builder = ColumnBuilder::new(_fbb);
                        if let Some(x) = args.user_metadata {
                            builder.add_user_metadata(x);
                        }
                        if let Some(x) = args.metadata {
                            builder.add_metadata(x);
                        }
                        if let Some(x) = args.values {
                            builder.add_values(x);
                        }
                        if let Some(x) = args.name {
                            builder.add_name(x);
                        }
                        builder.add_metadata_type(args.metadata_type);
                        builder.finish()
                    }

                    pub const VT_NAME: flatbuffers::VOffsetT = 4;
                    pub const VT_VALUES: flatbuffers::VOffsetT = 6;
                    pub const VT_METADATA_TYPE: flatbuffers::VOffsetT = 8;
                    pub const VT_METADATA: flatbuffers::VOffsetT = 10;
                    pub const VT_USER_METADATA: flatbuffers::VOffsetT = 12;

                    #[inline]
                    pub fn name(&self) -> Option<&'a str> {
                        self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                            Column::VT_NAME,
                            None,
                        )
                    }
                    #[inline]
                    pub fn values(&self) -> Option<PrimitiveArray<'a>> {
                        self._tab
                            .get::<flatbuffers::ForwardsUOffset<PrimitiveArray<'a>>>(
                                Column::VT_VALUES,
                                None,
                            )
                    }
                    #[inline]
                    pub fn metadata_type(&self) -> TypeMetadata {
                        self._tab
                            .get::<TypeMetadata>(
                                Column::VT_METADATA_TYPE,
                                Some(TypeMetadata::NONE),
                            )
                            .unwrap()
                    }
                    #[inline]
                    pub fn metadata(&self) -> Option<flatbuffers::Table<'a>> {
                        self._tab
                            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                                Column::VT_METADATA,
                                None,
                            )
                    }
                    /// This should (probably) be JSON
                    #[inline]
                    pub fn user_metadata(&self) -> Option<&'a str> {
                        self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                            Column::VT_USER_METADATA,
                            None,
                        )
                    }
                    #[inline]
                    #[allow(non_snake_case)]
                    pub fn metadata_as_category_metadata(
                        &'a self,
                    ) -> Option<CategoryMetadata> {
                        if self.metadata_type() == TypeMetadata::CategoryMetadata {
                            self.metadata()
                                .map(|u| CategoryMetadata::init_from_table(u))
                        } else {
                            None
                        }
                    }

                    #[inline]
                    #[allow(non_snake_case)]
                    pub fn metadata_as_timestamp_metadata(
                        &'a self,
                    ) -> Option<TimestampMetadata> {
                        if self.metadata_type() == TypeMetadata::TimestampMetadata {
                            self.metadata()
                                .map(|u| TimestampMetadata::init_from_table(u))
                        } else {
                            None
                        }
                    }

                    #[inline]
                    #[allow(non_snake_case)]
                    pub fn metadata_as_date_metadata(&'a self) -> Option<DateMetadata> {
                        if self.metadata_type() == TypeMetadata::DateMetadata {
                            self.metadata().map(|u| DateMetadata::init_from_table(u))
                        } else {
                            None
                        }
                    }

                    #[inline]
                    #[allow(non_snake_case)]
                    pub fn metadata_as_time_metadata(&'a self) -> Option<TimeMetadata> {
                        if self.metadata_type() == TypeMetadata::TimeMetadata {
                            self.metadata().map(|u| TimeMetadata::init_from_table(u))
                        } else {
                            None
                        }
                    }
                }

                pub struct ColumnArgs<'a> {
                    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
                    pub values: Option<flatbuffers::WIPOffset<PrimitiveArray<'a>>>,
                    pub metadata_type: TypeMetadata,
                    pub metadata:
                        Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
                    pub user_metadata: Option<flatbuffers::WIPOffset<&'a str>>,
                }
                impl<'a> Default for ColumnArgs<'a> {
                    #[inline]
                    fn default() -> Self {
                        ColumnArgs {
                            name: None,
                            values: None,
                            metadata_type: TypeMetadata::NONE,
                            metadata: None,
                            user_metadata: None,
                        }
                    }
                }
                pub struct ColumnBuilder<'a: 'b, 'b> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b> ColumnBuilder<'a, 'b> {
                    #[inline]
                    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            Column::VT_NAME,
                            name,
                        );
                    }
                    #[inline]
                    pub fn add_values(
                        &mut self,
                        values: flatbuffers::WIPOffset<PrimitiveArray<'b>>,
                    ) {
                        self.fbb_
                            .push_slot_always::<flatbuffers::WIPOffset<PrimitiveArray>>(
                                Column::VT_VALUES,
                                values,
                            );
                    }
                    #[inline]
                    pub fn add_metadata_type(&mut self, metadata_type: TypeMetadata) {
                        self.fbb_.push_slot::<TypeMetadata>(
                            Column::VT_METADATA_TYPE,
                            metadata_type,
                            TypeMetadata::NONE,
                        );
                    }
                    #[inline]
                    pub fn add_metadata(
                        &mut self,
                        metadata: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
                    ) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            Column::VT_METADATA,
                            metadata,
                        );
                    }
                    #[inline]
                    pub fn add_user_metadata(
                        &mut self,
                        user_metadata: flatbuffers::WIPOffset<&'b str>,
                    ) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            Column::VT_USER_METADATA,
                            user_metadata,
                        );
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    ) -> ColumnBuilder<'a, 'b> {
                        let start = _fbb.start_table();
                        ColumnBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<Column<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                pub enum CTableOffset {}
                #[derive(Copy, Clone, Debug, PartialEq)]

                pub struct CTable<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for CTable<'a> {
                    type Inner = CTable<'a>;
                    #[inline]
                    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table { buf: buf, loc: loc },
                        }
                    }
                }

                impl<'a> CTable<'a> {
                    #[inline]
                    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        CTable { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                        args: &'args CTableArgs<'args>,
                    ) -> flatbuffers::WIPOffset<CTable<'bldr>> {
                        let mut builder = CTableBuilder::new(_fbb);
                        builder.add_num_rows(args.num_rows);
                        if let Some(x) = args.metadata {
                            builder.add_metadata(x);
                        }
                        builder.add_version(args.version);
                        if let Some(x) = args.columns {
                            builder.add_columns(x);
                        }
                        if let Some(x) = args.description {
                            builder.add_description(x);
                        }
                        builder.finish()
                    }

                    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 4;
                    pub const VT_NUM_ROWS: flatbuffers::VOffsetT = 6;
                    pub const VT_COLUMNS: flatbuffers::VOffsetT = 8;
                    pub const VT_VERSION: flatbuffers::VOffsetT = 10;
                    pub const VT_METADATA: flatbuffers::VOffsetT = 12;

                    /// Some text (or a name) metadata about what the file is, optional
                    #[inline]
                    pub fn description(&self) -> Option<&'a str> {
                        self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                            CTable::VT_DESCRIPTION,
                            None,
                        )
                    }
                    #[inline]
                    pub fn num_rows(&self) -> i64 {
                        self._tab.get::<i64>(CTable::VT_NUM_ROWS, Some(0)).unwrap()
                    }
                    #[inline]
                    pub fn columns(
                        &self,
                    ) -> Option<
                        flatbuffers::Vector<flatbuffers::ForwardsUOffset<Column<'a>>>,
                    > {
                        self._tab.get::<flatbuffers::ForwardsUOffset<
                            flatbuffers::Vector<flatbuffers::ForwardsUOffset<Column<'a>>>,
                        >>(CTable::VT_COLUMNS, None)
                    }
                    /// Version number of the Feather format
                    #[inline]
                    pub fn version(&self) -> i32 {
                        self._tab.get::<i32>(CTable::VT_VERSION, Some(0)).unwrap()
                    }
                    /// Table metadata (likely JSON), not yet used
                    #[inline]
                    pub fn metadata(&self) -> Option<&'a str> {
                        self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                            CTable::VT_METADATA,
                            None,
                        )
                    }
                }

                pub struct CTableArgs<'a> {
                    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
                    pub num_rows: i64,
                    pub columns: Option<
                        flatbuffers::WIPOffset<
                            flatbuffers::Vector<
                                'a,
                                flatbuffers::ForwardsUOffset<Column<'a>>,
                            >,
                        >,
                    >,
                    pub version: i32,
                    pub metadata: Option<flatbuffers::WIPOffset<&'a str>>,
                }
                impl<'a> Default for CTableArgs<'a> {
                    #[inline]
                    fn default() -> Self {
                        CTableArgs {
                            description: None,
                            num_rows: 0,
                            columns: None,
                            version: 0,
                            metadata: None,
                        }
                    }
                }
                pub struct CTableBuilder<'a: 'b, 'b> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b> CTableBuilder<'a, 'b> {
                    #[inline]
                    pub fn add_description(
                        &mut self,
                        description: flatbuffers::WIPOffset<&'b str>,
                    ) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            CTable::VT_DESCRIPTION,
                            description,
                        );
                    }
                    #[inline]
                    pub fn add_num_rows(&mut self, num_rows: i64) {
                        self.fbb_.push_slot::<i64>(CTable::VT_NUM_ROWS, num_rows, 0);
                    }
                    #[inline]
                    pub fn add_columns(
                        &mut self,
                        columns: flatbuffers::WIPOffset<
                            flatbuffers::Vector<
                                'b,
                                flatbuffers::ForwardsUOffset<Column<'b>>,
                            >,
                        >,
                    ) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            CTable::VT_COLUMNS,
                            columns,
                        );
                    }
                    #[inline]
                    pub fn add_version(&mut self, version: i32) {
                        self.fbb_.push_slot::<i32>(CTable::VT_VERSION, version, 0);
                    }
                    #[inline]
                    pub fn add_metadata(
                        &mut self,
                        metadata: flatbuffers::WIPOffset<&'b str>,
                    ) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            CTable::VT_METADATA,
                            metadata,
                        );
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    ) -> CTableBuilder<'a, 'b> {
                        let start = _fbb.start_table();
                        CTableBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<CTable<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                #[inline]
                pub fn get_root_as_ctable<'a>(buf: &'a [u8]) -> CTable<'a> {
                    flatbuffers::get_root::<CTable<'a>>(buf)
                }

                #[inline]
                pub fn get_size_prefixed_root_as_ctable<'a>(buf: &'a [u8]) -> CTable<'a> {
                    flatbuffers::get_size_prefixed_root::<CTable<'a>>(buf)
                }

                #[inline]
                pub fn finish_ctable_buffer<'a, 'b>(
                    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    root: flatbuffers::WIPOffset<CTable<'a>>,
                ) {
                    fbb.finish(root, None);
                }

                #[inline]
                pub fn finish_size_prefixed_ctable_buffer<'a, 'b>(
                    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
                    root: flatbuffers::WIPOffset<CTable<'a>>,
                ) {
                    fbb.finish_size_prefixed(root, None);
                }
            } // pub mod fbs
        } // pub mod feather
    } // pub mod ipc
} // pub mod arrow
